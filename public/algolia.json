[{"categories":["life"],"content":"2025第一篇博客！毕业了更新也随缘了 发一个粗略版日本游玩路线，后续有缘更新(实际上去年去的:)出发准备 提前三天兑换日币 （工商卡先购结售汇，再线下预约取汇） 提前四天办流量卡 （也可买亿点卡，机场自取+5元。注意晚上到，好像开通了也算一天 ） 充电宝满电 护照、身份证 visit Japan wen https://tenki.jp/ 看天气 night 找家便利店吃饭，考虑购买100yen的硬币收集器，并且微信搜索”微信支付全球有礼“集满6单小零食，汇率最低get，或者支付宝铂金会员可直接使用支付宝，汇率差不多day 1 上午9点到浅草寺 中午去西餐 近秋叶原、近浅草寺 吃完去猫头鹰咖啡馆！要预约 悲 下午逛秋叶原 晚上六点到天空塔，建议提前购票 晚餐 Venu's South Indian Dining 又去了附近的大黑汤，语言不通还是很尴尬的 day 2 早上去恩赐庭园 中午银座 晚上东京塔 来得及去台场高达基地八点关门 https://maps.app.goo.gl/sLCVZqfAXehnYuYy7 饭：午餐：银座鳗鱼饭、银座鳗鱼饭2 、银座拉面 便宜、靠近恩赐庭园 顺","date":"2025-01-16T19:27:28+08:00","objectID":"d96624030a49a9537409f6c96ced4a20_0","order":0,"summary":"2025第一篇博客！毕业了更新也随缘了 发一个粗略版日本游玩路线，后续有缘更新(实际上去年去的:)出发准备 提前三天兑换日币 （工商卡先购结售汇，再线下预约取汇） 提前四天办流量卡 （也可买亿点卡，机场自取+5元。注意晚上到，好像开通了也算一天 ） 充电宝满电 护照、身份证 visit Japan wen https://tenki.jp/ 看天气 night 找家便利店吃饭，考虑购买100yen的硬币收集器，并且微信搜索”微信支付全球有礼“集满6单小零食，汇率最低get，或者支付宝铂金会员可直接使用支付宝，汇率差不多day 1 上午9点到浅草寺 中午去西餐 近秋叶原、近浅草寺 吃完去猫头鹰咖啡馆！要预约 悲 下午逛秋叶原 晚上六点到天空塔，建议提前购票 晚餐 Venu's South Indian Dining 又去了附近的大黑汤，语言不通还是很尴尬的 day 2 早上去恩赐庭园 中午银座 晚上东京塔 来得及去台场高达基地八点关门 https://maps.app.goo.gl/sLCVZqfAXehnYuYy7 饭：午餐：银座鳗鱼饭、银座鳗鱼饭2 、银座拉面 便宜、靠近恩赐庭园 顺","tags":["Blog","Travel"],"title":"日本游玩五天记","url":"http://localhost:1313/posts/life/japan-travel/"},{"categories":["life"],"content":"路 但是只有晚餐、恩赐庭园 中晚餐 饮品：抹茶拿铁 可能排队 、松饼 （个人不推荐松饼，太甜，另一家的xhs推的松饼也不好吃） day 3 10点前办理退宿早上去明治神宫午餐 11:00–23:00、11:00–22:00中午润京都 晚上逛八坂神社→二条→三条→有时间清水寺 晚餐 和牛烤肉，起码一个月前预定、炸猪排(搭讪了国人，一起逛了清水寺哈哈哈)、神户牛肉 需预定、寿司，金枪鱼好吃 贵day 4 寄存行李早上去二条城中午回大阪，全走地铁比较便宜 午餐：food1、food2下午去大阪城公园晚餐：和牛、和牛 应该挺少的 价格较贵 、和牛 距离最远，得反方向先道顿晚上逛道顿街、心斋桥小吃：鲷鱼烧 、Takoyaki Achako 离酒店近 夜宵章鱼烧day 5 一整天的环球影城，强烈推荐去玩 good！！！","date":"2025-01-16T19:27:28+08:00","objectID":"d96624030a49a9537409f6c96ced4a20_1","order":1,"summary":"路 但是只有晚餐、恩赐庭园 中晚餐 饮品：抹茶拿铁 可能排队 、松饼 （个人不推荐松饼，太甜，另一家的xhs推的松饼也不好吃） day 3 10点前办理退宿早上去明治神宫午餐 11:00–23:00、11:00–22:00中午润京都 晚上逛八坂神社→二条→三条→有时间清水寺 晚餐 和牛烤肉，起码一个月前预定、炸猪排(搭讪了国人，一起逛了清水寺哈哈哈)、神户牛肉 需预定、寿司，金枪鱼好吃 贵day 4 寄存行李早上去二条城中午回大阪，全走地铁比较便宜 午餐：food1、food2下午去大阪城公园晚餐：和牛、和牛 应该挺少的 价格较贵 、和牛 距离最远，得反方向先道顿晚上逛道顿街、心斋桥小吃：鲷鱼烧 、Takoyaki Achako 离酒店近 夜宵章鱼烧day 5 一整天的环球影城，强烈推荐去玩 good！！！","tags":["Blog","Travel"],"title":"日本游玩五天记","url":"http://localhost:1313/posts/life/japan-travel/"},{"categories":["life"],"content":" 前情提要：最近两个月腾讯云的消费突然激增了300倍的消费（0.01→3.21￥） 预告：最近再整篇大的，关于qt面试总结，看我找工作情况择日发布吧查看消费来源 首先在网站上登陆你的账号，然后进入费用界面 选择费用账单→账单查看→选择按产品汇总的\"查看更多\"，从中找到最高消费的服务 选择对应的存储桶id，最后就能找到高消费的来源 本文是由于开启了盲水印服务，导致消费激增。（笑死，都没人看，还防盗） 解决方案 询问GPT 获得Python代码 修改后上传至服务器，就不会使用该服务了（标题党嫌疑，哈哈哈） 注意，数据万象这个服务一旦开启就无法关闭，只能通过修改路径接口，停止使用对应服务即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import os import re def modify_md_files(folder_path): # 遍历文件夹及其子文件夹 for root, dirs, files in os.walk(folder_path): for file_name in files: if file","date":"2024-05-03T14:53:49+08:00","objectID":"5e9b0767e9e034fd38afc6994550326d_0","order":0,"summary":" 前情提要：最近两个月腾讯云的消费突然激增了300倍的消费（0.01→3.21￥） 预告：最近再整篇大的，关于qt面试总结，看我找工作情况择日发布吧查看消费来源 首先在网站上登陆你的账号，然后进入费用界面 选择费用账单→账单查看→选择按产品汇总的\"查看更多\"，从中找到最高消费的服务 选择对应的存储桶id，最后就能找到高消费的来源 本文是由于开启了盲水印服务，导致消费激增。（笑死，都没人看，还防盗） 解决方案 询问GPT 获得Python代码 修改后上传至服务器，就不会使用该服务了（标题党嫌疑，哈哈哈） 注意，数据万象这个服务一旦开启就无法关闭，只能通过修改路径接口，停止使用对应服务即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import os import re def modify_md_files(folder_path): # 遍历文件夹及其子文件夹 for root, dirs, files in os.walk(folder_path): for file_name in files: if file","tags":["Others"],"title":"腾讯云关闭数据万象相关服务","url":"http://localhost:1313/posts/life/oss-high-cost/"},{"categories":["other"],"content":"记录一些我没用到但是butterfly上是true的选项Page Front-matter PFM1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- title: # 【必需】页面标题 date: #【必需】页面创建日期 updated: type: # 【必需】标签、分类和友情链接三个页面需要配置 comments: description: keywords: top_img: mathjax: katex: aside: aplayer: highlight_shrink: --- updated\t【可选】页面更新日期description\t【可选】页面描述keywords\t【可选】页面关键字comments\t【可选】显示页面评论模块 (默认 true)top_img\t【可选】页面顶部图片mathjax\t【可选】显示mathjax (当设置mathjax的per_page: false时，才需要配置，默认 false)katex\t【可选】显示katex (当设置katex的per_page: false时，才需要配置，默认 false)aside\t【可","date":"2024-04-01T09:31:54+08:00","objectID":"c0119240ec6f9e481110b7e7562d9546_0","order":0,"summary":"记录一些我没用到但是butterfly上是true的选项Page Front-matter PFM1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 --- title: # 【必需】页面标题 date: #【必需】页面创建日期 updated: type: # 【必需】标签、分类和友情链接三个页面需要配置 comments: description: keywords: top_img: mathjax: katex: aside: aplayer: highlight_shrink: --- updated\t【可选】页面更新日期description\t【可选】页面描述keywords\t【可选】页面关键字comments\t【可选】显示页面评论模块 (默认 true)top_img\t【可选】页面顶部图片mathjax\t【可选】显示mathjax (当设置mathjax的per_page: false时，才需要配置，默认 false)katex\t【可选】显示katex (当设置katex的per_page: false时，才需要配置，默认 false)aside\t【可","tags":["Blog","Hugo"],"title":"hexo博客美化","url":"http://localhost:1313/posts/other/hexo-custom/"},{"categories":["other"],"content":"选】显示侧边栏 (默认 true)aplayer\t【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置highlight_shrink\t【可选】配置代码框是否展开 (true/false) (默认为设置中highlight_shrink的配置)Post Front-matter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 --- title: date: updated: tags: categories: keywords: description: top_img: comments: cover: toc: toc_number: toc_style_simple: copyright: copyright_author: copyright_author_href: copyright_url: copyright_info: mathjax: katex: aplayer: highlight_shrink: aside: abcjs: --- title","date":"2024-04-01T09:31:54+08:00","objectID":"c0119240ec6f9e481110b7e7562d9546_1","order":1,"summary":"选】显示侧边栏 (默认 true)aplayer\t【可选】在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置highlight_shrink\t【可选】配置代码框是否展开 (true/false) (默认为设置中highlight_shrink的配置)Post Front-matter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 --- title: date: updated: tags: categories: keywords: description: top_img: comments: cover: toc: toc_number: toc_style_simple: copyright: copyright_author: copyright_author_href: copyright_url: copyright_info: mathjax: katex: aplayer: highlight_shrink: aside: abcjs: --- title","tags":["Blog","Hugo"],"title":"hexo博客美化","url":"http://localhost:1313/posts/other/hexo-custom/"},{"categories":["other"],"content":"\t【必需】文章标题date\t【必需】文章创建日期updated\t【可选】文章更新日期tags\t【可选】文章标签categories\t【可选】文章分类keywords\t【可选】文章关键字description\t【可选】文章描述top_img\t【可选】文章顶部图片cover\t【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)comments\t【可选】显示文章评论模块(默认 true)toc\t【可选】显示文章TOC(默认为设置中toc的enable配置)toc_number\t【可选】显示toc_number(默认为设置中toc的number配置)toc_style_simple\t【可选】显示 toc 简洁模式copyright\t【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)copyright_author\t【可选】文章版权模块的文章作者copyright_author_href\t【可选】文章版权模块的文章作者链接copyright_url\t【可选】文章版权模块的文章连结链接copyright_in","date":"2024-04-01T09:31:54+08:00","objectID":"c0119240ec6f9e481110b7e7562d9546_2","order":2,"summary":"\t【必需】文章标题date\t【必需】文章创建日期updated\t【可选】文章更新日期tags\t【可选】文章标签categories\t【可选】文章分类keywords\t【可选】文章关键字description\t【可选】文章描述top_img\t【可选】文章顶部图片cover\t【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)comments\t【可选】显示文章评论模块(默认 true)toc\t【可选】显示文章TOC(默认为设置中toc的enable配置)toc_number\t【可选】显示toc_number(默认为设置中toc的number配置)toc_style_simple\t【可选】显示 toc 简洁模式copyright\t【可选】显示文章版权模块(默认为设置中post_copyright的enable配置)copyright_author\t【可选】文章版权模块的文章作者copyright_author_href\t【可选】文章版权模块的文章作者链接copyright_url\t【可选】文章版权模块的文章连结链接copyright_in","tags":["Blog","Hugo"],"title":"hexo博客美化","url":"http://localhost:1313/posts/other/hexo-custom/"},{"categories":["other"],"content":"fo\t【可选】文章版权模块的版权声明文字mathjax\t【可选】显示mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false )katex\t【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false )aplayer\t【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置highlight_shrink\t【可选】配置代码框是否展开(true/false)(默认为设置中 highlight_shrink 的配置)aside\t【可选】显示侧边栏 (默认 true)abcjs\t【可选】加载 abcjs (当设置 abcjs 的 per_page: false 时，才需要配置，默认 false )图库 https://butterfly.js.org/posts/dc584b87/#%E5%9C%96%E5%BA%AB网址同步 因为我是从halo迁移过来，原主题的front-matter信息跟hexo不一致，多了一个url属性，表明文件路径1 2 3","date":"2024-04-01T09:31:54+08:00","objectID":"c0119240ec6f9e481110b7e7562d9546_3","order":3,"summary":"fo\t【可选】文章版权模块的版权声明文字mathjax\t【可选】显示mathjax(当设置 mathjax 的 per_page: false 时，才需要配置，默认 false )katex\t【可选】显示 katex (当设置 katex 的 per_page: false 时，才需要配置，默认 false )aplayer\t【可选】在需要的页面加载 aplayer 的 js 和 css,请参考文章下面的音乐 配置highlight_shrink\t【可选】配置代码框是否展开(true/false)(默认为设置中 highlight_shrink 的配置)aside\t【可选】显示侧边栏 (默认 true)abcjs\t【可选】加载 abcjs (当设置 abcjs 的 per_page: false 时，才需要配置，默认 false )图库 https://butterfly.js.org/posts/dc584b87/#%E5%9C%96%E5%BA%AB网址同步 因为我是从halo迁移过来，原主题的front-matter信息跟hexo不一致，多了一个url属性，表明文件路径1 2 3","tags":["Blog","Hugo"],"title":"hexo博客美化","url":"http://localhost:1313/posts/other/hexo-custom/"},{"categories":["create"],"content":"题注的章节号设置 问题：题注或页码中不含章节编号。请使用“开始”选项卡上的“多级列表”按钮，然后选择链接到标题样式的编号方案。 前因：从师兄复制过来的样式不对，将每个标题都新建了一个样式并且应用到标题中（见图1中的1.1，1.1.1），不是默认的标题x（见图1中的最右上角） 方案： 首先将光标移动到你的标题1旁，使当前多级列表为你设置的样式。 点击“开始”选项卡上的“多级列表”按钮。（见图1） 点击弹出框内的“更多”，点击右侧的“将级别链接到样式”下拉框，选择标题1. （可选）并且调整左侧的“输入编号的格式”，为编号1左侧加入“第”，右侧加入“章”，实现第 x 章的效果，注意1不能删除。（见图2） 调整你的标题1的样式为学校要求的格式，如黑体三号，行距1.5。（如果遇到没有标题2，见此处）（见图3） 至此，你的标题格式已设置好，并且题注已经链接到标题1的样式，此时就可以插入带有章节号的题注了（见图4，注意先居中图片，题注就会自动居中） 修改题注样式为学校要求的格式，如中文宋体小四加粗、英文新罗马，使每次插入题注一致（见图5，注意如果对齐设置的是居中，题注框中的文字预览部分可能看不见字，","date":"2024-03-31T23:51:27+08:00","objectID":"9cda2b5a4e8d2e603df89b4d500a6a19_0","order":0,"summary":"题注的章节号设置 问题：题注或页码中不含章节编号。请使用“开始”选项卡上的“多级列表”按钮，然后选择链接到标题样式的编号方案。 前因：从师兄复制过来的样式不对，将每个标题都新建了一个样式并且应用到标题中（见图1中的1.1，1.1.1），不是默认的标题x（见图1中的最右上角） 方案： 首先将光标移动到你的标题1旁，使当前多级列表为你设置的样式。 点击“开始”选项卡上的“多级列表”按钮。（见图1） 点击弹出框内的“更多”，点击右侧的“将级别链接到样式”下拉框，选择标题1. （可选）并且调整左侧的“输入编号的格式”，为编号1左侧加入“第”，右侧加入“章”，实现第 x 章的效果，注意1不能删除。（见图2） 调整你的标题1的样式为学校要求的格式，如黑体三号，行距1.5。（如果遇到没有标题2，见此处）（见图3） 至此，你的标题格式已设置好，并且题注已经链接到标题1的样式，此时就可以插入带有章节号的题注了（见图4，注意先居中图片，题注就会自动居中） 修改题注样式为学校要求的格式，如中文宋体小四加粗、英文新罗马，使每次插入题注一致（见图5，注意如果对齐设置的是居中，题注框中的文字预览部分可能看不见字，","tags":["Others"],"title":"毕业论文格式小技巧","url":"http://localhost:1313/posts/create/graduation-thesis-format-tips/"},{"categories":["create"],"content":"见此处） 一些小提醒：如果仍出现上述问题，需要手动再应用一下标题1到原来的标题上；题注中序号和标题之间需要加个小空格 图片： 图1图2图3图4图5参考链接 word报错 目录格式统一 问题：目录每次刷新目录，都会出现中英文混杂，导致前导符样式不一致 方案： 全选目录，右键弹出菜单栏，修改为宋体，小四 缺点：无法自动更新，每次刷新目录需要手动，暂无更好的解决方案 图片： 论文打勾样式 方案： 直接复制☑即可，但是跟不打勾的样式不一致，无法解决 其他打勾样式：word方框（□）中打钩（√）的5种方法 图表样式更新域后不变 问题：正文中交叉引用图表后，样式设置为正文样式，但是更新域代码后又变为题注样式。 前因：正文中交叉引用图标后，“图”和“1.1”之间带空格，想删去，保持统一，但是打印预览后，样式不对 方案： 手动删除所有题注之间的空格，或者设置创建题注时，自动删除（见此处） 然后重新应用格式刷即可（ctrl+shift+c / ctrl+shift+v） （可选）检查是否选上“更新时保留原格式” 主要原因是题注和引用的内容不一致：“图 1.1”≠“图1.1”，导致每次更新域会重新应用原题","date":"2024-03-31T23:51:27+08:00","objectID":"9cda2b5a4e8d2e603df89b4d500a6a19_1","order":1,"summary":"见此处） 一些小提醒：如果仍出现上述问题，需要手动再应用一下标题1到原来的标题上；题注中序号和标题之间需要加个小空格 图片： 图1图2图3图4图5参考链接 word报错 目录格式统一 问题：目录每次刷新目录，都会出现中英文混杂，导致前导符样式不一致 方案： 全选目录，右键弹出菜单栏，修改为宋体，小四 缺点：无法自动更新，每次刷新目录需要手动，暂无更好的解决方案 图片： 论文打勾样式 方案： 直接复制☑即可，但是跟不打勾的样式不一致，无法解决 其他打勾样式：word方框（□）中打钩（√）的5种方法 图表样式更新域后不变 问题：正文中交叉引用图表后，样式设置为正文样式，但是更新域代码后又变为题注样式。 前因：正文中交叉引用图标后，“图”和“1.1”之间带空格，想删去，保持统一，但是打印预览后，样式不对 方案： 手动删除所有题注之间的空格，或者设置创建题注时，自动删除（见此处） 然后重新应用格式刷即可（ctrl+shift+c / ctrl+shift+v） （可选）检查是否选上“更新时保留原格式” 主要原因是题注和引用的内容不一致：“图 1.1”≠“图1.1”，导致每次更新域会重新应用原题","tags":["Others"],"title":"毕业论文格式小技巧","url":"http://localhost:1313/posts/create/graduation-thesis-format-tips/"},{"categories":["create"],"content":"注样式 图片 批量更新域 方案： 文件-\u003e打印，或者搜索栏搜索“打印预览” CTRL+A 然后 F9 小提示：这也是出现格式问题最大的地方，如果你的引用没有设置好，不再检查一下的话，很容易就会样式不对，直接打回延毕！🤪 图片： 查看多余空格，换行等 方案： CTRL+*，启用显示编辑标记 选择上图中的互指箭头 效果为空格以·表示 插入高清图片 方案： 一种是使用visio画图，直接粘贴复制到word中，不推荐drawio 一种是将visio或者excel做的图导出为svg（推荐，但是可能会出现显示不全的问题，或者文字被压缩） 截图的图片、上述不行的图片转成png（次推荐，但相对来说不清晰） 保存为emf文件（可能会稍微清晰，但是个人感觉效果不好） 设置ppi 表格续表 方案： 插入文本框，布局选项设置为固定，并且紧密型环绕 选中文本框，右键弹出样式框，修改边框为”无轮廓“，然后”设置为默认文本框“ 交叉引用出表编号，再加入（续），设置文字样式，最后居中 tips：手动加入续表（样式最一致，但比较麻烦，适合终稿再修改，精致党可选🤗） 图片： 参考链接：表格跨页续表 分割符与页表页码 问题","date":"2024-03-31T23:51:27+08:00","objectID":"9cda2b5a4e8d2e603df89b4d500a6a19_2","order":2,"summary":"注样式 图片 批量更新域 方案： 文件-\u003e打印，或者搜索栏搜索“打印预览” CTRL+A 然后 F9 小提示：这也是出现格式问题最大的地方，如果你的引用没有设置好，不再检查一下的话，很容易就会样式不对，直接打回延毕！🤪 图片： 查看多余空格，换行等 方案： CTRL+*，启用显示编辑标记 选择上图中的互指箭头 效果为空格以·表示 插入高清图片 方案： 一种是使用visio画图，直接粘贴复制到word中，不推荐drawio 一种是将visio或者excel做的图导出为svg（推荐，但是可能会出现显示不全的问题，或者文字被压缩） 截图的图片、上述不行的图片转成png（次推荐，但相对来说不清晰） 保存为emf文件（可能会稍微清晰，但是个人感觉效果不好） 设置ppi 表格续表 方案： 插入文本框，布局选项设置为固定，并且紧密型环绕 选中文本框，右键弹出样式框，修改边框为”无轮廓“，然后”设置为默认文本框“ 交叉引用出表编号，再加入（续），设置文字样式，最后居中 tips：手动加入续表（样式最一致，但比较麻烦，适合终稿再修改，精致党可选🤗） 图片： 参考链接：表格跨页续表 分割符与页表页码 问题","tags":["Others"],"title":"毕业论文格式小技巧","url":"http://localhost:1313/posts/create/graduation-thesis-format-tips/"},{"categories":["create"],"content":"：摘要的中英文页码为罗马数字，正文的是数字；并且目录不带页码 前因：分隔符直接用快捷键SHIFT+ENTER，插入的是分节符，而不是分节符（下一页） 方案： 在英文摘要最后插入”分节符（下一页）” 双击目录第一页的页眉部分，在页眉和页脚栏处取消“链接到前一节” 设置中英文摘要为罗马数字，将中文摘要取消“链接到前一节” 删除封面的页码 tips：取消链接到前一节，就可以防止前一节的页码继承到当前节，就可以解决当前页号不对或者删除前一节的页号导致当前节的页号一起消失。 图片： 其他方法：封面、目录、正文设置不同页码步骤教学 修改表格中公式间距问题 问题：表格中插入公式，导致每行的间距不一致，并且正文部分插入公式也会修改行间距。 前因：答辩老师指出需要修改 方案： 选中对应文字 搜索段落设置 或者右键找到段落 修改如果定义了文档网格，则对齐到网格 为false 参考连接：Word中插入公式后行距变大的解决办法 ","date":"2024-03-31T23:51:27+08:00","objectID":"9cda2b5a4e8d2e603df89b4d500a6a19_3","order":3,"summary":"：摘要的中英文页码为罗马数字，正文的是数字；并且目录不带页码 前因：分隔符直接用快捷键SHIFT+ENTER，插入的是分节符，而不是分节符（下一页） 方案： 在英文摘要最后插入”分节符（下一页）” 双击目录第一页的页眉部分，在页眉和页脚栏处取消“链接到前一节” 设置中英文摘要为罗马数字，将中文摘要取消“链接到前一节” 删除封面的页码 tips：取消链接到前一节，就可以防止前一节的页码继承到当前节，就可以解决当前页号不对或者删除前一节的页号导致当前节的页号一起消失。 图片： 其他方法：封面、目录、正文设置不同页码步骤教学 修改表格中公式间距问题 问题：表格中插入公式，导致每行的间距不一致，并且正文部分插入公式也会修改行间距。 前因：答辩老师指出需要修改 方案： 选中对应文字 搜索段落设置 或者右键找到段落 修改如果定义了文档网格，则对齐到网格 为false 参考连接：Word中插入公式后行距变大的解决办法 ","tags":["Others"],"title":"毕业论文格式小技巧","url":"http://localhost:1313/posts/create/graduation-thesis-format-tips/"},{"categories":["tech"],"content":"预准备 环境：Ubuntu 18.04 cuda11.3 gcc7.5 qt5.14.2 不必一致 安装教程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 sudo apt-get install \\ git \\ cmake \\ ninja-build \\ build-essential \\ libboost-program-options-dev \\ libboost-filesystem-dev \\ libboost-graph-dev \\ libboost-system-dev \\ libeigen3-dev \\ libflann-dev \\ libfreeimage-dev \\ libmetis-dev \\ libgoogle-glog-dev \\ libgtest-dev \\ libsqlite3-dev \\ libglew-dev \\ qtbase5-dev \\ libqt5opengl5-dev \\ libcgal-dev \\ libceres-dev 安装colmap 参考colmap新版本没有dev环境 1","date":"2024-01-17T23:07:42+08:00","objectID":"6ffd7573136e217acfee8cfa3c1e4a8c_0","order":0,"summary":"预准备 环境：Ubuntu 18.04 cuda11.3 gcc7.5 qt5.14.2 不必一致 安装教程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 sudo apt-get install \\ git \\ cmake \\ ninja-build \\ build-essential \\ libboost-program-options-dev \\ libboost-filesystem-dev \\ libboost-graph-dev \\ libboost-system-dev \\ libeigen3-dev \\ libflann-dev \\ libfreeimage-dev \\ libmetis-dev \\ libgoogle-glog-dev \\ libgtest-dev \\ libsqlite3-dev \\ libglew-dev \\ qtbase5-dev \\ libqt5opengl5-dev \\ libcgal-dev \\ libceres-dev 安装colmap 参考colmap新版本没有dev环境 1","tags":["Install"],"title":"colmap 安装","url":"http://localhost:1313/posts/tech/colmap-install/"},{"categories":["other"],"content":"对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少? FIN_WAIT_2：半关闭状态。发送断开请求一方还有接收数据能力，但已经没有发送数据能力。CLOSE_WAIT状态：被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。TIME_WAIT状态：又叫2MSL等待状态。 为了使被动关闭的一方正确的关闭，以及防止历史数据出现在新连接中。 你了解流量控制原理吗？ 流量控制就是让「发送方」根据「接收方」的实际接收能力控制发送的数据量。 如何控制： 接收方每次收到数据包，可以在发送ACK报文时，同时告诉发送方自己的接收窗口大小还剩余多少是空闲的。发送方收到之后，便会调整发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，并且同时开启一个定时器，每隔一段时间就发个探测报文询问接收方。如果可以，接收方就告诉他此时接受窗口的大小；如果接受窗口大小还是为0，则发送方再次刷新启动定时器。一般情况下接收窗口 \u003e= 发送窗口。 https://blog.csdn","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_0","order":0,"summary":"对于FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？你知道多少? FIN_WAIT_2：半关闭状态。发送断开请求一方还有接收数据能力，但已经没有发送数据能力。CLOSE_WAIT状态：被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。被动关闭连接一方如果还有剩余数据要发送就会进入CLOSE_WAIT状态。TIME_WAIT状态：又叫2MSL等待状态。 为了使被动关闭的一方正确的关闭，以及防止历史数据出现在新连接中。 你了解流量控制原理吗？ 流量控制就是让「发送方」根据「接收方」的实际接收能力控制发送的数据量。 如何控制： 接收方每次收到数据包，可以在发送ACK报文时，同时告诉发送方自己的接收窗口大小还剩余多少是空闲的。发送方收到之后，便会调整发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，并且同时开启一个定时器，每隔一段时间就发个探测报文询问接收方。如果可以，接收方就告诉他此时接受窗口的大小；如果接受窗口大小还是为0，则发送方再次刷新启动定时器。一般情况下接收窗口 \u003e= 发送窗口。 https://blog.csdn","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":".net/weixin_43901865/article/details/113106417建立TCP服务器的各个系统调用过程是怎样的？ 服务器：创建socket -\u003e int socket(int domain, int type, int protocol);domain：协议域，决定了socket的地址类型，IPv4为AF_INET。type：指定socket类型，SOCK_STREAM为TCP连接,SOCK_DGRAM为UDP连接。protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。绑定socket和端口号 -\u003e int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockfd：socket返回的套接字描述符，类似于文件描述符fd。addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。addrlen：地址长度。1 2 3 4 5 6 7 8 9 // IPv4的sockaddr地址结构 struct sockaddr_in { sa","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_1","order":1,"summary":".net/weixin_43901865/article/details/113106417建立TCP服务器的各个系统调用过程是怎样的？ 服务器：创建socket -\u003e int socket(int domain, int type, int protocol);domain：协议域，决定了socket的地址类型，IPv4为AF_INET。type：指定socket类型，SOCK_STREAM为TCP连接,SOCK_DGRAM为UDP连接。protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。绑定socket和端口号 -\u003e int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);sockfd：socket返回的套接字描述符，类似于文件描述符fd。addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。addrlen：地址长度。1 2 3 4 5 6 7 8 9 // IPv4的sockaddr地址结构 struct sockaddr_in { sa","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"_family_t sin_family; // 协议类型，AF_INET in_port_t sin_port; // 端口号 struct in_addr sin_addr; // IP地址 }; struct in_addr { uint32_t s_addr; } 监听端口号 -\u003e int listen(int sockfd, int backlog);sockfd：要监听的sock描述字。backlog：socket可以排队的最大连接数。接收用户请求 -\u003e int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);sockfd：服务器socket描述字。addr：指向客户端地址结构指针。addrlen：协议地址长度。注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。从socket中读取字符 -\u003e ssize_t read(int fd, void *buf, size_t count);fd：连接描述字。buf：缓冲区buf。count：缓冲区长度。注：大于0表示","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_2","order":2,"summary":"_family_t sin_family; // 协议类型，AF_INET in_port_t sin_port; // 端口号 struct in_addr sin_addr; // IP地址 }; struct in_addr { uint32_t s_addr; } 监听端口号 -\u003e int listen(int sockfd, int backlog);sockfd：要监听的sock描述字。backlog：socket可以排队的最大连接数。接收用户请求 -\u003e int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);sockfd：服务器socket描述字。addr：指向客户端地址结构指针。addrlen：协议地址长度。注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。从socket中读取字符 -\u003e ssize_t read(int fd, void *buf, size_t count);fd：连接描述字。buf：缓冲区buf。count：缓冲区长度。注：大于0表示","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"读取的字节数，返回0表示文件读取结束，小于0表示发生错误。关闭socket -\u003e int close(int fd);fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。客户机：创建socket -\u003e int socket(int domain, int type, int protocol);连接指定计算机 -\u003e int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);sockfd客户端的sock描述字。addr：服务器的地址。addrlen：socket地址长度。向socket写入信息 -\u003e ssize_t write(int fd, const void *buf, size_t count);fd、buf、count：同read中意义。大于0表示写了部分或全部数据，小于0表示出错。关闭socket -\u003e int close(int fd);fd：同服务器端fd。 TCP 协议如","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_3","order":3,"summary":"读取的字节数，返回0表示文件读取结束，小于0表示发生错误。关闭socket -\u003e int close(int fd);fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。客户机：创建socket -\u003e int socket(int domain, int type, int protocol);连接指定计算机 -\u003e int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);sockfd客户端的sock描述字。addr：服务器的地址。addrlen：socket地址长度。向socket写入信息 -\u003e ssize_t write(int fd, const void *buf, size_t count);fd、buf、count：同read中意义。大于0表示写了部分或全部数据，小于0表示出错。关闭socket -\u003e int close(int fd);fd：同服务器端fd。 TCP 协议如","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"何保证可靠传输？ 建立连接（标志位）：通信前确认通信实体存在。序号机制（序号、确认号）：确保了数据是按序、完整到达。数据校验（校验和）：CRC校验全部数据。超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。流量控制：发送方根据接受方的实际接受能力控制发送的数据量。拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。UDP是什么？ 提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。UDP头部只有8个字节，包含源和目标端口号，包长度和校验和，各占16位。TCP和UDP的区别 连接TCP 是面向连接的传输层协议，传输数据前先要建立连接。 UDP 是面向报文的传输层协议，即刻传输数据。 服务对象TCP 是一对一的两点服务，即一条连接只有两个端点。 UDP 支持一对一、一对多、多对多的交互通信 可靠性TCP 是可靠交付数据的~~，数据可以无差错、不丢失、不重复、按序到达~~。 UDP 是尽最大努力交付，不保证可靠交付数据。拓展：但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：如何基于 UDP 协议实现","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_4","order":4,"summary":"何保证可靠传输？ 建立连接（标志位）：通信前确认通信实体存在。序号机制（序号、确认号）：确保了数据是按序、完整到达。数据校验（校验和）：CRC校验全部数据。超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。流量控制：发送方根据接受方的实际接受能力控制发送的数据量。拥塞控制：当网络拥塞时，通过拥塞窗口，减少数据的发送，防止包丢失。UDP是什么？ 提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。UDP头部只有8个字节，包含源和目标端口号，包长度和校验和，各占16位。TCP和UDP的区别 连接TCP 是面向连接的传输层协议，传输数据前先要建立连接。 UDP 是面向报文的传输层协议，即刻传输数据。 服务对象TCP 是一对一的两点服务，即一条连接只有两个端点。 UDP 支持一对一、一对多、多对多的交互通信 可靠性TCP 是可靠交付数据的~~，数据可以无差错、不丢失、不重复、按序到达~~。 UDP 是尽最大努力交付，不保证可靠交付数据。拓展：但是我们可以基于 UDP 传输协议实现一个可靠的传输协议，比如 QUIC 协议，具体可以参见这篇文章：如何基于 UDP 协议实现","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"可靠传输？(opens new window) 拥塞控制、流量控制TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。 首部开销TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长（最大60字节）。 UDP 首部只有 8 个字节，并且是固定不变的，开销较小。 传输方式TCP 是流式传输，没有边界 UDP 是一个包一个包的发送，是有边界的 分片不同TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，在传输层组装 TCP 数据包。 UDP 的数据大小如果大于 MTU 大小，则会在网络层进行分片，目标主机收到后，在网络层组装完数据，接着再传给传输层。 补充题：封包和拆包你听说过吗？它是基于TCP还是UDP的？ 封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，包含该数据包的总长度。 拆包：接收方接收","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_5","order":5,"summary":"可靠传输？(opens new window) 拥塞控制、流量控制TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。 UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。 首部开销TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长（最大60字节）。 UDP 首部只有 8 个字节，并且是固定不变的，开销较小。 传输方式TCP 是流式传输，没有边界 UDP 是一个包一个包的发送，是有边界的 分片不同TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，在传输层组装 TCP 数据包。 UDP 的数据大小如果大于 MTU 大小，则会在网络层进行分片，目标主机收到后，在网络层组装完数据，接着再传给传输层。 补充题：封包和拆包你听说过吗？它是基于TCP还是UDP的？ 封包和拆包都是基于TCP的概念。因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，包含该数据包的总长度。 拆包：接收方接收","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"到报文后提取包头中的长度信息进行截取。 UDP的特点有哪些（附赠TCP的特点）？ UDP是无连接的，面向报文的； UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）； UDP支持一对一、一对多、多对多的交互通信； UDP的首部开销小，只有8个字节 那么，再说一次TCP的特点：TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）； TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_6","order":6,"summary":"到报文后提取包头中的长度信息进行截取。 UDP的特点有哪些（附赠TCP的特点）？ UDP是无连接的，面向报文的； UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）； UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）； UDP支持一对一、一对多、多对多的交互通信； UDP的首部开销小，只有8个字节 那么，再说一次TCP的特点：TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）； 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）； TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且按序到达； TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据； 面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。 TCP对应的应用层协议 FTP：定义了文件传输协议，使用21端口. Telnet：它是一种用于远程登陆的端口,23端口 SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件，110端口。UDP对应的应用层协议 DNS：用于域名解析服务，用的是53号端口 SNMP：简单网络管理协议，使用161号端口 TFTP(Trival File Transfer Protocal)：简单文件传输协议，69数据链路层常见协议？可以说一下吗？ 协议 名称 作用 ARP 地址解析协议 根据IP地址获取物理地址 RARP 反向地址转换协议 根据物理地址获取IP地址 PPP 点对点协议 主要是用来通过拨号或专线方式建立点对点连接发送数据 Ping命令基于什么协议？原理是什么？ ping是基于网络层的ICMP协议实现的。通过向对方发送一个ICMP回送请求报文，如果对方主机可达的话会收到该报文，并响应一个ICMP回送回答报文。扩展：ICMP报文的介绍。ICMP报文分为两个种类：IC","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_7","order":7,"summary":"不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。 TCP对应的应用层协议 FTP：定义了文件传输协议，使用21端口. Telnet：它是一种用于远程登陆的端口,23端口 SMTP：定义了简单邮件传送协议，服务器开放的是25号端口。 POP3：它是和SMTP对应，POP3用于接收邮件，110端口。UDP对应的应用层协议 DNS：用于域名解析服务，用的是53号端口 SNMP：简单网络管理协议，使用161号端口 TFTP(Trival File Transfer Protocal)：简单文件传输协议，69数据链路层常见协议？可以说一下吗？ 协议 名称 作用 ARP 地址解析协议 根据IP地址获取物理地址 RARP 反向地址转换协议 根据物理地址获取IP地址 PPP 点对点协议 主要是用来通过拨号或专线方式建立点对点连接发送数据 Ping命令基于什么协议？原理是什么？ ping是基于网络层的ICMP协议实现的。通过向对方发送一个ICMP回送请求报文，如果对方主机可达的话会收到该报文，并响应一个ICMP回送回答报文。扩展：ICMP报文的介绍。ICMP报文分为两个种类：IC","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"MP差错报告报文，常见的有 终点不可达 时间超过 参数问题 改变路由 ICMP询问报文 回送请求和回答：向特定主机发出回送请求报文，收到回送请求报文的主机响应回送回答报文。 时间戳请求和回答：询问对方当前的时间，返回的是一个32位的时间戳。 在进行UDP编程的时候，一次发送多少bytes好? 最好的情况下是数据链路层限制的MTU大小-IP层头部20字节-UDP包头部8字节的数据量进行发送，如以太网可以发送1472字节的数据。在进行Internet的UDP编程时，最好将UDP的数据长度控件在548字节(576-8-20)以内。因为UDP是不可靠的协议，应该尽量防止数据包在数据链路层分片。 https://taifua.com/udp-512bytes-limit.htmlTCP 利用滑动窗口实现流量控制的机制？ 参考82 https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3可以解释一下RTO，RTT和超时重传分别是什么吗？ 超时重传：发送端发送报文后若长时","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_8","order":8,"summary":"MP差错报告报文，常见的有 终点不可达 时间超过 参数问题 改变路由 ICMP询问报文 回送请求和回答：向特定主机发出回送请求报文，收到回送请求报文的主机响应回送回答报文。 时间戳请求和回答：询问对方当前的时间，返回的是一个32位的时间戳。 在进行UDP编程的时候，一次发送多少bytes好? 最好的情况下是数据链路层限制的MTU大小-IP层头部20字节-UDP包头部8字节的数据量进行发送，如以太网可以发送1472字节的数据。在进行Internet的UDP编程时，最好将UDP的数据长度控件在548字节(576-8-20)以内。因为UDP是不可靠的协议，应该尽量防止数据包在数据链路层分片。 https://taifua.com/udp-512bytes-limit.htmlTCP 利用滑动窗口实现流量控制的机制？ 参考82 https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3可以解释一下RTO，RTT和超时重传分别是什么吗？ 超时重传：发送端发送报文后若长时","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"间未收到确认的报文则需要重发该报文。 可能有以下几种情况：发送的数据没能到达接收端，所以对方没有响应。接收端接收到数据，但是ACK报文在返回过程中丢失。接收端拒绝或丢弃数据。RTO(Retransmission Time Out)：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......重传次数到达上限之后停止重传。RTT(Round Trip Time)：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值。拥塞控制原理听说过吗？ 拥塞控制目的是防止数据过多注入到网络中导致网络资源（路由器、交换机等）过载。 TCP拥塞控制算法： 慢开始 \u0026 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口，呈指数增加，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以 1/拥塞窗口 增长拥塞窗口大小，呈线性增加，当发生拥塞，进行超时重传或者快速重传+快速恢复。 最终拥塞窗口会收敛于稳定值。 如何区分流量控制和拥塞控制？ 流量控制属于通信双方协商；拥塞控制用于控","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_9","order":9,"summary":"间未收到确认的报文则需要重发该报文。 可能有以下几种情况：发送的数据没能到达接收端，所以对方没有响应。接收端接收到数据，但是ACK报文在返回过程中丢失。接收端拒绝或丢弃数据。RTO(Retransmission Time Out)：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......重传次数到达上限之后停止重传。RTT(Round Trip Time)：一个连接的往返时间，即数据发送时刻到接收到确认的时刻的差值。拥塞控制原理听说过吗？ 拥塞控制目的是防止数据过多注入到网络中导致网络资源（路由器、交换机等）过载。 TCP拥塞控制算法： 慢开始 \u0026 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口，呈指数增加，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以 1/拥塞窗口 增长拥塞窗口大小，呈线性增加，当发生拥塞，进行超时重传或者快速重传+快速恢复。 最终拥塞窗口会收敛于稳定值。 如何区分流量控制和拥塞控制？ 流量控制属于通信双方协商；拥塞控制用于控","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"制网络中的拥塞情况。流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。常见的HTTP状态码有哪些？ 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。「301 M","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_10","order":10,"summary":"制网络中的拥塞情况。流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。常见的HTTP状态码有哪些？ 1xx 类状态码属于提示信息，是协议处理中的一种中间状态，实际用到的比较少。2xx 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。「200 OK」是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。「204 No Content」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。「206 Partial Content」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。「301 M","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"oved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。「500 Internal Server Error」与 400 类型，是个笼统通用的错误","date":"2024-01-13T21:57:33+08:00","objectID":"5593b00f17aa84c9c17ce2378cc83317_11","order":11,"summary":"oved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。 4xx 类状态码表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。5xx 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。「500 Internal Server Error」与 400 类型，是个笼统通用的错误","tags":["Interview"],"title":"面试之计算机网络-5","url":"http://localhost:1313/posts/other/interview-network-5/"},{"categories":["other"],"content":"四次挥手相关内容 TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE_WAIT 状态。 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态 服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。 客户端在经过 2MSL 时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。 挥手为什么需要四次？ 服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，但是服务端应用程序可能还有数据要发送，所以并不能马上","date":"2024-01-13T21:57:19+08:00","objectID":"9b8c764f570114b5f0ab8c8c827895fd_0","order":0,"summary":"四次挥手相关内容 TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。客户端打算关闭连接，此时会发送一个 TCP 首部 FIN 标志位被置为 1 的报文，即 FIN 报文，之后客户端进入 FIN_WAIT_1 状态。 服务端收到该报文后，就向客户端发送 ACK 应答报文，接着服务端进入 CLOSE_WAIT 状态。 客户端收到服务端的 ACK 应答报文后，之后进入 FIN_WAIT_2 状态。 等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态。 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态 服务端收到了 ACK 应答报文后，就进入了 CLOSE 状态，至此服务端已经完成连接的关闭。 客户端在经过 2MSL 时间后，自动进入 CLOSE 状态，至此客户端也完成连接的关闭。 挥手为什么需要四次？ 服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，但是服务端应用程序可能还有数据要发送，所以并不能马上","tags":["Interview"],"title":"面试之计算机网络-4","url":"http://localhost:1313/posts/other/interview-network-4/"},{"categories":["other"],"content":"发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序：如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数； 如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数， MSL和TTL？ MSL（Maximum Segment Lifetime），它是任何报文在网络上存在的最长时间。IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。四次挥手释放连接时，等待2MSL的意义? 保证客户端发送的最后一个ACK报文段能够到达服务端。 因为这个ACK有可能丢失，如果丢失服务器会超时重传这个FIN报文，接着客户端再重传一次确认，重新启动时间等待计时器。保证服务器能正常的关闭。 防止历史连接中的数据，出现在本连接中。经过2MSL，就可以使历史连接内所产生的所有报文段都从网络","date":"2024-01-13T21:57:19+08:00","objectID":"9b8c764f570114b5f0ab8c8c827895fd_1","order":1,"summary":"发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序：如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数； 如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数， MSL和TTL？ MSL（Maximum Segment Lifetime），它是任何报文在网络上存在的最长时间。IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。四次挥手释放连接时，等待2MSL的意义? 保证客户端发送的最后一个ACK报文段能够到达服务端。 因为这个ACK有可能丢失，如果丢失服务器会超时重传这个FIN报文，接着客户端再重传一次确认，重新启动时间等待计时器。保证服务器能正常的关闭。 防止历史连接中的数据，出现在本连接中。经过2MSL，就可以使历史连接内所产生的所有报文段都从网络","tags":["Interview"],"title":"面试之计算机网络-4","url":"http://localhost:1313/posts/other/interview-network-4/"},{"categories":["other"],"content":"中消失。 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？ 同上TCP粘包问题是什么？你会如何去解决它？ TCP粘包是由于TCP是面向流的协议，它只提供了数据的可靠传输，而没有明确的消息边界，用户不知道数据的边界在哪里，导致解析出错。解决：通过特殊标识符表示数据包的边界，例如\\n\\r，\\t，或者一些隐藏字符。 在TCP报文的头部加上表示数据长度。 发送数据时定长发送。 OSI七层模型中表示层和会话层功能是什么？ 参考OSI七层模型。三次握手四次挥手的变迁图 建议不看《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。对称密钥加密的优点缺点？ 对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。优点：运算速度快 缺点：无法安全地将密钥传输给通信方 非对称密钥加密你了解吗？优缺点？ 非对称密钥加密，加密和解密使用不同的密钥。公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被","date":"2024-01-13T21:57:19+08:00","objectID":"9b8c764f570114b5f0ab8c8c827895fd_2","order":2,"summary":"中消失。 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？ 同上TCP粘包问题是什么？你会如何去解决它？ TCP粘包是由于TCP是面向流的协议，它只提供了数据的可靠传输，而没有明确的消息边界，用户不知道数据的边界在哪里，导致解析出错。解决：通过特殊标识符表示数据包的边界，例如\\n\\r，\\t，或者一些隐藏字符。 在TCP报文的头部加上表示数据长度。 发送数据时定长发送。 OSI七层模型中表示层和会话层功能是什么？ 参考OSI七层模型。三次握手四次挥手的变迁图 建议不看《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。对称密钥加密的优点缺点？ 对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。优点：运算速度快 缺点：无法安全地将密钥传输给通信方 非对称密钥加密你了解吗？优缺点？ 非对称密钥加密，加密和解密使用不同的密钥。公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被","tags":["Interview"],"title":"面试之计算机网络-4","url":"http://localhost:1313/posts/other/interview-network-4/"},{"categories":["other"],"content":"公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。优点：可以更安全地将公开密钥传输给通信发送方；缺点：运算速度慢。HTTPS是什么？ HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。HTTP的缺点有哪些？ 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS采用的加密方式有哪些？是对称还是非对称？ HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输会话密钥来保证传输过程的安全性，之后使用对称密钥加密通信来保证通信过程的效率。可以说一下ECDHE的过程。为什么有的时候刷新页面不需要重新建立 SSL 连接？ 由于浏览器和服务器之间的持久","date":"2024-01-13T21:57:19+08:00","objectID":"9b8c764f570114b5f0ab8c8c827895fd_3","order":3,"summary":"公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；私钥加密，公钥解密。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。优点：可以更安全地将公开密钥传输给通信发送方；缺点：运算速度慢。HTTPS是什么？ HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。HTTP的缺点有哪些？ 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPS采用的加密方式有哪些？是对称还是非对称？ HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输会话密钥来保证传输过程的安全性，之后使用对称密钥加密通信来保证通信过程的效率。可以说一下ECDHE的过程。为什么有的时候刷新页面不需要重新建立 SSL 连接？ 由于浏览器和服务器之间的持久","tags":["Interview"],"title":"面试之计算机网络-4","url":"http://localhost:1313/posts/other/interview-network-4/"},{"categories":["other"],"content":"连接机制。当客户端发送新的请求时，提供了之前建立 SSL 连接时的会话标识符或会话票据，服务器就可以使用这些信息恢复之前的 SSL 会话状态，从而避免重新进行完整的 SSL 握手过程。SSL中的认证中的证书是什么？了解过吗？ 一个数字证书通常包含了：公钥； 持有者信息； 证书认证机构（CA）的信息； CA 对这份文件的数字签名及使用的算法； 证书有效期； 还有一些其他额外信息； 数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。扩展 CA 签发证书的过程，如上图左边部分：首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值； 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名； 最后将 Certificate Signature 添加在文件证书上，形成数字证书； 客户端校验服务端的数字证书的过程，如上图右边部分：首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1； 通常浏览器和操作系统中集成了 C","date":"2024-01-13T21:57:19+08:00","objectID":"9b8c764f570114b5f0ab8c8c827895fd_4","order":4,"summary":"连接机制。当客户端发送新的请求时，提供了之前建立 SSL 连接时的会话标识符或会话票据，服务器就可以使用这些信息恢复之前的 SSL 会话状态，从而避免重新进行完整的 SSL 握手过程。SSL中的认证中的证书是什么？了解过吗？ 一个数字证书通常包含了：公钥； 持有者信息； 证书认证机构（CA）的信息； CA 对这份文件的数字签名及使用的算法； 证书有效期； 还有一些其他额外信息； 数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。扩展 CA 签发证书的过程，如上图左边部分：首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值； 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名； 最后将 Certificate Signature 添加在文件证书上，形成数字证书； 客户端校验服务端的数字证书的过程，如上图右边部分：首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1； 通常浏览器和操作系统中集成了 C","tags":["Interview"],"title":"面试之计算机网络-4","url":"http://localhost:1313/posts/other/interview-network-4/"},{"categories":["other"],"content":"A 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ； 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。 HTTP如何禁用缓存？如何确认缓存？ 可以通过 Cache-Control 首部字段来控制缓存：Cache-Control: no-store：指示客户端不缓存任何响应，每次请求都要向服务器发送。 Cache-Control: no-cache：指示客户端在使用缓存前必须先向服务器进行重新验证。 要确认缓存是否生效，可以使用以下方法之一：查看响应头：在HTTP响应中，可以查看响应头中的缓存控制指令和其他相关字段。其中，常见的字段包括：Cache-Control：指示缓存行为的指令。 Expires：指示响应的过期时间。 ETag：用于标识响应内容的唯一标识符。 Last-Modified：指示响应内容的最后修改时间。 通过查看这些响应头字段的值，可以了解缓存是否被启用，并确定缓存的相关信息。GET与POST传递数据的最大长度能够达到多少呢？ HTTP 协议没有GET","date":"2024-01-13T21:57:19+08:00","objectID":"9b8c764f570114b5f0ab8c8c827895fd_5","order":5,"summary":"A 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ； 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。 HTTP如何禁用缓存？如何确认缓存？ 可以通过 Cache-Control 首部字段来控制缓存：Cache-Control: no-store：指示客户端不缓存任何响应，每次请求都要向服务器发送。 Cache-Control: no-cache：指示客户端在使用缓存前必须先向服务器进行重新验证。 要确认缓存是否生效，可以使用以下方法之一：查看响应头：在HTTP响应中，可以查看响应头中的缓存控制指令和其他相关字段。其中，常见的字段包括：Cache-Control：指示缓存行为的指令。 Expires：指示响应的过期时间。 ETag：用于标识响应内容的唯一标识符。 Last-Modified：指示响应内容的最后修改时间。 通过查看这些响应头字段的值，可以了解缓存是否被启用，并确定缓存的相关信息。GET与POST传递数据的最大长度能够达到多少呢？ HTTP 协议没有GET","tags":["Interview"],"title":"面试之计算机网络-4","url":"http://localhost:1313/posts/other/interview-network-4/"},{"categories":["other"],"content":"(URL)和POST(Body)的长度限制，对 URL 限制的大多是浏览器和服务器的原因。为了浏览器的兼容性，需要限制url长度，一般情况下最大应为2083字节；服务器是为了性能和安全考虑，会给get、post长度加限制。了解：这个限制是特定的浏览器及服务器对它的限制，比如IE对URL长度的限制是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统；即如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。因为我们一般post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较大的文件到服务器时候，可能上传不上去。以php语言来说，查原因的时候你也许会看到有说PHP上传文件涉及到的参数PHP默认的上传有限定，一般这个值是2MB，更改这个值需要更改php.c","date":"2024-01-13T21:57:19+08:00","objectID":"9b8c764f570114b5f0ab8c8c827895fd_6","order":6,"summary":"(URL)和POST(Body)的长度限制，对 URL 限制的大多是浏览器和服务器的原因。为了浏览器的兼容性，需要限制url长度，一般情况下最大应为2083字节；服务器是为了性能和安全考虑，会给get、post长度加限制。了解：这个限制是特定的浏览器及服务器对它的限制，比如IE对URL长度的限制是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统；即如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。因为我们一般post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较大的文件到服务器时候，可能上传不上去。以php语言来说，查原因的时候你也许会看到有说PHP上传文件涉及到的参数PHP默认的上传有限定，一般这个值是2MB，更改这个值需要更改php.c","tags":["Interview"],"title":"面试之计算机网络-4","url":"http://localhost:1313/posts/other/interview-network-4/"},{"categories":["other"],"content":"onf的post_max_size这个值。这就很明白的说明了这个问题了。网络层常见协议？可以说一下吗？ Internet Protocol (IP)：IP是互联网的基础协议，负责在网络中传输数据包。它使用IP地址来标识网络上的设备，并提供数据包的路由功能。Internet Control Message Protocol (ICMP)：ICMP用于在IP网络中传输控制消息。它主要用于网络故障排除、错误报告和网络状态查询等。Internet Group Management Protocol (IGMP)：IGMP是用于在IP网络中管理多播组的协议。它允许主机加入或离开多播组，并与路由器通信以确定多播数据的传输。Address Resolution Protocol (ARP)：ARP用于将IP地址解析为物理（MAC）地址。当主机需要与目标设备通信时，它可以使用ARP协议来获取目标设备的物理地址。Reverse Address Resolution Protocol (RARP)：RARP与ARP相反，它将物理地址解析为IP地址。它可以帮助没有硬盘和操作系统配置的设备（如磁盘less工作","date":"2024-01-13T21:57:19+08:00","objectID":"9b8c764f570114b5f0ab8c8c827895fd_7","order":7,"summary":"onf的post_max_size这个值。这就很明白的说明了这个问题了。网络层常见协议？可以说一下吗？ Internet Protocol (IP)：IP是互联网的基础协议，负责在网络中传输数据包。它使用IP地址来标识网络上的设备，并提供数据包的路由功能。Internet Control Message Protocol (ICMP)：ICMP用于在IP网络中传输控制消息。它主要用于网络故障排除、错误报告和网络状态查询等。Internet Group Management Protocol (IGMP)：IGMP是用于在IP网络中管理多播组的协议。它允许主机加入或离开多播组，并与路由器通信以确定多播数据的传输。Address Resolution Protocol (ARP)：ARP用于将IP地址解析为物理（MAC）地址。当主机需要与目标设备通信时，它可以使用ARP协议来获取目标设备的物理地址。Reverse Address Resolution Protocol (RARP)：RARP与ARP相反，它将物理地址解析为IP地址。它可以帮助没有硬盘和操作系统配置的设备（如磁盘less工作","tags":["Interview"],"title":"面试之计算机网络-4","url":"http://localhost:1313/posts/other/interview-network-4/"},{"categories":["other"],"content":"站）获取其IP地址。Internet Protocol version 6 (IPv6)：IPv6是IP协议的下一代版本，旨在解决IPv4地址耗尽和其他一些限制。它使用128位的地址空间，提供更大的地址容量和其他改进。TCP四大拥塞控制算法总结？（极其重要） 慢启动算法 – Slow Start 慢启动是TCP连接刚开始时的拥塞控制算法。 慢启动的算法的规则就是：**每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**呈指数增加。 慢启动算法：连接建立完成后，一开始初始化 cwnd = 1，表示可以传一个 MSS 大小的数据。 当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个 当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个，呈指数增长。 慢启动算法还有一个慢启动门限 ssthresh （slow start threshold）状态变量。当 cwnd \u0026lt; ssthresh 时，使用慢启动算法。 当 cwnd \u003e= ssthresh 时，就会使用「拥塞避免算法」。 一般来说 s","date":"2024-01-13T21:57:19+08:00","objectID":"9b8c764f570114b5f0ab8c8c827895fd_8","order":8,"summary":"站）获取其IP地址。Internet Protocol version 6 (IPv6)：IPv6是IP协议的下一代版本，旨在解决IPv4地址耗尽和其他一些限制。它使用128位的地址空间，提供更大的地址容量和其他改进。TCP四大拥塞控制算法总结？（极其重要） 慢启动算法 – Slow Start 慢启动是TCP连接刚开始时的拥塞控制算法。 慢启动的算法的规则就是：**每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**呈指数增加。 慢启动算法：连接建立完成后，一开始初始化 cwnd = 1，表示可以传一个 MSS 大小的数据。 当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个 当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个，呈指数增长。 慢启动算法还有一个慢启动门限 ssthresh （slow start threshold）状态变量。当 cwnd \u0026lt; ssthresh 时，使用慢启动算法。 当 cwnd \u003e= ssthresh 时，就会使用「拥塞避免算法」。 一般来说 s","tags":["Interview"],"title":"面试之计算机网络-4","url":"http://localhost:1313/posts/other/interview-network-4/"},{"categories":["other"],"content":"sthresh 的大小是 65535 字节。拥塞避免算法 – Congestion Avoidance 当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。，呈线性增长。接上前面的慢启动的例子，现假定 ssthresh 为 8：当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了线性增长。 过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值，直到出现丢包现象，触发拥塞发生的算法。拥塞发生算法 当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：超时重传 快速重传 超时重传是在发送一个数据以后就开启一个计时器，在指定时间内如果没有收到ACK报文，说明网络拥塞严重，就触发该算法： 将慢启动门限ssthresh 设为 cwnd/2，拥塞窗口cwnd 重置为 cwnd 初始化值(Linux 是10)，进入慢启动算法。 快","date":"2024-01-13T21:57:19+08:00","objectID":"9b8c764f570114b5f0ab8c8c827895fd_9","order":9,"summary":"sthresh 的大小是 65535 字节。拥塞避免算法 – Congestion Avoidance 当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。，呈线性增长。接上前面的慢启动的例子，现假定 ssthresh 为 8：当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 MSS 大小的数据，变成了线性增长。 过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值，直到出现丢包现象，触发拥塞发生的算法。拥塞发生算法 当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：超时重传 快速重传 超时重传是在发送一个数据以后就开启一个计时器，在指定时间内如果没有收到ACK报文，说明网络拥塞严重，就触发该算法： 将慢启动门限ssthresh 设为 cwnd/2，拥塞窗口cwnd 重置为 cwnd 初始化值(Linux 是10)，进入慢启动算法。 快","tags":["Interview"],"title":"面试之计算机网络-4","url":"http://localhost:1313/posts/other/interview-network-4/"},{"categories":["other"],"content":"使用 Session 的过程是怎样的？ 用户进行登录时，提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到本地中，生成一个 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从本地中取出用户信息，继续之前的业务操作。 Session和cookie应该如何去选择（适用场景）？ Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； 对于用户状态和敏感数据，应优先使用Session，因为数据存储在服务器端，更安全可靠。 对于用户偏好设置和非敏感数据，可以使用Cookie，便于在客户端存储和传递，减轻服务器压力。 需要注意的是，Session和Cookie可以结合使用，例如将Session ID存储在Cookie中，以便在客户端","date":"2024-01-13T21:57:09+08:00","objectID":"57d4f01236cd1b71e2e0b26cea9989c9_0","order":0,"summary":"使用 Session 的过程是怎样的？ 用户进行登录时，提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到本地中，生成一个 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从本地中取出用户信息，继续之前的业务操作。 Session和cookie应该如何去选择（适用场景）？ Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； 对于用户状态和敏感数据，应优先使用Session，因为数据存储在服务器端，更安全可靠。 对于用户偏好设置和非敏感数据，可以使用Cookie，便于在客户端存储和传递，减轻服务器压力。 需要注意的是，Session和Cookie可以结合使用，例如将Session ID存储在Cookie中，以便在客户端","tags":["Interview"],"title":"面试之计算机网络-3","url":"http://localhost:1313/posts/other/interview-network-3/"},{"categories":["other"],"content":"和服务器之间建立关联。 DDos 攻击了解吗？ DDoS (Distributed Denial of Service) 攻击是一种恶意行为，旨在通过超过目标系统处理能力的大量请求或恶意流量来使目标系统无法正常运行。DDos 预防：流量分析和监测：实施流量分析和监测系统，以便及时检测和识别异常的网络流量模式。防火墙和过滤器：配置防火墙和过滤器以过滤恶意流量并屏蔽来自已知攻击源的访问。负载均衡：使用负载均衡设备将流量分散到多个服务器上，减轻单个服务器的负载压力。反向代理：使用反向代理服务器来隐藏真实服务器的IP地址，使其更难受到直接的攻击。限制连接和频率：防止单个IP地址或用户对系统进行过多的连接或请求MTU和MSS分别是什么？ MTU（Maximum Transmission Unit）是指数据链路层所能承载的最大数据包大小，以太网的MTU为1500字节。MSS（Maximum Segment Size）表示在TCP传输数据的最大大小。是在建立TCP连接时通过协商确定的。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。MSL和","date":"2024-01-13T21:57:09+08:00","objectID":"57d4f01236cd1b71e2e0b26cea9989c9_1","order":1,"summary":"和服务器之间建立关联。 DDos 攻击了解吗？ DDoS (Distributed Denial of Service) 攻击是一种恶意行为，旨在通过超过目标系统处理能力的大量请求或恶意流量来使目标系统无法正常运行。DDos 预防：流量分析和监测：实施流量分析和监测系统，以便及时检测和识别异常的网络流量模式。防火墙和过滤器：配置防火墙和过滤器以过滤恶意流量并屏蔽来自已知攻击源的访问。负载均衡：使用负载均衡设备将流量分散到多个服务器上，减轻单个服务器的负载压力。反向代理：使用反向代理服务器来隐藏真实服务器的IP地址，使其更难受到直接的攻击。限制连接和频率：防止单个IP地址或用户对系统进行过多的连接或请求MTU和MSS分别是什么？ MTU（Maximum Transmission Unit）是指数据链路层所能承载的最大数据包大小，以太网的MTU为1500字节。MSS（Maximum Segment Size）表示在TCP传输数据的最大大小。是在建立TCP连接时通过协商确定的。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。MSL和","tags":["Interview"],"title":"面试之计算机网络-3","url":"http://localhost:1313/posts/other/interview-network-3/"},{"categories":["other"],"content":"TTL？ MSL（Maximum Segment Lifetime），它是任何报文在网络上存在的最长时间。IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。HTTP中有个缓存机制，但如何保证缓存是最新的呢？ HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存。强制缓存：当浏览器第一次请求访问服务器资源时，服务器会在 Response 头部加上 Cache-Control，表示资源过期时间； 浏览器再次请求访问服务器中的该资源时，会先比较请求时间与资源过期时间，如果没有过期，则直接使用该缓存，否则重新请求服务器； 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。 使用 ETag 字段实现的协商缓存的过程：当浏览器第一次请求访问服务器资源时，服务器在 Respon","date":"2024-01-13T21:57:09+08:00","objectID":"57d4f01236cd1b71e2e0b26cea9989c9_2","order":2,"summary":"TTL？ MSL（Maximum Segment Lifetime），它是任何报文在网络上存在的最长时间。IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL 消耗为 0 的时间，以确保报文已被自然消亡。HTTP中有个缓存机制，但如何保证缓存是最新的呢？ HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存。强制缓存：当浏览器第一次请求访问服务器资源时，服务器会在 Response 头部加上 Cache-Control，表示资源过期时间； 浏览器再次请求访问服务器中的该资源时，会先比较请求时间与资源过期时间，如果没有过期，则直接使用该缓存，否则重新请求服务器； 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。 使用 ETag 字段实现的协商缓存的过程：当浏览器第一次请求访问服务器资源时，服务器在 Respon","tags":["Interview"],"title":"面试之计算机网络-3","url":"http://localhost:1313/posts/other/interview-network-3/"},{"categories":["other"],"content":"se 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的； 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期： 如果没有过期，则直接使用本地缓存； 如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag； 服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较： 如果值相等，则返回 304 Not Modified，不会返回资源； 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识； 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。 TCP头部中有哪些信息？ 源端口号、目的端口号序号（32bit）：在建立连接时由计算机生成的随机数作为其初始值，每发送一次数据，就「累加」一次该「数据字节数」的大小。用于解决网络包乱序问题。确认号（32bit）：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢","date":"2024-01-13T21:57:09+08:00","objectID":"57d4f01236cd1b71e2e0b26cea9989c9_3","order":3,"summary":"se 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的； 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期： 如果没有过期，则直接使用本地缓存； 如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag； 服务器再次收到请求后，会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较： 如果值相等，则返回 304 Not Modified，不会返回资源； 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识； 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。 TCP头部中有哪些信息？ 源端口号、目的端口号序号（32bit）：在建立连接时由计算机生成的随机数作为其初始值，每发送一次数据，就「累加」一次该「数据字节数」的大小。用于解决网络包乱序问题。确认号（32bit）：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢","tags":["Interview"],"title":"面试之计算机网络-3","url":"http://localhost:1313/posts/other/interview-network-3/"},{"categories":["other"],"content":"包的问题。首部长（4bit）：32位系统中一个字等于4个字节，首部长度的单位是字，首部长度字段有4位，所以TCP首部最长为 $2^4 -1 = 15(字) = 60(字节)$。标志位（6bit）：URG：标志紧急指针是否有效。ACK：标志确认号是否有效（确认报文段）。PSH：提示接收端立即从缓冲读走数据。RST：表示要求对方重新建立连接（复位报文段）。SYN：表示请求建立一个连接（连接报文段）。FIN：表示关闭连接（断开报文段）。窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流量控制。校验和（16bit）：接收端用CRC检验整个报文段的完整性。常见TCP的连接状态有哪些？ https://blog.csdn.net/chenxiyuehh/article/details/100146419CLOSED：初始关闭状态。 LISTEN：服务器处于监听状态。 SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。 SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。 ESTABLISH：表示连接建","date":"2024-01-13T21:57:09+08:00","objectID":"57d4f01236cd1b71e2e0b26cea9989c9_4","order":4,"summary":"包的问题。首部长（4bit）：32位系统中一个字等于4个字节，首部长度的单位是字，首部长度字段有4位，所以TCP首部最长为 $2^4 -1 = 15(字) = 60(字节)$。标志位（6bit）：URG：标志紧急指针是否有效。ACK：标志确认号是否有效（确认报文段）。PSH：提示接收端立即从缓冲读走数据。RST：表示要求对方重新建立连接（复位报文段）。SYN：表示请求建立一个连接（连接报文段）。FIN：表示关闭连接（断开报文段）。窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流量控制。校验和（16bit）：接收端用CRC检验整个报文段的完整性。常见TCP的连接状态有哪些？ https://blog.csdn.net/chenxiyuehh/article/details/100146419CLOSED：初始关闭状态。 LISTEN：服务器处于监听状态。 SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。 SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。 ESTABLISH：表示连接建","tags":["Interview"],"title":"面试之计算机网络-3","url":"http://localhost:1313/posts/other/interview-network-3/"},{"categories":["other"],"content":"立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。 FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。 CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段，发送ACK包给客户机。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。 FIN_WAIT_2：客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。 LAST_ACK：服务端发送最后的FIN包，进入此状态，等待最后的客户端ACK响应，进入CLOSE状态。 TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态，之后进入CLOSE状态。 TCP是什么？ TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协","date":"2024-01-13T21:57:09+08:00","objectID":"57d4f01236cd1b71e2e0b26cea9989c9_5","order":5,"summary":"立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。 FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。 CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段，发送ACK包给客户机。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。 FIN_WAIT_2：客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。 LAST_ACK：服务端发送最后的FIN包，进入此状态，等待最后的客户端ACK响应，进入CLOSE状态。 TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态，之后进入CLOSE状态。 TCP是什么？ TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协","tags":["Interview"],"title":"面试之计算机网络-3","url":"http://localhost:1313/posts/other/interview-network-3/"},{"categories":["other"],"content":"议。OSI 的七层模型的主要功能？ 物理层：负责传输比特流，处理物理介质和电信号。 数据链路层：提供可靠的点对点数据传输，处理帧和物理地址。 网络层：将数据包从源主机传输到目标主机，处理路由和寻址。 传输层：提供端到端的可靠数据传输，处理连接和流控制。 会话层：管理应用程序之间的会话。 表示层：处理数据的表示和格式转换，提供加密和压缩功能。 应用层：给用户提供网络应用服务，如HTTP、FTP等。 **物理层：**利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。 **数据链路层：**接收来自物理层的位流形式的数据，并封装成帧，传送到上一层 **网络层：**将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。 **传输层：**在源端与目的端之间提供可靠的透明数据传输 **会话层：**负责在网络中的两节点之间建立、维持和终止通信 **表示层：**处理用户信息的表示问题，数据的编码，压缩和解压缩，数据的加密和解密 **应用层：**为用户的应用进程提供网络通信服务应用层常见协议知道多少？了解几个？ 协议 名称 默认端口 底层协议 HTTP 超文本传输","date":"2024-01-13T21:57:09+08:00","objectID":"57d4f01236cd1b71e2e0b26cea9989c9_6","order":6,"summary":"议。OSI 的七层模型的主要功能？ 物理层：负责传输比特流，处理物理介质和电信号。 数据链路层：提供可靠的点对点数据传输，处理帧和物理地址。 网络层：将数据包从源主机传输到目标主机，处理路由和寻址。 传输层：提供端到端的可靠数据传输，处理连接和流控制。 会话层：管理应用程序之间的会话。 表示层：处理数据的表示和格式转换，提供加密和压缩功能。 应用层：给用户提供网络应用服务，如HTTP、FTP等。 **物理层：**利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。 **数据链路层：**接收来自物理层的位流形式的数据，并封装成帧，传送到上一层 **网络层：**将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。 **传输层：**在源端与目的端之间提供可靠的透明数据传输 **会话层：**负责在网络中的两节点之间建立、维持和终止通信 **表示层：**处理用户信息的表示问题，数据的编码，压缩和解压缩，数据的加密和解密 **应用层：**为用户的应用进程提供网络通信服务应用层常见协议知道多少？了解几个？ 协议 名称 默认端口 底层协议 HTTP 超文本传输","tags":["Interview"],"title":"面试之计算机网络-3","url":"http://localhost:1313/posts/other/interview-network-3/"},{"categories":["other"],"content":"协议 80 TCP HTTPS 超文本传输安全协议 443 TCP Telnet Teletype远程登录服务的标准协议 23 TCP FTP 文件传输协议 20传输和21连接 TCP TFTP Trivial File简单文件传输协议 69 UDP SMTP 简单邮件传输协议（发送用） 25 TCP POP 邮局协议（接收用） 110 TCP DNS 域名解析服务 53 服务器间进行区域传输的时候用TCP客户端查询DNS服务器时用 UDP 浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？ 如果采取短连接，则在HTTP请求完成后断开。如果采取长连接，则会一直保持TCP连接。当遇到以下情况就会断开：服务器或浏览器主动关闭连接。 连接超时或故障。 三次握手相关内容 一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态 客户端发送SYN包给服务器，其中序列号字段中填入随机初始化序号(ISN)，把 SYN 标志位置为 1。客户端处于 SYN-SENT 状态。 服务端收到客户端的 SYN 报文后，","date":"2024-01-13T21:57:09+08:00","objectID":"57d4f01236cd1b71e2e0b26cea9989c9_7","order":7,"summary":"协议 80 TCP HTTPS 超文本传输安全协议 443 TCP Telnet Teletype远程登录服务的标准协议 23 TCP FTP 文件传输协议 20传输和21连接 TCP TFTP Trivial File简单文件传输协议 69 UDP SMTP 简单邮件传输协议（发送用） 25 TCP POP 邮局协议（接收用） 110 TCP DNS 域名解析服务 53 服务器间进行区域传输的时候用TCP客户端查询DNS服务器时用 UDP 浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？ 如果采取短连接，则在HTTP请求完成后断开。如果采取长连接，则会一直保持TCP连接。当遇到以下情况就会断开：服务器或浏览器主动关闭连接。 连接超时或故障。 三次握手相关内容 一开始，客户端和服务端都处于 CLOSE 状态。先是服务端主动监听某个端口，处于 LISTEN 状态 客户端发送SYN包给服务器，其中序列号字段中填入随机初始化序号(ISN)，把 SYN 标志位置为 1。客户端处于 SYN-SENT 状态。 服务端收到客户端的 SYN 报文后，","tags":["Interview"],"title":"面试之计算机网络-3","url":"http://localhost:1313/posts/other/interview-network-3/"},{"categories":["other"],"content":"服务端发送SYN+ACK包给客户端。其中序列号字段中填入随机初始化序号，其次把 确认应答号字段填入客户端序列号+1，接着把 SYN 和 ACK 标志位置为 1。服务端处于 SYN-RCVD 状态。 客户端收到服务端报文后，发送ACK包给服务器将，其中序列号为客户端序列号+1 ，其次确认应答号字段填入 服务端序列号+1 ， ACK 标志位置为 1。这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。 为什么需要三次握手，两次不行吗？ 通过这个三次握手的过程，双方确保了彼此的接受和发送能力和彼此的初始序列号的确认。这种双向确认可以防止已失效的连接请求被错误地接受，确保了连接建立的可靠性，避免了资源浪费。什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在半连接队列。扩展： 当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。这里在补充一点关于SYN-ACK 重","date":"2024-01-13T21:57:09+08:00","objectID":"57d4f01236cd1b71e2e0b26cea9989c9_8","order":8,"summary":"服务端发送SYN+ACK包给客户端。其中序列号字段中填入随机初始化序号，其次把 确认应答号字段填入客户端序列号+1，接着把 SYN 和 ACK 标志位置为 1。服务端处于 SYN-RCVD 状态。 客户端收到服务端报文后，发送ACK包给服务器将，其中序列号为客户端序列号+1 ，其次确认应答号字段填入 服务端序列号+1 ， ACK 标志位置为 1。这次报文可以携带客户到服务端的数据，之后客户端处于 ESTABLISHED 状态。 服务端收到客户端的应答报文后，也进入 ESTABLISHED 状态。 为什么需要三次握手，两次不行吗？ 通过这个三次握手的过程，双方确保了彼此的接受和发送能力和彼此的初始序列号的确认。这种双向确认可以防止已失效的连接请求被错误地接受，确保了连接建立的可靠性，避免了资源浪费。什么是半连接队列？ 服务器第一次收到客户端的 SYN 之后，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在半连接队列。扩展： 当然还有一个全连接队列，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。这里在补充一点关于SYN-ACK 重","tags":["Interview"],"title":"面试之计算机网络-3","url":"http://localhost:1313/posts/other/interview-network-3/"},{"categories":["other"],"content":"传次数的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......ISN(Initial Sequence Number)是固定的吗？ 初始化序列号 ISN 由 M + F(localhost, localport, remotehost, remoteport)生成。M 是一个计时器，这个计时器每隔 4 微秒加 1。 F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。 用于防止已失效的连接请求被错误地接受，以及被攻击者得到初始序列号。三次握手过程中可以携带数据吗？ 其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客","date":"2024-01-13T21:57:09+08:00","objectID":"57d4f01236cd1b71e2e0b26cea9989c9_9","order":9,"summary":"传次数的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......ISN(Initial Sequence Number)是固定的吗？ 初始化序列号 ISN 由 M + F(localhost, localport, remotehost, remoteport)生成。M 是一个计时器，这个计时器每隔 4 微秒加 1。 F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。 用于防止已失效的连接请求被错误地接受，以及被攻击者得到初始序列号。三次握手过程中可以携带数据吗？ 其实第三次握手的时候，是可以携带数据的。但是，第一次、第二次握手不可以携带数据也就是说，第一次握手不可以放数据，其中一个简单的原因就是会让服务器更加容易受到攻击了。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客","tags":["Interview"],"title":"面试之计算机网络-3","url":"http://localhost:1313/posts/other/interview-network-3/"},{"categories":["other"],"content":"HTTPS是如何保证数据传输的安全，整体的流程是什么？ （SSL是怎么工作保证安全的）https://www.cnblogs.com/fangdada/p/15686204.htmlECDHE过程：客户端首先会发送使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random） 当服务端收到客户端的消息后，会确认 TLS 版本号，选择ECDHE密码套件，以及生成随机数（Server Random），并会发送数字证书给客户端。 然后服务端会选择一个椭圆曲线，如x25519曲线，生成随机数作为私钥，再根据椭圆曲线和私钥计算出服务端的公钥，利用签名算法签名，并将曲线、公钥和签名发送给客户端。 客户端验证证书是否合法，合法则生成随机数作为客户端私钥，利用私钥和椭圆曲线计算出客户端公钥后发送给服务端。 双方利用客户端随机数和服务端随机数和ECDHE算出的共享密钥计算出会话密钥来加密通话。互相验证加密和解密是否成功，并且验证消息是否被篡改。 最后进行HTTP通信。 RSA过程：客户端首先会发送使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Ra","date":"2024-01-13T21:56:59+08:00","objectID":"4f4a34570b1cd11ca3ac49b767643bd8_0","order":0,"summary":"HTTPS是如何保证数据传输的安全，整体的流程是什么？ （SSL是怎么工作保证安全的）https://www.cnblogs.com/fangdada/p/15686204.htmlECDHE过程：客户端首先会发送使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random） 当服务端收到客户端的消息后，会确认 TLS 版本号，选择ECDHE密码套件，以及生成随机数（Server Random），并会发送数字证书给客户端。 然后服务端会选择一个椭圆曲线，如x25519曲线，生成随机数作为私钥，再根据椭圆曲线和私钥计算出服务端的公钥，利用签名算法签名，并将曲线、公钥和签名发送给客户端。 客户端验证证书是否合法，合法则生成随机数作为客户端私钥，利用私钥和椭圆曲线计算出客户端公钥后发送给服务端。 双方利用客户端随机数和服务端随机数和ECDHE算出的共享密钥计算出会话密钥来加密通话。互相验证加密和解密是否成功，并且验证消息是否被篡改。 最后进行HTTP通信。 RSA过程：客户端首先会发送使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Ra","tags":["Interview"],"title":"面试之计算机网络-2","url":"http://localhost:1313/posts/other/interview-network-2/"},{"categories":["other"],"content":"ndom） 当服务端收到客户端的消息后，会确认 TLS 版本号，选择RSA密码套件，以及生成随机数（Server Random），并会发送数字证书给客户端。 客户端验证证书是否合法，判断服务器是否真实，取出服务端公钥。 接着，客户端就会生成一个新的随机数 (pre-master)，用服务器的公钥加密该随机数，传给服务端。 然后，利用前面的3个随机数生成「会话密钥」，把之前所有发送的数据做个摘要，用会话密钥（master secret）加密。 服务器也是同样的操作，如果双方都验证加密和解密没问题，那么握手正式完成。 最后，就用「会话密钥」加解密 HTTP 请求和响应了。 RSA是缺点是不支持前向保密，一旦服务器的私钥泄漏了，则之前的通信内容就被破解。 SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。22、如何保证公钥不被篡改？ 将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 ","date":"2024-01-13T21:56:59+08:00","objectID":"4f4a34570b1cd11ca3ac49b767643bd8_1","order":1,"summary":"ndom） 当服务端收到客户端的消息后，会确认 TLS 版本号，选择RSA密码套件，以及生成随机数（Server Random），并会发送数字证书给客户端。 客户端验证证书是否合法，判断服务器是否真实，取出服务端公钥。 接着，客户端就会生成一个新的随机数 (pre-master)，用服务器的公钥加密该随机数，传给服务端。 然后，利用前面的3个随机数生成「会话密钥」，把之前所有发送的数据做个摘要，用会话密钥（master secret）加密。 服务器也是同样的操作，如果双方都验证加密和解密没问题，那么握手正式完成。 最后，就用「会话密钥」加解密 HTTP 请求和响应了。 RSA是缺点是不支持前向保密，一旦服务器的私钥泄漏了，则之前的通信内容就被破解。 SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。22、如何保证公钥不被篡改？ 将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 ","tags":["Interview"],"title":"面试之计算机网络-2","url":"http://localhost:1313/posts/other/interview-network-2/"},{"categories":["other"],"content":"Hash 值； 然后 CA 会使用自己的私钥将该 Hash 值加密，生成证书签名； 最后将证书签名添加在文件证书上，形成数字证书； 公钥加密计算量太大，如何减少耗用的时间？ https://stardust567.github.io/post/84d.html 解决方法：握手阶段使用非对称加密，通信采取对称加密的方式(使用对话密钥)并且使用ECDHE作为加密套件。HTTP请求和响应报文有哪些主要字段？ 请求报文 HTTP请求报文和HTTP响应报文请求行：Request Line （请求方法、url、协议版本） 请求头：Request Headers（键值对组成，如host、user-agent、accept） 请求体：Request Body 响应报文状态行：Status Line （协议版本；响应状态代码；状态代码的文本描述） 响应头：Response Headers（content-type、content-length、server、connection） 响应体：Response Body Cookie是什么？ HTTP 协议是无状态的，HTTP/1.1 引入 Cookie 来","date":"2024-01-13T21:56:59+08:00","objectID":"4f4a34570b1cd11ca3ac49b767643bd8_2","order":2,"summary":"Hash 值； 然后 CA 会使用自己的私钥将该 Hash 值加密，生成证书签名； 最后将证书签名添加在文件证书上，形成数字证书； 公钥加密计算量太大，如何减少耗用的时间？ https://stardust567.github.io/post/84d.html 解决方法：握手阶段使用非对称加密，通信采取对称加密的方式(使用对话密钥)并且使用ECDHE作为加密套件。HTTP请求和响应报文有哪些主要字段？ 请求报文 HTTP请求报文和HTTP响应报文请求行：Request Line （请求方法、url、协议版本） 请求头：Request Headers（键值对组成，如host、user-agent、accept） 请求体：Request Body 响应报文状态行：Status Line （协议版本；响应状态代码；状态代码的文本描述） 响应头：Response Headers（content-type、content-length、server、connection） 响应体：Response Body Cookie是什么？ HTTP 协议是无状态的，HTTP/1.1 引入 Cookie 来","tags":["Interview"],"title":"面试之计算机网络-2","url":"http://localhost:1313/posts/other/interview-network-2/"},{"categories":["other"],"content":"保存状态信息。Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。Cookie有什么用途？ 会话状态管理（如用户登录状态） 喜好设置（存储用户偏好等设置，向用户显示喜好内容） 浏览器行为跟踪（如跟踪分析用户行为等） Session知识大总结 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。使用 Session 维护用户登录状态的过程如下：用户进行登录时，提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到本地中，生成一个 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Sess","date":"2024-01-13T21:56:59+08:00","objectID":"4f4a34570b1cd11ca3ac49b767643bd8_3","order":3,"summary":"保存状态信息。Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。Cookie有什么用途？ 会话状态管理（如用户登录状态） 喜好设置（存储用户偏好等设置，向用户显示喜好内容） 浏览器行为跟踪（如跟踪分析用户行为等） Session知识大总结 除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。使用 Session 维护用户登录状态的过程如下：用户进行登录时，提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到本地中，生成一个 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Sess","tags":["Interview"],"title":"面试之计算机网络-2","url":"http://localhost:1313/posts/other/interview-network-2/"},{"categories":["other"],"content":"ion ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从本地中取出用户信息，继续之前的业务操作。 注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。Session 的工作原理是什么？ session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，然后把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 session id，服务器拿到 session id 之后，在内存找到与之对应的 session 这样就可以正常工作了。Cookie与Session的对比 https://mp.weixin.qq.com/s","date":"2024-01-13T21:56:59+08:00","objectID":"4f4a34570b1cd11ca3ac49b767643bd8_4","order":4,"summary":"ion ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从本地中取出用户信息，继续之前的业务操作。 注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。Session 的工作原理是什么？ session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，然后把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 session id，服务器拿到 session id 之后，在内存找到与之对应的 session 这样就可以正常工作了。Cookie与Session的对比 https://mp.weixin.qq.com/s","tags":["Interview"],"title":"面试之计算机网络-2","url":"http://localhost:1313/posts/other/interview-network-2/"},{"categories":["other"],"content":"/cuTmhjnzdngE0EEb5RlbxQ存储范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。 存储方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。（跟get/post一样） 存储时限不同，Cookie可设置为长时间保持，比如默认登录功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。 存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。 隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。 SQL注入攻击了解吗？ https://www.jianshu.com/p/078df7a35671攻击者在HTTP请求中注入恶意的SQL代码，服务器使用请求中的参数拼接数据库SQL命令时，恶意SQL被一起拼接，并在数据库中执行。用户登录，输入用户名 123' or 1=1 # ，密码 any ，如果此时使用参数构造的方式，就会出现1 select * from users where ","date":"2024-01-13T21:56:59+08:00","objectID":"4f4a34570b1cd11ca3ac49b767643bd8_5","order":5,"summary":"/cuTmhjnzdngE0EEb5RlbxQ存储范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。 存储方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。（跟get/post一样） 存储时限不同，Cookie可设置为长时间保持，比如默认登录功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。 存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。 隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。 SQL注入攻击了解吗？ https://www.jianshu.com/p/078df7a35671攻击者在HTTP请求中注入恶意的SQL代码，服务器使用请求中的参数拼接数据库SQL命令时，恶意SQL被一起拼接，并在数据库中执行。用户登录，输入用户名 123' or 1=1 # ，密码 any ，如果此时使用参数构造的方式，就会出现1 select * from users where ","tags":["Interview"],"title":"面试之计算机网络-2","url":"http://localhost:1313/posts/other/interview-network-2/"},{"categories":["other"],"content":"username='123' or 1=1 #' and password='123' or 1=1 #' 按照 Mysql 语法，# 后面的内容会被忽略。由于判断语句 or 1=1 恒成立，所以结果当然返回真，成功登录。如何防范SQL注入攻击 Web端有效性检验。 限制字符串输入的长度。 服务端避免使用动态SQL。 使用预编译的PreparedStatement。 有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) 过滤SQL需要的参数中的特殊字符。比如单引号、双引号。 什么是RARP？工作原理 概括： 反向地址转换协议，是网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。原理：~~网络上的每台设备都会有一个独一无二的硬件地址。~~主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包。 RARP服务器响应该RARP请求，为其分配IP地址，并将IP地址发送给主机。 主机收到RARP回应后，就可以使用得到的IP地址进行通讯。 无非就是发包，响应包，得到内容端口有效范围是多","date":"2024-01-13T21:56:59+08:00","objectID":"4f4a34570b1cd11ca3ac49b767643bd8_6","order":6,"summary":"username='123' or 1=1 #' and password='123' or 1=1 #' 按照 Mysql 语法，# 后面的内容会被忽略。由于判断语句 or 1=1 恒成立，所以结果当然返回真，成功登录。如何防范SQL注入攻击 Web端有效性检验。 限制字符串输入的长度。 服务端避免使用动态SQL。 使用预编译的PreparedStatement。 有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) 过滤SQL需要的参数中的特殊字符。比如单引号、双引号。 什么是RARP？工作原理 概括： 反向地址转换协议，是网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。原理：~~网络上的每台设备都会有一个独一无二的硬件地址。~~主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包。 RARP服务器响应该RARP请求，为其分配IP地址，并将IP地址发送给主机。 主机收到RARP回应后，就可以使用得到的IP地址进行通讯。 无非就是发包，响应包，得到内容端口有效范围是多","tags":["Interview"],"title":"面试之计算机网络-2","url":"http://localhost:1313/posts/other/interview-network-2/"},{"categories":["other"],"content":"少到多少？ 0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535为何把 TCP/IP 协议栈分成 5 层（或7层）？开放式回答。 分层的好处：易维护与实现，将一个难以处理的复杂问题分解为若干个较容易处理的更小的问题。 灵活性好，各层之间是独立的。任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不影响。 结构上可分割，各层都可以采用最合适的技术实现。 能促进标准化工作，每一层的功能及其所提供的服务都已有了明确的说明。 https://blog.csdn.net/qq_32798897/article/details/121879151DNS查询方式有哪些？ https://zhuanlan.zhihu.com/p/423222573递归查询递归查询一般发生在 Client 请求 DNS Server。Client 发出一个域名解析的请求，DNS Server 必须返回对应的 IP 地址，或者返回找不到的错误。","date":"2024-01-13T21:56:59+08:00","objectID":"4f4a34570b1cd11ca3ac49b767643bd8_7","order":7,"summary":"少到多少？ 0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535为何把 TCP/IP 协议栈分成 5 层（或7层）？开放式回答。 分层的好处：易维护与实现，将一个难以处理的复杂问题分解为若干个较容易处理的更小的问题。 灵活性好，各层之间是独立的。任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不影响。 结构上可分割，各层都可以采用最合适的技术实现。 能促进标准化工作，每一层的功能及其所提供的服务都已有了明确的说明。 https://blog.csdn.net/qq_32798897/article/details/121879151DNS查询方式有哪些？ https://zhuanlan.zhihu.com/p/423222573递归查询递归查询一般发生在 Client 请求 DNS Server。Client 发出一个域名解析的请求，DNS Server 必须返回对应的 IP 地址，或者返回找不到的错误。","tags":["Interview"],"title":"面试之计算机网络-2","url":"http://localhost:1313/posts/other/interview-network-2/"},{"categories":["other"],"content":"迭代查询迭代查询一般发生在 DNS Server 之间，当 Client 发出域名解析的请求后，DNS Server 需要经过多次查询，才能得到相应的结果。比如先找到根服务器、根据根服务器的信息找到顶级域名服务器，再根据顶级域名服务器找到权威服务器，最后根据权威服务器返回结果，或提示错误。非递归查询非递归查询发生在 Client 和 DNS Server 之间，指的是，请求的 DNS Server 已经知道答案，直接返回。https://juejin.cn/post/6844903900982558734HTTP中缓存的私有和共有字段？知道吗？ 响应头中的Cache-Control: private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。响应头中的Cache-Control:public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。GET 方法参数写法是固定的吗？ 不固定，只要服务端能够解释出来就行，但一般来说，参数写在url的？后面，键值对用\u0026分离。GET 方法的长度限制是怎么回事？ HTTP 协议没有 Body 和 ","date":"2024-01-13T21:56:59+08:00","objectID":"4f4a34570b1cd11ca3ac49b767643bd8_8","order":8,"summary":"迭代查询迭代查询一般发生在 DNS Server 之间，当 Client 发出域名解析的请求后，DNS Server 需要经过多次查询，才能得到相应的结果。比如先找到根服务器、根据根服务器的信息找到顶级域名服务器，再根据顶级域名服务器找到权威服务器，最后根据权威服务器返回结果，或提示错误。非递归查询非递归查询发生在 Client 和 DNS Server 之间，指的是，请求的 DNS Server 已经知道答案，直接返回。https://juejin.cn/post/6844903900982558734HTTP中缓存的私有和共有字段？知道吗？ 响应头中的Cache-Control: private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。响应头中的Cache-Control:public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。GET 方法参数写法是固定的吗？ 不固定，只要服务端能够解释出来就行，但一般来说，参数写在url的？后面，键值对用\u0026分离。GET 方法的长度限制是怎么回事？ HTTP 协议没有 Body 和 ","tags":["Interview"],"title":"面试之计算机网络-2","url":"http://localhost:1313/posts/other/interview-network-2/"},{"categories":["other"],"content":"未标明出处的，均来自小林coding、阿秀的学习笔记、GPT3.5OSI 的七层模型分别是？各自的功能是什么？ 物理层：负责传输比特流，处理物理介质和电信号。 数据链路层：提供可靠的点对点数据传输，处理帧和物理地址。 网络层：将数据包从源主机传输到目标主机，处理路由和寻址。 传输层：提供端口到端口的可靠数据传输，处理连接和流控制。 会话层：管理应用程序之间的会话。 表示层：处理数据的表示和格式转换，提供加密和压缩功能。 应用层：给用户提供网络应用服务，如HTTP、FTP等。 说明传输层数据被称作tcp报文段或udp用户数据报（Segments）； 网络层数据被称做包（Packages）； 数据链路层数据被称为帧（Frames）； 物理层数据被称为比特流（Bits）。 总结网络七层模型是一个标准，而非实现。 网络四层模型是一个实现的应用模型。 网络四层模型由七层模型简化合并而来。 一次完整的HTTP请求过程？ 根据域名，进行DNS域名解析； 拿到解析的IP地址，建立TCP连接； 向IP地址发送HTTP请求； 服务器处理请求，返回响应结果； 浏览器解析HTML； 浏览器渲染页面； 关闭TC","date":"2024-01-13T21:56:32+08:00","objectID":"36b6971d62443652a837b13d05106d8f_0","order":0,"summary":"未标明出处的，均来自小林coding、阿秀的学习笔记、GPT3.5OSI 的七层模型分别是？各自的功能是什么？ 物理层：负责传输比特流，处理物理介质和电信号。 数据链路层：提供可靠的点对点数据传输，处理帧和物理地址。 网络层：将数据包从源主机传输到目标主机，处理路由和寻址。 传输层：提供端口到端口的可靠数据传输，处理连接和流控制。 会话层：管理应用程序之间的会话。 表示层：处理数据的表示和格式转换，提供加密和压缩功能。 应用层：给用户提供网络应用服务，如HTTP、FTP等。 说明传输层数据被称作tcp报文段或udp用户数据报（Segments）； 网络层数据被称做包（Packages）； 数据链路层数据被称为帧（Frames）； 物理层数据被称为比特流（Bits）。 总结网络七层模型是一个标准，而非实现。 网络四层模型是一个实现的应用模型。 网络四层模型由七层模型简化合并而来。 一次完整的HTTP请求过程？ 根据域名，进行DNS域名解析； 拿到解析的IP地址，建立TCP连接； 向IP地址发送HTTP请求； 服务器处理请求，返回响应结果； 浏览器解析HTML； 浏览器渲染页面； 关闭TC","tags":["Interview"],"title":"面试之计算机网络-1","url":"http://localhost:1313/posts/other/interview-network-1/"},{"categories":["other"],"content":"P连接； DNS是？ DNS（Domain Name System，域名系统），是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网。DNS的工作原理？ 将主机域名转换为ip地址，属于应用层协议，使用UDP传输。（DNS应用层协议，以前有个考官问过）过程： 总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 一、主机向本地域名服务器的查询一般都是采用递归查询。 二、本地域名服务器向根域名服务器的查询的迭代查询。当用户输入域名时，浏览器先检查自己的缓存中是否包含这个域名映射的ip地址，有解析结束。 若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。 若无命中，则请求本地域名服务器递归解析（LDNS）。 若LDNS没有命中就进行迭代解析。请求根域名服务器，根域名服务器返回给LDNS一个顶级域名服务器地址。 此时LDNS再发送请求给顶级域名服务器， 接受请求的顶级域名服务器查找并返回这个域名对应的权威服务器的地址 LDNS再请求权威服务器，接受的权威服","date":"2024-01-13T21:56:32+08:00","objectID":"36b6971d62443652a837b13d05106d8f_1","order":1,"summary":"P连接； DNS是？ DNS（Domain Name System，域名系统），是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网。DNS的工作原理？ 将主机域名转换为ip地址，属于应用层协议，使用UDP传输。（DNS应用层协议，以前有个考官问过）过程： 总结： 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 一、主机向本地域名服务器的查询一般都是采用递归查询。 二、本地域名服务器向根域名服务器的查询的迭代查询。当用户输入域名时，浏览器先检查自己的缓存中是否包含这个域名映射的ip地址，有解析结束。 若没命中，则检查操作系统缓存（如Windows的hosts）中有没有解析过的结果，有解析结束。 若无命中，则请求本地域名服务器递归解析（LDNS）。 若LDNS没有命中就进行迭代解析。请求根域名服务器，根域名服务器返回给LDNS一个顶级域名服务器地址。 此时LDNS再发送请求给顶级域名服务器， 接受请求的顶级域名服务器查找并返回这个域名对应的权威服务器的地址 LDNS再请求权威服务器，接受的权威服","tags":["Interview"],"title":"面试之计算机网络-1","url":"http://localhost:1313/posts/other/interview-network-1/"},{"categories":["other"],"content":"务器根据映射关系表找到目标ip，返回给LDNS LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户再缓存到本地系统缓存中。 为什么域名解析用UDP协议？ 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。在某些情况下，域名解析可能会使用TCP来处理较为复杂的查询或处理大型响应。为什么区域传送用TCP协议？ 区域传送（Zone Transfer）是指将一个DNS域的完整副本从一个DNS服务器传输到另一个DNS服务器的过程。需要确保可靠性和完整性，并且这个副本往往包含大量数据，适合用TCP传输。HTTP长连接和短连接的区别 长连接：长连接，指在一个连接上可以处理多个请求，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。短连接：指的是一个连接上只能处理一个请求，之后断开此连接，即每次连接只完成一项业务的发送。长连接的优点是减少了连接的建立和关闭的开销，节省了时间和资源。它可以提高性能和效率，特别是在需要频繁通信的场景下。然而，长连接也需要维护连接的状态和资源，可能会导致服务器负","date":"2024-01-13T21:56:32+08:00","objectID":"36b6971d62443652a837b13d05106d8f_2","order":2,"summary":"务器根据映射关系表找到目标ip，返回给LDNS LDNS缓存这个域名和对应的ip， 把解析的结果返回给用户，用户再缓存到本地系统缓存中。 为什么域名解析用UDP协议？ 客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过TCP三次握手，这样DNS服务器负载更低，响应更快。在某些情况下，域名解析可能会使用TCP来处理较为复杂的查询或处理大型响应。为什么区域传送用TCP协议？ 区域传送（Zone Transfer）是指将一个DNS域的完整副本从一个DNS服务器传输到另一个DNS服务器的过程。需要确保可靠性和完整性，并且这个副本往往包含大量数据，适合用TCP传输。HTTP长连接和短连接的区别 长连接：长连接，指在一个连接上可以处理多个请求，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。短连接：指的是一个连接上只能处理一个请求，之后断开此连接，即每次连接只完成一项业务的发送。长连接的优点是减少了连接的建立和关闭的开销，节省了时间和资源。它可以提高性能和效率，特别是在需要频繁通信的场景下。然而，长连接也需要维护连接的状态和资源，可能会导致服务器负","tags":["Interview"],"title":"面试之计算机网络-1","url":"http://localhost:1313/posts/other/interview-network-1/"},{"categories":["other"],"content":"担增加。什么是TCP粘包/拆包？发生的原因？ 一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。原因1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小.2、进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度)3、进行MTU大小的IP分片。解决方案1、消息定长。2、在包尾部增加回车或者空格符等特殊字符进行分割3、将消息分为消息头和消息尾为什么服务器会缓存?如何实现的？ 原因缓解服务器压力； 降低客户端获取资源的延迟~~：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。~~ 实现方法让代理服务器进行缓存； 让客户端浏览器进行缓存。 HTTP请求方法你知道多少？ 客户端发送的 请求报文 第一行为请求行，包含了请求方法字段。HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。序 号 方","date":"2024-01-13T21:56:32+08:00","objectID":"36b6971d62443652a837b13d05106d8f_3","order":3,"summary":"担增加。什么是TCP粘包/拆包？发生的原因？ 一个完整的业务可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题。原因1、应用程序写入数据的字节大小大于套接字发送缓冲区的大小.2、进行MSS大小的TCP分段。( MSS=TCP报文段长度-TCP首部长度)3、进行MTU大小的IP分片。解决方案1、消息定长。2、在包尾部增加回车或者空格符等特殊字符进行分割3、将消息分为消息头和消息尾为什么服务器会缓存?如何实现的？ 原因缓解服务器压力； 降低客户端获取资源的延迟~~：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。~~ 实现方法让代理服务器进行缓存； 让客户端浏览器进行缓存。 HTTP请求方法你知道多少？ 客户端发送的 请求报文 第一行为请求行，包含了请求方法字段。HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。序 号 方","tags":["Interview"],"title":"面试之计算机网络-1","url":"http://localhost:1313/posts/other/interview-network-1/"},{"categories":["other"],"content":"法 描述 1 GET 【获取资源】请求指定的页面信息，并返回实体主体。 2 HEAD 【获得报文首部】类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 【传输实体文本】向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 【传输文件】从客户端向服务器传送的数据取代指定的文档的内容。PUT通常指定了资源的存放位置，而POST则没有 5 DELETE 【删除文件】请求服务器删除指定的页面。 6 CONNECT 【要求用管道协议连接代理服务器】HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 【询问支持的方法】客户端询问服务器可以提交哪些请求方法。这个方法很有趣，它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。 8 TRACE 【追踪路径】回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 【局部更新文件】是对 PUT ","date":"2024-01-13T21:56:32+08:00","objectID":"36b6971d62443652a837b13d05106d8f_4","order":4,"summary":"法 描述 1 GET 【获取资源】请求指定的页面信息，并返回实体主体。 2 HEAD 【获得报文首部】类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 【传输实体文本】向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 【传输文件】从客户端向服务器传送的数据取代指定的文档的内容。PUT通常指定了资源的存放位置，而POST则没有 5 DELETE 【删除文件】请求服务器删除指定的页面。 6 CONNECT 【要求用管道协议连接代理服务器】HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 【询问支持的方法】客户端询问服务器可以提交哪些请求方法。这个方法很有趣，它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。 8 TRACE 【追踪路径】回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 【局部更新文件】是对 PUT ","tags":["Interview"],"title":"面试之计算机网络-1","url":"http://localhost:1313/posts/other/interview-network-1/"},{"categories":["other"],"content":"方法的补充，用来对已知资源进行局部更新 。 https://blog.csdn.net/demo_yo/article/details/123596028GET 和 POST 的区别，你知道哪些？ get是请求数据，post是传输实体文本，可能导致新资源的建立或者已有资源的修改get提交的数据有限制最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。GET请求会被浏览器主动缓存，而POST不会，除非手动设置。本质区别：GET是幂等的，而POST不是幂等的GET只允许ASCII字符，POST没有限制。这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。 正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。一个TCP连接可以对应几个HTTP请求？ 如果是长连接，一个 TCP 连接是可以发送","date":"2024-01-13T21:56:32+08:00","objectID":"36b6971d62443652a837b13d05106d8f_5","order":5,"summary":"方法的补充，用来对已知资源进行局部更新 。 https://blog.csdn.net/demo_yo/article/details/123596028GET 和 POST 的区别，你知道哪些？ get是请求数据，post是传输实体文本，可能导致新资源的建立或者已有资源的修改get提交的数据有限制最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。GET请求会被浏览器主动缓存，而POST不会，除非手动设置。本质区别：GET是幂等的，而POST不是幂等的GET只允许ASCII字符，POST没有限制。这里的幂等性：幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一URL的多个请求应该返回同样的结果。 正因为它们有这样的区别，所以不应该且不能用get请求做数据的增删改这些有副作用的操作。因为get请求是幂等的，在网络不好的隧道中会尝试重试。如果用get请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用get请求去做增操作）。一个TCP连接可以对应几个HTTP请求？ 如果是长连接，一个 TCP 连接是可以发送","tags":["Interview"],"title":"面试之计算机网络-1","url":"http://localhost:1313/posts/other/interview-network-1/"},{"categories":["other"],"content":"多个 HTTP 请求的。如果关闭长连接，则只能一对一。一个 TCP 连接中 HTTP 请求发送可以一起发送么？ （比如一起发三个请求，再三个响应一起接收）如果采用的是HTTP1.1,是不可行的，单个TCP连接在同一时刻只能处理一个请求，如果开启管道（pipelining）技术则可以实现多个http请求。如果采用的是http2则是可行的，因为http2具备多路复用（multiplexing）的功能，多个 HTTP 请求可以在同一个 TCP 连接中并行处理。那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。 和服务器建立多个 TCP 连接。 浏览器对同一 Host 建立 TCP 连接的数量有没有限制？ 有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。拓展： 如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不","date":"2024-01-13T21:56:32+08:00","objectID":"36b6971d62443652a837b13d05106d8f_6","order":6,"summary":"多个 HTTP 请求的。如果关闭长连接，则只能一对一。一个 TCP 连接中 HTTP 请求发送可以一起发送么？ （比如一起发三个请求，再三个响应一起接收）如果采用的是HTTP1.1,是不可行的，单个TCP连接在同一时刻只能处理一个请求，如果开启管道（pipelining）技术则可以实现多个http请求。如果采用的是http2则是可行的，因为http2具备多路复用（multiplexing）的功能，多个 HTTP 请求可以在同一个 TCP 连接中并行处理。那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点：维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。 和服务器建立多个 TCP 连接。 浏览器对同一 Host 建立 TCP 连接的数量有没有限制？ 有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。拓展： 如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不","tags":["Interview"],"title":"面试之计算机网络-1","url":"http://localhost:1313/posts/other/interview-network-1/"},{"categories":["other"],"content":"过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。在浏览器中输入url地址后显示主页的过程? 根据域名，进行DNS域名解析； 拿到解析的IP地址，建立TCP连接； 向IP地址发送HTTP请求； 服务器处理请求，返回响应结果； 浏览器解析HTML； 浏览器渲染页面； 关闭TCP连接； 在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？ https://mp.weixin.qq.com/s/9vGRSkUNgRQWO6tVmUisOw应用层：浏览器封装 HTTP 请求报文 DNS 解析域名获得目标服务器地址 传输层：建立连接 将HTTP请求封装成TCP或UDP包（将","date":"2024-01-13T21:56:32+08:00","objectID":"36b6971d62443652a837b13d05106d8f_7","order":7,"summary":"过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。如果发现用不了 HTTP2 呢？或者用不了 HTTPS（现实中的 HTTP2 都是在 HTTPS 上实现的，所以也就是只能使用 HTTP/1.1）。那浏览器就会在一个 HOST 上建立多个 TCP 连接，连接数量的最大限制取决于浏览器设置，这些连接会在空闲的时候被浏览器用来发送新的请求，如果所有的连接都正在发送请求呢？那其他的请求就只能等等了。在浏览器中输入url地址后显示主页的过程? 根据域名，进行DNS域名解析； 拿到解析的IP地址，建立TCP连接； 向IP地址发送HTTP请求； 服务器处理请求，返回响应结果； 浏览器解析HTML； 浏览器渲染页面； 关闭TCP连接； 在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？ https://mp.weixin.qq.com/s/9vGRSkUNgRQWO6tVmUisOw应用层：浏览器封装 HTTP 请求报文 DNS 解析域名获得目标服务器地址 传输层：建立连接 将HTTP请求封装成TCP或UDP包（将","tags":["Interview"],"title":"面试之计算机网络-1","url":"http://localhost:1313/posts/other/interview-network-1/"},{"categories":["other"],"content":"HTTP 请求报文进行分割，并在各个报文上加入标记序号及端口号） 网络层：利用 ARP 协议根据 IP 地址获取目的地的 MAC 地址后将数据包转发给链路层进行传输 服务端在链路层收到数据，按序往上层发送拆包，一直到应用层接收到浏览器发送来的 HTTP 请求报文，然后处理该请求并返回 HTTP 响应报文，浏览器接收到响应报文之后解析渲染界面。最后 TCP 断开连接。DNS负载均衡是什么策略？ 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答对该主机的DNS查询时,DNS服务器利用这些IP地址引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。HTTPS和HTTP的区别 HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报","date":"2024-01-13T21:56:32+08:00","objectID":"36b6971d62443652a837b13d05106d8f_8","order":8,"summary":"HTTP 请求报文进行分割，并在各个报文上加入标记序号及端口号） 网络层：利用 ARP 协议根据 IP 地址获取目的地的 MAC 地址后将数据包转发给链路层进行传输 服务端在链路层收到数据，按序往上层发送拆包，一直到应用层接收到浏览器发送来的 HTTP 请求报文，然后处理该请求并返回 HTTP 响应报文，浏览器接收到响应报文之后解析渲染界面。最后 TCP 断开连接。DNS负载均衡是什么策略？ 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答对该主机的DNS查询时,DNS服务器利用这些IP地址引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。HTTPS和HTTP的区别 HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报","tags":["Interview"],"title":"面试之计算机网络-1","url":"http://localhost:1313/posts/other/interview-network-1/"},{"categories":["other"],"content":"类的对象存储空间？ 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；内存对齐另外分配的空间大小；虚函数会在类对象插入vptr指针，加上指针大小；基类的数据成员也会存在派生类中的空间。简要说明C++的内存分区 C++中的内存分区，分别是堆、栈、全局/静态存储区、常量存储区和代码区。如下图所示栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限堆：由 new分配的内存块，需要应用程序去控制，new和 delete要对应。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收全局/静态存储区：全局变量和静态变量被分配到同一块内存中，~~在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，~~在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0常量存储区：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改代码区：存放函数体的二进制代码什么是内存池，如何实现 内存池（Memory","date":"2024-01-13T21:56:13+08:00","objectID":"604ce3a921cd654d6fabc3cacf9ba4e4_0","order":0,"summary":"类的对象存储空间？ 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；内存对齐另外分配的空间大小；虚函数会在类对象插入vptr指针，加上指针大小；基类的数据成员也会存在派生类中的空间。简要说明C++的内存分区 C++中的内存分区，分别是堆、栈、全局/静态存储区、常量存储区和代码区。如下图所示栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限堆：由 new分配的内存块，需要应用程序去控制，new和 delete要对应。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收全局/静态存储区：全局变量和静态变量被分配到同一块内存中，~~在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，~~在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0常量存储区：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改代码区：存放函数体的二进制代码什么是内存池，如何实现 内存池（Memory","tags":["Interview"],"title":"面试之CPP基础知识-8","url":"http://localhost:1313/posts/other/interview-basic-cpp-8/"},{"categories":["other"],"content":" Pool）是一种动态内存分配与管理技术，通常情况下，程序员习惯直接使用new，delete，malloc,free等API申请和释放内存，这样导致的后果就是：当程序运行的时间很长的时候，由于所申请的内存块的大小不定，频繁使用时会造成大量的内存碎片从而降低程序和操作系统的性能。 内存池则是在真正使用内存之前，先申请分配一大块内存（内存池）留作备用。当程序员申请内存时，从池中取出一块动态分配，当程序员释放时，将释放的内存放回到池内，再次申请，就可以从池里取出来使用，并尽量与周边的空闲内存块合并。若内存池不够时，则自动扩大内存池，从操作系统中申请更大的内存池。 https://zhuanlan.zhihu.com/p/523216209C++的内存管理？ 在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区和代码区。栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限堆：由 new分配的内存块，需要应用程序去控制，new和 delete要对应。如果程序员","date":"2024-01-13T21:56:13+08:00","objectID":"604ce3a921cd654d6fabc3cacf9ba4e4_1","order":1,"summary":" Pool）是一种动态内存分配与管理技术，通常情况下，程序员习惯直接使用new，delete，malloc,free等API申请和释放内存，这样导致的后果就是：当程序运行的时间很长的时候，由于所申请的内存块的大小不定，频繁使用时会造成大量的内存碎片从而降低程序和操作系统的性能。 内存池则是在真正使用内存之前，先申请分配一大块内存（内存池）留作备用。当程序员申请内存时，从池中取出一块动态分配，当程序员释放时，将释放的内存放回到池内，再次申请，就可以从池里取出来使用，并尽量与周边的空闲内存块合并。若内存池不够时，则自动扩大内存池，从操作系统中申请更大的内存池。 https://zhuanlan.zhihu.com/p/523216209C++的内存管理？ 在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区和代码区。栈：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限堆：由 new分配的内存块，需要应用程序去控制，new和 delete要对应。如果程序员","tags":["Interview"],"title":"面试之CPP基础知识-8","url":"http://localhost:1313/posts/other/interview-basic-cpp-8/"},{"categories":["other"],"content":"没有释放掉，那么在程序结束后，操作系统会自动回收全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了， 在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0常量存储区：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改代码区：存放函数体的二进制代码C++中类的数据成员和成员函数内存分布情况 类的首地址为声明的第一个成员变量的地址。成员变量保存在栈或堆中，成员函数保存在代码段。https://zhuanlan.zhihu.com/p/5127627551 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u003e using namespace std; class Person { public: Person() { this-\u003eage = 23; } void printAge() { cout \u0026","date":"2024-01-13T21:56:13+08:00","objectID":"604ce3a921cd654d6fabc3cacf9ba4e4_2","order":2,"summary":"没有释放掉，那么在程序结束后，操作系统会自动回收全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了， 在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0常量存储区：这是一块比较特殊的存储区，这里面存放的是常量，不允许修改代码区：存放函数体的二进制代码C++中类的数据成员和成员函数内存分布情况 类的首地址为声明的第一个成员变量的地址。成员变量保存在栈或堆中，成员函数保存在代码段。https://zhuanlan.zhihu.com/p/5127627551 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u003e using namespace std; class Person { public: Person() { this-\u003eage = 23; } void printAge() { cout \u0026","tags":["Interview"],"title":"面试之CPP基础知识-8","url":"http://localhost:1313/posts/other/interview-basic-cpp-8/"},{"categories":["other"],"content":"lt;\u0026lt; this-\u003eage \u0026lt;\u0026lt;endl; } ~Person(){} public: int age; const int a = 5; static int b; }; int main() { Person p; cout \u0026lt;\u0026lt; \"对象地址：\"\u0026lt;\u0026lt; \u0026p \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \"age地址：\"\u0026lt;\u0026lt; \u0026(p.age) \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \"对象大小：\"\u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt;endl; return 0; } //输出结果 //对象地址：0x7fffec0f15a8 //age地址：0x7fffec0f15a8 //对象大小：8 所有函数都存放在代码区，静态函数也不例外。一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。关于this指针你知道什么？ this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 this 指针被隐含地声明为: ClassName *const","date":"2024-01-13T21:56:13+08:00","objectID":"604ce3a921cd654d6fabc3cacf9ba4e4_3","order":3,"summary":"lt;\u0026lt; this-\u003eage \u0026lt;\u0026lt;endl; } ~Person(){} public: int age; const int a = 5; static int b; }; int main() { Person p; cout \u0026lt;\u0026lt; \"对象地址：\"\u0026lt;\u0026lt; \u0026p \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \"age地址：\"\u0026lt;\u0026lt; \u0026(p.age) \u0026lt;\u0026lt;endl; cout \u0026lt;\u0026lt; \"对象大小：\"\u0026lt;\u0026lt; sizeof(p) \u0026lt;\u0026lt;endl; return 0; } //输出结果 //对象地址：0x7fffec0f15a8 //age地址：0x7fffec0f15a8 //对象大小：8 所有函数都存放在代码区，静态函数也不例外。一看到 static 这个单词就主观的认为是存放在全局数据区，那是不对的。关于this指针你知道什么？ this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 this 指针被隐含地声明为: ClassName *const","tags":["Interview"],"title":"面试之CPP基础知识-8","url":"http://localhost:1313/posts/other/interview-basic-cpp-8/"},{"categories":["other"],"content":" this，这意味着不能给 this指针赋值 this 并不是一个常规变量，而是个右值，所以不能取得 this的地址。 this在成员函数的开始执行前构造，在成员函数的执行结束后清除。 A a; a.fun(); // aka a.fun(this) 在以下场景中，经常需要使用 this 指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 内存泄漏的后果？如何监测？解决方法？ 你觉得会问吗1) 内存泄漏内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况，导致程序无法再次利用这段内存。2) 后果只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种症状：性能下降到内存逐渐用完，导致另一个程序失败；3) 如何排除使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，","date":"2024-01-13T21:56:13+08:00","objectID":"604ce3a921cd654d6fabc3cacf9ba4e4_4","order":4,"summary":" this，这意味着不能给 this指针赋值 this 并不是一个常规变量，而是个右值，所以不能取得 this的地址。 this在成员函数的开始执行前构造，在成员函数的执行结束后清除。 A a; a.fun(); // aka a.fun(this) 在以下场景中，经常需要使用 this 指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 内存泄漏的后果？如何监测？解决方法？ 你觉得会问吗1) 内存泄漏内存泄漏是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况，导致程序无法再次利用这段内存。2) 后果只发生一次小的内存泄漏可能不被注意，但泄漏大量内存的程序将会出现各种症状：性能下降到内存逐渐用完，导致另一个程序失败；3) 如何排除使用工具软件BoundsChecker，BoundsChecker是一个运行时错误检测工具，它主要定位程序运行时期发生的各种错误；调试运行DEBUG版程序，运用以下技术：CRT(C run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号(集成开发环境OUTPUT窗口)，","tags":["Interview"],"title":"面试之CPP基础知识-8","url":"http://localhost:1313/posts/other/interview-basic-cpp-8/"},{"categories":["other"],"content":"综合分析内存泄漏的原因，排除内存泄漏。4) 解决方法智能指针。5) 检查、定位内存泄漏检查方法：在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出，查看输出：输出这样的格式{453}normal block at 0x02432CA8,868 bytes long被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。定位代码位置在main函数第一行加上_CrtSetBreakAlloc(453);意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件#include \u0026lt;crtdbg.h\u003e在成员函数中调用delete this会出现什么问题？对象还可以使用吗？ 当 调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。为什么是不可预期的问题？这个问题牵涉","date":"2024-01-13T21:56:13+08:00","objectID":"604ce3a921cd654d6fabc3cacf9ba4e4_5","order":5,"summary":"综合分析内存泄漏的原因，排除内存泄漏。4) 解决方法智能指针。5) 检查、定位内存泄漏检查方法：在main函数最后面一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出，查看输出：输出这样的格式{453}normal block at 0x02432CA8,868 bytes long被{}包围的453就是我们需要的内存泄漏定位值，868 bytes long就是说这个地方有868比特内存没有释放。定位代码位置在main函数第一行加上_CrtSetBreakAlloc(453);意思就是在申请453这块内存的位置中断。然后调试程序，程序中断了，查看调用堆栈。加上头文件#include \u0026lt;crtdbg.h\u003e在成员函数中调用delete this会出现什么问题？对象还可以使用吗？ 当 调用delete this时，类对象的内存空间被释放。在delete this之后进行的其他任何函数调用，只要不涉及到this指针的内容，都能够正常运行。一旦涉及到this指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题。为什么是不可预期的问题？这个问题牵涉","tags":["Interview"],"title":"面试之CPP基础知识-8","url":"http://localhost:1313/posts/other/interview-basic-cpp-8/"},{"categories":["other"],"content":"到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。在析构函数中调用delete this 会导致堆栈溢出，因为delete调用析构，而析构再次调用delete。https://blog.csdn.net/qq_39661275/article/details/106373853你知道空类的大小是多少吗？ 笔试做到过空类(没有非静态数据成员)的对象的size为1, 当作为基类时, size为0。因为标准规定是0，因为每个类需要独一无二的地址，防止出现除0错误。 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定； 这几个类的大小是多少？ 1 2 3 4 5 6 7 8 9 class A {}; class B{ virtu","date":"2024-01-13T21:56:13+08:00","objectID":"604ce3a921cd654d6fabc3cacf9ba4e4_6","order":6,"summary":"到操作系统的内存管理策略。delete this释放了类对象的内存空间，但是内存空间却并不是马上被回收到系统中，可能是缓冲或者其他什么原因，导致这段内存空间暂时并没有被系统收回。此时这段内存是可以访问的，你可以加上100，加上200，但是其中的值却是不确定的。当你获取数据成员，可能得到的是一串很长的未初始化的随机数；访问虚函数表，指针无效的可能性非常高，造成系统崩溃。在析构函数中调用delete this 会导致堆栈溢出，因为delete调用析构，而析构再次调用delete。https://blog.csdn.net/qq_39661275/article/details/106373853你知道空类的大小是多少吗？ 笔试做到过空类(没有非静态数据成员)的对象的size为1, 当作为基类时, size为0。因为标准规定是0，因为每个类需要独一无二的地址，防止出现除0错误。 带有虚函数的C++类大小不为1，因为每一个对象会有一个vptr指向虚函数表，具体大小根据指针大小确定； 这几个类的大小是多少？ 1 2 3 4 5 6 7 8 9 class A {}; class B{ virtu","tags":["Interview"],"title":"面试之CPP基础知识-8","url":"http://localhost:1313/posts/other/interview-basic-cpp-8/"},{"categories":["other"],"content":"static_cast比C语言中的转换强在哪里？ 在编译期间就能发现转换错误 更容易检索到何处强制转换 不同的转换类型体现程序员的意图 https://blog.csdn.net/liji_digital/article/details/123148607成员函数里memset(this,0,sizeof(*this))会发生什么 有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，但是一句句的写太麻烦，在构造函数用memset(this, 0, sizeof *this);中将基本类型成员变量一次性初始化为0，但是下面几种情形是不可以这么使用的：类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常； 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。 https://www.nowcoder.com/search/all?query=memset%28this,%200,%20sizeo","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_0","order":0,"summary":"static_cast比C语言中的转换强在哪里？ 在编译期间就能发现转换错误 更容易检索到何处强制转换 不同的转换类型体现程序员的意图 https://blog.csdn.net/liji_digital/article/details/123148607成员函数里memset(this,0,sizeof(*this))会发生什么 有时候类里面定义了很多int,char,struct等c语言里的那些类型的变量，但是一句句的写太麻烦，在构造函数用memset(this, 0, sizeof *this);中将基本类型成员变量一次性初始化为0，但是下面几种情形是不可以这么使用的：类含有虚函数表：这么做会破坏虚函数表，后续对虚函数的调用都将出现异常； 类中含有C++类型的对象：例如，类中定义了一个list的对象，由于在构造函数体的代码执行之前就对list对象完成了初始化，假设list在它的构造函数里分配了内存，那么我们这么一做就破坏了list对象的内存。 https://www.nowcoder.com/search/all?query=memset%28this,%200,%20sizeo","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"f%28%2athis%29%29\u0026type=all回调函数是？作用？ 回调函数是做为参数传递的一种函数回调函数的创建步骤大概为：1，声明一个函数指针类型。2，实现一个使用回调函数的函数，将函数指针作为参数传递。3，实现一个符合函数指针类型的函数，将该函数的指针作为参数传递给使用它的函数。或者使用C++标准库的function和bind。std::funtion定义函数类型(输入、输出)，std::bind绑定特定的函数（具体的要调用的函数）（对于普通函数直接将函数名给function即可）。作用：把调用者与被调用者分开。调用者不关心谁是被调用者，它只需知道存在一个满足其需求的被调用函数。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // std::function\u0026lt;returnType(argType, argType，...)\u003e func; // std::bind(\u0026funcName, std::placeholders::_1, ...); // 类：std::bind","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_1","order":1,"summary":"f%28%2athis%29%29\u0026type=all回调函数是？作用？ 回调函数是做为参数传递的一种函数回调函数的创建步骤大概为：1，声明一个函数指针类型。2，实现一个使用回调函数的函数，将函数指针作为参数传递。3，实现一个符合函数指针类型的函数，将该函数的指针作为参数传递给使用它的函数。或者使用C++标准库的function和bind。std::funtion定义函数类型(输入、输出)，std::bind绑定特定的函数（具体的要调用的函数）（对于普通函数直接将函数名给function即可）。作用：把调用者与被调用者分开。调用者不关心谁是被调用者，它只需知道存在一个满足其需求的被调用函数。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // std::function\u0026lt;returnType(argType, argType，...)\u003e func; // std::bind(\u0026funcName, std::placeholders::_1, ...); // 类：std::bind","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"(\u0026className::funcName, classPtr, std::placeholders::_1, ...); class BrainToolBox { public: int Add(int a, int b) { return a + b; }; }; bool CompareInt(int a, int b) { return a \u003e b; } int main() { int a = 4; int b = 6; std::function\u0026lt;bool(int, int)\u003e compareFunc = CompareInt; std::shared_ptr\u0026lt;BrainToolBox\u003e brain = std::make_shared\u0026lt;BrainToolBox\u003e(); std::function\u0026lt;int(int, int)\u003e addFunc = std::bind(\u0026BrainToolBox::Add, brain, std::placeholders::_1, std::placeholders::_2); int c = addFunc(a, ","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_2","order":2,"summary":"(\u0026className::funcName, classPtr, std::placeholders::_1, ...); class BrainToolBox { public: int Add(int a, int b) { return a + b; }; }; bool CompareInt(int a, int b) { return a \u003e b; } int main() { int a = 4; int b = 6; std::function\u0026lt;bool(int, int)\u003e compareFunc = CompareInt; std::shared_ptr\u0026lt;BrainToolBox\u003e brain = std::make_shared\u0026lt;BrainToolBox\u003e(); std::function\u0026lt;int(int, int)\u003e addFunc = std::bind(\u0026BrainToolBox::Add, brain, std::placeholders::_1, std::placeholders::_2); int c = addFunc(a, ","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"b); std::cout \u0026lt;\u0026lt; \"c Value: \" \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl; return EXIT_SUCCESS; } https://www.airchip.org.cn/index.php/2022/03/05/cpp-example-callback/https://blog.csdn.net/zhoupian/article/details/119495949什么是一致性哈希？ 大厂双非硕简历过不了，不看。小厂就说不知道。C++从代码到可执行程序经历了什么？ （1）预编译对源代码文件中的头文件、预编译语句（宏定义）进行分析和替换，生成预编译.ii文件。 处理规则见下：删除所有的#define，展开所有的宏定义。 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。 删除所有的注释，“//”和“/**/”。 保留所有的#pragma 编译器指令，编译器需要用到他们","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_3","order":3,"summary":"b); std::cout \u0026lt;\u0026lt; \"c Value: \" \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl; return EXIT_SUCCESS; } https://www.airchip.org.cn/index.php/2022/03/05/cpp-example-callback/https://blog.csdn.net/zhoupian/article/details/119495949什么是一致性哈希？ 大厂双非硕简历过不了，不看。小厂就说不知道。C++从代码到可执行程序经历了什么？ （1）预编译对源代码文件中的头文件、预编译语句（宏定义）进行分析和替换，生成预编译.ii文件。 处理规则见下：删除所有的#define，展开所有的宏定义。 处理所有的条件预编译指令，如“#if”、“#endif”、“#ifdef”、“#elif”和“#else”。 处理“#include”预编译指令，将文件内容替换到它的位置，这个过程是递归进行的，文件中包含其他文件。 删除所有的注释，“//”和“/**/”。 保留所有的#pragma 编译器指令，编译器需要用到他们","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"，如：#pragma once 是为了防止有文件被重复引用。 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。 （2）编译把预编译生成的文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码.s文件。词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。 优化：源代码级别的一个优化过程。 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。 （3）汇编将汇编文件转化成机器码，生成可重定位目标文件xxx.o","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_4","order":4,"summary":"，如：#pragma once 是为了防止有文件被重复引用。 添加行号和文件标识，便于编译时编译器产生调试用的行号信息，和编译时产生编译错误或警告是能够显示行号。 （2）编译把预编译生成的文件，进行一系列词法分析、语法分析、语义分析及优化后，生成相应的汇编代码.s文件。词法分析：利用类似于“有限状态机”的算法，将源代码程序输入到扫描机中，将其中的字符序列分割成一系列的记号。 语法分析：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。 语义分析：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。 优化：源代码级别的一个优化过程。 目标代码生成：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——汇编语言表示。 目标代码优化：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。 （3）汇编将汇编文件转化成机器码，生成可重定位目标文件xxx.o","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"(Linux下)、xxx.obj(Window下)。只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。（4）链接将多个目标文件及所需要的库链接成最终的可执行目标文件(.out或.exe文件)。 又分为静态链接和动态链接目标文件可执行目标文件：可以直接在内存中执行； 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接； 静态链接函数和数据被编译进一个二进制文件。在使用静态库的情况下，在链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。 动态链接动态链接的","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_5","order":5,"summary":"(Linux下)、xxx.obj(Window下)。只是根据汇编指令和机器指令的对照表一一翻译过来，汇编过程有汇编器as完成。（4）链接将多个目标文件及所需要的库链接成最终的可执行目标文件(.out或.exe文件)。 又分为静态链接和动态链接目标文件可执行目标文件：可以直接在内存中执行； 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接； 静态链接函数和数据被编译进一个二进制文件。在使用静态库的情况下，在链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件。 空间浪费：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，会出现同一个目标文件都在内存存在多个副本； 更新困难：每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。 运行速度快：但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。 动态链接动态链接的","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。 共享库：每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本； 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就成了升级的目标。 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。 为什么友元函数必须在类内部声明？ 因为这样友元函数才能知道访问的是哪个类的私有成员。友元函数和友元类的基本情况 通过友元可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率（即减少了类型检查和安全性检查等需要的时间开销），但同时也破坏了类的封装性和隐藏性，导致程序可维护性变差。友元关系是单向的（若要互为友元，必须显式地互相声明为友元），不可继承、不可相互推导。1）友元函数友元函数分为普通函数和类成员函数。普通函数只需要在类内声明友元","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_6","order":6,"summary":"基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。 共享库：每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多份副本，而是这多个程序在执行时共享同一份副本； 更新方便：更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就成了升级的目标。 性能损耗：因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。 为什么友元函数必须在类内部声明？ 因为这样友元函数才能知道访问的是哪个类的私有成员。友元函数和友元类的基本情况 通过友元可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率（即减少了类型检查和安全性检查等需要的时间开销），但同时也破坏了类的封装性和隐藏性，导致程序可维护性变差。友元关系是单向的（若要互为友元，必须显式地互相声明为友元），不可继承、不可相互推导。1）友元函数友元函数分为普通函数和类成员函数。普通函数只需要在类内声明友元","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"函数，并在类外实现函数即可。类成员函数需要先实现一个需要访问另一个类的私有成员的类，然后再使用friend关键字在另一个类中声明这些成员函数。具体过程如下：声明一个Me对象 在MyFriend类中定义一个使用Me的私有成员的成员函数 在Me类中声明MyFriend类中某些函数为友元函数 这是在h，cpp分别实现的过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 //MyFriend.h 声明 包含类成员函数作为友元函数 的类 #pragma once class Me; //声明包含类成员友元函数的类 class MyFriend { public: MyFriend(","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_7","order":7,"summary":"函数，并在类外实现函数即可。类成员函数需要先实现一个需要访问另一个类的私有成员的类，然后再使用friend关键字在另一个类中声明这些成员函数。具体过程如下：声明一个Me对象 在MyFriend类中定义一个使用Me的私有成员的成员函数 在Me类中声明MyFriend类中某些函数为友元函数 这是在h，cpp分别实现的过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 //MyFriend.h 声明 包含类成员函数作为友元函数 的类 #pragma once class Me; //声明包含类成员友元函数的类 class MyFriend { public: MyFriend(","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"void){}; void printMe(const Me \u0026pt); double calcDist(const Me \u0026a, const Me \u0026b); }; // ---------------------------------- //Me.h 声明原始类Me #pragma once #include \"MyFriend.h\" class Me { //若此处不声明友元函数，则MyFriend类里对应的函数报错：不能访问Me私有变量 friend void MyFriend::printMe(const Me \u0026pt); friend double MyFriend::calcDist(const Me \u0026a, const Me \u0026b); friend void globalFunc(const Me \u0026a); public: Me(double x, double y); private: double mX; double mY; }; // ---------------------------------- //Me.cpp 定义原始类 #include \"Me.h","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_8","order":8,"summary":"void){}; void printMe(const Me \u0026pt); double calcDist(const Me \u0026a, const Me \u0026b); }; // ---------------------------------- //Me.h 声明原始类Me #pragma once #include \"MyFriend.h\" class Me { //若此处不声明友元函数，则MyFriend类里对应的函数报错：不能访问Me私有变量 friend void MyFriend::printMe(const Me \u0026pt); friend double MyFriend::calcDist(const Me \u0026a, const Me \u0026b); friend void globalFunc(const Me \u0026a); public: Me(double x, double y); private: double mX; double mY; }; // ---------------------------------- //Me.cpp 定义原始类 #include \"Me.h","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"\" Me::Me(double x, double y) { mX = x; mY = y; } // ---------------------------------- //MyFriend.cpp #include \"MyFriend.h\" #include \u0026lt;cmath\u003e #include \u0026lt;iostream\u003e using namespace std; //在cpp中包含 原始类 头文件 #include \"Me.h\" void MyFriend::printMe(const Me \u0026pt) { cout\u0026lt;\u0026lt; \"(\" \u0026lt;\u0026lt; pt.mX \u0026lt;\u0026lt; \", \" \u0026lt;\u0026lt; pt.mY \u0026lt;\u0026lt; \")\" \u0026lt;\u0026lt; endl; } double MyFriend::calcDist(const Me \u0026a, const Me \u0026b) { double deltX = a.mX - b.mX; double deltY = a.mY - b.mY; return sqrt( deltX * deltX - deltY * d","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_9","order":9,"summary":"\" Me::Me(double x, double y) { mX = x; mY = y; } // ---------------------------------- //MyFriend.cpp #include \"MyFriend.h\" #include \u0026lt;cmath\u003e #include \u0026lt;iostream\u003e using namespace std; //在cpp中包含 原始类 头文件 #include \"Me.h\" void MyFriend::printMe(const Me \u0026pt) { cout\u0026lt;\u0026lt; \"(\" \u0026lt;\u0026lt; pt.mX \u0026lt;\u0026lt; \", \" \u0026lt;\u0026lt; pt.mY \u0026lt;\u0026lt; \")\" \u0026lt;\u0026lt; endl; } double MyFriend::calcDist(const Me \u0026a, const Me \u0026b) { double deltX = a.mX - b.mX; double deltY = a.mY - b.mY; return sqrt( deltX * deltX - deltY * d","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"eltY ); } // ---------------------------------- //main.cpp #include \u0026lt;iostream\u003e #include \"Me.h\" using namespace std; void globalFunc(const Me \u0026a) { cout \u0026lt;\u0026lt; \"friend Global Func \" \u0026lt;\u0026lt; a.mX \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; a.mY \u0026lt;\u0026lt; endl; } int main(void) { Me p1(1.0, 4.0); Me p2(6.0, 8.0); MyFriend pc; pc.printMe(p1); pc.printMe(p2); double dist = pc.calcDist(p2, p1); cout\u0026lt;\u0026lt;\"Distance between p1 and p2 is \"\u0026lt;\u0026lt;dist\u0026lt;\u0026lt;endl; globalFunc(p1); return 0; } 一个函数可以是多个类的友元函数，但是每个类中都要声明这","date":"2024-01-13T21:55:47+08:00","objectID":"ee06f344f903fb601cce01db85c8d531_10","order":10,"summary":"eltY ); } // ---------------------------------- //main.cpp #include \u0026lt;iostream\u003e #include \"Me.h\" using namespace std; void globalFunc(const Me \u0026a) { cout \u0026lt;\u0026lt; \"friend Global Func \" \u0026lt;\u0026lt; a.mX \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; a.mY \u0026lt;\u0026lt; endl; } int main(void) { Me p1(1.0, 4.0); Me p2(6.0, 8.0); MyFriend pc; pc.printMe(p1); pc.printMe(p2); double dist = pc.calcDist(p2, p1); cout\u0026lt;\u0026lt;\"Distance between p1 and p2 is \"\u0026lt;\u0026lt;dist\u0026lt;\u0026lt;endl; globalFunc(p1); return 0; } 一个函数可以是多个类的友元函数，但是每个类中都要声明这","tags":["Interview"],"title":"面试之CPP基础知识-7","url":"http://localhost:1313/posts/other/interview-basic-cpp-7/"},{"categories":["other"],"content":"int main(int argc, char *argv[])里的参数，你了解吗？ 参数的含义是程序在命令行下运行的时候，输入了argc 个参数，每个参数以char*类型存入 argv[]，第一个参数为程序的名称。volatile关键字的作用？ volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，系统总是重新从它所在的内存读取数据。可以用在多线程中，每次读取到修改后的值。如果有一个空类，它会默认添加哪些函数？ 1 2 3 4 5 6 Empty(); // 缺省构造函数 Empty( const Empty\u0026 ); // 拷贝构造函数 ~Empty(); // 析构函数 Empty\u0026 operator=( const Empty\u0026 ); // 赋值运算符 Empty* operator\u0026(); // 取址运算符 const Empty* operator\u0026() const; // 取址运算符 const 只有你需要用到这些函数并且你又没有显示的声明这些函数的时候，编译器才会贴心的自动声明相应的函数。https://developer.ali","date":"2024-01-13T21:55:29+08:00","objectID":"4b0db0f11f72499d9a2bc87d210e3654_0","order":0,"summary":"int main(int argc, char *argv[])里的参数，你了解吗？ 参数的含义是程序在命令行下运行的时候，输入了argc 个参数，每个参数以char*类型存入 argv[]，第一个参数为程序的名称。volatile关键字的作用？ volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，系统总是重新从它所在的内存读取数据。可以用在多线程中，每次读取到修改后的值。如果有一个空类，它会默认添加哪些函数？ 1 2 3 4 5 6 Empty(); // 缺省构造函数 Empty( const Empty\u0026 ); // 拷贝构造函数 ~Empty(); // 析构函数 Empty\u0026 operator=( const Empty\u0026 ); // 赋值运算符 Empty* operator\u0026(); // 取址运算符 const Empty* operator\u0026() const; // 取址运算符 const 只有你需要用到这些函数并且你又没有显示的声明这些函数的时候，编译器才会贴心的自动声明相应的函数。https://developer.ali","tags":["Interview"],"title":"面试之CPP基础知识-6","url":"http://localhost:1313/posts/other/interview-basic-cpp-6/"},{"categories":["other"],"content":"yun.com/article/3763C++中标准库是什么？ C++ 标准库可以分为两部分：标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数 面向对象类库： 这个库是类及其相关函数的集合。标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库 https://www.runoob.com/cplusplus/cpp-standard-library.htmlconst char* 与string之间的关系？ string 是c++标准库提供的字符串类，封装了对字符串的操作const char *是指向一个常量字符串的指针可以用const char*给string类初始化，用string.c_str()给const char *初始化。三者的转化关系如下所示：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18","date":"2024-01-13T21:55:29+08:00","objectID":"4b0db0f11f72499d9a2bc87d210e3654_1","order":1,"summary":"yun.com/article/3763C++中标准库是什么？ C++ 标准库可以分为两部分：标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。输入/输出 I/O、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数 面向对象类库： 这个库是类及其相关函数的集合。标准的 C++ I/O 类、String 类、数值类、STL 容器类、STL 算法、STL 函数对象、STL 迭代器、STL 分配器、本地化库、异常处理类、杂项支持库 https://www.runoob.com/cplusplus/cpp-standard-library.htmlconst char* 与string之间的关系？ string 是c++标准库提供的字符串类，封装了对字符串的操作const char *是指向一个常量字符串的指针可以用const char*给string类初始化，用string.c_str()给const char *初始化。三者的转化关系如下所示：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18","tags":["Interview"],"title":"面试之CPP基础知识-6","url":"http://localhost:1313/posts/other/interview-basic-cpp-6/"},{"categories":["other"],"content":" 19 20 21 22 // a) string转const char* string s = \"abc\"; const char* c_s = s.c_str(); // b) const char* 转string，直接赋值即可 const char* c_s = \"abc\"; string s(c_s); // c) string 转char* string s = \"abc\"; char* c; const int len = s.length(); c = new char[len+1]; strcpy(c,s.c_str()); // d) char* 转string char c[] = \"abc\"; string s(c); // e) const char* 转char* const char* cpc = \"abc\"; char* pc = new char[strlen(cpc)+1]; strcpy(pc,cpc); // f) char* 转const char*，直接赋值即可 char c[] = \"abc\"; const char* cpc = c; 你","date":"2024-01-13T21:55:29+08:00","objectID":"4b0db0f11f72499d9a2bc87d210e3654_2","order":2,"summary":" 19 20 21 22 // a) string转const char* string s = \"abc\"; const char* c_s = s.c_str(); // b) const char* 转string，直接赋值即可 const char* c_s = \"abc\"; string s(c_s); // c) string 转char* string s = \"abc\"; char* c; const int len = s.length(); c = new char[len+1]; strcpy(c,s.c_str()); // d) char* 转string char c[] = \"abc\"; string s(c); // e) const char* 转char* const char* cpc = \"abc\"; char* pc = new char[strlen(cpc)+1]; strcpy(pc,cpc); // f) char* 转const char*，直接赋值即可 char c[] = \"abc\"; const char* cpc = c; 你","tags":["Interview"],"title":"面试之CPP基础知识-6","url":"http://localhost:1313/posts/other/interview-basic-cpp-6/"},{"categories":["other"],"content":"什么情况用指针当参数，什么时候用引用，为什么？ 用指针的情况一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向），其他情况一般都使用引用，它可以避免判断是否为空提高效率，并且不会像普通的值传递还需要拷贝实参。https://blog.csdn.net/wyg1065395142https://blog.csdn.net/lyd_253261362静态绑定和动态绑定？ 静态类型：对象在声明时采用的类型，在编译期既已确定； 动态类型：通常是指一个指针或引用，目前所指对象的类型，是在运行期决定的； 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期； 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定； 如何设计一个计算仅单个子类的对象个数？ 1、为类设计一个static静态变量count作为计数器；2、类外初始化count;3、在构造函数~~、拷贝构造函数、赋值构造函数~","date":"2024-01-13T21:55:29+08:00","objectID":"4b0db0f11f72499d9a2bc87d210e3654_3","order":3,"summary":"什么情况用指针当参数，什么时候用引用，为什么？ 用指针的情况一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向），其他情况一般都使用引用，它可以避免判断是否为空提高效率，并且不会像普通的值传递还需要拷贝实参。https://blog.csdn.net/wyg1065395142https://blog.csdn.net/lyd_253261362静态绑定和动态绑定？ 静态类型：对象在声明时采用的类型，在编译期既已确定； 动态类型：通常是指一个指针或引用，目前所指对象的类型，是在运行期决定的； 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期； 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期； 在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定； 如何设计一个计算仅单个子类的对象个数？ 1、为类设计一个static静态变量count作为计数器；2、类外初始化count;3、在构造函数~~、拷贝构造函数、赋值构造函数~","tags":["Interview"],"title":"面试之CPP基础知识-6","url":"http://localhost:1313/posts/other/interview-basic-cpp-6/"},{"categories":["other"],"content":"~中对count进行+1;4、在析构函数中对count进行-1；怎么快速定位错误出现的地方? 查看错误信息和日志：首先，仔细阅读错误信息和日志，它们通常会提供关于错误类型、发生位置和相关调用栈的信息。错误信息可能包含文件名、行号、函数名等，这些信息可以帮助你快速定位到错误的源代码位置。使用调试器：调试器是一种强大的工具，可以逐行跟踪代码的执行过程，查看变量的值、调用堆栈等信息。通过在出现错误的地方设置断点，你可以在运行时停止程序并检查当前的状态，帮助你找到问题所在。日志输出和断言：在代码中适当地添加日志输出和断言语句，可以帮助你追踪程序的执行过程，并在特定条件下中断程序执行。通过在关键位置输出日志信息，你可以了解程序的执行流程和变量的值，从而更容易定位错误。缩小搜索范围：如果你已经确定错误发生在某个函数或代码块内部，可以采用二分法或逐步注释法来缩小搜索范围。通过逐渐注释掉代码段或只保留关键部分，可以确定错误发生的具体位置。使用工具和技术：利用各种可用的工具和技术来辅助定位错误，如代码静态分析工具、内存泄漏检测工具、性能分析器等。这些工具可以提供更详细的分析和报告，帮助你找出潜在的问题所","date":"2024-01-13T21:55:29+08:00","objectID":"4b0db0f11f72499d9a2bc87d210e3654_4","order":4,"summary":"~中对count进行+1;4、在析构函数中对count进行-1；怎么快速定位错误出现的地方? 查看错误信息和日志：首先，仔细阅读错误信息和日志，它们通常会提供关于错误类型、发生位置和相关调用栈的信息。错误信息可能包含文件名、行号、函数名等，这些信息可以帮助你快速定位到错误的源代码位置。使用调试器：调试器是一种强大的工具，可以逐行跟踪代码的执行过程，查看变量的值、调用堆栈等信息。通过在出现错误的地方设置断点，你可以在运行时停止程序并检查当前的状态，帮助你找到问题所在。日志输出和断言：在代码中适当地添加日志输出和断言语句，可以帮助你追踪程序的执行过程，并在特定条件下中断程序执行。通过在关键位置输出日志信息，你可以了解程序的执行流程和变量的值，从而更容易定位错误。缩小搜索范围：如果你已经确定错误发生在某个函数或代码块内部，可以采用二分法或逐步注释法来缩小搜索范围。通过逐渐注释掉代码段或只保留关键部分，可以确定错误发生的具体位置。使用工具和技术：利用各种可用的工具和技术来辅助定位错误，如代码静态分析工具、内存泄漏检测工具、性能分析器等。这些工具可以提供更详细的分析和报告，帮助你找出潜在的问题所","tags":["Interview"],"title":"面试之CPP基础知识-6","url":"http://localhost:1313/posts/other/interview-basic-cpp-6/"},{"categories":["other"],"content":"在。与他人讨论和协作：如果你遇到困难或无法确定错误的来源，寻求他人的帮助是一个明智的选择。与其他开发者或论坛社区交流，描述你的问题和尝试过的解决方法，他们可能会提供新的思路和建议。mark成员初始化列表会在什么时候用到？它的调用过程是什么？ 当初始化一个引用成员变量时；初始化一个const成员变量时；初始化没有默认构造函数的成员对象或者基类对象；考虑性能的时候，列表初始化减少一次拷贝调用过程？不知道，初始化参数过程：按照类中定义变量的顺序进行初始化 代码进行函数参数以及返回值传递时，使用引用的好处有哪些？ 对比值传递，引用传参的好处：在函数内部可以直接对实参修改 提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗） 用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。但是不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁。说一说strcpy、sprintf与memcpy这三个函数的不同之处 操作对象不同 ① strcpy的两个操作对象均为字符串② sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串③ memcpy的两个对象就是两个任意可操","date":"2024-01-13T21:55:29+08:00","objectID":"4b0db0f11f72499d9a2bc87d210e3654_5","order":5,"summary":"在。与他人讨论和协作：如果你遇到困难或无法确定错误的来源，寻求他人的帮助是一个明智的选择。与其他开发者或论坛社区交流，描述你的问题和尝试过的解决方法，他们可能会提供新的思路和建议。mark成员初始化列表会在什么时候用到？它的调用过程是什么？ 当初始化一个引用成员变量时；初始化一个const成员变量时；初始化没有默认构造函数的成员对象或者基类对象；考虑性能的时候，列表初始化减少一次拷贝调用过程？不知道，初始化参数过程：按照类中定义变量的顺序进行初始化 代码进行函数参数以及返回值传递时，使用引用的好处有哪些？ 对比值传递，引用传参的好处：在函数内部可以直接对实参修改 提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗） 用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。但是不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁。说一说strcpy、sprintf与memcpy这三个函数的不同之处 操作对象不同 ① strcpy的两个操作对象均为字符串② sprintf的操作源对象可以是多种数据类型，目的操作对象是字符串③ memcpy的两个对象就是两个任意可操","tags":["Interview"],"title":"面试之CPP基础知识-6","url":"http://localhost:1313/posts/other/interview-basic-cpp-6/"},{"categories":["other"],"content":"作的内存地址，并不限于何种数据类型。执行效率不同 memcpy最高，strcpy次之，sprintf的效率最低。实现功能不同 ① strcpy主要实现字符串变量间的拷贝② sprintf主要实现其他数据类型格式到字符串的转化③ memcpy主要是内存块间的拷贝。1 2 3 4 5 6 char str [50]; int n, a=5, b=3; n=sprintf(str, \"%d plus %d is %d\", a, b, a+b); char cpy[80]; strcpy(cpy, str); memcpy(cpy, str, 80); 将引用作为函数参数有哪些好处？ 在函数内部可以对此参数进行修改 提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗） 用指针的情况 一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空）， 二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）， 你知道数组和指针的区别吗？ 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p)，p 为指针得到的是一个指针变量的字节数。 ","date":"2024-01-13T21:55:29+08:00","objectID":"4b0db0f11f72499d9a2bc87d210e3654_6","order":6,"summary":"作的内存地址，并不限于何种数据类型。执行效率不同 memcpy最高，strcpy次之，sprintf的效率最低。实现功能不同 ① strcpy主要实现字符串变量间的拷贝② sprintf主要实现其他数据类型格式到字符串的转化③ memcpy主要是内存块间的拷贝。1 2 3 4 5 6 char str [50]; int n, a=5, b=3; n=sprintf(str, \"%d plus %d is %d\", a, b, a+b); char cpy[80]; strcpy(cpy, str); memcpy(cpy, str, 80); 将引用作为函数参数有哪些好处？ 在函数内部可以对此参数进行修改 提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗） 用指针的情况 一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空）， 二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）， 你知道数组和指针的区别吗？ 用运算符sizeof 可以计算出数组的容量（字节数）。sizeof(p)，p 为指针得到的是一个指针变量的字节数。 ","tags":["Interview"],"title":"面试之CPP基础知识-6","url":"http://localhost:1313/posts/other/interview-basic-cpp-6/"},{"categories":["other"],"content":"在向函数传递参数的时候，如果实参是一个数组，数组会退化成指针，指向数组的首地址。 对数组取地址操作后，必须用pointer to array来接受。 如何阻止一个类被实例化？有哪些方法？ 将类定义为抽象基类（抽象类含有纯虚函数） 构造函数声明为private 如何禁止程序自动生成拷贝构造函数？ 手动去重写这两个函数，并将他们设置成delete。 声明这两个函数，并加上private访问权限，一旦使用在编译阶段就报错。 1 2 3 4 5 6 7 8 9 10 11 12 class Uncopyable { protected: Uncopyable(){} ~Uncopyable(){} private: Uncopyable(const Uncopyable\u0026); Uncopyable\u0026 operator= (const Uncopyable\u0026); public: Uncopyable(const Uncopyable\u0026) = delete; Uncopyable\u0026 operator= (const Uncopyable\u0026) = delete; }; 拓展：A a() 和 A a的","date":"2024-01-13T21:55:29+08:00","objectID":"4b0db0f11f72499d9a2bc87d210e3654_7","order":7,"summary":"在向函数传递参数的时候，如果实参是一个数组，数组会退化成指针，指向数组的首地址。 对数组取地址操作后，必须用pointer to array来接受。 如何阻止一个类被实例化？有哪些方法？ 将类定义为抽象基类（抽象类含有纯虚函数） 构造函数声明为private 如何禁止程序自动生成拷贝构造函数？ 手动去重写这两个函数，并将他们设置成delete。 声明这两个函数，并加上private访问权限，一旦使用在编译阶段就报错。 1 2 3 4 5 6 7 8 9 10 11 12 class Uncopyable { protected: Uncopyable(){} ~Uncopyable(){} private: Uncopyable(const Uncopyable\u0026); Uncopyable\u0026 operator= (const Uncopyable\u0026); public: Uncopyable(const Uncopyable\u0026) = delete; Uncopyable\u0026 operator= (const Uncopyable\u0026) = delete; }; 拓展：A a() 和 A a的","tags":["Interview"],"title":"面试之CPP基础知识-6","url":"http://localhost:1313/posts/other/interview-basic-cpp-6/"},{"categories":["other"],"content":"区别 不要想当然的认为a()会调用默认构造函数，实际上它只是声明，而a才是会调用那个默认构造函数，即定义。https://blog.csdn.net/m0_37166947/article/details/72856841在C++中，A a()和A a有不同的含义和行为。A a()：这是一个函数声明的语法，而不是对象的定义或创建。 它声明了一个名为a的函数，该函数没有参数并返回类型为A的值。 这种语法在某些情况下可能会引起误解，因为它看起来像是在创建一个名为a的对象，但实际上它是一个函数声明。 要创建一个对象，应该使用A a;或A a{};的形式。 A a：这是一个对象的定义和创建。 它声明了一个名为a的对象，类型为A。 如果A是一个类类型，则会调用默认构造函数来初始化对象a。 对象a的生命周期将根据其定义的作用域和存储位置进行管理。 from GPT3.5Debug和Release的区别？ 调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或","date":"2024-01-13T21:55:29+08:00","objectID":"4b0db0f11f72499d9a2bc87d210e3654_8","order":8,"summary":"区别 不要想当然的认为a()会调用默认构造函数，实际上它只是声明，而a才是会调用那个默认构造函数，即定义。https://blog.csdn.net/m0_37166947/article/details/72856841在C++中，A a()和A a有不同的含义和行为。A a()：这是一个函数声明的语法，而不是对象的定义或创建。 它声明了一个名为a的函数，该函数没有参数并返回类型为A的值。 这种语法在某些情况下可能会引起误解，因为它看起来像是在创建一个名为a的对象，但实际上它是一个函数声明。 要创建一个对象，应该使用A a;或A a{};的形式。 A a：这是一个对象的定义和创建。 它声明了一个名为a的对象，类型为A。 如果A是一个类类型，则会调用默认构造函数来初始化对象a。 对象a的生命周期将根据其定义的作用域和存储位置进行管理。 from GPT3.5Debug和Release的区别？ 调试版本，包含调试信息，所以容量比Release大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或","tags":["Interview"],"title":"面试之CPP基础知识-6","url":"http://localhost:1313/posts/other/interview-basic-cpp-6/"},{"categories":["other"],"content":"知道C++中的组合吗？它与继承相比有什么优缺点吗？ 一：继承继承是Is a 的关系。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。继承的缺点：把父类的内部实现细节暴露给了子类， 子类的实现会和父类的实现紧密的绑定在一起， 结果是父类实现的改动，会导致子类也必须得改变。 二：组合组合是has A的关系。也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。组合的优点：组合的类的内部细节是不可见。 相互依赖较小，低耦合。 例子 组合的缺点：容易产生过多的对象。 为了能组合多个对象，必须仔细对接口进行定义。 https://blog.csdn.net/K346K346/article/details/55045295组合 继承 has-a关系 is-a关系 运行期决定 编译期决定 不破坏封装，低耦合 破坏，子类依赖父类 支持扩展 扩展必须实现父类方法 动态选择组合类方法 复用父类方法 函数指针？ 1) 什么是函数指针?函数指针就是一个指针指向某个函数，因为在程序中如果定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，函数名表示的就是这个存储空间的","date":"2024-01-13T21:52:56+08:00","objectID":"46664a202421df1ac6b80f7f377b151c_0","order":0,"summary":"知道C++中的组合吗？它与继承相比有什么优缺点吗？ 一：继承继承是Is a 的关系。继承的优点是子类可以重写父类的方法来方便地实现对父类的扩展。继承的缺点：把父类的内部实现细节暴露给了子类， 子类的实现会和父类的实现紧密的绑定在一起， 结果是父类实现的改动，会导致子类也必须得改变。 二：组合组合是has A的关系。也就是设计类的时候把要组合的类的对象加入到该类中作为自己的成员变量。组合的优点：组合的类的内部细节是不可见。 相互依赖较小，低耦合。 例子 组合的缺点：容易产生过多的对象。 为了能组合多个对象，必须仔细对接口进行定义。 https://blog.csdn.net/K346K346/article/details/55045295组合 继承 has-a关系 is-a关系 运行期决定 编译期决定 不破坏封装，低耦合 破坏，子类依赖父类 支持扩展 扩展必须实现父类方法 动态选择组合类方法 复用父类方法 函数指针？ 1) 什么是函数指针?函数指针就是一个指针指向某个函数，因为在程序中如果定义了一个函数，那么在编译时系统就会为这个函数代码分配一段存储空间，函数名表示的就是这个存储空间的","tags":["Interview"],"title":"面试之CPP基础知识-5","url":"http://localhost:1313/posts/other/interview-basic-cpp-5/"},{"categories":["other"],"content":"首地址。2) 函数指针的声明方法函数返回值类型 (* 指针变量名) (函数参数列表);3) 两种方法赋值：指针名 = 函数名； 指针名 = \u0026函数名可以用于回调函数说一说你理解的内存对齐以及原因 分配内存的顺序是按照声明的顺序，不满对齐数则翻倍。 Linux默认以4字节对齐，可通过#pragma pack(n) 修改对齐字节数。 字节对齐后可以方便系统读取 对齐规则:基本类型的对齐值就是其sizeof值; 结构体的对齐值是其成员的最大对齐值; 编译器可以设置一个最大对齐值，类型的实际对齐值是该类型的对齐值与设置的对齐值取最小值得来。 结构体变量比较是否相等 重载==操作符 1 2 3 4 5 6 7 8 9 10 struct foo { int a; int b; bool operator==(const foo\u0026 rhs) const { return( a == rhs.a) \u0026\u0026 (b == rhs.b); } }; 元素的话，一个个比；指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；函数调用过程栈的变化，返回值和参数变量哪个先入栈？ 调用方将函数的参数按照","date":"2024-01-13T21:52:56+08:00","objectID":"46664a202421df1ac6b80f7f377b151c_1","order":1,"summary":"首地址。2) 函数指针的声明方法函数返回值类型 (* 指针变量名) (函数参数列表);3) 两种方法赋值：指针名 = 函数名； 指针名 = \u0026函数名可以用于回调函数说一说你理解的内存对齐以及原因 分配内存的顺序是按照声明的顺序，不满对齐数则翻倍。 Linux默认以4字节对齐，可通过#pragma pack(n) 修改对齐字节数。 字节对齐后可以方便系统读取 对齐规则:基本类型的对齐值就是其sizeof值; 结构体的对齐值是其成员的最大对齐值; 编译器可以设置一个最大对齐值，类型的实际对齐值是该类型的对齐值与设置的对齐值取最小值得来。 结构体变量比较是否相等 重载==操作符 1 2 3 4 5 6 7 8 9 10 struct foo { int a; int b; bool operator==(const foo\u0026 rhs) const { return( a == rhs.a) \u0026\u0026 (b == rhs.b); } }; 元素的话，一个个比；指针直接比较，如果保存的是同一个实例地址，则(p1==p2)为真；函数调用过程栈的变化，返回值和参数变量哪个先入栈？ 调用方将函数的参数按照","tags":["Interview"],"title":"面试之CPP基础知识-5","url":"http://localhost:1313/posts/other/interview-basic-cpp-5/"},{"categories":["other"],"content":"从右到左的顺序压入栈中。再将函数的返回地址压入栈中。 调用方执行函数调用指令，将控制权转移到被调用函数。 被调用函数为局部变量分配内存，并将它们按照定义顺序压入栈中。 被调用函数执行完毕后，将返回值存储在约定的位置。 被调用函数弹出栈中数据，直到弹出返回地址，然后跳回调用方的代码处。 调用方从约定处取回返回值（如果有的话）。 from GPTdefine、const、typedef、inline的使用方法？他们之间有什么区别？ 宏定义 typedef const inline 宏定义，相当于字符替换 定义类型别名 变量不能修改 调用处字符替换 预处理阶段 编译阶段 编译阶段 编译阶段 无类型安全检查 有类型安全检查 有 有 不是语句 是语句加分号 分配内存 分配内存 无 有返回值 #define p_int int * 显示 int*typedef int *p_int; 显示p_int你知道printf函数的实现原理是什么吗？ C/C++的函数参数是通过压入栈的方式来给函数传参数的，并且从右到左入栈。printf第一个被找到的参数就是那个字符串指针，函数通过判断字符串里控制参数的个数","date":"2024-01-13T21:52:56+08:00","objectID":"46664a202421df1ac6b80f7f377b151c_2","order":2,"summary":"从右到左的顺序压入栈中。再将函数的返回地址压入栈中。 调用方执行函数调用指令，将控制权转移到被调用函数。 被调用函数为局部变量分配内存，并将它们按照定义顺序压入栈中。 被调用函数执行完毕后，将返回值存储在约定的位置。 被调用函数弹出栈中数据，直到弹出返回地址，然后跳回调用方的代码处。 调用方从约定处取回返回值（如果有的话）。 from GPTdefine、const、typedef、inline的使用方法？他们之间有什么区别？ 宏定义 typedef const inline 宏定义，相当于字符替换 定义类型别名 变量不能修改 调用处字符替换 预处理阶段 编译阶段 编译阶段 编译阶段 无类型安全检查 有类型安全检查 有 有 不是语句 是语句加分号 分配内存 分配内存 无 有返回值 #define p_int int * 显示 int*typedef int *p_int; 显示p_int你知道printf函数的实现原理是什么吗？ C/C++的函数参数是通过压入栈的方式来给函数传参数的，并且从右到左入栈。printf第一个被找到的参数就是那个字符串指针，函数通过判断字符串里控制参数的个数","tags":["Interview"],"title":"面试之CPP基础知识-5","url":"http://localhost:1313/posts/other/interview-basic-cpp-5/"},{"categories":["other"],"content":"来判断参数个数及数据类型，通过这些算出数据需要的堆栈指针的偏移量，然后依次弹出数据进行填充。为什么模板类一般都是放在一个h文件中 将模板类的声明和定义放在头文件中是为了支持模板的编译和实例化，并提供更好的可读性和可维护性。from GPT模板定义很特殊。由template\u0026lt;…\u003e处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。 所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。 所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是","date":"2024-01-13T21:52:56+08:00","objectID":"46664a202421df1ac6b80f7f377b151c_3","order":3,"summary":"来判断参数个数及数据类型，通过这些算出数据需要的堆栈指针的偏移量，然后依次弹出数据进行填充。为什么模板类一般都是放在一个h文件中 将模板类的声明和定义放在头文件中是为了支持模板的编译和实例化，并提供更好的可读性和可维护性。from GPT模板定义很特殊。由template\u0026lt;…\u003e处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。 所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来。 所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是","tags":["Interview"],"title":"面试之CPP基础知识-5","url":"http://localhost:1313/posts/other/interview-basic-cpp-5/"},{"categories":["other"],"content":"连接器也黔驴技穷了。cout和printf有什么区别？ 语法和用法： cout 是 C++ 中的输出流对象，可以使用流操作符 \u0026lt;\u0026lt; 来输出各种类型的数据。例如：cout \u0026lt;\u0026lt; \"Hello, World!\"。 printf 是 C语言中的函数，它使用格式化字符串来输出数据。例如：printf(\"Hello, World!\")。 处理数据类型的方式： cout 能够自动推断输出对象的数据类型，并自动调用适当的输出运算符来进行输出。因此，它可以直接输出各种类型的数据，包括整数、浮点数、字符、字符串等。 printf 需要使用格式化字符串来指定输出的数据类型和格式，如 %d 表示整数，%f 表示浮点数，%c 表示字符等。 错误处理和安全： cout 具有更好的错误处理机制，它提供了许多重载的输出运算符，可以检查输出操作是否成功，并能够自动刷新输出缓冲区。 printf 通常直接将数据写入输出缓冲区，如果需要手动刷新缓冲区，或者在输出过程中进行错误处理，可以使用相关的库函数来实现。 标准库支持： cout 是 C++ 标准库的一部分，它提供了丰富的功能和灵活性，可以与其","date":"2024-01-13T21:52:56+08:00","objectID":"46664a202421df1ac6b80f7f377b151c_4","order":4,"summary":"连接器也黔驴技穷了。cout和printf有什么区别？ 语法和用法： cout 是 C++ 中的输出流对象，可以使用流操作符 \u0026lt;\u0026lt; 来输出各种类型的数据。例如：cout \u0026lt;\u0026lt; \"Hello, World!\"。 printf 是 C语言中的函数，它使用格式化字符串来输出数据。例如：printf(\"Hello, World!\")。 处理数据类型的方式： cout 能够自动推断输出对象的数据类型，并自动调用适当的输出运算符来进行输出。因此，它可以直接输出各种类型的数据，包括整数、浮点数、字符、字符串等。 printf 需要使用格式化字符串来指定输出的数据类型和格式，如 %d 表示整数，%f 表示浮点数，%c 表示字符等。 错误处理和安全： cout 具有更好的错误处理机制，它提供了许多重载的输出运算符，可以检查输出操作是否成功，并能够自动刷新输出缓冲区。 printf 通常直接将数据写入输出缓冲区，如果需要手动刷新缓冲区，或者在输出过程中进行错误处理，可以使用相关的库函数来实现。 标准库支持： cout 是 C++ 标准库的一部分，它提供了丰富的功能和灵活性，可以与其","tags":["Interview"],"title":"面试之CPP基础知识-5","url":"http://localhost:1313/posts/other/interview-basic-cpp-5/"},{"categories":["other"],"content":"他标准库函数和类一起使用。 printf 是 C语言的标准库函数，它提供了一定的灵活性和功能，但相对于 cout 而言，它的功能相对较简单，且通常不与其他标准库函数和类一起使用。 你知道重载运算符吗？ 重载运算符是指在类中重新定义标准运算符的行为。通过重载运算符，可以使得类对象可以像内置类型一样进行运算操作，使得代码更加直观和易于理解。只能重载已有的运算符；并且符合其运算含义。如+-/*，\u003e\u0026lt;=，++/-- balabala 当程序中有函数重载时，函数的匹配原则和顺序是什么？ 匹配原则Best_viable_function根据函数名选定候选函数 其声明在调用处可见 根据实参选定可行函数 形参数量和实参一致 形参和实参类型相同，或能转换 根据匹配规则寻找最佳匹配 参数类型和个数完全一致 底层const转化 类型提升 算数类型转换 类类型转换 按顺序进行依次匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void f(int *a) { cout \u0026lt;\u0026lt; \"const1\" \u0026lt;\u0026lt; endl; } // redefinit","date":"2024-01-13T21:52:56+08:00","objectID":"46664a202421df1ac6b80f7f377b151c_5","order":5,"summary":"他标准库函数和类一起使用。 printf 是 C语言的标准库函数，它提供了一定的灵活性和功能，但相对于 cout 而言，它的功能相对较简单，且通常不与其他标准库函数和类一起使用。 你知道重载运算符吗？ 重载运算符是指在类中重新定义标准运算符的行为。通过重载运算符，可以使得类对象可以像内置类型一样进行运算操作，使得代码更加直观和易于理解。只能重载已有的运算符；并且符合其运算含义。如+-/*，\u003e\u0026lt;=，++/-- balabala 当程序中有函数重载时，函数的匹配原则和顺序是什么？ 匹配原则Best_viable_function根据函数名选定候选函数 其声明在调用处可见 根据实参选定可行函数 形参数量和实参一致 形参和实参类型相同，或能转换 根据匹配规则寻找最佳匹配 参数类型和个数完全一致 底层const转化 类型提升 算数类型转换 类类型转换 按顺序进行依次匹配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void f(int *a) { cout \u0026lt;\u0026lt; \"const1\" \u0026lt;\u0026lt; endl; } // redefinit","tags":["Interview"],"title":"面试之CPP基础知识-5","url":"http://localhost:1313/posts/other/interview-basic-cpp-5/"},{"categories":["other"],"content":"ion of ‘void f(int*)’ // 形参只是临时量，调用结束就被销毁，所以是否是常量不会影响实参，可以搜索形参为什么忽略顶层const // void f(int *const a) { cout \u0026lt;\u0026lt; \"const2\" \u0026lt;\u0026lt; endl; } void f(const int *a) { cout \u0026lt;\u0026lt; \"const3\" \u0026lt;\u0026lt; endl; } int main(int argc, char *argv[]) { int b = 4; int *a1 = \u0026b; int *const a2 = \u0026b; const int *a3 = \u0026b; f(a1); // 1 f(a2); // 1 f(a3); // 3 return 0; } 定义和声明的区别 如果是指变量的声明和定义： 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。如果是指函数的声明和定义： 声明：一般在头文件里，只是让编译器知道这个函数的存在。 定义：一般在源文件里，存放函数的具体实现。全","date":"2024-01-13T21:52:56+08:00","objectID":"46664a202421df1ac6b80f7f377b151c_6","order":6,"summary":"ion of ‘void f(int*)’ // 形参只是临时量，调用结束就被销毁，所以是否是常量不会影响实参，可以搜索形参为什么忽略顶层const // void f(int *const a) { cout \u0026lt;\u0026lt; \"const2\" \u0026lt;\u0026lt; endl; } void f(const int *a) { cout \u0026lt;\u0026lt; \"const3\" \u0026lt;\u0026lt; endl; } int main(int argc, char *argv[]) { int b = 4; int *a1 = \u0026b; int *const a2 = \u0026b; const int *a3 = \u0026b; f(a1); // 1 f(a2); // 1 f(a3); // 3 return 0; } 定义和声明的区别 如果是指变量的声明和定义： 从编译原理上来说，声明是仅仅告诉编译器，有个某类型的变量会被使用，但是编译器并不会为它分配任何内存。而定义就是分配了内存。如果是指函数的声明和定义： 声明：一般在头文件里，只是让编译器知道这个函数的存在。 定义：一般在源文件里，存放函数的具体实现。全","tags":["Interview"],"title":"面试之CPP基础知识-5","url":"http://localhost:1313/posts/other/interview-basic-cpp-5/"},{"categories":["other"],"content":"局变量和static变量的区别 按存储区域分，全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。主要区别：按作用域分，全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量只在定义它的函数内有效。并且程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。https://blog.csdn.net/mm_hh/article/details/77126878static函数与普通函数有什么区别？static函数与普通的函数作用域不同。静态函数只在本文件内可使用，普通函数可以被其他文件共享static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。静态成员与普通成员的区别是什么？ 生命周期 静态成员变量存储在静态存储区，其生命周期和程序的生命周期一致；普通成员变量存储在堆或栈内，生命周期同创建的类的生命周期一致；共享方式 静态成员变量是全类共享；普通成员变量是每个对象单独享用的；初始化位置 普通成员变量在类中初始化；静态成员变量在类外初始化；说一下你理解的 ifdef e","date":"2024-01-13T21:52:56+08:00","objectID":"46664a202421df1ac6b80f7f377b151c_7","order":7,"summary":"局变量和static变量的区别 按存储区域分，全局变量、静态全局变量和静态局部变量都存放在内存的静态存储区域，局部变量存放在内存的栈区。主要区别：按作用域分，全局变量在整个工程文件内都有效；静态全局变量只在定义它的文件内有效；静态局部变量只在定义它的函数内有效。并且程序仅分配一次内存，函数返回后，该变量不会消失；局部变量在定义它的函数内有效，但是函数返回后失效。https://blog.csdn.net/mm_hh/article/details/77126878static函数与普通函数有什么区别？static函数与普通的函数作用域不同。静态函数只在本文件内可使用，普通函数可以被其他文件共享static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。静态成员与普通成员的区别是什么？ 生命周期 静态成员变量存储在静态存储区，其生命周期和程序的生命周期一致；普通成员变量存储在堆或栈内，生命周期同创建的类的生命周期一致；共享方式 静态成员变量是全类共享；普通成员变量是每个对象单独享用的；初始化位置 普通成员变量在类中初始化；静态成员变量在类外初始化；说一下你理解的 ifdef e","tags":["Interview"],"title":"面试之CPP基础知识-5","url":"http://localhost:1313/posts/other/interview-basic-cpp-5/"},{"categories":["other"],"content":"ndif代表着什么？ 指的是条件编译，它让程序满足一定的条件下才会编译该代码段，否则不编译或者编译另一个代码段。条件编译命令最常见的形式为：1 2 3 4 5 #ifdef 标识符 程序段1 #else 程序段2 #endif 它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。在头文件使用，可以避免“重定义”错误。 隐式转换，如何消除隐式转换？ 隐式转换分为标准转换，用户自定义转换。标准准换即编译器内置的转换规则，如整数类型提升，数组退化成指针等。用户自定义转换包括转换构造函数，用于将其他类型转换为本类型，或者是自定义转换函数，用于将本类型转换为其他类型。1 2 3 4 5 6 7 8 9 10 11 struct A {}; struct B { // 转换构造函数 B(int); B(const A\u0026); // 用户定义转换函数，不需要显式指定返回值 operator A(); operator int(); } 对于需要进行隐式转换的上下文，编译器会生成一个隐式转换序列：零个或一个由标准转换规则组成的标准转换序列，叫做初始","date":"2024-01-13T21:52:56+08:00","objectID":"46664a202421df1ac6b80f7f377b151c_8","order":8,"summary":"ndif代表着什么？ 指的是条件编译，它让程序满足一定的条件下才会编译该代码段，否则不编译或者编译另一个代码段。条件编译命令最常见的形式为：1 2 3 4 5 #ifdef 标识符 程序段1 #else 程序段2 #endif 它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2。在头文件使用，可以避免“重定义”错误。 隐式转换，如何消除隐式转换？ 隐式转换分为标准转换，用户自定义转换。标准准换即编译器内置的转换规则，如整数类型提升，数组退化成指针等。用户自定义转换包括转换构造函数，用于将其他类型转换为本类型，或者是自定义转换函数，用于将本类型转换为其他类型。1 2 3 4 5 6 7 8 9 10 11 struct A {}; struct B { // 转换构造函数 B(int); B(const A\u0026); // 用户定义转换函数，不需要显式指定返回值 operator A(); operator int(); } 对于需要进行隐式转换的上下文，编译器会生成一个隐式转换序列：零个或一个由标准转换规则组成的标准转换序列，叫做初始","tags":["Interview"],"title":"面试之CPP基础知识-5","url":"http://localhost:1313/posts/other/interview-basic-cpp-5/"},{"categories":["other"],"content":"C++中有几种类型的new 在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new（1）plain new 如果分配空间失败，会抛出异常std::bad_alloc。 定义如下：1 2 void* operator new(std::size_t) throw(std::bad_alloc); void operator delete(void *) throw(); 例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u003e #include \u0026lt;string\u003e using namespace std; int main() { try { char *p = new char[10e11]; delete p; } catch (const std::bad_alloc \u0026ex) { cout \u0026lt;\u0026lt; ex.what() \u0026lt;\u0026lt; endl; } return 0; } //执行结果：bad allocation （2）nothr","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_0","order":0,"summary":"C++中有几种类型的new 在C++中，new有三种典型的使用方法：plain new，nothrow new和placement new（1）plain new 如果分配空间失败，会抛出异常std::bad_alloc。 定义如下：1 2 void* operator new(std::size_t) throw(std::bad_alloc); void operator delete(void *) throw(); 例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u003e #include \u0026lt;string\u003e using namespace std; int main() { try { char *p = new char[10e11]; delete p; } catch (const std::bad_alloc \u0026ex) { cout \u0026lt;\u0026lt; ex.what() \u0026lt;\u0026lt; endl; } return 0; } //执行结果：bad allocation （2）nothr","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"ow newnothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：1 2 void * operator new(std::size_t,const std::nothrow_t\u0026) throw(); void operator delete(void*) throw(); 举个例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u003e #include \u0026lt;string\u003e using namespace std; int main() { char *p = new(nothrow) char[10e11]; if (p == NULL) { cout \u0026lt;\u0026lt; \"alloc failed\" \u0026lt;\u0026lt; endl; } delete p; return 0; } //运行结果：alloc failed （3）placement new这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_1","order":1,"summary":"ow newnothrow new在空间分配失败的情况下是不抛出异常，而是返回NULL，定义如下：1 2 void * operator new(std::size_t,const std::nothrow_t\u0026) throw(); void operator delete(void*) throw(); 举个例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u003e #include \u0026lt;string\u003e using namespace std; int main() { char *p = new(nothrow) char[10e11]; if (p == NULL) { cout \u0026lt;\u0026lt; \"alloc failed\" \u0026lt;\u0026lt; endl; } delete p; return 0; } //运行结果：alloc failed （3）placement new这种new允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"唯一一件事情就是调用对象的构造函数。定义如下：1 2 void* operator new(size_t,void*); void operator delete(void*,void*); 使用placement new需要注意两点：palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。举个例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u003e #include \u0026lt;string\u003e using namespace std; class ADT{ int i; int j; publi","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_2","order":2,"summary":"唯一一件事情就是调用对象的构造函数。定义如下：1 2 void* operator new(size_t,void*); void operator delete(void*,void*); 使用placement new需要注意两点：palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。举个例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u003e #include \u0026lt;string\u003e using namespace std; class ADT{ int i; int j; publi","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"c: ADT(){ i = 10; j = 100; cout \u0026lt;\u0026lt; \"ADT construct i=\" \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \"j=\"\u0026lt;\u0026lt;j \u0026lt;\u0026lt;endl; } ~ADT(){ cout \u0026lt;\u0026lt; \"ADT destruct\" \u0026lt;\u0026lt; endl; } }; int main() { char *p = new(nothrow) char[sizeof ADT + 1]; if (p == NULL) { cout \u0026lt;\u0026lt; \"alloc failed\" \u0026lt;\u0026lt; endl; } ADT *q = new(p) ADT; //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可 //delete q;//错误!不能在此处调用delete q; q-\u003eADT::~ADT();//显示调用析构函数 delete[] p; return 0; } //输出结果： //ADT construct i=10j=100 //ADT destruct C++的异常处理的方法 通过在","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_3","order":3,"summary":"c: ADT(){ i = 10; j = 100; cout \u0026lt;\u0026lt; \"ADT construct i=\" \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \"j=\"\u0026lt;\u0026lt;j \u0026lt;\u0026lt;endl; } ~ADT(){ cout \u0026lt;\u0026lt; \"ADT destruct\" \u0026lt;\u0026lt; endl; } }; int main() { char *p = new(nothrow) char[sizeof ADT + 1]; if (p == NULL) { cout \u0026lt;\u0026lt; \"alloc failed\" \u0026lt;\u0026lt; endl; } ADT *q = new(p) ADT; //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可 //delete q;//错误!不能在此处调用delete q; q-\u003eADT::~ADT();//显示调用析构函数 delete[] p; return 0; } //输出结果： //ADT construct i=10j=100 //ADT destruct C++的异常处理的方法 通过在","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"代码中使用 try-catch 块，程序可以在遇到异常时跳转到异常处理代码。避免程序崩溃和数据损坏。 使程序的调试和维护更加容易。 提高代码的可读性和可维护性。 https://www.zhihu.com/tardis/zm/art/610549350?source_id=1003在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：数组下标越界 除法计算时除数为0 动态分配空间时空间不足 ... 如果不及时对这些异常进行处理，程序多数情况下都会崩溃。（1）try、throw和catch关键字C++中的异常处理机制主要使用try、throw和catch三个关键字，其在程序中的用法如下：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u003e using namespace std; int main() { double m = 1, n = 0; try { cout \u0026lt;\u0026lt;","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_4","order":4,"summary":"代码中使用 try-catch 块，程序可以在遇到异常时跳转到异常处理代码。避免程序崩溃和数据损坏。 使程序的调试和维护更加容易。 提高代码的可读性和可维护性。 https://www.zhihu.com/tardis/zm/art/610549350?source_id=1003在程序执行过程中，由于程序员的疏忽或是系统资源紧张等因素都有可能导致异常，任何程序都无法保证绝对的稳定，常见的异常有：数组下标越界 除法计算时除数为0 动态分配空间时空间不足 ... 如果不及时对这些异常进行处理，程序多数情况下都会崩溃。（1）try、throw和catch关键字C++中的异常处理机制主要使用try、throw和catch三个关键字，其在程序中的用法如下：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u003e using namespace std; int main() { double m = 1, n = 0; try { cout \u0026lt;\u0026lt;","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":" \"before dividing.\" \u0026lt;\u0026lt; endl; if (n == 0) throw - 1; //抛出int型异常 else if (m == 0) throw - 1.0; //拋出 double 型异常 else cout \u0026lt;\u0026lt; m / n \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \"after dividing.\" \u0026lt;\u0026lt; endl; } catch (double d) { cout \u0026lt;\u0026lt; \"catch (double)\" \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; } catch (...) { cout \u0026lt;\u0026lt; \"catch (...)\" \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \"finished\" \u0026lt;\u0026lt; endl; return 0; } //运行结果 //before dividing. //catch (...) //finished 代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_5","order":5,"summary":" \"before dividing.\" \u0026lt;\u0026lt; endl; if (n == 0) throw - 1; //抛出int型异常 else if (m == 0) throw - 1.0; //拋出 double 型异常 else cout \u0026lt;\u0026lt; m / n \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \"after dividing.\" \u0026lt;\u0026lt; endl; } catch (double d) { cout \u0026lt;\u0026lt; \"catch (double)\" \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl; } catch (...) { cout \u0026lt;\u0026lt; \"catch (...)\" \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; \"finished\" \u0026lt;\u0026lt; endl; return 0; } //运行结果 //before dividing. //catch (...) //finished 代码中，对两个数进行除法计算，其中除数为0。可以看到以上三个关键字，程序的执行流程是先执行try包裹的语句块，如","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。 当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。（注意，匹配不是最佳匹配，如果基类异常在派生类异常之前，则会一直匹配基类异常）（2）函数的异常声明列表有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：1 int fun() throw(int,double,A,B,C){...}; 这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常（3）C++标准异常类 exceptionC","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_6","order":6,"summary":"果执行过程中没有异常发生，则不会进入任何catch包裹的语句块，如果发生异常，则使用throw进行异常抛出，再由catch进行捕获，throw可以抛出各种数据类型的信息，代码中使用的是数字，也可以自定义异常class。catch根据throw抛出的数据类型进行精确捕获（不会出现类型转换），如果匹配不到就直接报错，可以使用catch(...)的方式捕获任何异常（不推荐）。 当然，如果catch了异常，当前函数如果不进行处理，或者已经处理了想通知上一层的调用者，可以在catch里面再throw异常。（注意，匹配不是最佳匹配，如果基类异常在派生类异常之前，则会一直匹配基类异常）（2）函数的异常声明列表有时候，程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常的列表，写法如下：1 int fun() throw(int,double,A,B,C){...}; 这种写法表名函数可能会抛出int,double型或者A、B、C三种类型的异常，如果throw中为空，表明不会抛出任何异常，如果没有throw则可能抛出任何异常（3）C++标准异常类 exceptionC","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u003e #include \u0026lt;typeinfo\u003e using namespace std; class A{ public: virtual ~A(); }; using namespace std; int main() { A* a = NULL; try { cout \u0026lt;\u0026lt; typeid(*a).name() \u0026lt;\u0026lt; endl; // Error condition } catch (bad_typeid){ cout \u0026lt;\u0026lt; \"Object is NULL\" \u0026lt;\u0026lt; endl; } return 0; } //运行结果：bject is NULL bad_cast：在用 dy","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_7","order":7,"summary":"++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的，如下图所示bad_typeid：使用typeid运算符，如果其操作数是一个多态类的指针，而该指针的值为 NULL，则会拋出此异常，例如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u003e #include \u0026lt;typeinfo\u003e using namespace std; class A{ public: virtual ~A(); }; using namespace std; int main() { A* a = NULL; try { cout \u0026lt;\u0026lt; typeid(*a).name() \u0026lt;\u0026lt; endl; // Error condition } catch (bad_typeid){ cout \u0026lt;\u0026lt; \"Object is NULL\" \u0026lt;\u0026lt; endl; } return 0; } //运行结果：bject is NULL bad_cast：在用 dy","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"namic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常 bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常 out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常 形参与实参的区别？ 形参只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，实参应该具有确定的值， 以便把这些值传送给形参。实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。当形参和实参不是指针/引用类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_8","order":8,"summary":"namic_cast 进行从多态基类对象（或引用）到派生类的引用的强制类型转换时，如果转换是不安全的，则会拋出此异常 bad_alloc：在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常 out_of_range:用 vector 或 string的at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常 形参与实参的区别？ 形参只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。 函数调用结束返回主调函数后则不能再使用该形参变量。实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，实参应该具有确定的值， 以便把这些值传送给形参。实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。 因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。当形参和实参不是指针/引用类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。值传递、指针传递、引用传递的区别和效率 值传递：形参会拷贝整个实参，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）指针传递：形参会拷贝实参的地址。（传值，传递的是地址值）引用传递：形参等同于实参。（传地址）效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。静态变量什么时候初始化 静态局部变量和局部对象都在函数首次执行到对象定义时进行初始化； 全局变量和对象在程序启动时进行初始化。什么是类的继承？ 类与类之间的关系 has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性，即一个类的成员属性是另一个已经定义好的类；use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；is-A，继承关系，关系具有传递性；子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；从汇编层去解释一下引用 1 2 3 4 5 6 7 8 9 9: int x ","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_9","order":9,"summary":"参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。值传递、指针传递、引用传递的区别和效率 值传递：形参会拷贝整个实参，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）指针传递：形参会拷贝实参的地址。（传值，传递的是地址值）引用传递：形参等同于实参。（传地址）效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。静态变量什么时候初始化 静态局部变量和局部对象都在函数首次执行到对象定义时进行初始化； 全局变量和对象在程序启动时进行初始化。什么是类的继承？ 类与类之间的关系 has-A包含关系，用以描述一个类由多个部件类构成，实现has-A关系用类的成员属性，即一个类的成员属性是另一个已经定义好的类；use-A，一个类使用另一个类，通过类之间的成员函数相互联系，定义友元或者通过传递参数的方式来实现；is-A，继承关系，关系具有传递性；子类拥有父类的所有属性和方法，子类可以拥有父类没有的属性和方法，子类对象可以当做父类对象使用；从汇编层去解释一下引用 1 2 3 4 5 6 7 8 9 9: int x ","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"= 1; 00401048 mov dword ptr [ebp-4],1 10: int \u0026b = x; 0040104F lea eax,[ebp-4] 00401052 mov dword ptr [ebp-8],eax x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。delete p、delete [] p、allocator都有什么作用？ delete p：用于释放使用new运算符动态分配的单个对象的内存。delete p会调用对象的析构函数，并释放对象占用的内存。 delete [] p：用于释放使用new[]运算符动态分配的数组的内存。delete [] p会按照数组元素的逆序调用每个元素的析构函数，并释放数","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_10","order":10,"summary":"= 1; 00401048 mov dword ptr [ebp-4],1 10: int \u0026b = x; 0040104F lea eax,[ebp-4] 00401052 mov dword ptr [ebp-8],eax x的地址为ebp-4，b的地址为ebp-8，因为栈内的变量内存是从高往低进行分配的，所以b的地址比x的低。lea eax,[ebp-4] 这条语句将x的地址ebp-4放入eax寄存器mov dword ptr [ebp-8],eax 这条语句将eax的值放入b的地址ebp-8中上面两条汇编的作用即：将x的地址存入变量b中，这不和将某个变量的地址存入指针变量是一样的吗？所以从汇编层次来看，的确引用是通过指针来实现的。delete p、delete [] p、allocator都有什么作用？ delete p：用于释放使用new运算符动态分配的单个对象的内存。delete p会调用对象的析构函数，并释放对象占用的内存。 delete [] p：用于释放使用new[]运算符动态分配的数组的内存。delete [] p会按照数组元素的逆序调用每个元素的析构函数，并释放数","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"组占用的内存。 allocator：是C++标准库中的一个类模板，用于动态分配和释放内存，可以用于分配单个对象或数组。 new和delete的实现原理， delete是如何知道释放内存的大小的？ new先调用operator new分配内存，然后调用构造函数初始化内存，返回该内存的指针 delete先调用析构函数再调用operator delete释放指针指向的内存 new[]先调用operator new[]分配内存，然后在内存块的首地址放入数组大小，然后依次调用数组元素的构造函数来初始化每个对象，返回该内存的指针。 delete[]获得内存首地址的数组大小，调用析构函数后，再调用operator delete 释放内存。 https://blog.csdn.net/passion_wu128/article/details/38966581malloc申请的存储空间能用delete释放吗? 混合使用malloc和delete会导致未定义的行为，可能引发内存泄漏或其他问题。建议malloc配套free使用。malloc与free的实现原理？ malloc的实现原理：malloc函数通","date":"2024-01-13T21:52:47+08:00","objectID":"83f8559cdf609f81df05d0c3062fd436_11","order":11,"summary":"组占用的内存。 allocator：是C++标准库中的一个类模板，用于动态分配和释放内存，可以用于分配单个对象或数组。 new和delete的实现原理， delete是如何知道释放内存的大小的？ new先调用operator new分配内存，然后调用构造函数初始化内存，返回该内存的指针 delete先调用析构函数再调用operator delete释放指针指向的内存 new[]先调用operator new[]分配内存，然后在内存块的首地址放入数组大小，然后依次调用数组元素的构造函数来初始化每个对象，返回该内存的指针。 delete[]获得内存首地址的数组大小，调用析构函数后，再调用operator delete 释放内存。 https://blog.csdn.net/passion_wu128/article/details/38966581malloc申请的存储空间能用delete释放吗? 混合使用malloc和delete会导致未定义的行为，可能引发内存泄漏或其他问题。建议malloc配套free使用。malloc与free的实现原理？ malloc的实现原理：malloc函数通","tags":["Interview"],"title":"面试之CPP基础知识-3","url":"http://localhost:1313/posts/other/interview-basic-cpp-3/"},{"categories":["other"],"content":"什么是内存泄露，如何检测与避免 内存泄露用new/malloc申请了内存，但是没有用delete/free释放内存。而其他程序就无法再申请该块空间避免内存泄露的几种方式使用shared_ptr管理对象。 将基类的析构函数声明为虚函数 对象数组的释放用delete [] 有new就有delete，有malloc就有free，保证它们一定成对出现 检测工具Linux下可以使用Valgrind工具 Windows下可以使用CRT库 对象复用的了解，零拷贝的了解 对象复用对象复用其本质是一种设计模式：Flyweight享元模式。通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。零拷贝零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。零拷贝技术可以减少数据拷贝和共享总线操作的次数。在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用empla","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_0","order":0,"summary":"什么是内存泄露，如何检测与避免 内存泄露用new/malloc申请了内存，但是没有用delete/free释放内存。而其他程序就无法再申请该块空间避免内存泄露的几种方式使用shared_ptr管理对象。 将基类的析构函数声明为虚函数 对象数组的释放用delete [] 有new就有delete，有malloc就有free，保证它们一定成对出现 检测工具Linux下可以使用Valgrind工具 Windows下可以使用CRT库 对象复用的了解，零拷贝的了解 对象复用对象复用其本质是一种设计模式：Flyweight享元模式。通过将对象存储到“对象池”中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。零拷贝零拷贝就是一种避免 CPU 将数据从一块存储拷贝到另外一块存储的技术。零拷贝技术可以减少数据拷贝和共享总线操作的次数。在C++中，vector的一个成员函数**emplace_back()**很好地体现了零拷贝技术，它跟push_back()函数一样可以将一个元素插入容器尾部，区别在于：使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用empla","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"ce_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高。举个例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;vector\u003e #include \u0026lt;string\u003e #include \u0026lt;iostream\u003e using namespace std; struct Person { string name; int age; //初始构造函数 Person(string p_name, int p_age): name(std::move(p_name)), age(p_age) { cout \u0026lt;\u0026lt; \"I have been constructed\" \u0026lt;\u0026lt;endl; } //拷贝构造函数 Person(const Person\u0026 other): name(std::move(other.name)), age(othe","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_1","order":1,"summary":"ce_back()插入的元素原地构造，不需要触发拷贝构造和转移构造，效率更高。举个例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;vector\u003e #include \u0026lt;string\u003e #include \u0026lt;iostream\u003e using namespace std; struct Person { string name; int age; //初始构造函数 Person(string p_name, int p_age): name(std::move(p_name)), age(p_age) { cout \u0026lt;\u0026lt; \"I have been constructed\" \u0026lt;\u0026lt;endl; } //拷贝构造函数 Person(const Person\u0026 other): name(std::move(other.name)), age(othe","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"r.age) { cout \u0026lt;\u0026lt; \"I have been copy constructed\" \u0026lt;\u0026lt;endl; } //转移构造函数 Person(Person\u0026\u0026 other): name(std::move(other.name)), age(other.age) { cout \u0026lt;\u0026lt; \"I have been moved\"\u0026lt;\u0026lt;endl; } }; int main() { vector\u0026lt;Person\u003e e; cout \u0026lt;\u0026lt; \"emplace_back:\" \u0026lt;\u0026lt;endl; e.emplace_back(\"Jane\", 23); //不用构造类对象 vector\u0026lt;Person\u003e p; cout \u0026lt;\u0026lt; \"push_back:\"\u0026lt;\u0026lt;endl; p.push_back(Person(\"Mike\",36)); return 0; } //输出结果： //emplace_back: //I have been constructed //push_back: //I have been c","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_2","order":2,"summary":"r.age) { cout \u0026lt;\u0026lt; \"I have been copy constructed\" \u0026lt;\u0026lt;endl; } //转移构造函数 Person(Person\u0026\u0026 other): name(std::move(other.name)), age(other.age) { cout \u0026lt;\u0026lt; \"I have been moved\"\u0026lt;\u0026lt;endl; } }; int main() { vector\u0026lt;Person\u003e e; cout \u0026lt;\u0026lt; \"emplace_back:\" \u0026lt;\u0026lt;endl; e.emplace_back(\"Jane\", 23); //不用构造类对象 vector\u0026lt;Person\u003e p; cout \u0026lt;\u0026lt; \"push_back:\"\u0026lt;\u0026lt;endl; p.push_back(Person(\"Mike\",36)); return 0; } //输出结果： //emplace_back: //I have been constructed //push_back: //I have been c","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"onstructed //I am being moved. 介绍面向对象的三大特性，并且举例说明 三大特性：封装 继承 多态（1）继承让派生类获得基类的属性和方法。它可以使用现有类的所有功能，并在类中对这些功能进行扩展例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法（2）封装封装，也就是把客观事物封装成抽象的类，并且给类的属性和方法设置访问权限，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。（3）多态同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为**（重载实现编译时多态，虚函数实现运行时多态）** 。允许将子类类型的指针赋值给父类类型的指针实现多态有二种方式：覆盖（override），重载（overload）。覆盖：是指子类重新定义父类的虚函数的做法。重载：是指允许存在多个同名函数，而这些函数的参数类型不同或者个数不同。C++的四种强制转换 MS","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_3","order":3,"summary":"onstructed //I am being moved. 介绍面向对象的三大特性，并且举例说明 三大特性：封装 继承 多态（1）继承让派生类获得基类的属性和方法。它可以使用现有类的所有功能，并在类中对这些功能进行扩展例如，将人定义为一个抽象类，拥有姓名、性别、年龄等公共属性，吃饭、睡觉、走路等公共方法，在定义一个具体的人时，就可以继承这个抽象类，既保留了公共属性和方法，也可以在此基础上扩展跳舞、唱歌等特有方法（2）封装封装，也就是把客观事物封装成抽象的类，并且给类的属性和方法设置访问权限，例如：将公共的数据或方法使用public修饰，而不希望被访问的数据或方法采用private修饰。（3）多态同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为**（重载实现编译时多态，虚函数实现运行时多态）** 。允许将子类类型的指针赋值给父类类型的指针实现多态有二种方式：覆盖（override），重载（overload）。覆盖：是指子类重新定义父类的虚函数的做法。重载：是指允许存在多个同名函数，而这些函数的参数类型不同或者个数不同。C++的四种强制转换 MS","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"DN . 强制转换运算符static_cast dynamic_cast const_cast reinterpret_cast 一般用于数值转换 用于指针和引用 删除const特性 指针间转换 不执行运行时类型检查 执行检查 删除volatile特性 整数类型转指针 类指针可以向上转换 向上/下转换 不能用于函数指针 指针转整数类型 不安全 转换失败返回null 不安全 C++函数调用的压栈过程 跳过。从代码入手，解释这个过程：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u003e using namespace std; int f(int n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return n; } void func(int param1, int param2) { int var1 = param1; int var2 = param2; printf(\"var1=%d,var2=%d\", f(var1), f(var2","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_4","order":4,"summary":"DN . 强制转换运算符static_cast dynamic_cast const_cast reinterpret_cast 一般用于数值转换 用于指针和引用 删除const特性 指针间转换 不执行运行时类型检查 执行检查 删除volatile特性 整数类型转指针 类指针可以向上转换 向上/下转换 不能用于函数指针 指针转整数类型 不安全 转换失败返回null 不安全 C++函数调用的压栈过程 跳过。从代码入手，解释这个过程：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u003e using namespace std; int f(int n) { cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return n; } void func(int param1, int param2) { int var1 = param1; int var2 = param2; printf(\"var1=%d,var2=%d\", f(var1), f(var2","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"));//如果将printf换为cout进行输出，输出结果则刚好相反 } int main(int argc, char* argv[]) { func(1, 2); return 0; } //输出结果 //2 //1 //var1=1,var2=2 当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将f()的返回地址、函数的参数从右到左、定义变量依次压栈。从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。coredump 遇到过吗？怎么调试这个错误？ coredump是程序由于异常或者bug在运行时","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_5","order":5,"summary":"));//如果将printf换为cout进行输出，输出结果则刚好相反 } int main(int argc, char* argv[]) { func(1, 2); return 0; } //输出结果 //2 //1 //var1=1,var2=2 当函数从入口函数main函数开始执行时，编译器会将我们操作系统的运行状态，main函数的返回地址、main的参数、mian函数中的变量、进行依次压栈；当main函数开始调用func()函数时，编译器此时会将main函数的运行状态进行压栈，再将func()函数的返回地址、func()函数的参数从右到左、func()定义变量依次压栈；当func()调用f()的时候，编译器此时会将func()函数的运行状态进行压栈，再将f()的返回地址、函数的参数从右到左、定义变量依次压栈。从代码的输出结果可以看出，函数f(var1)、f(var2)依次入栈，而后先执行f(var2)，再执行f(var1)，最后打印整个字符串，将栈中的变量依次弹出，最后主函数返回。coredump 遇到过吗？怎么调试这个错误？ coredump是程序由于异常或者bug在运行时","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"异常退出或者终止，在一定的条件下生成的一个叫做core的文件，~~这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。~~对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。使用gdb命令对core文件进行调试gdb \u0026lt;可执行文件路径\u003e \u0026lt;core文件路径\u003e gdb 调试准备说说移动构造函数 移动构造函数使右值对象拥有的资源无需复制即可移动到左值中。可以搭配std::move将变量转为右值。C++中将临时变量作为返回值时的处理过程 临时变量在函数调用过程中是先被压到程序进程的栈中 当函数退出时，临时变量出栈，销毁临时变量，但是临时变量占用的内存空间没有被清空，可以被分配给其他变量 所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了 所以建议不再函数中返回局部变量。 硬要返回用new个局部指针并外部接受后再delete、声明为static、用全局变量（推荐）如何获得结构成员相对于结构开头的字节偏移量 使用\u0026lt;stddef.h\u003e头文件中的，offsetof宏。静态类型和动态类型，静态绑定和动态绑定的介绍 ","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_6","order":6,"summary":"异常退出或者终止，在一定的条件下生成的一个叫做core的文件，~~这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。~~对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。使用gdb命令对core文件进行调试gdb \u0026lt;可执行文件路径\u003e \u0026lt;core文件路径\u003e gdb 调试准备说说移动构造函数 移动构造函数使右值对象拥有的资源无需复制即可移动到左值中。可以搭配std::move将变量转为右值。C++中将临时变量作为返回值时的处理过程 临时变量在函数调用过程中是先被压到程序进程的栈中 当函数退出时，临时变量出栈，销毁临时变量，但是临时变量占用的内存空间没有被清空，可以被分配给其他变量 所以有可能在函数退出时，该内存已经被修改了，对于临时变量来说已经是没有意义的值了 所以建议不再函数中返回局部变量。 硬要返回用new个局部指针并外部接受后再delete、声明为static、用全局变量（推荐）如何获得结构成员相对于结构开头的字节偏移量 使用\u0026lt;stddef.h\u003e头文件中的，offsetof宏。静态类型和动态类型，静态绑定和动态绑定的介绍 ","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"静态类型：对象在声明时采用的类型，在编译期确定；动态类型：通常是指一个指针或引用，具体所指对象的类型，是在运行期决定的；静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；引用是否能实现动态绑定，为什么可以实现？ 可以。因为引用在运行期确定其指向的对象，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。举个例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u003e using namespace std; class Base { public: virtual void fun() { cout \u0026lt;\u0026lt; \"base :: fun()\" \u0026lt;\u0026lt; endl; } }; class Son : ","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_7","order":7,"summary":"静态类型：对象在声明时采用的类型，在编译期确定；动态类型：通常是指一个指针或引用，具体所指对象的类型，是在运行期决定的；静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定；引用是否能实现动态绑定，为什么可以实现？ 可以。因为引用在运行期确定其指向的对象，在访问虚函数时，编译器会根据其所绑定的对象类型决定要调用哪个函数。注意只能调用虚函数。举个例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u003e using namespace std; class Base { public: virtual void fun() { cout \u0026lt;\u0026lt; \"base :: fun()\" \u0026lt;\u0026lt; endl; } }; class Son : ","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"public Base { public: virtual void fun() { cout \u0026lt;\u0026lt; \"son :: fun()\" \u0026lt;\u0026lt; endl; } void func() { cout \u0026lt;\u0026lt; \"son :: not virtual function\" \u0026lt;\u0026lt;endl; } }; int main() { Son s; Base\u0026 b = s; // 基类类型引用绑定已经存在的Son对象，引用必须初始化 s.fun(); //son::fun() b.fun(); //son :: fun() return 0; } 需要说明的是虚函数才具有动态绑定，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。全局变量和局部变量有什么区别？ 生命周期不同：全局变量的生命周期跟主程序一样；局部变量的生命周期超出大括号就不存在了；全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。指针加减计算要注意什么？ 指针加减","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_8","order":8,"summary":"public Base { public: virtual void fun() { cout \u0026lt;\u0026lt; \"son :: fun()\" \u0026lt;\u0026lt; endl; } void func() { cout \u0026lt;\u0026lt; \"son :: not virtual function\" \u0026lt;\u0026lt;endl; } }; int main() { Son s; Base\u0026 b = s; // 基类类型引用绑定已经存在的Son对象，引用必须初始化 s.fun(); //son::fun() b.fun(); //son :: fun() return 0; } 需要说明的是虚函数才具有动态绑定，上面代码中，Son类中还有一个非虚函数func()，这在b对象中是无法调用的，如果使用基类指针来指向子类也是一样的。全局变量和局部变量有什么区别？ 生命周期不同：全局变量的生命周期跟主程序一样；局部变量的生命周期超出大括号就不存在了；全局变量保存在内存的全局存储区中，占用静态的存储单元；局部变量保存在栈中，只有在所在函数被调用时才动态地为变量分配存储单元。指针加减计算要注意什么？ 指针加减","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"本质是对其所指地址的移动，移动的步长跟指针的类型大小一致。遇到指针的计算，需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果怎样判断两个浮点数是否相等？ 两个浮点数比较只能通过相减取绝对值后与预先设定的精度比较。浮点数与0的比较也应该注意。这是计算机浮点数表示法精度导致的问题。 https://blog.csdn.net/bitekong/article/details/119933898方法调用的原理（栈，汇编） pass机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_9","order":9,"summary":"本质是对其所指地址的移动，移动的步长跟指针的类型大小一致。遇到指针的计算，需要明确的是指针每移动一位，它实际跨越的内存间隔是指针类型的长度，建议都转成10进制计算，计算结果除以类型长度取得结果怎样判断两个浮点数是否相等？ 两个浮点数比较只能通过相减取绝对值后与预先设定的精度比较。浮点数与0的比较也应该注意。这是计算机浮点数表示法精度导致的问题。 https://blog.csdn.net/bitekong/article/details/119933898方法调用的原理（栈，汇编） pass机器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈称为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始地址，一个标识着结束地址，两个指针结束地址指针esp，开始地址指针ebp;由一系列栈帧构成，这些栈帧对应一个过程，而且每一个栈指针+4的位置存储函数返回地址；每一个栈帧都建立在调用者的下方，当被调用者执行完毕时，这一段栈帧会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相当于给栈帧分配了一定空间的内存。如果","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。过程实现① 备份原来的帧指针，调整当前的栈帧指针到栈指针位置；② 建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；③ 使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。④ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了⑤ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。⑥ 释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。⑦ 恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。⑧ 弹出返回地址，跳出当前过程，继续执行调用者的代码。过程调用和返回指令 ① call指令② leave指令③ ret指令​C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？ 指针传递是将参数的内存地址传递给函数，需要使用","date":"2024-01-13T21:52:43+08:00","objectID":"4cb0c69c0d40d9750d78d908d8292abf_10","order":10,"summary":"将栈指针加上一定的值，也就是向上移动，那么就相当于压缩了栈帧的长度，也就是说内存被释放了。过程实现① 备份原来的帧指针，调整当前的栈帧指针到栈指针位置；② 建立起来的栈帧就是为被调用者准备的，当被调用者使用栈帧时，需要给临时变量分配预留内存；③ 使用建立好的栈帧，比如读取和写入，一般使用mov，push以及pop指令等等。④ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了⑤ 恢复被调用者寄存器当中的值，这一过程其实是从栈帧中将备份的值再恢复到寄存器，不过此时这些值可能已经不在栈顶了。⑥ 释放被调用者的栈帧，释放就意味着将栈指针加大，而具体的做法一般是直接将栈指针指向帧指针，因此会采用类似下面的汇编代码处理。⑦ 恢复调用者的栈帧，恢复其实就是调整栈帧两端，使得当前栈帧的区域又回到了原始的位置。⑧ 弹出返回地址，跳出当前过程，继续执行调用者的代码。过程调用和返回指令 ① call指令② leave指令③ ret指令​C++中的指针参数传递和引用参数传递有什么区别？底层原理你知道吗？ 指针传递是将参数的内存地址传递给函数，需要使用","tags":["Interview"],"title":"面试之CPP基础知识-4","url":"http://localhost:1313/posts/other/interview-basic-cpp-4/"},{"categories":["other"],"content":"struct和class的区别 相同点两者都拥有成员函数、公有和私有部分 任何可以使用struct完成的工作，同样可以使用class完成 不同点struct默认访问权限是public，class默认是private struct默认继承权限是public，class默认是private 引申：C++和C的struct区别C语言中：struct是用户自定义数据类型（UDT），只能是变量的集合体；C++中struct是抽象数据类型（ADT），是类的一种特例一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）；C++中结构体标记（结构体名）可以直接作为结构体类型名使用const和static的作用 static不考虑类的情况 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件中使用 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_0","order":0,"summary":"struct和class的区别 相同点两者都拥有成员函数、公有和私有部分 任何可以使用struct完成的工作，同样可以使用class完成 不同点struct默认访问权限是public，class默认是private struct默认继承权限是public，class默认是private 引申：C++和C的struct区别C语言中：struct是用户自定义数据类型（UDT），只能是变量的集合体；C++中struct是抽象数据类型（ADT），是类的一种特例一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）；C++中结构体标记（结构体名）可以直接作为结构体类型名使用const和static的作用 static不考虑类的情况 隐藏。所有不加static的全局变量和函数具有全局可见性，可以在其他文件中使用，加了之后只能在该文件中使用 默认初始化为0，包括未初始化的全局静态变量与局部静态变量，都存在全局未初始化区 静态变量在函数内定义，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，函数退出后仍然存","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"在，但不能使用 考虑类的情况 static成员变量：不能在类声明中初始化，必须在类外初始化，（初始化时不需要标示为static，只有static才能在类外初始化）；可以不创建对象直接使用，并且所有对象共享该变量。 static成员函数：不具有this指针，只能访问static修饰的变量和函数；不能被声明为const、volatile和虚函数 static修饰的成员可以被非static成员函数任意访问 const修饰的东西不能被修改不考虑类的情况const常量在定义时必须初始化，之后无法更改 修饰变量，说明该变量不可以被改变； 修饰指针，分为指针常量(pointer to const)和常量指针(const pointer)； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； const也能隐藏变量（再加extern就不能了）（vscode编译多个文件） 考虑类的情况const成员变量：最好通过构造函数初始化列表进行初始化，且初始化后不能修改。（不同类对象对其const数据成员的值可以不同，所以不建议在类中声明时初始化","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_1","order":1,"summary":"在，但不能使用 考虑类的情况 static成员变量：不能在类声明中初始化，必须在类外初始化，（初始化时不需要标示为static，只有static才能在类外初始化）；可以不创建对象直接使用，并且所有对象共享该变量。 static成员函数：不具有this指针，只能访问static修饰的变量和函数；不能被声明为const、volatile和虚函数 static修饰的成员可以被非static成员函数任意访问 const修饰的东西不能被修改不考虑类的情况const常量在定义时必须初始化，之后无法更改 修饰变量，说明该变量不可以被改变； 修饰指针，分为指针常量(pointer to const)和常量指针(const pointer)； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； const也能隐藏变量（再加extern就不能了）（vscode编译多个文件） 考虑类的情况const成员变量：最好通过构造函数初始化列表进行初始化，且初始化后不能修改。（不同类对象对其const数据成员的值可以不同，所以不建议在类中声明时初始化","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"） const成员函数：不可以改变非mutable数据的值。（const对象不可以调用非const成员函数；非const对象都可以调用；） 顶层const和底层const 概念区分顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边 底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边 举个例子1 2 3 4 5 int a = 10;int* const b1 = \u0026a; //顶层const，b1本身是一个常量 const int* b2 = \u0026a; //底层const，b2本身可变，所指的对象是常量 const int b3 = 20; //顶层const，b3是常量不可变 const int* const b4 = \u0026a; //前一个const为底层，后一个为顶层，b4不可变 const int\u0026 b5 = a;\t//用于声明引用变量，都是底层const 区分作用执行对象拷贝时，对象必须都具有底层const。 使用强制类型转换函数const_cast时，只能改变运算对象的底层const ","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_2","order":2,"summary":"） const成员函数：不可以改变非mutable数据的值。（const对象不可以调用非const成员函数；非const对象都可以调用；） 顶层const和底层const 概念区分顶层const：指的是const修饰的变量本身是一个常量，无法修改，指的是指针，就是 * 号的右边 底层const：指的是const修饰的变量所指向的对象是一个常量，指的是所指变量，就是 * 号的左边 举个例子1 2 3 4 5 int a = 10;int* const b1 = \u0026a; //顶层const，b1本身是一个常量 const int* b2 = \u0026a; //底层const，b2本身可变，所指的对象是常量 const int b3 = 20; //顶层const，b3是常量不可变 const int* const b4 = \u0026a; //前一个const为底层，后一个为顶层，b4不可变 const int\u0026 b5 = a;\t//用于声明引用变量，都是底层const 区分作用执行对象拷贝时，对象必须都具有底层const。 使用强制类型转换函数const_cast时，只能改变运算对象的底层const ","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"https://zhuanlan.zhihu.com/p/161560391 数组名和指针区别？ 二者均可通过增减偏移量来访问数组中的元素。数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。区别在于sizeof和\u0026假设一个数组int a[4];sizeof(数组)得到16，sizeof(指针)得到8对数组取地址必须用指向长度为4的数组的指针接受，而不是指向指针的指针。c中，数组名跟指针有区别吗？final和override关键字 overrideoverride指定了子类的这个函数是重写父类的虚函数，如果你名字不小心打错了的话，编译器是不会编译通过的。final当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。拷贝初始化和直接初始化 当用于类的对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_3","order":3,"summary":"https://zhuanlan.zhihu.com/p/161560391 数组名和指针区别？ 二者均可通过增减偏移量来访问数组中的元素。数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。区别在于sizeof和\u0026假设一个数组int a[4];sizeof(数组)得到16，sizeof(指针)得到8对数组取地址必须用指向长度为4的数组的指针接受，而不是指向指针的指针。c中，数组名跟指针有区别吗？final和override关键字 overrideoverride指定了子类的这个函数是重写父类的虚函数，如果你名字不小心打错了的话，编译器是不会编译通过的。final当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名和虚函数后添加final关键字，添加final关键字后被继承或重写，编译器会报错。拷贝初始化和直接初始化 当用于类的对象时，初始化的拷贝形式和直接形式有所不同：直接初始化直接调用与实参匹配的构造函数，拷贝初始化总","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下 1 2 3 4 string str1(\"I am a string\");//语句1 直接初始化 string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化 string str3 = \"I am a string\";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3 string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数 为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了（语句1和语句3等价），但是需要辨别两种情况。 当拷贝构造函数为private时：语句3和语句4在编译时会报错 使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错 初始化和赋值的区别 AKA拷贝初始","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_4","order":4,"summary":"是调用拷贝构造函数。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。举例如下 1 2 3 4 string str1(\"I am a string\");//语句1 直接初始化 string str2(str1);//语句2 直接初始化，str1是已经存在的对象，直接调用拷贝构造函数对str2进行初始化 string str3 = \"I am a string\";//语句3 拷贝初始化，先为字符串”I am a string“创建临时对象，再把临时对象作为参数，使用拷贝构造函数构造str3 string str4 = str1;//语句4 拷贝初始化，这里相当于隐式调用拷贝构造函数，而不是调用赋值运算符函数 为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了（语句1和语句3等价），但是需要辨别两种情况。 当拷贝构造函数为private时：语句3和语句4在编译时会报错 使用explicit修饰构造函数时：如果构造函数存在隐式转换，编译时会报错 初始化和赋值的区别 AKA拷贝初始","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"化和直接初始化extern\"C\"的用法 为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern \"C\"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；哪些情况下使用extern \"C\"：（1）C++代码中调用C语言代码；（2）在C++中的头文件中使用；（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；总结出如下形式：（1）C++调用C函数：1 2 3 4 5 6 7 8 9 //xx.h extern int add(){}; //xx.c int add(){ } //xx.cpp extern \"C\" { #include \"xx.h\" } （2）C调用C++函数1 2 3 4 5 6 7 8 9 //xx.h extern \"C\"{ int add(); } //xx.cpp int add(){ } //xx.c extern int add(); 野指针和悬空指针 都是是指向无效内存区域(这里的无效指的是\"不安全不可控\")的指针，访问行为将会导致未定义行为。野指针野指针，指的是没有被初始化过的指针。为了防止出错","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_5","order":5,"summary":"化和直接初始化extern\"C\"的用法 为了能够正确的在C++代码中调用C语言的代码：在程序中加上extern \"C\"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++；哪些情况下使用extern \"C\"：（1）C++代码中调用C语言代码；（2）在C++中的头文件中使用；（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；总结出如下形式：（1）C++调用C函数：1 2 3 4 5 6 7 8 9 //xx.h extern int add(){}; //xx.c int add(){ } //xx.cpp extern \"C\" { #include \"xx.h\" } （2）C调用C++函数1 2 3 4 5 6 7 8 9 //xx.h extern \"C\"{ int add(); } //xx.cpp int add(){ } //xx.c extern int add(); 野指针和悬空指针 都是是指向无效内存区域(这里的无效指的是\"不安全不可控\")的指针，访问行为将会导致未定义行为。野指针野指针，指的是没有被初始化过的指针。为了防止出错","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"，对于指针初始化时赋值为 nullptr或者及时初始化。悬空指针 悬空指针，指针最初指向的内存已经被释放了的一种指针。释放内存后及时置空指针或者引入智能指针避免悬空指针的产生。C和C++的类型安全 什么是类型安全？类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。（1）C的类型安全C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C中相当多的操作是不安全的。以下是两个十分常见的例子：printf格式输出 上述代码中，使用%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误malloc函数的返回值 malloc是C中进行内存分配的函数，它的返回类型是void*即空类型指针，一旦出现int* pInt=(int*)malloc(100*sizeof(char))就很可能带来一些问题，而这样的转换C并不会提示错误。（2）C++的类型安全操作符new返回的指针类型严格与对象匹配，而不是void*C","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_6","order":6,"summary":"，对于指针初始化时赋值为 nullptr或者及时初始化。悬空指针 悬空指针，指针最初指向的内存已经被释放了的一种指针。释放内存后及时置空指针或者引入智能指针避免悬空指针的产生。C和C++的类型安全 什么是类型安全？类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。（1）C的类型安全C只在局部上下文中表现出类型安全，比如试图从一种结构体的指针转换成另一种结构体的指针时，编译器将会报告错误，除非使用显式类型转换。然而，C中相当多的操作是不安全的。以下是两个十分常见的例子：printf格式输出 上述代码中，使用%d控制整型数字的输出，没有问题，但是改成%f时，明显输出错误，再改成%s时，运行直接报segmentation fault错误malloc函数的返回值 malloc是C中进行内存分配的函数，它的返回类型是void*即空类型指针，一旦出现int* pInt=(int*)malloc(100*sizeof(char))就很可能带来一些问题，而这样的转换C并不会提示错误。（2）C++的类型安全操作符new返回的指针类型严格与对象匹配，而不是void*C","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；引入const关键字代替#define constants 10，它是有类型、有作用域的，而#define constants 10只是简单的文本替换一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。重载、重写（覆盖）和隐藏的区别 （1）重载（overload）重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，无法重载仅按返回类型区分的函数。重载和函数成员是否是虚函数无关。举个例子：1 2 3 4 5 6 class A{ virtual int fun(); void fun(int); void fun(double, double); static int fun(char); } （2）重写（覆盖）（override）重写指的是在派生","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_7","order":7,"summary":"中很多以void*为参数的函数可以改写为C++模板函数，而模板是支持类型检查的；引入const关键字代替#define constants 10，它是有类型、有作用域的，而#define constants 10只是简单的文本替换一些#define宏可被改写为inline函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写为模板也能保证类型安全C++提供了dynamic_cast关键字，使得转换过程更加安全，因为dynamic_cast比static_cast涉及更多具体的类型检查。重载、重写（覆盖）和隐藏的区别 （1）重载（overload）重载是指在同一范围定义中的同名成员函数才存在重载关系。主要特点是函数名相同，参数类型和数目有所不同，无法重载仅按返回类型区分的函数。重载和函数成员是否是虚函数无关。举个例子：1 2 3 4 5 6 class A{ virtual int fun(); void fun(int); void fun(double, double); static int fun(char); } （2）重写（覆盖）（override）重写指的是在派生","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"类中覆盖基类中的同名虚函数，且：与基类的虚函数有相同的参数个数 与基类的虚函数有相同的参数类型 与基类的虚函数有相同的返回值类型 重载与重写的区别：重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体 （3）隐藏（hide）隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：两个函数参数相同，但是基类函数不是虚函数。**和重写的区别在于基类函数是否是虚函数。**举个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //父类 class A{ public: void fun(int a){ cout \u0026lt;\u0026lt; \"A中的fun函数\" \u0026lt;\u0026lt; endl; } }; //子类 // 必须是public继承才能调用父类方法 // 使得继承的方法变成public class B : public A{ public: //隐","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_8","order":8,"summary":"类中覆盖基类中的同名虚函数，且：与基类的虚函数有相同的参数个数 与基类的虚函数有相同的参数类型 与基类的虚函数有相同的返回值类型 重载与重写的区别：重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系 重写要求参数列表相同，重载则要求参数列表不同，返回值不要求 重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体 （3）隐藏（hide）隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数，包括以下情况：两个函数参数相同，但是基类函数不是虚函数。**和重写的区别在于基类函数是否是虚函数。**举个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //父类 class A{ public: void fun(int a){ cout \u0026lt;\u0026lt; \"A中的fun函数\" \u0026lt;\u0026lt; endl; } }; //子类 // 必须是public继承才能调用父类方法 // 使得继承的方法变成public class B : public A{ public: //隐","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"藏父类的fun函数 void fun(int a){ cout \u0026lt;\u0026lt; \"B中的fun函数\" \u0026lt;\u0026lt; endl; } }; int main(){ B b; b.fun(2); //调用B中的fun函数 b.A::fun(2); //调用A中fun函数 return 0; } 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //父类 class A{ public: virtual void fun(int a){ cout \u0026lt;\u0026lt; \"A中的fun函数\" \u0026lt;\u0026lt; endl; } }; //子类 class B : public A{ public: //隐藏父类的fun函数 virtual void fun(char* a){ cout \u0026lt;\u0026lt; \"A中的fun函数\" \u0026lt;\u0026lt; endl; } }; int main(){ B b; b.fun(2); //报错，调","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_9","order":9,"summary":"藏父类的fun函数 void fun(int a){ cout \u0026lt;\u0026lt; \"B中的fun函数\" \u0026lt;\u0026lt; endl; } }; int main(){ B b; b.fun(2); //调用B中的fun函数 b.A::fun(2); //调用A中fun函数 return 0; } 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。和重载的区别在于两个函数不在同一个类中。举个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //父类 class A{ public: virtual void fun(int a){ cout \u0026lt;\u0026lt; \"A中的fun函数\" \u0026lt;\u0026lt; endl; } }; //子类 class B : public A{ public: //隐藏父类的fun函数 virtual void fun(char* a){ cout \u0026lt;\u0026lt; \"A中的fun函数\" \u0026lt;\u0026lt; endl; } }; int main(){ B b; b.fun(2); //报错，调","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"用B中的fun函数，参数类型不对 b.A::fun(2); //调用A中fun函数 return 0; } 补充：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 父类 class A { public: virtual void fun(int a) { // 虚函数 cout \u0026lt;\u0026lt; \"This is A fun \" \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } void add(int a, int b) { cout \u0026lt;\u0026lt; \"This is A add \" \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } }; // 子类 class B: public A { public: void fun(int a) override { // 覆盖 cout \u0026lt;\u0026lt; \"this is B fun \" \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } void add(int a) {","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_10","order":10,"summary":"用B中的fun函数，参数类型不对 b.A::fun(2); //调用A中fun函数 return 0; } 补充：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 父类 class A { public: virtual void fun(int a) { // 虚函数 cout \u0026lt;\u0026lt; \"This is A fun \" \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } void add(int a, int b) { cout \u0026lt;\u0026lt; \"This is A add \" \u0026lt;\u0026lt; a + b \u0026lt;\u0026lt; endl; } }; // 子类 class B: public A { public: void fun(int a) override { // 覆盖 cout \u0026lt;\u0026lt; \"this is B fun \" \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } void add(int a) {","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":" // 隐藏 cout \u0026lt;\u0026lt; \"This is B add \" \u0026lt;\u0026lt; a + a \u0026lt;\u0026lt; endl; } }; int main() { // 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖的虚函数； // 而基类指针只能调用基类的被隐藏函数，**无法识别派生类中的隐藏函数。** A *p = new B(); p-\u003efun(1); // 调用子类 fun 覆盖函数 p-\u003eA::fun(1); // 调用父类 fun p-\u003eadd(1, 2); // p-\u003eadd(1); // 错误，识别的是 A 类中的 add 函数，参数不匹配 // p-\u003eB::add(1); // 错误，无法识别子类 add 函数 return 0; } https://stackoverflow.com/questions/11923890/reason-for-c-member-function-hiding C++有哪几种的构造函数 C++中的构造函数可以分为4类：默认构造函数 初始化构造函数（有参数） 拷贝构造函数 转","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_11","order":11,"summary":" // 隐藏 cout \u0026lt;\u0026lt; \"This is B add \" \u0026lt;\u0026lt; a + a \u0026lt;\u0026lt; endl; } }; int main() { // 基类指针指向派生类对象时，基类指针可以直接调用到派生类的覆盖函数，也可以通过 :: 调用到基类被覆盖的虚函数； // 而基类指针只能调用基类的被隐藏函数，**无法识别派生类中的隐藏函数。** A *p = new B(); p-\u003efun(1); // 调用子类 fun 覆盖函数 p-\u003eA::fun(1); // 调用父类 fun p-\u003eadd(1, 2); // p-\u003eadd(1); // 错误，识别的是 A 类中的 add 函数，参数不匹配 // p-\u003eB::add(1); // 错误，无法识别子类 add 函数 return 0; } https://stackoverflow.com/questions/11923890/reason-for-c-member-function-hiding C++有哪几种的构造函数 C++中的构造函数可以分为4类：默认构造函数 初始化构造函数（有参数） 拷贝构造函数 转","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"换构造函数 http://c.biancheng.net/view/2339.html 移动构造函数（move和右值引用） 委托构造函数 https://learn.microsoft.com/zh-cn/cpp/cpp/delegating-constructors?view=msvc-170 举个例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u003e using namespace std; class Student{ public: Student(){//默认构造函数，没有参数 this-\u003eage = 20; this-\u003enum = 1000; }; // 注意n不能赋默认值，否则会跟转换构造函数重复 Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数 Student(const Student\u0026 s){//拷贝构造函数 if (this == \u0026","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_12","order":12,"summary":"换构造函数 http://c.biancheng.net/view/2339.html 移动构造函数（move和右值引用） 委托构造函数 https://learn.microsoft.com/zh-cn/cpp/cpp/delegating-constructors?view=msvc-170 举个例子：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u003e using namespace std; class Student{ public: Student(){//默认构造函数，没有参数 this-\u003eage = 20; this-\u003enum = 1000; }; // 注意n不能赋默认值，否则会跟转换构造函数重复 Student(int a, int n):age(a), num(n){}; //初始化构造函数，有参数 Student(const Student\u0026 s){//拷贝构造函数 if (this == \u0026","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":"s) return; this-\u003eage = s.age; this-\u003enum = s.num; }; Student(int r){ //转换构造函数只有一个形参 this-\u003eage = r; this-\u003enum = 1002; }; ~Student(){} public: int age; int num; }; int main(){ Student s1; // 默认 Student s2(18,1001); // 初始化 Student s3(10); // 转换 Student s4(s3); // 拷贝 return 0; } 默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作 复制构造函数用于复制本类的对象 转换构造函数用于将其他类型的变量，隐式转换为本类对象，如int to Student 浅拷贝和深拷贝的区别 浅拷贝浅拷贝后两个指针指向同一个内存空间，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。可以用shared_ptr解决。深拷贝深拷贝后两个指针指向两个内存空间，它不但对指针进行拷贝，而且对指针指向的内容进行拷贝。各","date":"2024-01-13T21:52:05+08:00","objectID":"dbcf29ca99081c80f1917fa80ea46568_13","order":13,"summary":"s) return; this-\u003eage = s.age; this-\u003enum = s.num; }; Student(int r){ //转换构造函数只有一个形参 this-\u003eage = r; this-\u003enum = 1002; }; ~Student(){} public: int age; int num; }; int main(){ Student s1; // 默认 Student s2(18,1001); // 初始化 Student s3(10); // 转换 Student s4(s3); // 拷贝 return 0; } 默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作 复制构造函数用于复制本类的对象 转换构造函数用于将其他类型的变量，隐式转换为本类对象，如int to Student 浅拷贝和深拷贝的区别 浅拷贝浅拷贝后两个指针指向同一个内存空间，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。可以用shared_ptr解决。深拷贝深拷贝后两个指针指向两个内存空间，它不但对指针进行拷贝，而且对指针指向的内容进行拷贝。各","tags":["Interview"],"title":"面试之CPP基础知识-2","url":"http://localhost:1313/posts/other/interview-basic-cpp-2/"},{"categories":["other"],"content":" https://www.cnblogs.com/marjosong/p/13801160.html在main执行之前和之后执行的代码可能是什么？ 牛客网全局对象的构造函数在main函数之前调用，析构函数在main函数之后调用。局部栈对象在定义的时候调用构造函数，出了可见范围的时候调用析构函数。堆对象在new的时候调用构造函数，delete的时候调用析构。全局静态对象和全局对象一样。局部静态对象在定义的时候调用构造，main函数之后调用析构main函数执行之前，主要就是初始化系统相关资源：配置堆栈 初始化静态static变量和global全局变量，即.data段的内容 将未初始化的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容 全局对象初始化，在main之前调用构造函数，（可以利用构造函数先执行代码） 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数 main函数执行之后：全局对象的析构函数会在main函数之后执行； 可以用 atexit 注册一个函数，它会在main 之后执行","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_0","order":0,"summary":" https://www.cnblogs.com/marjosong/p/13801160.html在main执行之前和之后执行的代码可能是什么？ 牛客网全局对象的构造函数在main函数之前调用，析构函数在main函数之后调用。局部栈对象在定义的时候调用构造函数，出了可见范围的时候调用析构函数。堆对象在new的时候调用构造函数，delete的时候调用析构。全局静态对象和全局对象一样。局部静态对象在定义的时候调用构造，main函数之后调用析构main函数执行之前，主要就是初始化系统相关资源：配置堆栈 初始化静态static变量和global全局变量，即.data段的内容 将未初始化的全局变量赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL等等，即.bss段的内容 全局对象初始化，在main之前调用构造函数，（可以利用构造函数先执行代码） 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数 main函数执行之后：全局对象的析构函数会在main函数之后执行； 可以用 atexit 注册一个函数，它会在main 之后执行","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["other"],"content":"; https://blog.csdn.net/qq_44844115/article/details/98945612结构体内存对齐问题？ 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。 一般按结构体中size最大的成员对齐 对齐后，只需访问一次就可获得值 c++11以后引入两个关键字 alignas与 alignof。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式。若alignas小于自然对齐的最小单位，则被忽略。如果想使用单字节对齐的方式，应该使用#pragma pack(push,1)或者使用__attribute__((packed))。 指针和引用的区别 引用是变量的别名，指针是存储变量地址的变量。 引用初始化后不能被改变，指针可以改变所指的对象。 不存在指向空值的引用，但是存在指向空值的指针。 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？ 需要返回函数内局部变量的时候用指针。当实参是指针时传递给形参用指针。对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小类对象","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_1","order":1,"summary":"; https://blog.csdn.net/qq_44844115/article/details/98945612结构体内存对齐问题？ 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。 一般按结构体中size最大的成员对齐 对齐后，只需访问一次就可获得值 c++11以后引入两个关键字 alignas与 alignof。其中alignof可以计算出类型的对齐方式，alignas可以指定结构体的对齐方式。若alignas小于自然对齐的最小单位，则被忽略。如果想使用单字节对齐的方式，应该使用#pragma pack(push,1)或者使用__attribute__((packed))。 指针和引用的区别 引用是变量的别名，指针是存储变量地址的变量。 引用初始化后不能被改变，指针可以改变所指的对象。 不存在指向空值的引用，但是存在指向空值的指针。 在传递函数参数时，什么时候该使用指针，什么时候该使用引用呢？ 需要返回函数内局部变量的时候用指针。当实参是指针时传递给形参用指针。对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小类对象","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["other"],"content":"作为参数传递的时候使用引用，这是C++类对象传递的标准方式堆和栈的区别 申请方式不同。栈由系统自动分配。堆是自己申请和释放的。申请大小限制不同。栈向低地址扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。申请效率不同。栈由系统分配，速度快，不会有碎片。堆由程序员分配，速度慢，且会有碎片。栈空间默认是4M, 堆区一般是 1G - 4G堆 栈 管理方式 堆中资源由程序员控制（容易产生memory leak） 栈资源由编译器自动管理，无需手工控制 内存管理机制 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_2","order":2,"summary":"作为参数传递的时候使用引用，这是C++类对象传递的标准方式堆和栈的区别 申请方式不同。栈由系统自动分配。堆是自己申请和释放的。申请大小限制不同。栈向低地址扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。申请效率不同。栈由系统分配，速度快，不会有碎片。堆由程序员分配，速度慢，且会有碎片。栈空间默认是4M, 堆区一般是 1G - 4G堆 栈 管理方式 堆中资源由程序员控制（容易产生memory leak） 栈资源由编译器自动管理，无需手工控制 内存管理机制 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["other"],"content":"别了） 空间大小 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置） 碎片问题 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） 生长方向 堆向上，向高地址方向增长。 栈向下，向低地址方向增长。 分配方式 堆都是动态分配（没有静态分配的堆） 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 分配效率 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。 你觉得","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_3","order":3,"summary":"别了） 空间大小 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置） 碎片问题 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） 生长方向 堆向上，向高地址方向增长。 栈向下，向低地址方向增长。 分配方式 堆都是动态分配（没有静态分配的堆） 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 分配效率 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。 你觉得","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["other"],"content":"堆快一点还是栈快一点？ 毫无疑问是栈快一点。 因为栈是由操作系统分配的，对其有专门的优化，而堆是由程序员分配的，需要先找到合适的内存块，再进行分配。区别以下指针类型？ 1 2 3 4 int *p[10] int (*p)[10] int *p(int) int (*p)(int) int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。https://blog.csdn.net/men_wen/article/details/52694069https://blog.csdn.net/lirendada/article/details/122931987int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。new / delete 与 mal","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_4","order":4,"summary":"堆快一点还是栈快一点？ 毫无疑问是栈快一点。 因为栈是由操作系统分配的，对其有专门的优化，而堆是由程序员分配的，需要先找到合适的内存块，再进行分配。区别以下指针类型？ 1 2 3 4 int *p[10] int (*p)[10] int *p(int) int (*p)(int) int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。https://blog.csdn.net/men_wen/article/details/52694069https://blog.csdn.net/lirendada/article/details/122931987int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。new / delete 与 mal","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["other"],"content":"loc / free的异同 相同点都可用于内存的动态申请和释放 不同点new自动计算要分配的空间大小，malloc需要手动计算 new是类型安全的，malloc不是。例如： 1 2 int *p = new float[2]; //编译错误 int *p = (int*)malloc(2 * sizeof(double));//编译无错误 new先分配足够空间并调用相关对象的构造函数；delete先调用析构函数释放资源，然后释放该对象所用内存。后者只是分配空间和释放空间。 malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。 new和delete是如何实现的？ new的实现过程是：首先调用名为operator new的标准库函数，为其分配该对象的大小的内存；接下来运行该类型的一个构造函数，初始化构造对象；最后返回指向该对象的指针 delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过释放该对象所用内存 有malloc/free，为什么还需要new/delete呢？ 类在创建的时候需要调用构造函数，但是malloc只","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_5","order":5,"summary":"loc / free的异同 相同点都可用于内存的动态申请和释放 不同点new自动计算要分配的空间大小，malloc需要手动计算 new是类型安全的，malloc不是。例如： 1 2 int *p = new float[2]; //编译错误 int *p = (int*)malloc(2 * sizeof(double));//编译无错误 new先分配足够空间并调用相关对象的构造函数；delete先调用析构函数释放资源，然后释放该对象所用内存。后者只是分配空间和释放空间。 malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。 new和delete是如何实现的？ new的实现过程是：首先调用名为operator new的标准库函数，为其分配该对象的大小的内存；接下来运行该类型的一个构造函数，初始化构造对象；最后返回指向该对象的指针 delete的实现过程：对指针指向的对象运行适当的析构函数；然后通过释放该对象所用内存 有malloc/free，为什么还需要new/delete呢？ 类在创建的时候需要调用构造函数，但是malloc只","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["other"],"content":"是分配内存，类在销毁的时候需要调用析构函数，但是free只能释放内存。被free回收的内存是立即返还给操作系统吗？ 不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。宏定义和函数有何区别？ 宏定义 #define 函数 宏定义，相当于字符替换 跳转到函数执行处 预处理器处理 - 无类型安全检查 有类型安全检查 无返回值 带返回值 - 宏定义不要在最后加分号。宏定义和typedef区别？ 宏定义 typedef 宏定义，相当于字符替换 定义类型别名 预处理阶段 编译阶段 无类型安全检查 有类型安全检查 不是语句 是语句加分号 #define p_int int * 显示 int*typedef int *p_int; 显示p_intdefine宏定义和const的区别 宏定义 const 宏定义，相当于字符替换 限制变量 预处理阶段 编译阶段 无类型安全检查 有类型安全检查 不分配内存 分配","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_6","order":6,"summary":"是分配内存，类在销毁的时候需要调用析构函数，但是free只能释放内存。被free回收的内存是立即返还给操作系统吗？ 不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。宏定义和函数有何区别？ 宏定义 #define 函数 宏定义，相当于字符替换 跳转到函数执行处 预处理器处理 - 无类型安全检查 有类型安全检查 无返回值 带返回值 - 宏定义不要在最后加分号。宏定义和typedef区别？ 宏定义 typedef 宏定义，相当于字符替换 定义类型别名 预处理阶段 编译阶段 无类型安全检查 有类型安全检查 不是语句 是语句加分号 #define p_int int * 显示 int*typedef int *p_int; 显示p_intdefine宏定义和const的区别 宏定义 const 宏定义，相当于字符替换 限制变量 预处理阶段 编译阶段 无类型安全检查 有类型安全检查 不分配内存 分配","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["other"],"content":"内存 内联函数和宏定义的区别 宏定义 inline 调用处字符替换 调用处字符替换 预处理阶段 编译阶段 无类型安全检查 有类型安全检查 不分配内存 分配内存 无 有返回值 变量声明和定义区别？ 声明仅仅是告诉这里有一个变量（把变量的声明的位置及类型提供给编译器，）并不分配内存空间；定义要在定义的地方为其分配存储空间。 strlen和sizeof区别？ sizeof strlen 运算符 库函数 任何类型 只能string 编译期 编译期 不能得到动态分配的空间大小 可以 算上'\\0' 不算上 1 2 3 4 5 6 7 8 9 10 int main(int argc, char const *argv[]) { const char *str = \"name\"; sizeof(str); // 8 strlen(str); // 4 char a[5] = \"1234\"; sizeof(a); // 5 strlen(b); // 4 return 0; } 一个指针占多少字节？在64位的编译环境下，指针的占用大小为8字节；而在32位环境下，指针占用大小为4字节。一个指针占内存的大","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_7","order":7,"summary":"内存 内联函数和宏定义的区别 宏定义 inline 调用处字符替换 调用处字符替换 预处理阶段 编译阶段 无类型安全检查 有类型安全检查 不分配内存 分配内存 无 有返回值 变量声明和定义区别？ 声明仅仅是告诉这里有一个变量（把变量的声明的位置及类型提供给编译器，）并不分配内存空间；定义要在定义的地方为其分配存储空间。 strlen和sizeof区别？ sizeof strlen 运算符 库函数 任何类型 只能string 编译期 编译期 不能得到动态分配的空间大小 可以 算上'\\0' 不算上 1 2 3 4 5 6 7 8 9 10 int main(int argc, char const *argv[]) { const char *str = \"name\"; sizeof(str); // 8 strlen(str); // 4 char a[5] = \"1234\"; sizeof(a); // 5 strlen(b); // 4 return 0; } 一个指针占多少字节？在64位的编译环境下，指针的占用大小为8字节；而在32位环境下，指针占用大小为4字节。一个指针占内存的大","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["other"],"content":"小跟编译环境有关，而与机器的位数无关常量指针和指针常量区别？ 指针常量强调常量，指向一个只读变量，可以写作int const *p或const int *p。常量指针强调指针，是一个不能改变指向的指针，必须初始化，如int *const p。a和\u0026a有什么区别？ 假设数组int a[10]; int (*p)[10] = \u0026a;其中：a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小。如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。 \u0026a是数组指针，其类型为int (*)[10]，其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。 不考虑数组，a是变量，\u0026a是变量的地址 二维数组取值： 1 2 3 4 5 6 7 8 9 10 11 12 int a[2][3] = {{2,2,3}, {4,5,6}}; // p指向一个包含3个元素的数组首地址,p+1 = int[3] + int[3] int (*p)[3] = a; // *(p+1)，指向下一个包含","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_8","order":8,"summary":"小跟编译环境有关，而与机器的位数无关常量指针和指针常量区别？ 指针常量强调常量，指向一个只读变量，可以写作int const *p或const int *p。常量指针强调指针，是一个不能改变指向的指针，必须初始化，如int *const p。a和\u0026a有什么区别？ 假设数组int a[10]; int (*p)[10] = \u0026a;其中：a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小。如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。 \u0026a是数组指针，其类型为int (*)[10]，其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。 不考虑数组，a是变量，\u0026a是变量的地址 二维数组取值： 1 2 3 4 5 6 7 8 9 10 11 12 int a[2][3] = {{2,2,3}, {4,5,6}}; // p指向一个包含3个元素的数组首地址,p+1 = int[3] + int[3] int (*p)[3] = a; // *(p+1)，指向下一个包含","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["other"],"content":"3个元素的数组首地址 cout \u0026lt;\u0026lt; *(*(p+1)+1) \u0026lt;\u0026lt; *(a[1]+1) \u0026lt;\u0026lt; '\\n'; // 5 // *p+4,指向第五个地址，因为数组是连续存储的，即第二行第二个元素地址 cout \u0026lt;\u0026lt; *(*p+4) \u0026lt;\u0026lt; *(a[0]+4) \u0026lt;\u0026lt; *(\u0026a[0][0]+4) \u0026lt;\u0026lt; a[1][1] \u0026lt;\u0026lt; '\\n'; // 5 // ptr指向首元素地址，ptr+1 = int + int int *ptr = \u0026a[0][0]; // 数组指针p是“二级指针”所以要再加* // ptr是一级指针，直接解引用即可 cout \u0026lt;\u0026lt; *(ptr+4) \u0026lt;\u0026lt; '\\n'; // 5 注意传递指针跟局部变量的关系 不能直接返回局部变量的引用/地址 C++和Python的区别 包括但不限于：Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。 Python使用缩进来区分不同的代码块","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_9","order":9,"summary":"3个元素的数组首地址 cout \u0026lt;\u0026lt; *(*(p+1)+1) \u0026lt;\u0026lt; *(a[1]+1) \u0026lt;\u0026lt; '\\n'; // 5 // *p+4,指向第五个地址，因为数组是连续存储的，即第二行第二个元素地址 cout \u0026lt;\u0026lt; *(*p+4) \u0026lt;\u0026lt; *(a[0]+4) \u0026lt;\u0026lt; *(\u0026a[0][0]+4) \u0026lt;\u0026lt; a[1][1] \u0026lt;\u0026lt; '\\n'; // 5 // ptr指向首元素地址，ptr+1 = int + int int *ptr = \u0026a[0][0]; // 数组指针p是“二级指针”所以要再加* // ptr是一级指针，直接解引用即可 cout \u0026lt;\u0026lt; *(ptr+4) \u0026lt;\u0026lt; '\\n'; // 5 注意传递指针跟局部变量的关系 不能直接返回局部变量的引用/地址 C++和Python的区别 包括但不限于：Python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。 Python使用缩进来区分不同的代码块","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["other"],"content":"，C++使用花括号来区分 C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等 Python的库函数比C++的多，调用起来很方便 C++和C语言的区别 C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。 标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。 C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。 C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。 C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++不允许重复定义变量，C语言也是做不到这一点的 在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我","date":"2024-01-13T21:51:17+08:00","objectID":"6b694b230dcd27345f974cf21d6cbaa9_10","order":10,"summary":"，C++使用花括号来区分 C++中需要事先定义变量的类型，而Python不需要，Python的基本数据类型只有数字，布尔值，字符串，列表，元组等等 Python的库函数比C++的多，调用起来很方便 C++和C语言的区别 C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。 标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。 C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。 C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。 C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++不允许重复定义变量，C语言也是做不到这一点的 在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我","tags":["Interview"],"title":"面试之CPP基础知识-1","url":"http://localhost:1313/posts/other/interview-basic-cpp-1/"},{"categories":["learn"],"content":"文章转载自行码棋，并稍作修改务必做到读万卷书，行万里路。另外C版本一定要对（可能要加编译参数-std=c++11），C11即可，C++17或20更好。使DEV支持C++20 ： https://blog.csdn.net/qq_50285142/article/details/122930647 '\\n' vs 'std::endl': linkvector 介绍 vector为可变长数组（动态数组），定义的vector数组可以随时添加数值和删除元素。注意：在局部区域中（比如局部函数里面）开vector，是在堆空间里面开的。 在局部区域开array是在栈空间开的，而栈空间比较小，如果开了非常长的array就会发生爆栈。 故局部区域不可以开大长度array，但是可以开大长度vector。头文件 1 2 #include \u0026lt;vector\u003e using namespace std; 初始化一维初始化1 2 3 vector\u0026lt;int\u003e a; //定义了一个名为a的一维数组,数组存储int类型数据 vector\u0026lt;double\u003e b;//定义了一个名为b的一维数组，数组存储dou","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_0","order":0,"summary":"文章转载自行码棋，并稍作修改务必做到读万卷书，行万里路。另外C版本一定要对（可能要加编译参数-std=c++11），C11即可，C++17或20更好。使DEV支持C++20 ： https://blog.csdn.net/qq_50285142/article/details/122930647 '\\n' vs 'std::endl': linkvector 介绍 vector为可变长数组（动态数组），定义的vector数组可以随时添加数值和删除元素。注意：在局部区域中（比如局部函数里面）开vector，是在堆空间里面开的。 在局部区域开array是在栈空间开的，而栈空间比较小，如果开了非常长的array就会发生爆栈。 故局部区域不可以开大长度array，但是可以开大长度vector。头文件 1 2 #include \u0026lt;vector\u003e using namespace std; 初始化一维初始化1 2 3 vector\u0026lt;int\u003e a; //定义了一个名为a的一维数组,数组存储int类型数据 vector\u0026lt;double\u003e b;//定义了一个名为b的一维数组，数组存储dou","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"ble类型数据 vector\u0026lt;node\u003e c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型 指定长度和初始值的初始化1 2 3 vector\u0026lt;int\u003e v(n);//定义一个长度为n的数组，初始值默认为0，下标范围[0, n - 1] vector\u0026lt;int\u003e v(n, 1);//v[0]到v[n-1]所有的元素初始值均为1 //注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了） 初始化中有多个元素1 vector\u0026lt;int\u003e a{1, 2, 3, 4, 5};//数组a中有五个元素，数组长度就为5 拷贝初始化1 2 vector\u0026lt;int\u003e a(n + 1, 0); vector\u0026lt;int\u003e b(a);//两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组 二维初始化 定义第一维固定长度为5，第二维可变化的二维数组1 2 3 vector\u0026lt;int\u003e v[5];//定义可变长二维数组 //注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素 //第一维固定长度为5，第二维长度可以改变","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_1","order":1,"summary":"ble类型数据 vector\u0026lt;node\u003e c;//定义了一个名为c的一维数组，数组存储结构体类型数据，node是结构体类型 指定长度和初始值的初始化1 2 3 vector\u0026lt;int\u003e v(n);//定义一个长度为n的数组，初始值默认为0，下标范围[0, n - 1] vector\u0026lt;int\u003e v(n, 1);//v[0]到v[n-1]所有的元素初始值均为1 //注意：指定数组长度之后（指定长度后的数组就相当于正常的数组了） 初始化中有多个元素1 vector\u0026lt;int\u003e a{1, 2, 3, 4, 5};//数组a中有五个元素，数组长度就为5 拷贝初始化1 2 vector\u0026lt;int\u003e a(n + 1, 0); vector\u0026lt;int\u003e b(a);//两个数组中的类型必须相同,a和b都是长度为n+1，初始值都为0的数组 二维初始化 定义第一维固定长度为5，第二维可变化的二维数组1 2 3 vector\u0026lt;int\u003e v[5];//定义可变长二维数组 //注意：行不可变（只有5行）, 而列可变,可以在指定行添加元素 //第一维固定长度为5，第二维长度可以改变","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":" vector\u0026lt;int\u003e v[5]可以这样理解：长度为5的v数组，数组中存储的是vector\u0026lt;int\u003e 数据类型，而该类型就是数组形式，故v为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：1 2 v[1].push_back(2); v[2].push_back(3); 行列均可变1 2 //初始化二维均可变长数组 vector\u0026lt;vector\u0026lt;int\u003e\u003e v;//定义一个行和列均可变的二维数组 应用：可以在v数组里面装多个数组1 2 3 4 5 vector\u0026lt;int\u003e t1{1, 2, 3, 4}; vector\u0026lt;int\u003e t2{2, 3, 4, 5}; v.push_back(t1); v.push_back(t2); v.push_back({3, 4, 5, 6}) // {3, 4, 5, 6}可以作为vector的初始化,相当于一个无名vector 行列长度均固定 n + 1行 m + 1列初始值为01 vector\u0026lt;vector\u0026lt;int\u003e\u003e a(n + 1, vector\u0026lt;int","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_2","order":2,"summary":" vector\u0026lt;int\u003e v[5]可以这样理解：长度为5的v数组，数组中存储的是vector\u0026lt;int\u003e 数据类型，而该类型就是数组形式，故v为二维数组。其中每个数组元素均为空，因为没有指定长度，所以第二维可变长。可以进行下述操作：1 2 v[1].push_back(2); v[2].push_back(3); 行列均可变1 2 //初始化二维均可变长数组 vector\u0026lt;vector\u0026lt;int\u003e\u003e v;//定义一个行和列均可变的二维数组 应用：可以在v数组里面装多个数组1 2 3 4 5 vector\u0026lt;int\u003e t1{1, 2, 3, 4}; vector\u0026lt;int\u003e t2{2, 3, 4, 5}; v.push_back(t1); v.push_back(t2); v.push_back({3, 4, 5, 6}) // {3, 4, 5, 6}可以作为vector的初始化,相当于一个无名vector 行列长度均固定 n + 1行 m + 1列初始值为01 vector\u0026lt;vector\u0026lt;int\u003e\u003e a(n + 1, vector\u0026lt;int","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"\u003e(m + 1, 0)); c++17或者c++20支持的形式（不常用），与上面相同的初始化1 vector a(n + 1, vector(m + 1, 0)); 方法函数 知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。c指定为数组名称，含义中会注明算法复杂度。代码 含义 c.front() 返回第一个数据$O(1)$ c.back() 返回数组中的最后一个数据 $O(1)$ c.pop_back() 删除最后一个数据$O(1)$ c.push_back(element) 在尾部加一个或多个数据push_back((1,2,3)) $O(1)$ c.size() 返回实际数据个数（unsigned类型）$O(1)$ c.clear() 清除元素个数$O(N)$，N为元素个数 c.resize(n, v) 改变数组大小为n,值为v，如果没有默认赋值为0 c.insert(it, x) 向任意迭代器it插入一个元素x ，$O(N)$ 例：c.insert(c.begin()+2,-1) 将-1插入c[2]的位置 c.erase(first,last) 删除[fir","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_3","order":3,"summary":"\u003e(m + 1, 0)); c++17或者c++20支持的形式（不常用），与上面相同的初始化1 vector a(n + 1, vector(m + 1, 0)); 方法函数 知道了如何定义初始化可变数组，下面就需要知道如何添加，删除，修改数据。c指定为数组名称，含义中会注明算法复杂度。代码 含义 c.front() 返回第一个数据$O(1)$ c.back() 返回数组中的最后一个数据 $O(1)$ c.pop_back() 删除最后一个数据$O(1)$ c.push_back(element) 在尾部加一个或多个数据push_back((1,2,3)) $O(1)$ c.size() 返回实际数据个数（unsigned类型）$O(1)$ c.clear() 清除元素个数$O(N)$，N为元素个数 c.resize(n, v) 改变数组大小为n,值为v，如果没有默认赋值为0 c.insert(it, x) 向任意迭代器it插入一个元素x ，$O(N)$ 例：c.insert(c.begin()+2,-1) 将-1插入c[2]的位置 c.erase(first,last) 删除[fir","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"st,last)的所有元素，$O(N)$ c.begin()/c.rbegin() 返回首/逆元素的迭代器（通俗来说就是地址）$O(1)$ c.end() /c.rend() 返回最后/逆一个元素后一个位置的迭代器（地址）$O(1)$ c.empty() 判断是否为空，为空返回真，反之返回假 $O(1)$ 注意： end()返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，所有STL容器均是如此排序使用sort排序要： sort(c.begin(), c.end());sort()为STL函数，请参考本文最后面STL函数系列。对所有元素进行排序，如果要对指定区间进行排序，可以对sort()里面的参数进行加减改动。1 2 vector\u0026lt;int\u003e a(n + 1); sort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序 访问 下标法： 和普通数组一样 注意：一维数组的下标是从$0$到$v.size()-1$，访问之外的数会出现越界错误迭代器法： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_4","order":4,"summary":"st,last)的所有元素，$O(N)$ c.begin()/c.rbegin() 返回首/逆元素的迭代器（通俗来说就是地址）$O(1)$ c.end() /c.rend() 返回最后/逆一个元素后一个位置的迭代器（地址）$O(1)$ c.empty() 判断是否为空，为空返回真，反之返回假 $O(1)$ 注意： end()返回的是最后一个元素的后一个位置的地址，不是最后一个元素的地址，所有STL容器均是如此排序使用sort排序要： sort(c.begin(), c.end());sort()为STL函数，请参考本文最后面STL函数系列。对所有元素进行排序，如果要对指定区间进行排序，可以对sort()里面的参数进行加减改动。1 2 vector\u0026lt;int\u003e a(n + 1); sort(a.begin() + 1, a.end()); // 对[1, n]区间进行从小到大排序 访问 下标法： 和普通数组一样 注意：一维数组的下标是从$0$到$v.size()-1$，访问之外的数会出现越界错误迭代器法： 类似指针一样的访问 ，首先需要声明迭代器变量，和声明指针变量一样，可以根据代码","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"进行理解（附有注释）。 代码如下：1 2 vector\u0026lt;int\u003e vi; //定义一个vi数组 vector\u0026lt;int\u003e::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置 下标访问 直接和普通数组一样进行访问即可。1 2 3 4 5 6 7 8 //添加元素 for(int i = 0; i \u0026lt; 5; i++) vi.push_back(i); //下标访问 for(int i = 0; i \u0026lt; 5; i++) cout \u0026lt;\u0026lt; vi[i] \u0026lt;\u0026lt; \" \"; cout \u0026lt;\u0026lt; \"\\n\"; 迭代器访问 类似指针。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //迭代器访问 vector\u0026lt;int\u003e::iterator it; //相当于声明了一个迭代器类型的变量it //通俗来说就是声明了一个指针变量 //方式一： vector\u0026lt;int\u003e::iterator it = vi.begin(); for(int i = 0; i \u0026lt; 5; i++) co","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_5","order":5,"summary":"进行理解（附有注释）。 代码如下：1 2 vector\u0026lt;int\u003e vi; //定义一个vi数组 vector\u0026lt;int\u003e::iterator it = vi.begin();//声明一个迭代器指向vi的初始位置 下标访问 直接和普通数组一样进行访问即可。1 2 3 4 5 6 7 8 //添加元素 for(int i = 0; i \u0026lt; 5; i++) vi.push_back(i); //下标访问 for(int i = 0; i \u0026lt; 5; i++) cout \u0026lt;\u0026lt; vi[i] \u0026lt;\u0026lt; \" \"; cout \u0026lt;\u0026lt; \"\\n\"; 迭代器访问 类似指针。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //迭代器访问 vector\u0026lt;int\u003e::iterator it; //相当于声明了一个迭代器类型的变量it //通俗来说就是声明了一个指针变量 //方式一： vector\u0026lt;int\u003e::iterator it = vi.begin(); for(int i = 0; i \u0026lt; 5; i++) co","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"ut \u0026lt;\u0026lt; *(it + i) \u0026lt;\u0026lt; \" \"; cout \u0026lt;\u0026lt; \"\\n\"; //方式二： vector\u0026lt;int\u003e::iterator it; for(it = vi.begin(); it != vi.end();it ++) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \" \"; //vi.end()指向尾元素地址的下一个地址 智能指针 只能遍历完数组，如果要指定的内容进行遍历，需要另选方法。 auto 能够自动识别并获取类型。1 2 3 4 5 vector\u0026lt;int\u003e v; v.push_back(12); v.push_back(241); for(auto val : v) cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \" \"; // 12 241 vector注意：vi[i] 和 *(vi.begin() + i) 等价vector和string的STL容器支持*(it + i)的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。stack 介绍 栈为数据结构的一种，是STL中实现的一个先进后","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_6","order":6,"summary":"ut \u0026lt;\u0026lt; *(it + i) \u0026lt;\u0026lt; \" \"; cout \u0026lt;\u0026lt; \"\\n\"; //方式二： vector\u0026lt;int\u003e::iterator it; for(it = vi.begin(); it != vi.end();it ++) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \" \"; //vi.end()指向尾元素地址的下一个地址 智能指针 只能遍历完数组，如果要指定的内容进行遍历，需要另选方法。 auto 能够自动识别并获取类型。1 2 3 4 5 vector\u0026lt;int\u003e v; v.push_back(12); v.push_back(241); for(auto val : v) cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; \" \"; // 12 241 vector注意：vi[i] 和 *(vi.begin() + i) 等价vector和string的STL容器支持*(it + i)的元素访问，其它容器可能也可以支持这种方式访问，但用的不多，可自行尝试。stack 介绍 栈为数据结构的一种，是STL中实现的一个先进后","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"出，后进先出的容器。1 2 3 4 5 6 7 8 9 10 11 //头文件需要添加 #include\u0026lt;stack\u003e using std::stack; //声明 stack\u0026lt;int\u003e s; stack\u0026lt;int, std::vector\u0026lt;int\u003e\u003e s; stack\u0026lt;node\u003e s;//node是结构体类型 // 初始化 stack\u0026lt;int\u003e s ({1,2,3,4}) // or (std::deque\u0026lt;int\u003e{1,2,3,4}) 默认container为deque // 不能进行列表初始化是因为必须用Container初始化，而不是allocator // [Template parameters](https://en.cppreference.com/w/cpp/container/stack) 方法函数 代码 含义 s.push(ele) 元素ele入栈，增加元素 $O(1)$ s.pop() 移除栈顶元素 $O(1)$ s.top() 取得栈顶元素（但不删除）$O(1)$ s.empty() 检测栈内是否为空，空为真 $O(1)","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_7","order":7,"summary":"出，后进先出的容器。1 2 3 4 5 6 7 8 9 10 11 //头文件需要添加 #include\u0026lt;stack\u003e using std::stack; //声明 stack\u0026lt;int\u003e s; stack\u0026lt;int, std::vector\u0026lt;int\u003e\u003e s; stack\u0026lt;node\u003e s;//node是结构体类型 // 初始化 stack\u0026lt;int\u003e s ({1,2,3,4}) // or (std::deque\u0026lt;int\u003e{1,2,3,4}) 默认container为deque // 不能进行列表初始化是因为必须用Container初始化，而不是allocator // [Template parameters](https://en.cppreference.com/w/cpp/container/stack) 方法函数 代码 含义 s.push(ele) 元素ele入栈，增加元素 $O(1)$ s.pop() 移除栈顶元素 $O(1)$ s.top() 取得栈顶元素（但不删除）$O(1)$ s.empty() 检测栈内是否为空，空为真 $O(1)","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"$ s.size() 返回栈内元素的个数 $O(1)$ stack/queue没有clear() 栈遍历 栈遍历 栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中数组模拟栈进行遍历 通过一个数组对栈进行模拟，一个存放下标的变量top模拟指向栈顶的指针。特点： 比STL的stack速度更快，遍历元素方便1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int s[100]; // 栈 从左至右为栈底到栈顶 int tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1 for(int i = 0; i \u0026lt;= 5; i++) { //入栈 s[++tt] = i; } // 出栈 int top_element = s[tt--]; //入栈操作示意 // 0 1 2 3 4 5 // tt //出栈后示意 // 0 1 2 3 4 // tt queue 介绍 队列是一种先进先出的数据结构。1 2 3 4 //头文件 #include\u0026lt;queue\u003e //定义初始化 queue\u0026lt;int\u003e q; 方","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_8","order":8,"summary":"$ s.size() 返回栈内元素的个数 $O(1)$ stack/queue没有clear() 栈遍历 栈遍历 栈只能对栈顶元素进行操作，如果想要进行遍历，只能将栈中元素一个个取出来存在数组中数组模拟栈进行遍历 通过一个数组对栈进行模拟，一个存放下标的变量top模拟指向栈顶的指针。特点： 比STL的stack速度更快，遍历元素方便1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int s[100]; // 栈 从左至右为栈底到栈顶 int tt = -1; // tt 代表栈顶指针,初始栈内无元素，tt为-1 for(int i = 0; i \u0026lt;= 5; i++) { //入栈 s[++tt] = i; } // 出栈 int top_element = s[tt--]; //入栈操作示意 // 0 1 2 3 4 5 // tt //出栈后示意 // 0 1 2 3 4 // tt queue 介绍 队列是一种先进先出的数据结构。1 2 3 4 //头文件 #include\u0026lt;queue\u003e //定义初始化 queue\u0026lt;int\u003e q; 方","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"法函数 代码 含义 q.front() 返回队首元素 $O(1)$ q.back() 返回队尾元素 $O(1)$ q.push(element) 尾部添加一个元素element 进队$O(1)$ q.pop() 删除第一个元素 出队 $O(1)$ q.size() 返回队列中元素个数，返回值类型unsigned int $O(1)$ q.empty() 判断是否为空，队列为空，返回true $O(1)$ 队列模拟 使用q[]数组模拟队列 hh表示队首元素的下标，初始值为0 tt表示队尾元素的下标，初始值为-1，表示刚开始队列为空1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;bits/stdc++.h\u003e using namespace std; const int N = 1e5+5; int q[N]; int main() { int hh = 0,tt = -1; //\t入队 q[++tt] = 1; q[++tt] = 2; //\t将所有元素出队 while(hh \u0026lt;= tt) { int t = q[hh++]","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_9","order":9,"summary":"法函数 代码 含义 q.front() 返回队首元素 $O(1)$ q.back() 返回队尾元素 $O(1)$ q.push(element) 尾部添加一个元素element 进队$O(1)$ q.pop() 删除第一个元素 出队 $O(1)$ q.size() 返回队列中元素个数，返回值类型unsigned int $O(1)$ q.empty() 判断是否为空，队列为空，返回true $O(1)$ 队列模拟 使用q[]数组模拟队列 hh表示队首元素的下标，初始值为0 tt表示队尾元素的下标，初始值为-1，表示刚开始队列为空1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;bits/stdc++.h\u003e using namespace std; const int N = 1e5+5; int q[N]; int main() { int hh = 0,tt = -1; //\t入队 q[++tt] = 1; q[++tt] = 2; //\t将所有元素出队 while(hh \u0026lt;= tt) { int t = q[hh++]","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"; printf(\"%d \",t); } return 0; } priority_queue 介绍 优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。可以实现每次从优先队列中取出的元素都是队列中优先级最大的一个。它的底层是通过堆来实现的。1 2 3 4 5 6 7 //头文件 #include\u0026lt;queue\u003e using namespace std; //初始化定义 priority_queue\u0026lt;int\u003e q; // 与stack/queue不同的是，需要加入比较函数less priority_queue\u0026lt;int\u003e q(less\u0026lt;int\u003e(), vector\u0026lt;int\u003e{1,2,3}); 函数方法 代码 含义 q.top() 访问队首元素 q.push() 入队 q.pop() 堆顶（队首）元素出队 q.size() 队列元素个数 q.empty() 是否为空 注意没有clear()！ 不提供该方法 优先队列只能通过top()访问队首元素（优先级最高的元素） 设置优先级 基本数据类型的优先级 1 2 priority_queue\u0026l","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_10","order":10,"summary":"; printf(\"%d \",t); } return 0; } priority_queue 介绍 优先队列是在正常队列的基础上加了优先级，保证每次的队首元素都是优先级最大的。可以实现每次从优先队列中取出的元素都是队列中优先级最大的一个。它的底层是通过堆来实现的。1 2 3 4 5 6 7 //头文件 #include\u0026lt;queue\u003e using namespace std; //初始化定义 priority_queue\u0026lt;int\u003e q; // 与stack/queue不同的是，需要加入比较函数less priority_queue\u0026lt;int\u003e q(less\u0026lt;int\u003e(), vector\u0026lt;int\u003e{1,2,3}); 函数方法 代码 含义 q.top() 访问队首元素 q.push() 入队 q.pop() 堆顶（队首）元素出队 q.size() 队列元素个数 q.empty() 是否为空 注意没有clear()！ 不提供该方法 优先队列只能通过top()访问队首元素（优先级最高的元素） 设置优先级 基本数据类型的优先级 1 2 priority_queue\u0026l","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"t;int\u003e pq; // 默认大根堆, 即每次取出的元素是队列中的最大值 priority_queue\u0026lt;int, vector\u0026lt;int\u003e, greater\u0026lt;int\u003e \u003e q; // 小根堆, 每次取出的元素是队列中的最小值 参数解释：第二个参数： vector\u0026lt; int \u003e 是用来承载底层数据结构堆的容器，若优先队列中存放的是double型数据，就要填vector\u0026lt; double \u003e 总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。第三个参数： less\u0026lt; int \u003e 表示数字大的优先级大，堆顶为最大的数字 greater\u0026lt; int \u003e表示数字小的优先级大，堆顶为最小的数字 int代表的是数据类型，也要填优先队列中存储的数据类型下面介绍基础数据类型优先级设置的写法。1. 基础写法（非常常用）1 2 3 4 priority_queue\u0026lt;int\u003e q1; // 默认大根堆, 即每次取出的元素是队列中的最大值 priority_queue\u0026lt;int, vector\u0026lt;int\u003e, less\u0026lt;","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_11","order":11,"summary":"t;int\u003e pq; // 默认大根堆, 即每次取出的元素是队列中的最大值 priority_queue\u0026lt;int, vector\u0026lt;int\u003e, greater\u0026lt;int\u003e \u003e q; // 小根堆, 每次取出的元素是队列中的最小值 参数解释：第二个参数： vector\u0026lt; int \u003e 是用来承载底层数据结构堆的容器，若优先队列中存放的是double型数据，就要填vector\u0026lt; double \u003e 总之存的是什么类型的数据，就相应的填写对应类型。同时也要改动第三个参数里面的对应类型。第三个参数： less\u0026lt; int \u003e 表示数字大的优先级大，堆顶为最大的数字 greater\u0026lt; int \u003e表示数字小的优先级大，堆顶为最小的数字 int代表的是数据类型，也要填优先队列中存储的数据类型下面介绍基础数据类型优先级设置的写法。1. 基础写法（非常常用）1 2 3 4 priority_queue\u0026lt;int\u003e q1; // 默认大根堆, 即每次取出的元素是队列中的最大值 priority_queue\u0026lt;int, vector\u0026lt;int\u003e, less\u0026lt;","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"int\u003e \u003e q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行 priority_queue\u0026lt;int, vector\u0026lt;int\u003e, greater\u0026lt;int\u003e \u003e q3; // 小根堆, 每次取出的元素是队列中的最小值 2. 自定义排序（不常见，主要是写着麻烦）下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。1 2 3 4 5 6 7 8 9 10 11 12 struct cmp1 { bool operator()(int x,int y) { return x \u003e y; } }; struct cmp2 { bool operator()(const int x,const int y) { return x \u0026lt; y; } }; priority_queue\u0026lt;int, vector\u0026lt;int\u003e, cmp1\u003e q1; // 小根堆 priority_queue\u0026lt;int, vector\u0026lt;int\u003e, cmp2\u003e q2; // 大根堆 结构体优先级设置 即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_12","order":12,"summary":"int\u003e \u003e q2; // 大根堆, 每次取出的元素是队列中的最大值，同第一行 priority_queue\u0026lt;int, vector\u0026lt;int\u003e, greater\u0026lt;int\u003e \u003e q3; // 小根堆, 每次取出的元素是队列中的最小值 2. 自定义排序（不常见，主要是写着麻烦）下面的代码比较长，基础类型优先级写着太麻烦，用第一种即可。1 2 3 4 5 6 7 8 9 10 11 12 struct cmp1 { bool operator()(int x,int y) { return x \u003e y; } }; struct cmp2 { bool operator()(const int x,const int y) { return x \u0026lt; y; } }; priority_queue\u0026lt;int, vector\u0026lt;int\u003e, cmp1\u003e q1; // 小根堆 priority_queue\u0026lt;int, vector\u0026lt;int\u003e, cmp2\u003e q2; // 大根堆 结构体优先级设置 即优先队列中存储结构体类型，必须要设置优先级，即结构体的比较运算（因","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。优先级设置可以定义在结构体内进行小于号重载，也可以定义在结构体外。1 2 3 4 5 //要排序的结构体（存储在优先队列里面的） struct Point { int x,y; }; 版本一：自定义全局比较规则 1 2 3 4 5 6 7 8 9 10 //定义的比较结构体 //注意：cmp是个结构体 struct cmp {//自定义堆的排序规则 bool operator()(const Point\u0026 a,const Point\u0026 b) { return a.x \u0026lt; b.x; } }; //初始化定义， priority_queue\u0026lt;Point, vector\u0026lt;Point\u003e, cmp\u003e q; // x大的在堆顶 版本二：直接在结构体里面写 因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。结构体内部有两种方式方式一1 2 3 4 5 6 7 struct node { int x, y; friend bool operator \u0026lt; (Point a, Po","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_13","order":13,"summary":"为优先队列的堆中要比较大小，才能将对应最大或者最小元素移到堆顶）。优先级设置可以定义在结构体内进行小于号重载，也可以定义在结构体外。1 2 3 4 5 //要排序的结构体（存储在优先队列里面的） struct Point { int x,y; }; 版本一：自定义全局比较规则 1 2 3 4 5 6 7 8 9 10 //定义的比较结构体 //注意：cmp是个结构体 struct cmp {//自定义堆的排序规则 bool operator()(const Point\u0026 a,const Point\u0026 b) { return a.x \u0026lt; b.x; } }; //初始化定义， priority_queue\u0026lt;Point, vector\u0026lt;Point\u003e, cmp\u003e q; // x大的在堆顶 版本二：直接在结构体里面写 因为是在结构体内部自定义的规则，一旦需要比较结构体，自动调用结构体内部重载运算符规则。结构体内部有两种方式方式一1 2 3 4 5 6 7 struct node { int x, y; friend bool operator \u0026lt; (Point a, Po","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"int b) {//为两个结构体参数，结构体调用一定要写上friend return a.x \u003e b.x;//按x从小到大排，x大的在堆顶 } }; priority_queue\u0026lt;node, vector\u0026lt;node\u003e, greater\u0026lt;node\u003e\u003e pq; 方式二1 2 3 4 5 6 7 8 struct node { int x, y; bool operator \u0026lt; (const Point \u0026a) const {//直接传入一个参数，不写friend，但写const函数 return x \u0026lt; a.x;//按x升序排列，x大的在堆顶 } }; // priority_queue 默认大根堆 priority_queue\u0026lt;node, vector\u0026lt;node\u003e\u003e pq; 优先队列的定义1 priority_queue\u0026lt;Point\u003e q; 注意： 优先队列自定义排序规则和sort()函数定义cmp函数很相似，但是最后返回的情况是相反的。即相同的符号，最后定义的排列顺序是完全相反的。 所以只需要记住sort的排序规则和优先队列的排序规则是相","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_14","order":14,"summary":"int b) {//为两个结构体参数，结构体调用一定要写上friend return a.x \u003e b.x;//按x从小到大排，x大的在堆顶 } }; priority_queue\u0026lt;node, vector\u0026lt;node\u003e, greater\u0026lt;node\u003e\u003e pq; 方式二1 2 3 4 5 6 7 8 struct node { int x, y; bool operator \u0026lt; (const Point \u0026a) const {//直接传入一个参数，不写friend，但写const函数 return x \u0026lt; a.x;//按x升序排列，x大的在堆顶 } }; // priority_queue 默认大根堆 priority_queue\u0026lt;node, vector\u0026lt;node\u003e\u003e pq; 优先队列的定义1 priority_queue\u0026lt;Point\u003e q; 注意： 优先队列自定义排序规则和sort()函数定义cmp函数很相似，但是最后返回的情况是相反的。即相同的符号，最后定义的排列顺序是完全相反的。 所以只需要记住sort的排序规则和优先队列的排序规则是相","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"反的就可以了。存储特殊类型的优先级 存储pair类型 排序规则： 默认先对pair的first进行降序排序，然后再对second降序排序 对first先排序，大的排在前面，如果first元素相同，再对second元素排序，保持大的在前面。 pair请参考下文1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;bits/stdc++.h\u003e using namespace std; int main() { priority_queue\u0026lt;pair\u0026lt;int, int\u003e \u003eq; // 完整默认写法 // priority_queue\u0026lt;pair\u0026lt;int, int\u003e, vector\u0026lt;pair\u0026lt;int, int\u003e\u003e, less\u0026lt;pair\u0026lt;int, int\u003e\u003e\u003e pq; q.push({7, 8}); q.push({7, 9}); q.push(make_pair(8, 7)); for (; !q.empty(); q.pop()) { auto i = q.top(); cout \u0026lt;\u0026lt; i.f","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_15","order":15,"summary":"反的就可以了。存储特殊类型的优先级 存储pair类型 排序规则： 默认先对pair的first进行降序排序，然后再对second降序排序 对first先排序，大的排在前面，如果first元素相同，再对second元素排序，保持大的在前面。 pair请参考下文1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;bits/stdc++.h\u003e using namespace std; int main() { priority_queue\u0026lt;pair\u0026lt;int, int\u003e \u003eq; // 完整默认写法 // priority_queue\u0026lt;pair\u0026lt;int, int\u003e, vector\u0026lt;pair\u0026lt;int, int\u003e\u003e, less\u0026lt;pair\u0026lt;int, int\u003e\u003e\u003e pq; q.push({7, 8}); q.push({7, 9}); q.push(make_pair(8, 7)); for (; !q.empty(); q.pop()) { auto i = q.top(); cout \u0026lt;\u0026lt; i.f","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"irst \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; i.second \u0026lt;\u0026lt; endl; } return 0; } 结果： 8 7 7 9 7 8stack、queue、priority_queue小结 它们的构造器都为Container，因此不包含诸如clear()、insert()、erase()函数deque 介绍 首尾都可插入和删除的队列为双端队列。1 2 3 4 //添加头文件 #include\u0026lt;deque\u003e //初始化定义 deque\u0026lt;int\u003e dq; 方法函数 代码 含义 push_back(x)/push_front(x) 把x插入队尾后 / 队首 $O(1)$ back()/front() 返回队尾 / 队首元素 $O(1)$ pop_back() / pop_front() 删除队尾 / 队首元素 $O(1)$ erase(iterator it) 删除双端队列中的某一个元素 erase(iterator first,iterator last) 删除双端队列中[first,last)中的元素 empty() 判断deque是否空 $O(1","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_16","order":16,"summary":"irst \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; i.second \u0026lt;\u0026lt; endl; } return 0; } 结果： 8 7 7 9 7 8stack、queue、priority_queue小结 它们的构造器都为Container，因此不包含诸如clear()、insert()、erase()函数deque 介绍 首尾都可插入和删除的队列为双端队列。1 2 3 4 //添加头文件 #include\u0026lt;deque\u003e //初始化定义 deque\u0026lt;int\u003e dq; 方法函数 代码 含义 push_back(x)/push_front(x) 把x插入队尾后 / 队首 $O(1)$ back()/front() 返回队尾 / 队首元素 $O(1)$ pop_back() / pop_front() 删除队尾 / 队首元素 $O(1)$ erase(iterator it) 删除双端队列中的某一个元素 erase(iterator first,iterator last) 删除双端队列中[first,last)中的元素 empty() 判断deque是否空 $O(1","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":")$ size() 返回deque的元素数量 $O(1)$ clear() 清空deque 注意点 deque可以进行排序1 2 3 4 5 //从小到大 sort(q.begin(), q.end()) //从大到小排序 sort(q.begin(), q.end(), greater\u0026lt;int\u003e());//deque里面的类型需要是int型 sort(q.begin(), q.end(), greater());//高版本C++才可以用 map 介绍 映射类似于函数的对应关系，每个x对应一个y，而map是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。1 2 3 4 5 6 7 8 //头文件 #include\u0026lt;map\u003e using std::map; using std::pair; //初始化定义 map\u0026lt;string,int\u003e mp; map\u0026lt;int,node\u003e mp;//node是结构体类型 map\u0026lt;int, int\u003e m{{1, 2}, {2, 3}}; map特性：map会按照键的顺序从小到大自动排序，键的","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_17","order":17,"summary":")$ size() 返回deque的元素数量 $O(1)$ clear() 清空deque 注意点 deque可以进行排序1 2 3 4 5 //从小到大 sort(q.begin(), q.end()) //从大到小排序 sort(q.begin(), q.end(), greater\u0026lt;int\u003e());//deque里面的类型需要是int型 sort(q.begin(), q.end(), greater());//高版本C++才可以用 map 介绍 映射类似于函数的对应关系，每个x对应一个y，而map是每个键对应一个值。会python的朋友学习后就会知道这和python的字典非常类似。1 2 3 4 5 6 7 8 //头文件 #include\u0026lt;map\u003e using std::map; using std::pair; //初始化定义 map\u0026lt;string,int\u003e mp; map\u0026lt;int,node\u003e mp;//node是结构体类型 map\u0026lt;int, int\u003e m{{1, 2}, {2, 3}}; map特性：map会按照键的顺序从小到大自动排序，键的","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"类型必须可以比较大小函数方法 函数方法 代码 含义 mp.find(key) 返回键为key的映射的迭代器 $O(logN)$ 注意：find函数返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回$mp.end()$ mp.erase(it) 删除迭代器对应的键和值$O(1)$ mp.erase(key) 根据映射的键删除键和值 $O(logN)$ mp.erase(first,last) 删除左闭右开区间迭代器对应的键和值 $O(last-first)$ mp.size() 返回映射的对数$O(1)$ mp.clear() 清空map中的所有元素$O(N)$ mp.insert() 插入元素，插入时要构造键值对 $O(logN)$ mp.empty() 如果map为空，返回true，否则返回false mp.begin() 返回指向map第一个元素的迭代器（地址） mp.end() 返回指向map尾部的迭代器（最后一个元素的下一个地址） mp.rbegin() 返回指向map最后一个元素的迭代器（地址） mp.rend() 返回指向map第一个元素前面(上一个","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_18","order":18,"summary":"类型必须可以比较大小函数方法 函数方法 代码 含义 mp.find(key) 返回键为key的映射的迭代器 $O(logN)$ 注意：find函数返回一个迭代器。当数据存在时，返回数据所在位置的迭代器，数据不存在时，返回$mp.end()$ mp.erase(it) 删除迭代器对应的键和值$O(1)$ mp.erase(key) 根据映射的键删除键和值 $O(logN)$ mp.erase(first,last) 删除左闭右开区间迭代器对应的键和值 $O(last-first)$ mp.size() 返回映射的对数$O(1)$ mp.clear() 清空map中的所有元素$O(N)$ mp.insert() 插入元素，插入时要构造键值对 $O(logN)$ mp.empty() 如果map为空，返回true，否则返回false mp.begin() 返回指向map第一个元素的迭代器（地址） mp.end() 返回指向map尾部的迭代器（最后一个元素的下一个地址） mp.rbegin() 返回指向map最后一个元素的迭代器（地址） mp.rend() 返回指向map第一个元素前面(上一个","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"）的逆向迭代器（地址） mp.count(key) 查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0 mp.lower_bound() 返回一个迭代器，指向键值**\u003e= key**的第一个元素 mp.upper_bound() 返回一个迭代器，指向键值**\u003e** key的第一个元素 注意点 下面说明部分函数方法的注意点注意： 查找元素是否存在时，可以使用 ①mp.find() ② mp.count() ③ mp[key] 但是第三种情况，如果不存在对应的key时，会自动创建一个键值对（产生一个额外的键值对空间） 所以为了不增加额外的空间负担，最好使用前两种方法迭代器进行正反向遍历 mp.begin()和mp.end()用法： 用于正向遍历map1 2 3 4 5 6 7 8 9 map\u0026lt;int,int\u003e mp; mp[1] = 2; mp[2] = 3; mp[3] = 4; auto it = mp.begin(); while(it != mp.end()) { cout \u0026lt;\u0026lt; it-\u003efirst \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; ","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_19","order":19,"summary":"）的逆向迭代器（地址） mp.count(key) 查看元素是否存在，因为map中键是唯一的，所以存在返回1，不存在返回0 mp.lower_bound() 返回一个迭代器，指向键值**\u003e= key**的第一个元素 mp.upper_bound() 返回一个迭代器，指向键值**\u003e** key的第一个元素 注意点 下面说明部分函数方法的注意点注意： 查找元素是否存在时，可以使用 ①mp.find() ② mp.count() ③ mp[key] 但是第三种情况，如果不存在对应的key时，会自动创建一个键值对（产生一个额外的键值对空间） 所以为了不增加额外的空间负担，最好使用前两种方法迭代器进行正反向遍历 mp.begin()和mp.end()用法： 用于正向遍历map1 2 3 4 5 6 7 8 9 map\u0026lt;int,int\u003e mp; mp[1] = 2; mp[2] = 3; mp[3] = 4; auto it = mp.begin(); while(it != mp.end()) { cout \u0026lt;\u0026lt; it-\u003efirst \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; ","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"it-\u003esecond \u0026lt;\u0026lt; \"\\n\"; it ++; } 结果：1 2 2 3 3 4 mp.rbegin()和mp.rend() 用于逆向遍历map1 2 3 4 5 6 7 8 9 map\u0026lt;int,int\u003e mp; mp[1] = 2; mp[2] = 3; mp[3] = 4; auto it = mp.rbegin(); while(it != mp.rend()) { cout \u0026lt;\u0026lt; it-\u003efirst \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; it-\u003esecond \u0026lt;\u0026lt; \"\\n\"; it ++; } 结果：3 4 2 3 1 2 二分查找 二分查找lower_bound() upper_bound()map的二分查找以第一个元素（即键为准），对键进行二分查找 返回值为map迭代器类型1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;bits/stdc++.h\u003e using namespace std; int main() { map\u0026lt;int, int\u003e m{{1, 2}, {2, 2}, {1, 2}","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_20","order":20,"summary":"it-\u003esecond \u0026lt;\u0026lt; \"\\n\"; it ++; } 结果：1 2 2 3 3 4 mp.rbegin()和mp.rend() 用于逆向遍历map1 2 3 4 5 6 7 8 9 map\u0026lt;int,int\u003e mp; mp[1] = 2; mp[2] = 3; mp[3] = 4; auto it = mp.rbegin(); while(it != mp.rend()) { cout \u0026lt;\u0026lt; it-\u003efirst \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; it-\u003esecond \u0026lt;\u0026lt; \"\\n\"; it ++; } 结果：3 4 2 3 1 2 二分查找 二分查找lower_bound() upper_bound()map的二分查找以第一个元素（即键为准），对键进行二分查找 返回值为map迭代器类型1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;bits/stdc++.h\u003e using namespace std; int main() { map\u0026lt;int, int\u003e m{{1, 2}, {2, 2}, {1, 2}","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":", {8, 2}, {6, 2}};//有序，重复key删除 map\u0026lt;int, int\u003e::iterator it1 = m.lower_bound(2); cout \u0026lt;\u0026lt; it1-\u003efirst \u0026lt;\u0026lt; \"\\n\";//it1-\u003efirst=2 map\u0026lt;int, int\u003e::iterator it2 = m.upper_bound(2); cout \u0026lt;\u0026lt; it2-\u003efirst \u0026lt;\u0026lt; \"\\n\";//it2-\u003efirst=6 return 0; } 添加元素 1 2 //先声明 map\u0026lt;string,string\u003e mp; 方式一： 1 2 mp[\"学习\"] = \"看书\"; mp[\"玩耍\"] = \"打游戏\"; 方式二：插入元素构造键值对 1 mp.insert(make_pair(\"vegetable\",\"蔬菜\")); 方式三： 1 mp.insert(pair\u0026lt;string,string\u003e(\"fruit\",\"水果\")); 方式四: 1 mp.insert({\"hahaha\",\"wawawa\"}); 访问元素 下标访问 (","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_21","order":21,"summary":", {8, 2}, {6, 2}};//有序，重复key删除 map\u0026lt;int, int\u003e::iterator it1 = m.lower_bound(2); cout \u0026lt;\u0026lt; it1-\u003efirst \u0026lt;\u0026lt; \"\\n\";//it1-\u003efirst=2 map\u0026lt;int, int\u003e::iterator it2 = m.upper_bound(2); cout \u0026lt;\u0026lt; it2-\u003efirst \u0026lt;\u0026lt; \"\\n\";//it2-\u003efirst=6 return 0; } 添加元素 1 2 //先声明 map\u0026lt;string,string\u003e mp; 方式一： 1 2 mp[\"学习\"] = \"看书\"; mp[\"玩耍\"] = \"打游戏\"; 方式二：插入元素构造键值对 1 mp.insert(make_pair(\"vegetable\",\"蔬菜\")); 方式三： 1 mp.insert(pair\u0026lt;string,string\u003e(\"fruit\",\"水果\")); 方式四: 1 mp.insert({\"hahaha\",\"wawawa\"}); 访问元素 下标访问 (","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"大部分情况用于访问单个元素)1 2 mp[\"菜哇菜\"] = \"强哇强\"; cout \u0026lt;\u0026lt; mp[\"菜哇菜\"] \u0026lt;\u0026lt; \"\\n\"; 遍历访问 方式一：迭代器访问 1 2 3 4 5 6 7 8 map\u0026lt;string,string\u003e::iterator it; for(it = mp.begin(); it != mp.end(); it++) { // 键 值 // it是结构体指针访问所以要用 -\u003e 访问 cout \u0026lt;\u0026lt; it-\u003efirst \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; it-\u003esecond \u0026lt;\u0026lt; \"\\n\"; //*it是结构体变量 访问要用 . 访问 //cout\u0026lt;\u0026lt;(*it).first\u0026lt;\u0026lt;\" \"\u0026lt;\u0026lt;(*it).second; } 方式二：智能指针访问 1 2 for(auto i : mp) cout \u0026lt;\u0026lt; i.first \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; i.second \u0026lt;\u0026lt; endl;//键，值 方式三：对指定单个元素访问 1 2 map\u0026","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_22","order":22,"summary":"大部分情况用于访问单个元素)1 2 mp[\"菜哇菜\"] = \"强哇强\"; cout \u0026lt;\u0026lt; mp[\"菜哇菜\"] \u0026lt;\u0026lt; \"\\n\"; 遍历访问 方式一：迭代器访问 1 2 3 4 5 6 7 8 map\u0026lt;string,string\u003e::iterator it; for(it = mp.begin(); it != mp.end(); it++) { // 键 值 // it是结构体指针访问所以要用 -\u003e 访问 cout \u0026lt;\u0026lt; it-\u003efirst \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; it-\u003esecond \u0026lt;\u0026lt; \"\\n\"; //*it是结构体变量 访问要用 . 访问 //cout\u0026lt;\u0026lt;(*it).first\u0026lt;\u0026lt;\" \"\u0026lt;\u0026lt;(*it).second; } 方式二：智能指针访问 1 2 for(auto i : mp) cout \u0026lt;\u0026lt; i.first \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; i.second \u0026lt;\u0026lt; endl;//键，值 方式三：对指定单个元素访问 1 2 map\u0026","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"lt;char,int\u003e::iterator it = mp.find('a'); cout \u0026lt;\u0026lt; it -\u003e first \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; it-\u003esecond \u0026lt;\u0026lt; \"\\n\"; 方式四：c++17特性才具有 1 2 3 for(auto [x, y] : mp) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \"\\n\"; //x,y对应键和值 与unordered_map的比较 这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。内部实现原理 map：内部用红黑树实现，具有自动排序（按键从小到大）功能。unordered_map：内部用哈希表实现，内部元素无序杂乱。效率比较 map：优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为$O(logN)$缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。unordered_map：优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。 缺点：建立哈希表比较耗时","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_23","order":23,"summary":"lt;char,int\u003e::iterator it = mp.find('a'); cout \u0026lt;\u0026lt; it -\u003e first \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; it-\u003esecond \u0026lt;\u0026lt; \"\\n\"; 方式四：c++17特性才具有 1 2 3 for(auto [x, y] : mp) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \"\\n\"; //x,y对应键和值 与unordered_map的比较 这里就不单开一个大目录讲unordered_map了，直接在map里面讲了。内部实现原理 map：内部用红黑树实现，具有自动排序（按键从小到大）功能。unordered_map：内部用哈希表实现，内部元素无序杂乱。效率比较 map：优点：内部用红黑树实现，内部元素具有有序性，查询删除等操作复杂度为$O(logN)$缺点：占用空间，红黑树里每个节点需要保存父子节点和红黑性质等信息，空间占用较大。unordered_map：优点：内部用哈希表实现，查找速度非常快（适用于大量的查询操作）。 缺点：建立哈希表比较耗时","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"。 两者方法函数基本一样，差别不大。注意：随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。使用[]查找元素时，如果元素不存在，两种容器都是创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会大大降低。查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）1 2 3 4 5 // 以 map 为例 map\u0026lt;int, int\u003e mp; int x = 999999999; if(mp.count(x)) // 此处判断是否存在x这个键 cout \u0026lt;\u0026lt; mp[x] \u0026lt;\u0026lt; \"\\n\"; // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建 另外：还有一种映射：multimap键可以重复，即一个键对应多个值，如要了解，可以自行搜索。set 介绍 set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。即：set里面的元素不重复 且有序1 2 3 4 //头文件 #i","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_24","order":24,"summary":"。 两者方法函数基本一样，差别不大。注意：随着内部元素越来越多，两种容器的插入删除查询操作的时间都会逐渐变大，效率逐渐变低。使用[]查找元素时，如果元素不存在，两种容器都是创建一个空的元素；如果存在，会正常索引对应的值。所以如果查询过多的不存在的元素值，容器内部会创建大量的空的键值对，后续查询创建删除效率会大大降低。查询容器内部元素的最优方法是：先判断存在与否，再索引对应值（适用于这两种容器）1 2 3 4 5 // 以 map 为例 map\u0026lt;int, int\u003e mp; int x = 999999999; if(mp.count(x)) // 此处判断是否存在x这个键 cout \u0026lt;\u0026lt; mp[x] \u0026lt;\u0026lt; \"\\n\"; // 只有存在才会索引对应的值，避免不存在x时多余空元素的创建 另外：还有一种映射：multimap键可以重复，即一个键对应多个值，如要了解，可以自行搜索。set 介绍 set容器中的元素不会重复，当插入集合中已有的元素时，并不会插入进去，而且set容器里的元素自动从小到大排序。即：set里面的元素不重复 且有序1 2 3 4 //头文件 #i","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"nclude\u0026lt;set\u003e //初始化定义 set\u0026lt;int\u003e s; 函数方法 代码 含义 s.begin() 返回set容器的第一个元素的地址（迭代器）$O(1)$ s.end() 返回set容器的最后一个元素的下一个地址（迭代器）$O(1)$ s.rbegin() 返回逆序迭代器，指向容器元素最后一个位置$O(1)$ s.rend() 返回逆序迭代器，指向容器第一个元素前面的位置$O(1)$ s.clear() 删除set容器中的所有的元素,返回unsigned int类型$O(N)$ s.empty() 判断set容器是否为空$O(1)$ s.insert() 插入一个元素 s.size() 返回当前set容器中的元素个数$O(1)$ erase(iterator) 删除迭代器iterator指向的值 erase(first,second） 删除迭代器first和second之间的值 erase(key_value) 删除键值key_value的值 查找 s.find(element) 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 s.count(","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_25","order":25,"summary":"nclude\u0026lt;set\u003e //初始化定义 set\u0026lt;int\u003e s; 函数方法 代码 含义 s.begin() 返回set容器的第一个元素的地址（迭代器）$O(1)$ s.end() 返回set容器的最后一个元素的下一个地址（迭代器）$O(1)$ s.rbegin() 返回逆序迭代器，指向容器元素最后一个位置$O(1)$ s.rend() 返回逆序迭代器，指向容器第一个元素前面的位置$O(1)$ s.clear() 删除set容器中的所有的元素,返回unsigned int类型$O(N)$ s.empty() 判断set容器是否为空$O(1)$ s.insert() 插入一个元素 s.size() 返回当前set容器中的元素个数$O(1)$ erase(iterator) 删除迭代器iterator指向的值 erase(first,second） 删除迭代器first和second之间的值 erase(key_value) 删除键值key_value的值 查找 s.find(element) 查找set中的某一元素，有则返回该元素对应的迭代器，无则返回结束迭代器 s.count(","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"element) 查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现 s.lower_bound(k) 返回大于等于k的第一个元素的迭代器$O(logN)$ s.upper_bound(k) 返回大于k的第一个元素的迭代器$O(logN)$ 访问 迭代器访问 1 2 for(set\u0026lt;int\u003e::iterator it = s.begin(); it != s.end(); it++) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \" \"; 智能指针 1 2 for(auto i : s) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; 访问最后一个元素 1 2 //第一种 cout \u0026lt;\u0026lt; *s.rbegin() \u0026lt;\u0026lt; endl; 1 2 //第二种 rend()也可以 cout \u0026lt;\u0026lt; (*s.end()) \u0026lt;\u0026lt; endl; // 对end()++/--没有效果 1 2 3 //逆序输出，注意是++it for (auto it = s.rbegin(); it != s.","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_26","order":26,"summary":"element) 查找set中的元素出现的个数，由于set中元素唯一，此函数相当于查询element是否出现 s.lower_bound(k) 返回大于等于k的第一个元素的迭代器$O(logN)$ s.upper_bound(k) 返回大于k的第一个元素的迭代器$O(logN)$ 访问 迭代器访问 1 2 for(set\u0026lt;int\u003e::iterator it = s.begin(); it != s.end(); it++) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \" \"; 智能指针 1 2 for(auto i : s) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; 访问最后一个元素 1 2 //第一种 cout \u0026lt;\u0026lt; *s.rbegin() \u0026lt;\u0026lt; endl; 1 2 //第二种 rend()也可以 cout \u0026lt;\u0026lt; (*s.end()) \u0026lt;\u0026lt; endl; // 对end()++/--没有效果 1 2 3 //逆序输出，注意是++it for (auto it = s.rbegin(); it != s.","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"rend(); ++it) std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; 重载\u0026lt;运算符 基础数据类型 方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）1 2 set\u0026lt;int\u003e s1; // 默认从小到大排序 set\u0026lt;int, greater\u0026lt;int\u003e \u003e s2; // 从大到小排序 方式二：重载运算符。（很麻烦，不太常用，没必要）1 2 3 4 5 6 7 8 9 10 11 12 13 14 //重载 \u0026lt; 运算符 struct cmp { bool operator () (const int\u0026 u, const int\u0026 v) const { // const参数 / const函数 return u \u003e v; } }; set\u0026lt;int, cmp\u003e s; for(int i = 1; i \u0026lt;= 10; i++) s.insert(i); for(auto i : s) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \" \"; // 10 9 8 7 6 5 4 3","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_27","order":27,"summary":"rend(); ++it) std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; 重载\u0026lt;运算符 基础数据类型 方式一：改变set排序规则，set中默认使用less比较器，即从小到大排序。（常用）1 2 set\u0026lt;int\u003e s1; // 默认从小到大排序 set\u0026lt;int, greater\u0026lt;int\u003e \u003e s2; // 从大到小排序 方式二：重载运算符。（很麻烦，不太常用，没必要）1 2 3 4 5 6 7 8 9 10 11 12 13 14 //重载 \u0026lt; 运算符 struct cmp { bool operator () (const int\u0026 u, const int\u0026 v) const { // const参数 / const函数 return u \u003e v; } }; set\u0026lt;int, cmp\u003e s; for(int i = 1; i \u0026lt;= 10; i++) s.insert(i); for(auto i : s) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \" \"; // 10 9 8 7 6 5 4 3","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":" 2 1 方式三：初始化时使用匿名函数定义比较规则1 2 3 4 5 6 7 8 #include \u0026lt;functional\u003e set\u0026lt;int, std::function\u0026lt;bool(int, int)\u003e\u003e s([\u0026](int i, int j){ return i \u003e j; // 从大到小 }); for(int i = 1; i \u0026lt;= 10; i++) s.insert(i); for(auto x : s) std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \" \"; 高级数据类型（结构体） 直接重载结构体运算符即可，让结构体可以比较。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct Point { int x, y; // friend bool operator \u0026lt; (const Point \u0026a, const Point \u0026b){ // if (a.x == b.x) return a.y \u0026lt; b.y; // return a.x \u0026lt; b.x;","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_28","order":28,"summary":" 2 1 方式三：初始化时使用匿名函数定义比较规则1 2 3 4 5 6 7 8 #include \u0026lt;functional\u003e set\u0026lt;int, std::function\u0026lt;bool(int, int)\u003e\u003e s([\u0026](int i, int j){ return i \u003e j; // 从大到小 }); for(int i = 1; i \u0026lt;= 10; i++) s.insert(i); for(auto x : s) std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \" \"; 高级数据类型（结构体） 直接重载结构体运算符即可，让结构体可以比较。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct Point { int x, y; // friend bool operator \u0026lt; (const Point \u0026a, const Point \u0026b){ // if (a.x == b.x) return a.y \u0026lt; b.y; // return a.x \u0026lt; b.x;","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":" // } bool operator \u0026lt; (const Point \u0026p) const { // 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大 if(x == p.x) return y \u0026lt; p.y; return x \u0026lt; p.x; } }; set\u0026lt;Point\u003e s; for(int i = 1; i \u0026lt;= 5; i++) { int x, y; cin \u003e\u003e x \u003e\u003e y; // vscode [控制台输入](https://stackoverflow.com/a/49846389) s.insert({x, y}); }\tfor(auto i : s) cout \u0026lt;\u0026lt; i.x \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; i.y \u0026lt;\u0026lt; \"\\n\"; 其它set multiset:元素可以重复，且元素有序unordered_set ：元素无序且只能出现一次unordered_multiset ： 元素无序可以出现多次总结 Containers library容器 迭代器类型 Container 有序？ 时间复杂度 底","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_29","order":29,"summary":" // } bool operator \u0026lt; (const Point \u0026p) const { // 按照点的横坐标从小到大排序,如果横坐标相同,纵坐标从小到大 if(x == p.x) return y \u0026lt; p.y; return x \u0026lt; p.x; } }; set\u0026lt;Point\u003e s; for(int i = 1; i \u0026lt;= 5; i++) { int x, y; cin \u003e\u003e x \u003e\u003e y; // vscode [控制台输入](https://stackoverflow.com/a/49846389) s.insert({x, y}); }\tfor(auto i : s) cout \u0026lt;\u0026lt; i.x \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; i.y \u0026lt;\u0026lt; \"\\n\"; 其它set multiset:元素可以重复，且元素有序unordered_set ：元素无序且只能出现一次unordered_multiset ： 元素无序可以出现多次总结 Containers library容器 迭代器类型 Container 有序？ 时间复杂度 底","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"层 备注 array 随机访问(支持iter+2) sequence 随机读改) $O(1)$ 静态数组 array\u0026lt;int, 5\u003e ay; 不能扩容 vector 随机访问 sequence 随机读改、尾插/删 $O(1)$插/删$O(n)$ 动态数组 是push_back() deque 随机访问 sequence 随机读改、头插/删、尾插/删 $O(1)$插/删$O(n)$ 双端队列(数组) 是push_back/front() list 双向访问 sequence 插/删$O(1)$ 双向链表(deque区别) 是push_back/front() map 双向访问(支持it--) associative 有 增/删/查$O(log_n)$(但是多态导致不同复杂度) 红黑树 只有insert() unordered_map 双向访问 unordered associative 增/删/查$O(1)$，最差$O(n)$ 哈希表 只有insert() set 双向访问 associative 有 增删改$O(log_n)$ 红黑树 只有insert() unordered_s","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_30","order":30,"summary":"层 备注 array 随机访问(支持iter+2) sequence 随机读改) $O(1)$ 静态数组 array\u0026lt;int, 5\u003e ay; 不能扩容 vector 随机访问 sequence 随机读改、尾插/删 $O(1)$插/删$O(n)$ 动态数组 是push_back() deque 随机访问 sequence 随机读改、头插/删、尾插/删 $O(1)$插/删$O(n)$ 双端队列(数组) 是push_back/front() list 双向访问 sequence 插/删$O(1)$ 双向链表(deque区别) 是push_back/front() map 双向访问(支持it--) associative 有 增/删/查$O(log_n)$(但是多态导致不同复杂度) 红黑树 只有insert() unordered_map 双向访问 unordered associative 增/删/查$O(1)$，最差$O(n)$ 哈希表 只有insert() set 双向访问 associative 有 增删改$O(log_n)$ 红黑树 只有insert() unordered_s","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"et 双向访问 unordered associative 增删查$O(1)$，最差$O(n)$ 哈希表 只有insert() stack 不支持 Container adaptor 顶删/增 $O(1)$（FIFO） deque/list/vector 不支持列表初始化，只有push() queue 不支持 Container adaptor 尾删/头插 $O(1)$（FILO） deque/list 不支持列表初始化，只有push() priority_queue 不支持 Container adaptor 最大/小在顶端 插入、删除 $O(log2n)$ 堆 不支持列表初始化，只有push() pair 介绍 pair只含有两个元素，可以看作是只有两个元素的结构体。应用：代替二元结构体 作为map键值对进行插入（代码如下） 1 2 3 4 map\u0026lt;string,int\u003emp; mp.insert(pair\u0026lt;string,int\u003e(\"xingmaqi\",1)); // mp.insert(make_pair(\"xingmaqi\", 1)); // mp.insert({","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_31","order":31,"summary":"et 双向访问 unordered associative 增删查$O(1)$，最差$O(n)$ 哈希表 只有insert() stack 不支持 Container adaptor 顶删/增 $O(1)$（FIFO） deque/list/vector 不支持列表初始化，只有push() queue 不支持 Container adaptor 尾删/头插 $O(1)$（FILO） deque/list 不支持列表初始化，只有push() priority_queue 不支持 Container adaptor 最大/小在顶端 插入、删除 $O(log2n)$ 堆 不支持列表初始化，只有push() pair 介绍 pair只含有两个元素，可以看作是只有两个元素的结构体。应用：代替二元结构体 作为map键值对进行插入（代码如下） 1 2 3 4 map\u0026lt;string,int\u003emp; mp.insert(pair\u0026lt;string,int\u003e(\"xingmaqi\",1)); // mp.insert(make_pair(\"xingmaqi\", 1)); // mp.insert({","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"\"xingmaqi\", 1}); 1 2 3 4 5 6 7 8 9 10 11 12 //头文件 #include\u0026lt;utility\u003e using std::pair; //1.初始化定义 pair\u0026lt;string,int\u003e p(\"wangyaqi\",1);//带初始值的 pair\u0026lt;string,int\u003e p;//不带初始值的 //2.赋值 p = {\"wang\", 18}; p = std::make_pair(\"wang\", 18); p = pair\u0026lt;string, int\u003e(\"wang\", 18); 访问 1 2 3 4 5 6 //定义结构体数组 pair\u0026lt;int,int\u003e p[20]; for(int i = 0; i \u0026lt; 20; i++) { //和结构体类似，first代表第一个元素，second代表第二个元素 cout \u0026lt;\u0026lt; p[i].first \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; p[i].second; } string 介绍 string是一个字符串类，和char型字符串类似。可以把string理解为一个字符","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_32","order":32,"summary":"\"xingmaqi\", 1}); 1 2 3 4 5 6 7 8 9 10 11 12 //头文件 #include\u0026lt;utility\u003e using std::pair; //1.初始化定义 pair\u0026lt;string,int\u003e p(\"wangyaqi\",1);//带初始值的 pair\u0026lt;string,int\u003e p;//不带初始值的 //2.赋值 p = {\"wang\", 18}; p = std::make_pair(\"wang\", 18); p = pair\u0026lt;string, int\u003e(\"wang\", 18); 访问 1 2 3 4 5 6 //定义结构体数组 pair\u0026lt;int,int\u003e p[20]; for(int i = 0; i \u0026lt; 20; i++) { //和结构体类似，first代表第一个元素，second代表第二个元素 cout \u0026lt;\u0026lt; p[i].first \u0026lt;\u0026lt; \" \" \u0026lt;\u0026lt; p[i].second; } string 介绍 string是一个字符串类，和char型字符串类似。可以把string理解为一个字符","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"串类型，像int一样可以定义初始化及定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //头文件 #include\u0026lt;string\u003e using std::string; //1. string str1; //生成空字符串 //2. string str2(\"123456789\"); //生成\"1234456789\"的复制品 //3. string str3(\"12345\", 0, 3);//结果为\"123\" ，从0位置开始，长度为3 //4. string str4(\"123456\", 5); //结果为\"12345\" ，长度为5 //5. string str5(5, '2'); //结果为\"22222\" ,构造5个字符'2'连接而成的字符串 //6. string str6(str2, 2); //结果为\"3456789\"，截取第三个元素（2对应第三位）到最后 简单使用访问单个字符： 1 2 3 4 5 6 7 8 9 #include\u0026lt;iostream\u003e #include\u0026lt;string\u003e using n","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_33","order":33,"summary":"串类型，像int一样可以定义初始化及定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //头文件 #include\u0026lt;string\u003e using std::string; //1. string str1; //生成空字符串 //2. string str2(\"123456789\"); //生成\"1234456789\"的复制品 //3. string str3(\"12345\", 0, 3);//结果为\"123\" ，从0位置开始，长度为3 //4. string str4(\"123456\", 5); //结果为\"12345\" ，长度为5 //5. string str5(5, '2'); //结果为\"22222\" ,构造5个字符'2'连接而成的字符串 //6. string str6(str2, 2); //结果为\"3456789\"，截取第三个元素（2对应第三位）到最后 简单使用访问单个字符： 1 2 3 4 5 6 7 8 9 #include\u0026lt;iostream\u003e #include\u0026lt;string\u003e using n","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":"amespace std; int main() { string s = \"xing ma qi!!!\"; for(int i = 0; i \u0026lt; s.size(); i++) cout \u0026lt;\u0026lt; s[i] \u0026lt;\u0026lt; \" \"; return 0; } string数组使用： 1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u003e #include\u0026lt;string\u003e using namespace std; int main() { string s[10]; for(int i = 1; i \u0026lt; 10; i++) { s[i] = \"loading... \" ; cout \u0026lt;\u0026lt; s[i] \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \"\\n\"; } return 0; } string 特性 支持比较运算符 string字符串支持常见的比较操作符（\u003e,\u003e=,\u0026lt;,\u0026lt;=,==,!=），支持string与C-string的比较（如 str \u0026lt; \"hello\"）。 在使用\u003e,\u003e=,\u0026lt;,\u0026lt;=这","date":"2024-01-13T20:52:18+08:00","objectID":"4a909580fea9cda0bcee2c54717c9300_34","order":34,"summary":"amespace std; int main() { string s = \"xing ma qi!!!\"; for(int i = 0; i \u0026lt; s.size(); i++) cout \u0026lt;\u0026lt; s[i] \u0026lt;\u0026lt; \" \"; return 0; } string数组使用： 1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u003e #include\u0026lt;string\u003e using namespace std; int main() { string s[10]; for(int i = 1; i \u0026lt; 10; i++) { s[i] = \"loading... \" ; cout \u0026lt;\u0026lt; s[i] \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \"\\n\"; } return 0; } string 特性 支持比较运算符 string字符串支持常见的比较操作符（\u003e,\u003e=,\u0026lt;,\u0026lt;=,==,!=），支持string与C-string的比较（如 str \u0026lt; \"hello\"）。 在使用\u003e,\u003e=,\u0026lt;,\u0026lt;=这","tags":["C++"],"title":"C-STL超全总结汇总版","url":"http://localhost:1313/posts/learn/stl-summary/"},{"categories":["learn"],"content":" 查找算法只涉及到用的最多的二分查找排序算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 // 未排序序列里两两交换，将最大值浮到已排序序列头部 void bubbleSort(vector\u0026lt;int\u003e\u0026 nums) { int len = nums.size(); bool flag = false; for (int i = 0; i \u0026lt; len - 1; ++i){ flag ","date":"2024-01-13T20:48:46+08:00","objectID":"8c21a14607d095597a045a1b0feacd94_0","order":0,"summary":" 查找算法只涉及到用的最多的二分查找排序算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 // 未排序序列里两两交换，将最大值浮到已排序序列头部 void bubbleSort(vector\u0026lt;int\u003e\u0026 nums) { int len = nums.size(); bool flag = false; for (int i = 0; i \u0026lt; len - 1; ++i){ flag ","tags":["C++"],"title":"排序、查找算法","url":"http://localhost:1313/posts/learn/basic-sort-and-search-algorithm/"},{"categories":["learn"],"content":"= false; for (int j = 0; j \u0026lt; len - i - 1; ++j) { if (nums[j] \u003e nums[j+1]) { int temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; flag = true; } } if (!flag) break; } } // 从未排序序列选择最小的，放入已排序序列末尾 void selectSort(vector\u0026lt;int\u003e\u0026 nums) { int len = nums.size(); for (int i = 0; i \u0026lt; len - 1; ++i) { int min = i; for (int j = i + 1; j \u0026lt; len; ++j) { if (nums[min] \u003e nums[j]) min = j; } int temp = nums[min]; nums[min] = nums[i]; nums[i] = temp; } } // 如果已排序序列的后一个值小于尾部，则放入已排序序列指定位置 void insertS","date":"2024-01-13T20:48:46+08:00","objectID":"8c21a14607d095597a045a1b0feacd94_1","order":1,"summary":"= false; for (int j = 0; j \u0026lt; len - i - 1; ++j) { if (nums[j] \u003e nums[j+1]) { int temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; flag = true; } } if (!flag) break; } } // 从未排序序列选择最小的，放入已排序序列末尾 void selectSort(vector\u0026lt;int\u003e\u0026 nums) { int len = nums.size(); for (int i = 0; i \u0026lt; len - 1; ++i) { int min = i; for (int j = i + 1; j \u0026lt; len; ++j) { if (nums[min] \u003e nums[j]) min = j; } int temp = nums[min]; nums[min] = nums[i]; nums[i] = temp; } } // 如果已排序序列的后一个值小于尾部，则放入已排序序列指定位置 void insertS","tags":["C++"],"title":"排序、查找算法","url":"http://localhost:1313/posts/learn/basic-sort-and-search-algorithm/"},{"categories":["learn"],"content":"图形推理 命题形式与考点 命题形式： 一组图：从左往右找规律，极少需要跳着找规律 二组图：第一组找规律，第二组应用规律 九宫格：优先从第一行找规律，然后应用规律；其次从第一列找规律，然后应用规律；极少遇到米字型和S型 分组分类：找图形的相同规律 空间重构：三维重建 考点： 位置规律 样式规律 属性规律 数量规律 特殊规律 空间重构 立体图形 利用图形特征快速找到规律 做题顺序： 元素相同找位置，元素相似找样式，否则找属性（优先对称其次曲直最后不得已开闭） 位置规律 视频位置类识别：元素组成相同 考点： 平移 方向：直线平移（上下、左右、对角线）、绕圈平移（顺逆时针） 步数：恒定、递增（等差） 旋转 方向：顺时针、逆时针 角度：45°、90°、180° 翻转 左右翻转：竖轴对称 b｜d 上下翻转：横轴对称 $\\frac{p}{b}$ 技巧：即可以比较题干，也可以比较选项（适用所有图推） 平移\u0026旋转\u0026翻转 元素组成相同，优先考虑位置规律 【例4】三角形底边在平移，并且顶点在按正方形进行平移【例5】看单幅图的规律，1黑点顺时针到三角形45同理，如果考虑黑点和三角形的位置为123，没答案所以不","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_0","order":0,"summary":"图形推理 命题形式与考点 命题形式： 一组图：从左往右找规律，极少需要跳着找规律 二组图：第一组找规律，第二组应用规律 九宫格：优先从第一行找规律，然后应用规律；其次从第一列找规律，然后应用规律；极少遇到米字型和S型 分组分类：找图形的相同规律 空间重构：三维重建 考点： 位置规律 样式规律 属性规律 数量规律 特殊规律 空间重构 立体图形 利用图形特征快速找到规律 做题顺序： 元素相同找位置，元素相似找样式，否则找属性（优先对称其次曲直最后不得已开闭） 位置规律 视频位置类识别：元素组成相同 考点： 平移 方向：直线平移（上下、左右、对角线）、绕圈平移（顺逆时针） 步数：恒定、递增（等差） 旋转 方向：顺时针、逆时针 角度：45°、90°、180° 翻转 左右翻转：竖轴对称 b｜d 上下翻转：横轴对称 $\\frac{p}{b}$ 技巧：即可以比较题干，也可以比较选项（适用所有图推） 平移\u0026旋转\u0026翻转 元素组成相同，优先考虑位置规律 【例4】三角形底边在平移，并且顶点在按正方形进行平移【例5】看单幅图的规律，1黑点顺时针到三角形45同理，如果考虑黑点和三角形的位置为123，没答案所以不","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"行【练4】一个个元素看（先横着看没规律，然后竖着看），第一个元素自上往下走，第二个往上走后从头跑，第三个位置不变，第四个从头跑。注意三角形走上去后，只会保留三角形内的方框。即梯形往上走变三角形。【练5】折返跑，是撞头后掉头不会穿越【练5】外圈逆时针、内圈顺时针【练2】九宫格优先看行，第一个到第二个是左右翻转、第二个到第三个是上下翻转。不要孤立单看白色三角形的变化和黑色三角形的变化。样式规律 识别特征：元素组成相似，相同（位置）线条重复出现 考点： 加减同异 相加、相减：S + I = $ 求同：B + 3 = 3 求异：消消乐。B + 3 = I 注意：位置+样式的复合考法 黑白运算 特征：图形轮廓和分隔区域相同，内部颜色不同 方法：相同位置运算 区分：黑块数量相同优先平移；不同优先黑白运算 技巧：直接从选项进行比较，图1黑（白）+图2黑（白）= 图3结果 技巧：即可以比较题干，也可以比较选项（适用所有图推） 消消乐\u0026黑白运算 【例5】第一行都存在平行四边形且第三幅图是消完后旋转的结果（并且顺逆旋转不变）。B是没有旋转，D是旋转后的结果。【练2】也可以自下往上看，第一列第一个为后两个相","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_1","order":1,"summary":"行【练4】一个个元素看（先横着看没规律，然后竖着看），第一个元素自上往下走，第二个往上走后从头跑，第三个位置不变，第四个从头跑。注意三角形走上去后，只会保留三角形内的方框。即梯形往上走变三角形。【练5】折返跑，是撞头后掉头不会穿越【练5】外圈逆时针、内圈顺时针【练2】九宫格优先看行，第一个到第二个是左右翻转、第二个到第三个是上下翻转。不要孤立单看白色三角形的变化和黑色三角形的变化。样式规律 识别特征：元素组成相似，相同（位置）线条重复出现 考点： 加减同异 相加、相减：S + I = $ 求同：B + 3 = 3 求异：消消乐。B + 3 = I 注意：位置+样式的复合考法 黑白运算 特征：图形轮廓和分隔区域相同，内部颜色不同 方法：相同位置运算 区分：黑块数量相同优先平移；不同优先黑白运算 技巧：直接从选项进行比较，图1黑（白）+图2黑（白）= 图3结果 技巧：即可以比较题干，也可以比较选项（适用所有图推） 消消乐\u0026黑白运算 【例5】第一行都存在平行四边形且第三幅图是消完后旋转的结果（并且顺逆旋转不变）。B是没有旋转，D是旋转后的结果。【练2】也可以自下往上看，第一列第一个为后两个相","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"加【练6】发现是消消乐后，找到相同的线然后排除一个选项，直到排除所有选项，不要全消完。【练1】发现是黑白运算后直接从第二组中按顺序找对应结果，不要先从第一组找到黑白运算表后再看选项属性规律 识别特征：元素组成不相同、不相似，优先属性 考点： 对称性（重要） 轴对称：对称轴方向、数量对称轴数量分别为1、1、5、5，注意方向变化 中心对称（图形旋转 180°后和原图形完全重合/找一中点，两点穿过该点距离相同）一般考试的图形都是上述特征图的变形 轴对称+中心对称曲直性 优先全直线/曲线组成图形 开闭性 优先全开放，全封闭（考到极少，综合考虑规律后再看开闭） 技巧：把对称性标出来，以及方向和数量 对称性\u0026曲直性\u0026开闭性 【练5】结合选项看，只有D包含竖轴，图中都是既有多轴又出现中心对称【练8】看各组成部分的对称性，134对称轴相交45°，256对称轴平行。【练9】对称轴数量相加【练1】发现第一幅图不对称，立马考虑曲直性。外曲/直内直/曲，图形全为曲直，排除BD，发现AC为不同在于内外曲直性【练2】优先考虑对称性，发现第四幅图不对称，然后考虑曲直性。结合内部对称轴方向+外部曲直性【例1】优先考虑","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_2","order":2,"summary":"加【练6】发现是消消乐后，找到相同的线然后排除一个选项，直到排除所有选项，不要全消完。【练1】发现是黑白运算后直接从第二组中按顺序找对应结果，不要先从第一组找到黑白运算表后再看选项属性规律 识别特征：元素组成不相同、不相似，优先属性 考点： 对称性（重要） 轴对称：对称轴方向、数量对称轴数量分别为1、1、5、5，注意方向变化 中心对称（图形旋转 180°后和原图形完全重合/找一中点，两点穿过该点距离相同）一般考试的图形都是上述特征图的变形 轴对称+中心对称曲直性 优先全直线/曲线组成图形 开闭性 优先全开放，全封闭（考到极少，综合考虑规律后再看开闭） 技巧：把对称性标出来，以及方向和数量 对称性\u0026曲直性\u0026开闭性 【练5】结合选项看，只有D包含竖轴，图中都是既有多轴又出现中心对称【练8】看各组成部分的对称性，134对称轴相交45°，256对称轴平行。【练9】对称轴数量相加【练1】发现第一幅图不对称，立马考虑曲直性。外曲/直内直/曲，图形全为曲直，排除BD，发现AC为不同在于内外曲直性【练2】优先考虑对称性，发现第四幅图不对称，然后考虑曲直性。结合内部对称轴方向+外部曲直性【例1】优先考虑","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"对称性，发现6不对称，曲直无法考虑，考虑开闭性。145一组，236一组【例2】146半开半闭。另一种更好的解释：146的面都是线连接，235面都是紧挨。数量规律 识别特征：元素不相同不相似、并且数量规律明显 点\u0026线\u0026一笔画 点 考点：线与线的交点（切点也是）数、注意出现圆后的点数 特征：线条交叉明显、一团线交叉（也有可能一笔画）、相切较多 线 考点：直线数量、曲线数量（一般不存在直线数量+曲线数量的题，需要分开数）、垂直平行关系、一笔画 特征：多边形、单一直线；曲线图形 一笔画 图形由一笔画成，特点：线条之间联通、奇点数=0或2（奇点：由一个点发射出奇数条线）、端点必为奇点（奇点数一定是偶数个） 考点：遇到特征图考虑笔画数 特征：明显存在一笔画图和其特征图 五角星（遇到时可能会考查线数量、点数量、 对称性和笔画数，可以结合其他的特征图判断考点） “日”字及其变形 “田”字及 其变形（“田”字共 4 个奇点，是两笔画图形） 圆相切/相交（圆相切和相交的点均发射出偶数条线，不是奇点）。 多笔画 笔画数=奇点数/2+分离图形笔画数 优先考虑一笔画，出现一笔画后，再看是不是多笔画的规律 题目：","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_3","order":3,"summary":"对称性，发现6不对称，曲直无法考虑，考虑开闭性。145一组，236一组【例2】146半开半闭。另一种更好的解释：146的面都是线连接，235面都是紧挨。数量规律 识别特征：元素不相同不相似、并且数量规律明显 点\u0026线\u0026一笔画 点 考点：线与线的交点（切点也是）数、注意出现圆后的点数 特征：线条交叉明显、一团线交叉（也有可能一笔画）、相切较多 线 考点：直线数量、曲线数量（一般不存在直线数量+曲线数量的题，需要分开数）、垂直平行关系、一笔画 特征：多边形、单一直线；曲线图形 一笔画 图形由一笔画成，特点：线条之间联通、奇点数=0或2（奇点：由一个点发射出奇数条线）、端点必为奇点（奇点数一定是偶数个） 考点：遇到特征图考虑笔画数 特征：明显存在一笔画图和其特征图 五角星（遇到时可能会考查线数量、点数量、 对称性和笔画数，可以结合其他的特征图判断考点） “日”字及其变形 “田”字及 其变形（“田”字共 4 个奇点，是两笔画图形） 圆相切/相交（圆相切和相交的点均发射出偶数条线，不是奇点）。 多笔画 笔画数=奇点数/2+分离图形笔画数 优先考虑一笔画，出现一笔画后，再看是不是多笔画的规律 题目：","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"【例2】不相同不相似，无全对称，考虑点。126二点，345四点。虽然134一笔画，但是6需要4笔。【练1】4图不对称，考虑点，但是正常数点不行，发现四图中都出现圆，找曲直交点/圆切点【练3】都出现圆，相切没规律，考虑圆内交点【例4】曲直性无法分类；点不行，曲线数量不行，看直线数量不行，两者合并发现曲-直相等。建议把各类特性写出来，不要只看一点【例5】首尾线垂直或平行【练3】汉字一般考笔画，线数，面，部分。笔画不行，线数发现左撇有关系【练4】数黑点没规律，数边没规律，两者相减有规律【练6】元素相同，都是三条线。三条线的移动【练7】同例5，但是平行的两条线方向不一致【练4】看对称，不能区分。看曲直不行。点肯定不行，出现一笔画24，考虑一笔画，135为多笔画，仅吉林会出现，一般都为同一规律面\u0026素\u0026角 面 封闭空间，面是白色，黑的不是面 考点：数量，形状 特征：图形被分隔、封闭面明显；生活化图形、粗线条图形中留空白区域 素 考点：优先看元素的种类数，其次元素的个数，最后是元素的替换 特征：多个独立小图形 另一考点：部分数（连续的黑色区域叫做一部分，数有几部分） 特征：生活化图形、黑色粗线条图形","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_4","order":4,"summary":"【例2】不相同不相似，无全对称，考虑点。126二点，345四点。虽然134一笔画，但是6需要4笔。【练1】4图不对称，考虑点，但是正常数点不行，发现四图中都出现圆，找曲直交点/圆切点【练3】都出现圆，相切没规律，考虑圆内交点【例4】曲直性无法分类；点不行，曲线数量不行，看直线数量不行，两者合并发现曲-直相等。建议把各类特性写出来，不要只看一点【例5】首尾线垂直或平行【练3】汉字一般考笔画，线数，面，部分。笔画不行，线数发现左撇有关系【练4】数黑点没规律，数边没规律，两者相减有规律【练6】元素相同，都是三条线。三条线的移动【练7】同例5，但是平行的两条线方向不一致【练4】看对称，不能区分。看曲直不行。点肯定不行，出现一笔画24，考虑一笔画，135为多笔画，仅吉林会出现，一般都为同一规律面\u0026素\u0026角 面 封闭空间，面是白色，黑的不是面 考点：数量，形状 特征：图形被分隔、封闭面明显；生活化图形、粗线条图形中留空白区域 素 考点：优先看元素的种类数，其次元素的个数，最后是元素的替换 特征：多个独立小图形 另一考点：部分数（连续的黑色区域叫做一部分，数有几部分） 特征：生活化图形、黑色粗线条图形","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":" 角 考点：内角数、细分为锐角、直角、钝角 特征：图形中出现扇形、改造图、折线图，优先考虑数角；图形中出现 直角时，可优先关注直角。 考到很少 生活化、黑线条图形常见考法 部分数 面（黑线条内留白较多，数字） 属性（对称、开闭） 题目：【例4】对称轴没规律；点线也没规律；发现面和轴一致。要记录下所有规律的数字。【例6】每个小图形由对称性，但是5太多。考虑面，都是5个面，但是每个图形其中最小的子图形的形状和其大轮廓一致，反之就是另3个。【练1】非常综合，首先判断对称性，排除A，曲直性交替排除B，面数量排除D【练4】数字考察：面、笔画、线。发现白面2个面，黑面3个面【练6】面无规律，发现每幅图三角形数量递增【例3】三角形变少，圆形逐渐变多，且仅这种图形，考虑元素替换，发现一个⚪=3个▲，每次递增一个▲。【练3】都包含三种元素，排除C，每幅图包含前幅图的一个元素，选A【练4】三种元素，五个元素，排除AD。发现每幅图形呈现311，221，311，221，311规律【练5】像这种内外圈图形，可以分开考虑，发现外圈2*3=6，内圈6=2*3【例4】第一行前两个就不符合黑白运算，考虑小元素的部分数，","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_5","order":5,"summary":" 角 考点：内角数、细分为锐角、直角、钝角 特征：图形中出现扇形、改造图、折线图，优先考虑数角；图形中出现 直角时，可优先关注直角。 考到很少 生活化、黑线条图形常见考法 部分数 面（黑线条内留白较多，数字） 属性（对称、开闭） 题目：【例4】对称轴没规律；点线也没规律；发现面和轴一致。要记录下所有规律的数字。【例6】每个小图形由对称性，但是5太多。考虑面，都是5个面，但是每个图形其中最小的子图形的形状和其大轮廓一致，反之就是另3个。【练1】非常综合，首先判断对称性，排除A，曲直性交替排除B，面数量排除D【练4】数字考察：面、笔画、线。发现白面2个面，黑面3个面【练6】面无规律，发现每幅图三角形数量递增【例3】三角形变少，圆形逐渐变多，且仅这种图形，考虑元素替换，发现一个⚪=3个▲，每次递增一个▲。【练3】都包含三种元素，排除C，每幅图包含前幅图的一个元素，选A【练4】三种元素，五个元素，排除AD。发现每幅图形呈现311，221，311，221，311规律【练5】像这种内外圈图形，可以分开考虑，发现外圈2*3=6，内圈6=2*3【例4】第一行前两个就不符合黑白运算，考虑小元素的部分数，","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"黑色部分为1、2、3【例2】注意数直角的两边都要数上【练1】一笔画不行、对称不行、看到改造图D，发现数角为2365，则应该数锐角而不是都数。特殊规律 功能元素 点观察点对其他图形的标记作用（角度、交点、边长） 观察点之间的关系，将两点连成线 箭头观察箭头的指向性 观察箭头之间的关系（垂直、平行） 特征：出现小黑点或者箭头等小元素【例3】连接两点【练1】对称性只有124，其他没有规律，pass。发现点在线上和点在交点上【练4】标记图形中最大和最小的角图形间关系 视频相离：图形间没有公共部分 相压：两个图形上下覆盖，被压图形有部分线条被遮盖，注意上下图形的区别 相交：图形间有公共部分，又可细分为以下 3 个考点，分别是相交于面、 相交于点、相交于边。 相交于面：可考查相交面的形状、面积等 相交于点：可考查相交点的位置（上下左右和内外）和数量 相交于边：1. 可考查相交于边的数量。2. 可考查相交边样式：长/短、包含/交错、曲/直等 题型特征：题干每幅图都出现两个元素或当几个封闭空间连在一起时。 题目：【例4】相同元素相交【练1】相交边的包含和交错关系【练2】相切点数量【练4】这题应该有敏感","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_6","order":6,"summary":"黑色部分为1、2、3【例2】注意数直角的两边都要数上【练1】一笔画不行、对称不行、看到改造图D，发现数角为2365，则应该数锐角而不是都数。特殊规律 功能元素 点观察点对其他图形的标记作用（角度、交点、边长） 观察点之间的关系，将两点连成线 箭头观察箭头的指向性 观察箭头之间的关系（垂直、平行） 特征：出现小黑点或者箭头等小元素【例3】连接两点【练1】对称性只有124，其他没有规律，pass。发现点在线上和点在交点上【练4】标记图形中最大和最小的角图形间关系 视频相离：图形间没有公共部分 相压：两个图形上下覆盖，被压图形有部分线条被遮盖，注意上下图形的区别 相交：图形间有公共部分，又可细分为以下 3 个考点，分别是相交于面、 相交于点、相交于边。 相交于面：可考查相交面的形状、面积等 相交于点：可考查相交点的位置（上下左右和内外）和数量 相交于边：1. 可考查相交于边的数量。2. 可考查相交边样式：长/短、包含/交错、曲/直等 题型特征：题干每幅图都出现两个元素或当几个封闭空间连在一起时。 题目：【例4】相同元素相交【练1】相交边的包含和交错关系【练2】相切点数量【练4】这题应该有敏感","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"性吧，图形由线连接和封闭图形其他规律 【例2】每个数字只出现一次，或者9+6+8+3=2+6+？+7选项和题目的对应关系【例6】第一行=第一列；第二行=第二列；第三行=第三列【例8】每列线条组合是米字【例9】优先数格子数，空间重构也会用到，排除AC。没时间优先选不规则图形。可以尝试在选项中进行拼接空间重构 技巧：所有方法都是排除错误选项 橡皮法 视频。不多说了，考场让带，直接画图即可。 六面体 相对面 同行或同列相隔一个面 “Z”字形两端 相邻面 折叠前后相邻关系保持不变 紧邻（挨着）的面是相邻面。外部构成直角的两条边是同一条边。四个格子的端点是相邻面 特征：图形方向明显，可直接唯一确定其相邻面位置。 箭头为相邻法、蓝色为相对面 画边法 结合选项，找一个特殊面的唯一点或唯一边 顺时针或逆时针方向描边 题干与选项对应面不一致——排除 A用到唯一边（注意是从一条边开始画，而不是点），B相对面，C唯一点 题目： 四面体和八面体 四面体 四面体的展开图只有两种情况，如下图，展开图中构成一条直线的两条边， 折合之后是同一条边 图 1 中的 a 和 b，c 和 d，e 和 f，折合以后是同一条边；","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_7","order":7,"summary":"性吧，图形由线连接和封闭图形其他规律 【例2】每个数字只出现一次，或者9+6+8+3=2+6+？+7选项和题目的对应关系【例6】第一行=第一列；第二行=第二列；第三行=第三列【例8】每列线条组合是米字【例9】优先数格子数，空间重构也会用到，排除AC。没时间优先选不规则图形。可以尝试在选项中进行拼接空间重构 技巧：所有方法都是排除错误选项 橡皮法 视频。不多说了，考场让带，直接画图即可。 六面体 相对面 同行或同列相隔一个面 “Z”字形两端 相邻面 折叠前后相邻关系保持不变 紧邻（挨着）的面是相邻面。外部构成直角的两条边是同一条边。四个格子的端点是相邻面 特征：图形方向明显，可直接唯一确定其相邻面位置。 箭头为相邻法、蓝色为相对面 画边法 结合选项，找一个特殊面的唯一点或唯一边 顺时针或逆时针方向描边 题干与选项对应面不一致——排除 A用到唯一边（注意是从一条边开始画，而不是点），B相对面，C唯一点 题目： 四面体和八面体 四面体 四面体的展开图只有两种情况，如下图，展开图中构成一条直线的两条边， 折合之后是同一条边 图 1 中的 a 和 b，c 和 d，e 和 f，折合以后是同一条边；","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":" 图 2 中的 a 和 b，c 和 d，剩余的 e 和 f，折合以后是同一条边。 解题技巧：箭头法（判定左、右、下三个方向的面） 图 1 中，在面2画箭头，则面3为其下面，面1为其左侧，面4为其右侧 图 2 中，面3为其底面，面1为其左侧，面4为其右侧。看箭头指向的左右下 八面体 钝角是公共边，顶点发出四个面 点 a 发出的四个面是 5，6，7 和 8。 点 b 发出的四个面呢？由于构成“ヘ”形的两条边，折合后是同一条边，那么 b 和 c 折合后是同一个点，所以 b 点发出的四个面是 2，3，6 和 7，同理，c 点发出的四个面也是 2，3，6 和 7。 蓝色公共边为5，8；红色为1，4；紫色为3，6 三视图、截面图、立体拼合 三视图 题型特征：通常出现分组分类题中，图 1 通常是立体图形，图 2 和图 3 通常是图 1 的三视图。 技巧： 观察到的三视图均是平面图。若选项的三视图是立体图形，则选项错误。 原图有线就有线，原图没线就没线。 被遮挡的时候，看不见被遮挡部分。注意有时候不会标出虚线 有些角度下弧会被压平。 先看轮廓排选项，再看细节选答案 【例5】选项方块数量不一致，优先数方","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_8","order":8,"summary":" 图 2 中的 a 和 b，c 和 d，剩余的 e 和 f，折合以后是同一条边。 解题技巧：箭头法（判定左、右、下三个方向的面） 图 1 中，在面2画箭头，则面3为其下面，面1为其左侧，面4为其右侧 图 2 中，面3为其底面，面1为其左侧，面4为其右侧。看箭头指向的左右下 八面体 钝角是公共边，顶点发出四个面 点 a 发出的四个面是 5，6，7 和 8。 点 b 发出的四个面呢？由于构成“ヘ”形的两条边，折合后是同一条边，那么 b 和 c 折合后是同一个点，所以 b 点发出的四个面是 2，3，6 和 7，同理，c 点发出的四个面也是 2，3，6 和 7。 蓝色公共边为5，8；红色为1，4；紫色为3，6 三视图、截面图、立体拼合 三视图 题型特征：通常出现分组分类题中，图 1 通常是立体图形，图 2 和图 3 通常是图 1 的三视图。 技巧： 观察到的三视图均是平面图。若选项的三视图是立体图形，则选项错误。 原图有线就有线，原图没线就没线。 被遮挡的时候，看不见被遮挡部分。注意有时候不会标出虚线 有些角度下弧会被压平。 先看轮廓排选项，再看细节选答案 【例5】选项方块数量不一致，优先数方","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"块数【例9】俯视图一致截面图 特征：题干中给出一个立体图形，问哪项能够（或不能）成为其截面。六面体的截面只能切出锐角三角形 圆柱体（1）圆（横切）（2）椭圆（斜切）（3）矩形（竖切）圆锥（1）圆（横切）（2）椭圆（斜切）（3）三角形（竖切）圆台（1）圆（横切）（2）椭圆（斜切）（3）梯形（竖切）【例3】可以分成两部分进行切割，A选项从对角线开始切正方体，然后到下半部分长方体后变长从而又是个梯形。【例5】BD选复杂的立体拼合 解题：凹凸有致：有凹必有凸，有凸必有凹。 【例4】其实还好，可以脑海里按它的位置摆好，因为位置肯定确定，①一定向左转，②一定开口向左 类比推理 语义关系 近义关系：理想∶梦想；锲而不舍∶坚持不懈 反义关系： 勇敢∶懦弱 言而有信∶言而无信 如果一级关系，即看意思（近反义关系）选不出唯一答案时，需进行二级辨析 常见二级辨析： 1.感情色彩（褒义、贬义、中性） 2.词语结构（如大同小异） 适用任何关系 比喻义、象征义：把一种事物比喻成另外的事物，或者词语本身的含义同时是另外一种事物的象征。 大义凛然∶卑躬屈膝 A.安分守己∶好高骛远 B.穷奢极欲∶节衣缩食 C.得心应手","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_9","order":9,"summary":"块数【例9】俯视图一致截面图 特征：题干中给出一个立体图形，问哪项能够（或不能）成为其截面。六面体的截面只能切出锐角三角形 圆柱体（1）圆（横切）（2）椭圆（斜切）（3）矩形（竖切）圆锥（1）圆（横切）（2）椭圆（斜切）（3）三角形（竖切）圆台（1）圆（横切）（2）椭圆（斜切）（3）梯形（竖切）【例3】可以分成两部分进行切割，A选项从对角线开始切正方体，然后到下半部分长方体后变长从而又是个梯形。【例5】BD选复杂的立体拼合 解题：凹凸有致：有凹必有凸，有凸必有凹。 【例4】其实还好，可以脑海里按它的位置摆好，因为位置肯定确定，①一定向左转，②一定开口向左 类比推理 语义关系 近义关系：理想∶梦想；锲而不舍∶坚持不懈 反义关系： 勇敢∶懦弱 言而有信∶言而无信 如果一级关系，即看意思（近反义关系）选不出唯一答案时，需进行二级辨析 常见二级辨析： 1.感情色彩（褒义、贬义、中性） 2.词语结构（如大同小异） 适用任何关系 比喻义、象征义：把一种事物比喻成另外的事物，或者词语本身的含义同时是另外一种事物的象征。 大义凛然∶卑躬屈膝 A.安分守己∶好高骛远 B.穷奢极欲∶节衣缩食 C.得心应手","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"∶百无一能 D.持之以恒∶虎头蛇尾先看语义：反义关系。A安分守己应该对应惹是生非；C：百无一能：什么都不会做。得心应手（又指做事顺利）对应束手无策。D：虎头蛇尾：言行不一致；有始无终。及逆行二次辨析，B是褒贬位置错误。沧桑∶白发 A.清纯∶酒窝 B.稚嫩∶乳牙 C.鲁莽∶健壮 D.博学∶眼镜白发象征沧桑，酒窝象征笑容，乳牙象征乳臭未干，健壮象征健康强壮，眼睛象征近视。指鹿为马：颠倒黑白 A．师心自用：固执己见 B．目无全牛：鼠目寸光 C．不以为然：不屑一顾 D．不孚众望：众望所归近义关系，排除BCD。师心自用：固执己见；刚愎自用：自以为是；目无全牛：技艺纯熟；不以为然：不同意；不孚众望：未符合大家的期望。陈词滥调：老生常谈 A．按部就班：循序渐进 B．博闻强识：见多识广 C．见义勇为：助人为乐 D．八面玲珑：面面俱到近义关系，排除C，二级辨析，1贬2中，排除AB。八面玲珑：为人处事圆滑，善于很周到地应付各个方面。逻辑关系 全同关系：浪漫∶罗曼蒂克；老鼠∶耗子 并列关系 矛盾关系：生∶死。反义关系不行，考虑并矛 反对关系：苹果∶香蕉。水果中有这些，但是苹果不能是香蕉 包容关系 种属关系：","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_10","order":10,"summary":"∶百无一能 D.持之以恒∶虎头蛇尾先看语义：反义关系。A安分守己应该对应惹是生非；C：百无一能：什么都不会做。得心应手（又指做事顺利）对应束手无策。D：虎头蛇尾：言行不一致；有始无终。及逆行二次辨析，B是褒贬位置错误。沧桑∶白发 A.清纯∶酒窝 B.稚嫩∶乳牙 C.鲁莽∶健壮 D.博学∶眼镜白发象征沧桑，酒窝象征笑容，乳牙象征乳臭未干，健壮象征健康强壮，眼睛象征近视。指鹿为马：颠倒黑白 A．师心自用：固执己见 B．目无全牛：鼠目寸光 C．不以为然：不屑一顾 D．不孚众望：众望所归近义关系，排除BCD。师心自用：固执己见；刚愎自用：自以为是；目无全牛：技艺纯熟；不以为然：不同意；不孚众望：未符合大家的期望。陈词滥调：老生常谈 A．按部就班：循序渐进 B．博闻强识：见多识广 C．见义勇为：助人为乐 D．八面玲珑：面面俱到近义关系，排除C，二级辨析，1贬2中，排除AB。八面玲珑：为人处事圆滑，善于很周到地应付各个方面。逻辑关系 全同关系：浪漫∶罗曼蒂克；老鼠∶耗子 并列关系 矛盾关系：生∶死。反义关系不行，考虑并矛 反对关系：苹果∶香蕉。水果中有这些，但是苹果不能是香蕉 包容关系 种属关系：","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"A 是 B 的一种。苹果∶水果 组成关系：A 是 B 的一个组成部分。轮胎∶汽车 交叉关系 女士∶公务员 对应关系 材料 例：小麦∶馒头 工艺 例：白酒∶发酵 物理变化、化学变化 功能 例：银行卡∶支付 主要功能、次要功能 属性 例：盐∶咸 必然属性、或然属性 时间顺序 例：学习∶考试 主体一致、主体不一致 依据 例：航行∶航线 因果 例：炎热∶中暑 职业 例：老师∶上课 五行：木火土金水 A．五经：诗书礼易大学 B．五音：宫商韵征羽 C．五色：青黄赤白绿 D．五味：酸苦甘辛咸【全同关系-练1】诗书礼易春秋、宫商角徵羽、青赤黄白黑动：静A.东∶西 B.贫：富 C.黑∶白 D.曲∶直【并列-矛盾-练1】东南西北、贫小康富...、青赤黄白黑（ ） 之于 钢琴 相当于 马褂 之于 （ ） A.羌笛∶长袍 B.胡琴：西服 C.京剧∶长裙 D.琴键∶唐装【并列-反对-练3】中国之于西方。琴的种类、衣服的种类，选B麻雀：动物：生物链 A.豆浆∶早餐∶豆制品 B.开水∶纸杯∶便利品 C.发卡∶首饰∶妆扮品 D.钢笔∶电脑∶办公品【包含关系-练3】麻雀是动物的一种，动物是生物链组成部分。A豆浆是豆制品","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_11","order":11,"summary":"A 是 B 的一种。苹果∶水果 组成关系：A 是 B 的一个组成部分。轮胎∶汽车 交叉关系 女士∶公务员 对应关系 材料 例：小麦∶馒头 工艺 例：白酒∶发酵 物理变化、化学变化 功能 例：银行卡∶支付 主要功能、次要功能 属性 例：盐∶咸 必然属性、或然属性 时间顺序 例：学习∶考试 主体一致、主体不一致 依据 例：航行∶航线 因果 例：炎热∶中暑 职业 例：老师∶上课 五行：木火土金水 A．五经：诗书礼易大学 B．五音：宫商韵征羽 C．五色：青黄赤白绿 D．五味：酸苦甘辛咸【全同关系-练1】诗书礼易春秋、宫商角徵羽、青赤黄白黑动：静A.东∶西 B.贫：富 C.黑∶白 D.曲∶直【并列-矛盾-练1】东南西北、贫小康富...、青赤黄白黑（ ） 之于 钢琴 相当于 马褂 之于 （ ） A.羌笛∶长袍 B.胡琴：西服 C.京剧∶长裙 D.琴键∶唐装【并列-反对-练3】中国之于西方。琴的种类、衣服的种类，选B麻雀：动物：生物链 A.豆浆∶早餐∶豆制品 B.开水∶纸杯∶便利品 C.发卡∶首饰∶妆扮品 D.钢笔∶电脑∶办公品【包含关系-练3】麻雀是动物的一种，动物是生物链组成部分。A豆浆是豆制品","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"的一种，B开水是水的一种，D钢笔是笔的一种。文物：建筑 A.烹饪∶佐料 B.故宫∶楼房 C.诗人∶教授 D.皮鞋∶布鞋【交叉关系-练1】文物里有建筑，建筑里有文物。A烹饪用佐料，B故宫是楼房，C诗人里有教授，教授里有诗人。D并列里的反对。玉石∶雕琢∶玉器 A.蚕丝∶织造∶丝绸 B.粮食∶酿造∶美酒 C.生铁∶冶炼∶钢材 D.蚊香∶点燃∶烟雾【对饮关系-例3】玉石物理雕琢玉器。A木材∶抽屉∶收纳 A.钢铁∶剪刀∶切割 B.棉花∶毛线∶保暖 C.城墙∶石头∶防御 D.橡胶∶气垫∶缓冲【对应关系-例4】木材是抽屉的原材料，收纳是抽屉的功能。D白醋∶消毒 A.热水器∶加热 B.汽油∶去渍 C.白糖∶调味 D.人参∶滋补【对应关系-例5】白醋的次要功能是消毒。B失之毫厘∶谬以千里 A.三十六计∶走为上计 B.召之即来∶挥之即去 C.种瓜得瓜∶种豆得豆 D.前人栽树∶后人乘凉【对应关系-例14】因为毫厘，所以千里。C内部因果。D外部因果故人西辞黄鹤楼 对于 （ ） 相当于 （ ） 对于 怀古 A.出游 越王勾践破吴归 B.场所 千古兴亡多少事 C.送别 折戟沉沙铁未销 D.离别 西出阳关无故人【比","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_12","order":12,"summary":"的一种，B开水是水的一种，D钢笔是笔的一种。文物：建筑 A.烹饪∶佐料 B.故宫∶楼房 C.诗人∶教授 D.皮鞋∶布鞋【交叉关系-练1】文物里有建筑，建筑里有文物。A烹饪用佐料，B故宫是楼房，C诗人里有教授，教授里有诗人。D并列里的反对。玉石∶雕琢∶玉器 A.蚕丝∶织造∶丝绸 B.粮食∶酿造∶美酒 C.生铁∶冶炼∶钢材 D.蚊香∶点燃∶烟雾【对饮关系-例3】玉石物理雕琢玉器。A木材∶抽屉∶收纳 A.钢铁∶剪刀∶切割 B.棉花∶毛线∶保暖 C.城墙∶石头∶防御 D.橡胶∶气垫∶缓冲【对应关系-例4】木材是抽屉的原材料，收纳是抽屉的功能。D白醋∶消毒 A.热水器∶加热 B.汽油∶去渍 C.白糖∶调味 D.人参∶滋补【对应关系-例5】白醋的次要功能是消毒。B失之毫厘∶谬以千里 A.三十六计∶走为上计 B.召之即来∶挥之即去 C.种瓜得瓜∶种豆得豆 D.前人栽树∶后人乘凉【对应关系-例14】因为毫厘，所以千里。C内部因果。D外部因果故人西辞黄鹤楼 对于 （ ） 相当于 （ ） 对于 怀古 A.出游 越王勾践破吴归 B.场所 千古兴亡多少事 C.送别 折戟沉沙铁未销 D.离别 西出阳关无故人【比","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"喻义-练7】故事象征送别，排除AB，C表怀古，D念友语法关系 主谓关系 例：学生∶学习 动宾关系 例：学习∶功课 主宾关系 例：学生∶功课 造句子原则：（1）能不加字就不加字；能少加字就少加字。（2）加字尽量加一样的。 讨论∶会议∶方案 A.合作∶课题∶计划 B.研究∶手机∶销量C.分析∶汽车∶技术 D.调研∶基层∶实情【练2】会议里讨论方案。基层里调研实情风险∶规避∶损失 A.保险∶购买∶赔偿 B.老人∶关爱∶长寿 C.锻炼∶加强∶肥胖 D.军队∶保卫∶战争【练3】规避风险减少损失。加强锻炼减轻肥胖定义判断 每道题先给出一个概念的定义，然后分别列出四种情况，要求报考者严格依据定义选出一个最符合最不符合该定义的答案。 解题思维： 看清提问方式，为“属于/符合”，“不属于/不符合”定义等 识别有效信息——找准关键词、关键句 逐一分析选项，当纠结时采用对比的思维进行排除，最终选择更符合题干要求的选项。对比思维，择优选择 识别有效信息 主体、客体 主客体不符合的选项一定不符合定义！ 不是每题一定都有主体和客体，但是出现了要重点看！ 条件+结果 方式：通过，利用； 原因：因为，由于； 时间：当","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_13","order":13,"summary":"喻义-练7】故事象征送别，排除AB，C表怀古，D念友语法关系 主谓关系 例：学生∶学习 动宾关系 例：学习∶功课 主宾关系 例：学生∶功课 造句子原则：（1）能不加字就不加字；能少加字就少加字。（2）加字尽量加一样的。 讨论∶会议∶方案 A.合作∶课题∶计划 B.研究∶手机∶销量C.分析∶汽车∶技术 D.调研∶基层∶实情【练2】会议里讨论方案。基层里调研实情风险∶规避∶损失 A.保险∶购买∶赔偿 B.老人∶关爱∶长寿 C.锻炼∶加强∶肥胖 D.军队∶保卫∶战争【练3】规避风险减少损失。加强锻炼减轻肥胖定义判断 每道题先给出一个概念的定义，然后分别列出四种情况，要求报考者严格依据定义选出一个最符合最不符合该定义的答案。 解题思维： 看清提问方式，为“属于/符合”，“不属于/不符合”定义等 识别有效信息——找准关键词、关键句 逐一分析选项，当纠结时采用对比的思维进行排除，最终选择更符合题干要求的选项。对比思维，择优选择 识别有效信息 主体、客体 主客体不符合的选项一定不符合定义！ 不是每题一定都有主体和客体，但是出现了要重点看！ 条件+结果 方式：通过，利用； 原因：因为，由于； 时间：当","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"……时； 结果：导致，从而； 目的：以，达到 包含定义的句子优先看 看完定义就懂，就不需要再读后面的。一般在第一句 读不懂，看补充说明：即、也就是说 多定义 问啥看啥。看清题干问的是哪个定义，重点看目标定义 比较定义。纠结两个选项时，再与其他定义比较 经营性资产是在生产和流通中能够为社会提供商品或劳务的资产。经营性资产的使用单位是具有法人地位的企业，其运营要以追求经济效益为原则。从会计角度看，主要指企业因盈利目的而持有，且实际也具有盈利能力的资产。 根据上述定义，下列不属于“经营性资产”的是： A．某电视机厂中积压的黑白电视机 B．建设中尚未投入使用的水力发电站 C．某外贸公司用于交纳税金的银行存款 D．某重点中学新购入的实验室设备和器材【主客体-练2】主体是具有盈利能力的资产。C的存款也是具有盈利能力的资产。D是用于教学，不追求经济效益。人类增强就是利用生物医学技术、智能技术、神经科学技术、信息技术和纳米技术等高新技术手段使健康人类的机体功能或能力超出其正常范围，从而使人类的体貌、寿命、人格、认知和行为等能力发生根本性变化并具有全新能力的一种技术手段，其目的是显著提高人类生活的质量。","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_14","order":14,"summary":"……时； 结果：导致，从而； 目的：以，达到 包含定义的句子优先看 看完定义就懂，就不需要再读后面的。一般在第一句 读不懂，看补充说明：即、也就是说 多定义 问啥看啥。看清题干问的是哪个定义，重点看目标定义 比较定义。纠结两个选项时，再与其他定义比较 经营性资产是在生产和流通中能够为社会提供商品或劳务的资产。经营性资产的使用单位是具有法人地位的企业，其运营要以追求经济效益为原则。从会计角度看，主要指企业因盈利目的而持有，且实际也具有盈利能力的资产。 根据上述定义，下列不属于“经营性资产”的是： A．某电视机厂中积压的黑白电视机 B．建设中尚未投入使用的水力发电站 C．某外贸公司用于交纳税金的银行存款 D．某重点中学新购入的实验室设备和器材【主客体-练2】主体是具有盈利能力的资产。C的存款也是具有盈利能力的资产。D是用于教学，不追求经济效益。人类增强就是利用生物医学技术、智能技术、神经科学技术、信息技术和纳米技术等高新技术手段使健康人类的机体功能或能力超出其正常范围，从而使人类的体貌、寿命、人格、认知和行为等能力发生根本性变化并具有全新能力的一种技术手段，其目的是显著提高人类生活的质量。","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":" 根据上述定义，下列选项不属于人类增强的是：A．演员赵某用药剂延缓衰老 B．医生建议老张去做心脏搭桥手术 C．医生将传感器植入老陈大脑提高其记忆力 D．小王为了增加自己的身高服用类增高药物【条件+结果-练2】通过医学技术导致健康人类xxx。B做手术是治疗。斜杠青年：指不满足于从事单一职业，追求拥有多重职业身份及多元生活方式的年轻人。他们在自我介绍时往往喜欢用斜杠来区分自己的不同身份，如：张三，金牌律师/企划师/专栏作家。下列属于斜杠青年的是： A 最近两三年，八零后导演黄某某先后出演了 10 多次男配角，去年在一个著名的国际电影节上斩获了最佳男配角奖 B 小丁在国外获得博士学位后，任职于国内一所著名高校，因科研成就突出， 被破格聘为教授，并入选省“双百”人才计划 C 某公司程序员小陈爱好广泛，性格温和，人际关系融洽，节假日常邀上三五个好友一起登山、打球、游泳 D 李总做过保安，送过快递，当过安装工，开过小杂货店，他经常自豪地向员工讲述自己 30 多年来丰富的职业经历【练5】多重身份。B单教授职业，C爱好≠生活方式D年轻人。文化自觉是指生活在一定文化中的人，对自己的文化有“自知之明”，即","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_15","order":15,"summary":" 根据上述定义，下列选项不属于人类增强的是：A．演员赵某用药剂延缓衰老 B．医生建议老张去做心脏搭桥手术 C．医生将传感器植入老陈大脑提高其记忆力 D．小王为了增加自己的身高服用类增高药物【条件+结果-练2】通过医学技术导致健康人类xxx。B做手术是治疗。斜杠青年：指不满足于从事单一职业，追求拥有多重职业身份及多元生活方式的年轻人。他们在自我介绍时往往喜欢用斜杠来区分自己的不同身份，如：张三，金牌律师/企划师/专栏作家。下列属于斜杠青年的是： A 最近两三年，八零后导演黄某某先后出演了 10 多次男配角，去年在一个著名的国际电影节上斩获了最佳男配角奖 B 小丁在国外获得博士学位后，任职于国内一所著名高校，因科研成就突出， 被破格聘为教授，并入选省“双百”人才计划 C 某公司程序员小陈爱好广泛，性格温和，人际关系融洽，节假日常邀上三五个好友一起登山、打球、游泳 D 李总做过保安，送过快递，当过安装工，开过小杂货店，他经常自豪地向员工讲述自己 30 多年来丰富的职业经历【练5】多重身份。B单教授职业，C爱好≠生活方式D年轻人。文化自觉是指生活在一定文化中的人，对自己的文化有“自知之明”，即","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"明白它的来历、形成过程、特色和发展趋向，从而增强自身文化转型的能力，并获得在新的时代条件下进行文化选择的能力和地位。此外， 文化自觉还表现为应具有世界眼光，能够理解别的民族的文化，增强与不同文化之间接触、对话、相处的能力。 根据上述定义，下列选项属于文化自觉的是： A．经谈判，中方同意增加美国电影进入中国市场的配额 B．为保护贵州梭嘎苗族文化习俗建立了梭嘎生态博物馆 C．赵武灵王的“胡服骑射”与北魏拓跋氏的“禁断胡语” D．湖北省襄樊市与河南省南阳市都自称是“诸葛亮故里”【包含定义-练5】即进行补充说明。A没提文化，B没提文化转型，D不了解自身来历。C学习其他文化并提高自己。农业干旱是指在作物生育期内，由于土壤水分不足而造成作物体内水分亏缺，影响作物正常生长发育。水文干旱是指由于降水的长期短缺而造成某段时间内地表水或地下水收支不平衡，出现水分短缺，使江河流量、 湖泊水位、水库蓄水等减少的现象。社会经济干旱是指由自然系统与人类社会经济系统中水资源供需不平衡造成的异常水分短缺现象，如果需大于供，就会发生社会经济干旱。 根据上述定义，下列选项属于社会经济干旱范畴的是： A．一月未雨，某著名河","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_16","order":16,"summary":"明白它的来历、形成过程、特色和发展趋向，从而增强自身文化转型的能力，并获得在新的时代条件下进行文化选择的能力和地位。此外， 文化自觉还表现为应具有世界眼光，能够理解别的民族的文化，增强与不同文化之间接触、对话、相处的能力。 根据上述定义，下列选项属于文化自觉的是： A．经谈判，中方同意增加美国电影进入中国市场的配额 B．为保护贵州梭嘎苗族文化习俗建立了梭嘎生态博物馆 C．赵武灵王的“胡服骑射”与北魏拓跋氏的“禁断胡语” D．湖北省襄樊市与河南省南阳市都自称是“诸葛亮故里”【包含定义-练5】即进行补充说明。A没提文化，B没提文化转型，D不了解自身来历。C学习其他文化并提高自己。农业干旱是指在作物生育期内，由于土壤水分不足而造成作物体内水分亏缺，影响作物正常生长发育。水文干旱是指由于降水的长期短缺而造成某段时间内地表水或地下水收支不平衡，出现水分短缺，使江河流量、 湖泊水位、水库蓄水等减少的现象。社会经济干旱是指由自然系统与人类社会经济系统中水资源供需不平衡造成的异常水分短缺现象，如果需大于供，就会发生社会经济干旱。 根据上述定义，下列选项属于社会经济干旱范畴的是： A．一月未雨，某著名河","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"流流域出现大规模的河床裸露现象 B．地铁建设施工队不慎挖破水管，导致几个小区停水一天 C．常年少雨致使某工业区推行按时段浮动征收水费的办法 D．半月不曾下雨，某地水稻出现穗长缩短、穗粒减少现象【多定义-练1】优先看社会经济干旱，选C。A水文干旱，D农业干旱，B挖破水管与自然系统无关。同构选项排除法 同构选项——意思相似、结构相似的选项。 解题思维：同构选项如果出现，直接排除。 往往出现在选非题中，只能选择一个答案。 何时使用同构选项： （1）题干读不懂，需要比较选项。 （2）题干可以读懂，但利用同构可以加速解题。 沉锚效应，指的是人们在对某事作出判断时，易受第一印象或第一信息支配，就像沉入海底的锚一样把人们的思想固定在某处。第一印象和先入为主是其在社会生活中的表现形式。 根据上述定义，下列选项没有应用到沉锚效应的是（）。 A.一家粥店服务员为客人盛粥后总问：“加一个鸡蛋还是两个？”另一家服务员总问：“加不加鸡蛋？”头一家店日销售额总高于后一家 B.男孩邀请心仪女生说：“出去玩好吗？”女孩觉得拒绝好像很自然，答应显得太主动，所以就说：“下次吧。”男孩认为女孩无意与他交往 C.邻居偷走华盛","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_17","order":17,"summary":"流流域出现大规模的河床裸露现象 B．地铁建设施工队不慎挖破水管，导致几个小区停水一天 C．常年少雨致使某工业区推行按时段浮动征收水费的办法 D．半月不曾下雨，某地水稻出现穗长缩短、穗粒减少现象【多定义-练1】优先看社会经济干旱，选C。A水文干旱，D农业干旱，B挖破水管与自然系统无关。同构选项排除法 同构选项——意思相似、结构相似的选项。 解题思维：同构选项如果出现，直接排除。 往往出现在选非题中，只能选择一个答案。 何时使用同构选项： （1）题干读不懂，需要比较选项。 （2）题干可以读懂，但利用同构可以加速解题。 沉锚效应，指的是人们在对某事作出判断时，易受第一印象或第一信息支配，就像沉入海底的锚一样把人们的思想固定在某处。第一印象和先入为主是其在社会生活中的表现形式。 根据上述定义，下列选项没有应用到沉锚效应的是（）。 A.一家粥店服务员为客人盛粥后总问：“加一个鸡蛋还是两个？”另一家服务员总问：“加不加鸡蛋？”头一家店日销售额总高于后一家 B.男孩邀请心仪女生说：“出去玩好吗？”女孩觉得拒绝好像很自然，答应显得太主动，所以就说：“下次吧。”男孩认为女孩无意与他交往 C.邻居偷走华盛","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"顿的马被发现拒不承认，华盛顿捂住马的双眼问邻居：“马哪只眼是瞎的？”邻居说：“右眼。”事实上，马的两只眼睛都没毛病 D.你去商场闲逛，导购小姐诱导说：“反正今天是出来买鞋的，甲或者乙都很适合你的气质，请选一双吧。”然后你就挑选了其中一双【同构-例1】学撩妹技巧。ACD都给定选项让人选择，B只是提供宏观选择。二难推理是由两个假言判断和一个选言判断作前提构成的推理。假言判断是断定一个事物情况的存在（称为前件）是另一个事物情况存在（称为后件）的条件判断。选言判断是断定在几种可能情况下，至少有一种情况存在的判断。二难推理是通过运用选言判断来肯定或否定假言判断，从而来肯定或否定假言判断的后件或前件存在或不存在的一种推理形式。 根据上述定义，下列不属于二难推理的是： A.如果刺激老虎，它是要吃人的；如果不刺激它，它也是要吃人的；或是刺激它，或是不刺激它，所以老虎总是要吃人的 B.如果张三是杀人犯，那么他有作案时间；如果张三是杀人犯，那么他有作案动机；张三或者没有作案时间，或者没有作案动机，所以他不是杀人犯 C.如果今天下午下大雨，那么操场就要积水；如果操场积水，那么球赛就要延期；所以，如果今天球赛","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_18","order":18,"summary":"顿的马被发现拒不承认，华盛顿捂住马的双眼问邻居：“马哪只眼是瞎的？”邻居说：“右眼。”事实上，马的两只眼睛都没毛病 D.你去商场闲逛，导购小姐诱导说：“反正今天是出来买鞋的，甲或者乙都很适合你的气质，请选一双吧。”然后你就挑选了其中一双【同构-例1】学撩妹技巧。ACD都给定选项让人选择，B只是提供宏观选择。二难推理是由两个假言判断和一个选言判断作前提构成的推理。假言判断是断定一个事物情况的存在（称为前件）是另一个事物情况存在（称为后件）的条件判断。选言判断是断定在几种可能情况下，至少有一种情况存在的判断。二难推理是通过运用选言判断来肯定或否定假言判断，从而来肯定或否定假言判断的后件或前件存在或不存在的一种推理形式。 根据上述定义，下列不属于二难推理的是： A.如果刺激老虎，它是要吃人的；如果不刺激它，它也是要吃人的；或是刺激它，或是不刺激它，所以老虎总是要吃人的 B.如果张三是杀人犯，那么他有作案时间；如果张三是杀人犯，那么他有作案动机；张三或者没有作案时间，或者没有作案动机，所以他不是杀人犯 C.如果今天下午下大雨，那么操场就要积水；如果操场积水，那么球赛就要延期；所以，如果今天球赛","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"不延期，那么今天下午没有下大雨 D.如果打人的行为触犯了法律，那么要受到法律处罚；如果打人的行为没有触犯法律，也要受到社会舆论的谴责；打人的行为或是触犯了法律，或者没有触犯法律，所以或是要受到法律处罚，或者要受到社会舆论的谴责【练1】A如果...如果，B如果...那么，C如果...那么，D如果...那么逻辑推理☆ 翻译推理（基础） 特征：明显的逻辑关联词；提问方式：“可以推出”、“不能推出” 解题：先翻译，再推理 “前推后”关键词：如果/就/都/一定 如果...那么... 只要...就...（区分只有...才） 为了...一定... 所有...都... ...是...的充分条件 逆否等价A→B 等价于 否B→否A 肯前必肯后；否后必否前；否前肯后不确定 “后推前”关键词：只有...才 不...不... 除非...否则不...（除非..否则... 转换成 否后） ...是...的基础/假设/前提/关键 ...是...的必要/必不可少的条件 谁关键/必不可少谁放在箭头后面 且/或A 且 B：二者同时成立 并列关系：和、既…又… 递进关系：甚至/而且/还... 转折关系：但是/然而/却...","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_19","order":19,"summary":"不延期，那么今天下午没有下大雨 D.如果打人的行为触犯了法律，那么要受到法律处罚；如果打人的行为没有触犯法律，也要受到社会舆论的谴责；打人的行为或是触犯了法律，或者没有触犯法律，所以或是要受到法律处罚，或者要受到社会舆论的谴责【练1】A如果...如果，B如果...那么，C如果...那么，D如果...那么逻辑推理☆ 翻译推理（基础） 特征：明显的逻辑关联词；提问方式：“可以推出”、“不能推出” 解题：先翻译，再推理 “前推后”关键词：如果/就/都/一定 如果...那么... 只要...就...（区分只有...才） 为了...一定... 所有...都... ...是...的充分条件 逆否等价A→B 等价于 否B→否A 肯前必肯后；否后必否前；否前肯后不确定 “后推前”关键词：只有...才 不...不... 除非...否则不...（除非..否则... 转换成 否后） ...是...的基础/假设/前提/关键 ...是...的必要/必不可少的条件 谁关键/必不可少谁放在箭头后面 且/或A 且 B：二者同时成立 并列关系：和、既…又… 递进关系：甚至/而且/还... 转折关系：但是/然而/却...","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":" 标点符号：、，； A 或 B：二者至少一个成立 ...和...至少有一个 或关系确定时，否1→1 要么 A，要么 B：二者只有一个成立 要么…要么…：…和…只有一个。 德·摩根定律-（A 且 B）＝ -A 或-B -（A 或 B）＝ -A 且-B 非号放进去，“且”变“或”，“或”变“且” 某学生考试作弊被学院监考老师发现。如果老师将此事向学校上报，这个学生会被学校开除；如果这个学生被开除，学院的年终考核会被一票否决。如果老师未将此事向学校上报，学生考试作弊现象将愈演愈烈。 由此可以推出（）。 A.如果学院的年终考核未被一票否决，则学生考试作弊现象将愈演愈烈 B.如果学院的年终考核被一票否决，作弊现象不会愈演愈烈 C.如果该学生被开除，说明老师已将此事向学校上报 D.如果作弊现象愈演愈烈，说明该学生没有被开除【前推后·例2】上报→开除；开除→否决；-上报→现象 等价于 -现象→上报，即-现象→上报→开除→否决。A：-否决→-开除→-上报→现象【后推前·练1】己所不欲，勿施于人。施于人→己所欲只要不起雾，飞机就能起飞。 以下哪项正确地表达了上述断定： （1）如果飞机按时起飞，则一定没有","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_20","order":20,"summary":" 标点符号：、，； A 或 B：二者至少一个成立 ...和...至少有一个 或关系确定时，否1→1 要么 A，要么 B：二者只有一个成立 要么…要么…：…和…只有一个。 德·摩根定律-（A 且 B）＝ -A 或-B -（A 或 B）＝ -A 且-B 非号放进去，“且”变“或”，“或”变“且” 某学生考试作弊被学院监考老师发现。如果老师将此事向学校上报，这个学生会被学校开除；如果这个学生被开除，学院的年终考核会被一票否决。如果老师未将此事向学校上报，学生考试作弊现象将愈演愈烈。 由此可以推出（）。 A.如果学院的年终考核未被一票否决，则学生考试作弊现象将愈演愈烈 B.如果学院的年终考核被一票否决，作弊现象不会愈演愈烈 C.如果该学生被开除，说明老师已将此事向学校上报 D.如果作弊现象愈演愈烈，说明该学生没有被开除【前推后·例2】上报→开除；开除→否决；-上报→现象 等价于 -现象→上报，即-现象→上报→开除→否决。A：-否决→-开除→-上报→现象【后推前·练1】己所不欲，勿施于人。施于人→己所欲只要不起雾，飞机就能起飞。 以下哪项正确地表达了上述断定： （1）如果飞机按时起飞，则一定没有","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"起雾（2）如果飞机不按时起飞，则一定起雾（3）除非起雾，否则飞机按时起飞【后推前·练4】不起雾→起飞。（1）起飞→不起雾。（2）不起飞→起雾。（3）起飞 转换成 不起飞→起雾。（2）（3）逆否等价题目某高校外语教研室新招进五位外语老师，每位老师只教授一门外语。并且满足以下条件：（1）如果小钱教德语，那么小孙不教俄语 （2）或者小李教德语，或者小钱教德语 （3）如果小孙不教俄语，那么小赵不教法语（4）或者小赵教法语，或者小周不教英语 以下哪项如果为真，可以得出“小李教德语”的结论？（） A.小孙不教俄语 B.小钱教德语 C.小周教英语 D.小赵不教法语【且或·例2】（1）钱德→孙不俄（2）李德或钱德（3）孙不俄→赵不法（4）赵法或周不英。周英→赵法（否1推1）→孙俄（逆否）→钱不德（逆否）→李德（否1推1）只要企业信用风险上升和有效信贷需求不足，银行就会陷入“资产荒”。 如果上述断定为真，银行没有陷入“资产荒”，那么？【德摩根·例3】风险且需求→银行 等价于 否银行→否风险或否需求苗苗是某少儿舞蹈班学生，她喜欢民族舞。对于该舞蹈班学生，她们或者喜欢拉丁舞，或者喜欢芭蕾舞；喜欢民族舞的，则","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_21","order":21,"summary":"起雾（2）如果飞机不按时起飞，则一定起雾（3）除非起雾，否则飞机按时起飞【后推前·练4】不起雾→起飞。（1）起飞→不起雾。（2）不起飞→起雾。（3）起飞 转换成 不起飞→起雾。（2）（3）逆否等价题目某高校外语教研室新招进五位外语老师，每位老师只教授一门外语。并且满足以下条件：（1）如果小钱教德语，那么小孙不教俄语 （2）或者小李教德语，或者小钱教德语 （3）如果小孙不教俄语，那么小赵不教法语（4）或者小赵教法语，或者小周不教英语 以下哪项如果为真，可以得出“小李教德语”的结论？（） A.小孙不教俄语 B.小钱教德语 C.小周教英语 D.小赵不教法语【且或·例2】（1）钱德→孙不俄（2）李德或钱德（3）孙不俄→赵不法（4）赵法或周不英。周英→赵法（否1推1）→孙俄（逆否）→钱不德（逆否）→李德（否1推1）只要企业信用风险上升和有效信贷需求不足，银行就会陷入“资产荒”。 如果上述断定为真，银行没有陷入“资产荒”，那么？【德摩根·例3】风险且需求→银行 等价于 否银行→否风险或否需求苗苗是某少儿舞蹈班学生，她喜欢民族舞。对于该舞蹈班学生，她们或者喜欢拉丁舞，或者喜欢芭蕾舞；喜欢民族舞的，则","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"不喜欢芭蕾舞。以下哪项如果为真，可推出苗苗喜欢街舞这一结论？ A．舞蹈班有些喜欢拉丁舞的学生也喜欢街舞B．舞蹈班学生中，喜欢拉丁舞的都喜欢街舞 C．舞蹈班学生喜欢的舞蹈只局限于民族舞、拉丁舞、芭蕾舞和街舞 D．民族舞和街舞比芭蕾舞更容易学【综合·练1】题目：拉丁或芭蕾；民族→不芭；苗→民族→不芭→拉丁。A拉丁或街舞。B拉丁且街舞即拉丁→街舞组合排列 特征：两组及两组以上对象，以及之间的关系 解题：排除法、代入法 题干条件确定，优先排除 不确定，尝试代入 辅助解题 最大信息（条件中出现次数最多的词）作为推理起点 符号：“＞”、“＜” 往往涉及年龄、成绩、收入、身高等大小比较 列表格 某单位要选拔人才下乡挂职。符合条件的人有甲、乙、 丙、丁、戊、己，人事部门、组织部门和办公室分别提出了自己的要求： 人事部门：丙、丁两人中只能去一人组织部门：若丁不去，则戊也不能去 办公室：甲、丙和己三人必须留下一个 由此可以推出，能够同时满足三个部门要求的派出方案是（）。 A.乙、丙、丁、戊 B.乙、丙、戊 C.甲、乙、丙、己 D.甲、乙、丙【排除法·例2】人事排除A；组织：丁不→戍不 \u0026lt;=\u003e 戍→丁","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_22","order":22,"summary":"不喜欢芭蕾舞。以下哪项如果为真，可推出苗苗喜欢街舞这一结论？ A．舞蹈班有些喜欢拉丁舞的学生也喜欢街舞B．舞蹈班学生中，喜欢拉丁舞的都喜欢街舞 C．舞蹈班学生喜欢的舞蹈只局限于民族舞、拉丁舞、芭蕾舞和街舞 D．民族舞和街舞比芭蕾舞更容易学【综合·练1】题目：拉丁或芭蕾；民族→不芭；苗→民族→不芭→拉丁。A拉丁或街舞。B拉丁且街舞即拉丁→街舞组合排列 特征：两组及两组以上对象，以及之间的关系 解题：排除法、代入法 题干条件确定，优先排除 不确定，尝试代入 辅助解题 最大信息（条件中出现次数最多的词）作为推理起点 符号：“＞”、“＜” 往往涉及年龄、成绩、收入、身高等大小比较 列表格 某单位要选拔人才下乡挂职。符合条件的人有甲、乙、 丙、丁、戊、己，人事部门、组织部门和办公室分别提出了自己的要求： 人事部门：丙、丁两人中只能去一人组织部门：若丁不去，则戊也不能去 办公室：甲、丙和己三人必须留下一个 由此可以推出，能够同时满足三个部门要求的派出方案是（）。 A.乙、丙、丁、戊 B.乙、丙、戊 C.甲、乙、丙、己 D.甲、乙、丙【排除法·例2】人事排除A；组织：丁不→戍不 \u0026lt;=\u003e 戍→丁","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"，排除B；办公室：排除C三人在一起猜测晚会节目的顺序。甲说：“一班第一个出场，二班第三个出场。”乙说：“三班第一个出场，四班第四个出场。”丙说：“四班第二个出场，一班第三个出场。”结果公布后，发现他们的预测都只对了一半。 由以上可以推出，节目的正确出场顺序是（）。 A.四班第一，三班第二，一班第三，二班第四 B.二班第一，一班第二，三班第三，四班第四 C.三班第一，四班第二，二班第三，一班第四D.一班第一，二班第二，四班第三，三班第四【代入法·例3】都只对一半，不确定对的条件，选择代入法。A一班第三，二班第四，甲全错，排除。B一班第二，三班第三，甲丙全错，排除。D四班第三，三班第四，乙全错，排除。大学毕业的张、王、李、赵 4 人应聘到了同一家大型 公司，每人负责一项工作，其中一人做行政管理，一人做销售，一人做研发，另 一人做安保。 已知： ①张不做行政管理，也不做安保； ②王不做行政管理，也不做研发； ③如果张没有做研发，那么赵也没有做行政管理； ④李不做行政管理，也不做安保； ⑤赵不做研发，也不做安保。 由此可以推出（） A.张做销售，李做研发 B.赵做研发，李做销售 C.李做销售，","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_23","order":23,"summary":"，排除B；办公室：排除C三人在一起猜测晚会节目的顺序。甲说：“一班第一个出场，二班第三个出场。”乙说：“三班第一个出场，四班第四个出场。”丙说：“四班第二个出场，一班第三个出场。”结果公布后，发现他们的预测都只对了一半。 由以上可以推出，节目的正确出场顺序是（）。 A.四班第一，三班第二，一班第三，二班第四 B.二班第一，一班第二，三班第三，四班第四 C.三班第一，四班第二，二班第三，一班第四D.一班第一，二班第二，四班第三，三班第四【代入法·例3】都只对一半，不确定对的条件，选择代入法。A一班第三，二班第四，甲全错，排除。B一班第二，三班第三，甲丙全错，排除。D四班第三，三班第四，乙全错，排除。大学毕业的张、王、李、赵 4 人应聘到了同一家大型 公司，每人负责一项工作，其中一人做行政管理，一人做销售，一人做研发，另 一人做安保。 已知： ①张不做行政管理，也不做安保； ②王不做行政管理，也不做研发； ③如果张没有做研发，那么赵也没有做行政管理； ④李不做行政管理，也不做安保； ⑤赵不做研发，也不做安保。 由此可以推出（） A.张做销售，李做研发 B.赵做研发，李做销售 C.李做销售，","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"张做研发 D.李做研发，赵做安保【最大信息·例1】无法直接排除选项，选择最大信息。行政管理4次，安保三次，从行政管理开始推，张王李不做行政→赵行政→张研发③上半年，国家食品药品监督管理局对市面上常见的 6 种抗生素进行了药效比较，得到结果如下：甲药比乙药有效，丙药的毒副作用比丁药大，戊药的药效最差，乙药与己药的药效相同。 由此可知（ ）。A.甲药与丁药的药效相同 B.戊药的毒副作用最大 C.甲药是最有效的药物 D.己药比甲药的药效差【符号·例2】药效：甲\u003e乙=己\u003e戍，毒副：丙\u003e丁甲、乙、丙、丁、戊 5 位摄影专业大学生为参加毕业 摄影大赛分赴黑龙江、西藏、云南、福建、江苏 5 地摄影采风。他们 5 人各有偏 爱的摄影题材：人物、花卉、风景、野生动物、古建筑，这次采风他们相约就上 述题材每人各拍一种。已知： （1）如果甲去黑龙江，乙就去江苏； （2）只有丙去福建，丁才去云南； （3）或者乙去江苏拍古建筑，或者戊去福建拍人物； （4）去江苏拍古建筑的大学生临行前曾与乙、丁话别。表格法·例4某办公室有王莉、李明和丁勇 3 名工作人员，本周有分别涉及网络、财务、管理、人事和教育的 5 项工作需","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_24","order":24,"summary":"张做研发 D.李做研发，赵做安保【最大信息·例1】无法直接排除选项，选择最大信息。行政管理4次，安保三次，从行政管理开始推，张王李不做行政→赵行政→张研发③上半年，国家食品药品监督管理局对市面上常见的 6 种抗生素进行了药效比较，得到结果如下：甲药比乙药有效，丙药的毒副作用比丁药大，戊药的药效最差，乙药与己药的药效相同。 由此可知（ ）。A.甲药与丁药的药效相同 B.戊药的毒副作用最大 C.甲药是最有效的药物 D.己药比甲药的药效差【符号·例2】药效：甲\u003e乙=己\u003e戍，毒副：丙\u003e丁甲、乙、丙、丁、戊 5 位摄影专业大学生为参加毕业 摄影大赛分赴黑龙江、西藏、云南、福建、江苏 5 地摄影采风。他们 5 人各有偏 爱的摄影题材：人物、花卉、风景、野生动物、古建筑，这次采风他们相约就上 述题材每人各拍一种。已知： （1）如果甲去黑龙江，乙就去江苏； （2）只有丙去福建，丁才去云南； （3）或者乙去江苏拍古建筑，或者戊去福建拍人物； （4）去江苏拍古建筑的大学生临行前曾与乙、丁话别。表格法·例4某办公室有王莉、李明和丁勇 3 名工作人员，本周有分别涉及网络、财务、管理、人事和教育的 5 项工作需","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"要他们完成。关于任务 安排，需要满足下列条件： ①每人均需至少完成其中的一项工作，一项工作只能由一人完成； ②人事和管理工作都不是由王莉完成的； ③如果人事工作由丁勇完成，那么财务工作由李明完成； ④完成教育工作的人至少还需完成一项其他工作。 到了周末，3 人顺利地完成了上述 5 项工作。 以下哪项中的任务不可能均由丁勇完成？ A．财务、管理 B．网络、人事 C．管理、人事 D．教育、管理练4只有③推出丁人事→李财。并且题目为不可能由丁完成，说明有三个正确答案，优先考虑使用选项中有人事的。选B日常结论 特征：题干：类言语、无逻辑关联词。问题：由此可以推出/不能推出？ 解题：代入法 思路 不选：逻辑错误、无中生有、偷换概念 慎选：比较关系、绝对词、程度、范围的扩大 优选：可能性的词汇 据介绍，北半球人口相对密集，燃烧化石燃料等人类活动不断推高碳排放量，因此北半球大气中的二氧化碳浓度在 2013 年已达到 400PPM 这一标杆水平。相对来说，南半球人类活动较少，而南极洲更是人烟稀少，但即便如此，2017 年 6 月南极洲的二氧化碳浓度也达到了 400PPM 这一标杆值。 根据以上信息，下","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_25","order":25,"summary":"要他们完成。关于任务 安排，需要满足下列条件： ①每人均需至少完成其中的一项工作，一项工作只能由一人完成； ②人事和管理工作都不是由王莉完成的； ③如果人事工作由丁勇完成，那么财务工作由李明完成； ④完成教育工作的人至少还需完成一项其他工作。 到了周末，3 人顺利地完成了上述 5 项工作。 以下哪项中的任务不可能均由丁勇完成？ A．财务、管理 B．网络、人事 C．管理、人事 D．教育、管理练4只有③推出丁人事→李财。并且题目为不可能由丁完成，说明有三个正确答案，优先考虑使用选项中有人事的。选B日常结论 特征：题干：类言语、无逻辑关联词。问题：由此可以推出/不能推出？ 解题：代入法 思路 不选：逻辑错误、无中生有、偷换概念 慎选：比较关系、绝对词、程度、范围的扩大 优选：可能性的词汇 据介绍，北半球人口相对密集，燃烧化石燃料等人类活动不断推高碳排放量，因此北半球大气中的二氧化碳浓度在 2013 年已达到 400PPM 这一标杆水平。相对来说，南半球人类活动较少，而南极洲更是人烟稀少，但即便如此，2017 年 6 月南极洲的二氧化碳浓度也达到了 400PPM 这一标杆值。 根据以上信息，下","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"列推论正确的是（）。 A.人类活动对地球的影响已经深入到极地 B.二氧化碳浓度升高对南极洲地貌有深远影响 C.南极洲二氧化碳浓度不会再降到 400PPM 以下 D.北极的二氧化碳浓度在 4、5 年前就远超南极【例4】B地貌无中生有。C不会无中生有。D北极偷换概念，应该是北半球。铝既能溶于酸，又能溶于碱，是人体维持正常运转 所需的微量元素。实验表明，红烧肉在铝锅里存放一夜，铝在肉中的含量每公斤 可高达 120 毫克至 250 毫克。但人体吸收铝元素后很难再从体内排出，容易造成 早衰和老年痴呆症。由此我们可以得出： A．铝是人体的必需元素 B．老年痴呆症是由于过量摄入铝造成的C．红烧肉不能隔夜吃 D．铝在人体内的含量很容易超标【练3】 微量=必需。B范围扩大，容易造成变为造成。C在铝锅里放一夜。D很容易，程度太大，并且没说超标的量逻辑论证 论证的基础知识： 1.论点：观点、态度、结论 2.论据：证明观点正确的条件、原因、例子 3.论证：论点与论据之间的联系 找论点： 关键词：因此，所以，认为，由此推出，据此可知…… 首尾句原则 结合提问方式（问啥找啥）找专家/某个人的观点 题型：加强削弱类","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_26","order":26,"summary":"列推论正确的是（）。 A.人类活动对地球的影响已经深入到极地 B.二氧化碳浓度升高对南极洲地貌有深远影响 C.南极洲二氧化碳浓度不会再降到 400PPM 以下 D.北极的二氧化碳浓度在 4、5 年前就远超南极【例4】B地貌无中生有。C不会无中生有。D北极偷换概念，应该是北半球。铝既能溶于酸，又能溶于碱，是人体维持正常运转 所需的微量元素。实验表明，红烧肉在铝锅里存放一夜，铝在肉中的含量每公斤 可高达 120 毫克至 250 毫克。但人体吸收铝元素后很难再从体内排出，容易造成 早衰和老年痴呆症。由此我们可以得出： A．铝是人体的必需元素 B．老年痴呆症是由于过量摄入铝造成的C．红烧肉不能隔夜吃 D．铝在人体内的含量很容易超标【练3】 微量=必需。B范围扩大，容易造成变为造成。C在铝锅里放一夜。D很容易，程度太大，并且没说超标的量逻辑论证 论证的基础知识： 1.论点：观点、态度、结论 2.论据：证明观点正确的条件、原因、例子 3.论证：论点与论据之间的联系 找论点： 关键词：因此，所以，认为，由此推出，据此可知…… 首尾句原则 结合提问方式（问啥找啥）找专家/某个人的观点 题型：加强削弱类","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":" 加强类 常见提问方式： 如果以下各项为真，最能加强/支持/赞同/证明上述论断的是？ 以下哪项为真，是上述论断的前提/假设/必要条件 如果以下各项为真，最不能加强上述论断的是？ 解题方法 搭桥（力度最强） 题型特征： 1.论点与论据话题不一致 2.提问方式为前提、假设、必要条件时，优先考虑搭桥 选项特征： 同时包含论点和论据中的关键词，并肯定论点和论据之间的关系 解题思维： 找论点→找论据→对比选项 补充论据 提问方式为前提、假设、必要条件且无搭桥选项 解题思维 必要条件：选项为论点成立的必要条件（没它不行） 解释：说明论点成立的原因 举例：证明论点成立的例子 搭桥\u003e必要条件\u003e解释\u003e举例 扬子鳄是中国特有的一种鳄鱼，主要分布在长江中下游地区，它是古老的、现存数量非常稀少的爬行动物。在扬子鳄身上，至今还可以找到恐龙类爬行动物的许多特征，常被称为“活化石”。因此，扬子鳄对于人们研究古代爬行动物的兴衰以及研究古地质学和生物的进化，都有重要意义。以下哪项如果为真，是上述论证所需的前提？（） A.扬子鳄是世界上最珍稀的爬行动物之一 B.扬子鳄生活的年代和恐龙生活的年代大抵相当 C.现存的具有恐龙","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_27","order":27,"summary":" 加强类 常见提问方式： 如果以下各项为真，最能加强/支持/赞同/证明上述论断的是？ 以下哪项为真，是上述论断的前提/假设/必要条件 如果以下各项为真，最不能加强上述论断的是？ 解题方法 搭桥（力度最强） 题型特征： 1.论点与论据话题不一致 2.提问方式为前提、假设、必要条件时，优先考虑搭桥 选项特征： 同时包含论点和论据中的关键词，并肯定论点和论据之间的关系 解题思维： 找论点→找论据→对比选项 补充论据 提问方式为前提、假设、必要条件且无搭桥选项 解题思维 必要条件：选项为论点成立的必要条件（没它不行） 解释：说明论点成立的原因 举例：证明论点成立的例子 搭桥\u003e必要条件\u003e解释\u003e举例 扬子鳄是中国特有的一种鳄鱼，主要分布在长江中下游地区，它是古老的、现存数量非常稀少的爬行动物。在扬子鳄身上，至今还可以找到恐龙类爬行动物的许多特征，常被称为“活化石”。因此，扬子鳄对于人们研究古代爬行动物的兴衰以及研究古地质学和生物的进化，都有重要意义。以下哪项如果为真，是上述论证所需的前提？（） A.扬子鳄是世界上最珍稀的爬行动物之一 B.扬子鳄生活的年代和恐龙生活的年代大抵相当 C.现存的具有恐龙","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"类爬行动物特征的动物已经为数不多 D.研究恐龙类爬行动物的特征是研究古代爬行动物兴衰的关键【搭桥·例2】论据：扬子鳄有恐龙类爬行动物特征，因此论点：研究古代爬行动物有意义。为什么恐龙特征对爬行动物有意义？搭桥。D特征和爬行动物有关系，联系上了。基本就是选项中找这两个关键词（特征/爬行）一个没有普通话一级甲等证书的人不可能成为一个主持人，因为主持人不能发音不标准。 上述论证还需基于以下哪一前提？ A．没有一级甲等证书的人都会发音不标准 B．发音不标准的主持人可能没有一级甲等证书 C．一个发音不标准的人有可能获得一级甲等证书 D．一个发音不标准的主持人不可能成为一个受人欢迎的主持人【搭桥·练5】论据：主持人发音标准，所以论点：主持人要证书。证书和发音标准的关系。秒A，BC削弱开车斗气、胡乱变线、强行超车等“路怒症”是一种被 称为间歇性、暴发性障碍（IED）的心理疾病。有研究发现，IED 患者弓形虫检测呈阳性的比例是非 IED 组的两倍。研究者认为，弓形虫感染有可能是导致包括 “路怒症”在内的 IED 的罪魁祸首。 以下哪项如果为真，无法支持研究者的观点？（） A.感染了弓形虫的老鼠往往更大","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_28","order":28,"summary":"类爬行动物特征的动物已经为数不多 D.研究恐龙类爬行动物的特征是研究古代爬行动物兴衰的关键【搭桥·例2】论据：扬子鳄有恐龙类爬行动物特征，因此论点：研究古代爬行动物有意义。为什么恐龙特征对爬行动物有意义？搭桥。D特征和爬行动物有关系，联系上了。基本就是选项中找这两个关键词（特征/爬行）一个没有普通话一级甲等证书的人不可能成为一个主持人，因为主持人不能发音不标准。 上述论证还需基于以下哪一前提？ A．没有一级甲等证书的人都会发音不标准 B．发音不标准的主持人可能没有一级甲等证书 C．一个发音不标准的人有可能获得一级甲等证书 D．一个发音不标准的主持人不可能成为一个受人欢迎的主持人【搭桥·练5】论据：主持人发音标准，所以论点：主持人要证书。证书和发音标准的关系。秒A，BC削弱开车斗气、胡乱变线、强行超车等“路怒症”是一种被 称为间歇性、暴发性障碍（IED）的心理疾病。有研究发现，IED 患者弓形虫检测呈阳性的比例是非 IED 组的两倍。研究者认为，弓形虫感染有可能是导致包括 “路怒症”在内的 IED 的罪魁祸首。 以下哪项如果为真，无法支持研究者的观点？（） A.感染了弓形虫的老鼠往往更大","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"胆、更敢于冒险，也因此更容易被猫抓到 B.弓形虫使大脑中控制威胁反应的神经元受到过度刺激，易引发攻击行为 C.对弓形虫检测呈阳性的 IED 患者施以抗虫感染治疗之后，冲动行为减少 D.弓形虫是猫身上的一种原生动物寄生虫，但猫是比较温顺的动物【补充·例6】注意题目是无法，看见无类词，花圈。A举例；B原因解释，搭桥。C补充实验。D削弱在一项针对 216 名 6 到 12 月的婴儿进行测试中，研究人员教给婴儿新的手指木偶玩耍的三个本领，有一半的宝宝在学习之后的四个小时就睡了一大觉，但是另外的宝宝则没有睡觉或者只小憩了不到 30 分钟。研究显示平均说来，有充足睡眠的宝宝能记住 1.5 个本领，但是没有怎么睡觉的宝宝则一项本领都没有记住。可见，婴儿学习本领后保持充足睡眠有利于增强记忆。 下列哪项是上述论证最可能依赖的假设。 A．该研究结果在青少年群体中同样适用 B．充足睡眠有利于宝宝正常的身体发育 C．实验前两组宝宝的智力水平状况相当 D．有其他研究验证了这项结果可靠性【补充·练3】婴儿充足睡眠增强记忆。A青少年，无关。B发育，无关。C控制变量法，前提条件。D举例效果最弱。素数是指只含有两个因子","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_29","order":29,"summary":"胆、更敢于冒险，也因此更容易被猫抓到 B.弓形虫使大脑中控制威胁反应的神经元受到过度刺激，易引发攻击行为 C.对弓形虫检测呈阳性的 IED 患者施以抗虫感染治疗之后，冲动行为减少 D.弓形虫是猫身上的一种原生动物寄生虫，但猫是比较温顺的动物【补充·例6】注意题目是无法，看见无类词，花圈。A举例；B原因解释，搭桥。C补充实验。D削弱在一项针对 216 名 6 到 12 月的婴儿进行测试中，研究人员教给婴儿新的手指木偶玩耍的三个本领，有一半的宝宝在学习之后的四个小时就睡了一大觉，但是另外的宝宝则没有睡觉或者只小憩了不到 30 分钟。研究显示平均说来，有充足睡眠的宝宝能记住 1.5 个本领，但是没有怎么睡觉的宝宝则一项本领都没有记住。可见，婴儿学习本领后保持充足睡眠有利于增强记忆。 下列哪项是上述论证最可能依赖的假设。 A．该研究结果在青少年群体中同样适用 B．充足睡眠有利于宝宝正常的身体发育 C．实验前两组宝宝的智力水平状况相当 D．有其他研究验证了这项结果可靠性【补充·练3】婴儿充足睡眠增强记忆。A青少年，无关。B发育，无关。C控制变量法，前提条件。D举例效果最弱。素数是指只含有两个因子","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"的自然数(即只能被自身 和 1 整除)，孪生素数是指两个相差为 2 的素数。比如，3 和 5，17 和 19 等。所 谓的孪生素数猜想，是由希腊数学家欧几里得提出的，意思是存在着无穷对孪生 素数。该论题一直未得到证明。近期，美国一位华人讲师的最新研究表明，虽然 还无法证明存在无穷多个之差为 2 的素数对，但存在无数多个之差小于 7000 万 的素数对。有关方面认为，如果这个结果成立，那么将是数论发展的一项重大突破。 以下哪项如果为真，最能支持有关方面的观点： A.这位华人讲师长期从事数学领域的相关教学和科研工作 B.关于孪生素数猜想的证明需要一个漫长的、逐步推进的过程C.这是第一次有人正式证明存在无穷多组间距小于定值的素数对 D.7000 万这个数字很大，离孪生素数猜想给出的 2 还有很大距离【练14】A教学跟突破无关。BD削弱。C无穷变有限，重大突破。削弱类 常见提问方式： 如果以下各项为真，最能质疑/反驳/削弱/反对上述论断的是？ 如果以下各项为真，最不能质疑上述论断的是？ 削弱之否定论点（力度最强\u0026最常考） 选项特征：与论点表述的意思相反 解题步骤： （1）找出论点 （2）想出与","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_30","order":30,"summary":"的自然数(即只能被自身 和 1 整除)，孪生素数是指两个相差为 2 的素数。比如，3 和 5，17 和 19 等。所 谓的孪生素数猜想，是由希腊数学家欧几里得提出的，意思是存在着无穷对孪生 素数。该论题一直未得到证明。近期，美国一位华人讲师的最新研究表明，虽然 还无法证明存在无穷多个之差为 2 的素数对，但存在无数多个之差小于 7000 万 的素数对。有关方面认为，如果这个结果成立，那么将是数论发展的一项重大突破。 以下哪项如果为真，最能支持有关方面的观点： A.这位华人讲师长期从事数学领域的相关教学和科研工作 B.关于孪生素数猜想的证明需要一个漫长的、逐步推进的过程C.这是第一次有人正式证明存在无穷多组间距小于定值的素数对 D.7000 万这个数字很大，离孪生素数猜想给出的 2 还有很大距离【练14】A教学跟突破无关。BD削弱。C无穷变有限，重大突破。削弱类 常见提问方式： 如果以下各项为真，最能质疑/反驳/削弱/反对上述论断的是？ 如果以下各项为真，最不能质疑上述论断的是？ 削弱之否定论点（力度最强\u0026最常考） 选项特征：与论点表述的意思相反 解题步骤： （1）找出论点 （2）想出与","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"论点相反意思的表述 （3）寻找对应选项 削弱之拆桥 题型特征： 论点、论据话题不一致 提问方式为“削弱论证”时，优先考虑拆桥 选项特征： 同时包含论点和论据中的关键词，并否定论点和论据之间的必然联系 削弱之否定论据 题型特征： 题干中出现支持方、反对方观点相反的情况，经常采用否定论据来削弱 结论是预测（预测无法验证的历史或者未来）或者建议（典型提示词：建议、应该等）时，经常采用否定论据来削弱 选项特征：与论据表述的意思相反 因果论证的削弱 题型特征：论点中包含因果关系。 常见句式：……是……的原因；……导致……；……使得……；……有助 于……；……有效增加（减少）……。 削弱方式： 因果倒置削弱：因果互换削弱题目的因果关系。 另有他因削弱：对现有因果不赞成也不反对，而是指出还存在另外一种原因， 也同样导致了相同的结果。 研究员将六百多位老年痴呆症患者分为三个组，一组补充一定剂量的维生素 E，另一组接受药物治疗，第三组服用安慰剂。在接下来 两年多的时间里，与服用安慰剂的患者相比，服用维生素 E 的患者从事制订计划、做饭和购物等日常活动的能力下降较慢。服用药物的患者没有获得类似的临床效果。","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_31","order":31,"summary":"论点相反意思的表述 （3）寻找对应选项 削弱之拆桥 题型特征： 论点、论据话题不一致 提问方式为“削弱论证”时，优先考虑拆桥 选项特征： 同时包含论点和论据中的关键词，并否定论点和论据之间的必然联系 削弱之否定论据 题型特征： 题干中出现支持方、反对方观点相反的情况，经常采用否定论据来削弱 结论是预测（预测无法验证的历史或者未来）或者建议（典型提示词：建议、应该等）时，经常采用否定论据来削弱 选项特征：与论据表述的意思相反 因果论证的削弱 题型特征：论点中包含因果关系。 常见句式：……是……的原因；……导致……；……使得……；……有助 于……；……有效增加（减少）……。 削弱方式： 因果倒置削弱：因果互换削弱题目的因果关系。 另有他因削弱：对现有因果不赞成也不反对，而是指出还存在另外一种原因， 也同样导致了相同的结果。 研究员将六百多位老年痴呆症患者分为三个组，一组补充一定剂量的维生素 E，另一组接受药物治疗，第三组服用安慰剂。在接下来 两年多的时间里，与服用安慰剂的患者相比，服用维生素 E 的患者从事制订计划、做饭和购物等日常活动的能力下降较慢。服用药物的患者没有获得类似的临床效果。","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"因而研究员认为，维生素 E 补充剂有望成为治愈老年痴呆症的特效药。 以下陈述如果为真，哪项最能质疑研究员的结论？（） A.维生素 E 为脂溶性，不易代谢，一次性大量服用会导致中毒B.老年痴呆是不可逆性疾病，症状的发生只可能延缓而无法逆转C.正常人体每日所需的维生素 E 可以从饮食中摄取，不必额外补充D.现有的抗老年痴呆的药物中均未添加维生素 E【否论-例4】维E能治愈。B否定论点。D只是举例，并且并未提到治愈。随着气候变化，肥料和供水导致了极大的能源和环境成本，如何让作物更好地吸收营养和水就显得极其重要。因此不少人认为只要增加植物根毛的长度，就可以更有效地吸收水和养分，从而提高作物产量。 下列哪项如果为真，最能削弱上述结论？ A．实践证明，合理控制光照时间，并保证同一块田地间隔播种作物能极大地提高产量 B．根毛的寿命很短，仅能存活 2~3 周便自行脱落，由于更新很快，植物的根部总能保持一个数量相对稳定的根毛区 C．如果植株过于密集而养料不足，即使增加了根毛长度，也无法保证植物的营养供应 D．根毛的长度与植物生长激素密切相关，当植物生长激素分泌旺盛时，根毛也变长；而生长激素分泌减少时，根","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_32","order":32,"summary":"因而研究员认为，维生素 E 补充剂有望成为治愈老年痴呆症的特效药。 以下陈述如果为真，哪项最能质疑研究员的结论？（） A.维生素 E 为脂溶性，不易代谢，一次性大量服用会导致中毒B.老年痴呆是不可逆性疾病，症状的发生只可能延缓而无法逆转C.正常人体每日所需的维生素 E 可以从饮食中摄取，不必额外补充D.现有的抗老年痴呆的药物中均未添加维生素 E【否论-例4】维E能治愈。B否定论点。D只是举例，并且并未提到治愈。随着气候变化，肥料和供水导致了极大的能源和环境成本，如何让作物更好地吸收营养和水就显得极其重要。因此不少人认为只要增加植物根毛的长度，就可以更有效地吸收水和养分，从而提高作物产量。 下列哪项如果为真，最能削弱上述结论？ A．实践证明，合理控制光照时间，并保证同一块田地间隔播种作物能极大地提高产量 B．根毛的寿命很短，仅能存活 2~3 周便自行脱落，由于更新很快，植物的根部总能保持一个数量相对稳定的根毛区 C．如果植株过于密集而养料不足，即使增加了根毛长度，也无法保证植物的营养供应 D．根毛的长度与植物生长激素密切相关，当植物生长激素分泌旺盛时，根毛也变长；而生长激素分泌减少时，根","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"毛也逐渐萎缩【否论-练2】增加长度，就能吸收水和养分。C增加了长度，也无法保证营养供应，否定论点。A无关，B没有提到吸收，D无关，不要脑部。某网购平台发布了一份网购调研报告，分析亚洲女性的网购特点。分析显示，当代亚洲女性在网购服饰、化妆品方面的决定权为 88%， 在网购家居用品方面的决定权为 85%。研究者由此认为，那些喜爱网购的亚洲女性在家庭中拥有更大的控制权。 以下哪项如果为真，最能反驳上述结论？ A．喜爱网购的亚洲女性的网购支出只占其家庭消费支出的 25% B．亚洲女性中，习惯上网购物的人数只占女性总人数的 30%左右 C．亚洲女性在购买贵重商品时往往会与丈夫商量，共同决定 D．一些亚洲女性经济不独立，对家庭收入没有贡献【拆桥-练3】主语选A。网购支出大→控制权。A直接拆桥。B人数少跟控制权无关。CD没有说明喜爱购物的女性。有研究表明，要成为男性至少需要拥有一条 Y 染色体。 3 亿年前，男性特有的 Y 染色体在产生之际含有 1438 个基因，但现在只剩下 45 个。按照这种速度，Y 染色体将在大约 1000 万年内消失殆尽。因此，随着 Y 染色体的消亡，人类也将走向消亡。如果以","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_33","order":33,"summary":"毛也逐渐萎缩【否论-练2】增加长度，就能吸收水和养分。C增加了长度，也无法保证营养供应，否定论点。A无关，B没有提到吸收，D无关，不要脑部。某网购平台发布了一份网购调研报告，分析亚洲女性的网购特点。分析显示，当代亚洲女性在网购服饰、化妆品方面的决定权为 88%， 在网购家居用品方面的决定权为 85%。研究者由此认为，那些喜爱网购的亚洲女性在家庭中拥有更大的控制权。 以下哪项如果为真，最能反驳上述结论？ A．喜爱网购的亚洲女性的网购支出只占其家庭消费支出的 25% B．亚洲女性中，习惯上网购物的人数只占女性总人数的 30%左右 C．亚洲女性在购买贵重商品时往往会与丈夫商量，共同决定 D．一些亚洲女性经济不独立，对家庭收入没有贡献【拆桥-练3】主语选A。网购支出大→控制权。A直接拆桥。B人数少跟控制权无关。CD没有说明喜爱购物的女性。有研究表明，要成为男性至少需要拥有一条 Y 染色体。 3 亿年前，男性特有的 Y 染色体在产生之际含有 1438 个基因，但现在只剩下 45 个。按照这种速度，Y 染色体将在大约 1000 万年内消失殆尽。因此，随着 Y 染色体的消亡，人类也将走向消亡。如果以","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"下各项为真，最不能质疑上述论证的是（）。 A.恒河猴 Y 染色体基因确实经历过早期高速的丧失过程，但在过去的 2500 万年内则未丢失任何一个基因 B.男性即使失去 Y 染色体也有可能继续生存下去，因为其他染色体有类似基因可以分担 Y 染色体的功能 C.人类进化过程中，可以找到单性繁殖或无性繁殖后代的方法，从而避免因基因缺失引发的繁殖风险 D.Y 染色体存在独特的回文结构，该结构具有自我修复功能，可以保持丢失基因的信息，实现基因再生【否据-例3】男性必须有Y，按照这种速度，Y消失，导致人类灭亡。BC否论，D否据。A类比推理最弱数据资料表明：“不让一个孩子落后”法案实施后，四年级、八年级学生的英语阅读科目和数学科目平均得分确实明显提高了。因此， 得出结论：这一教育改革法案在美国各地中小学取得了惊人的成就。以下哪项如果为真，对上述论证的质疑力度最弱？（） A.十二年级学生的英语阅读科目平均得分在同一时期出现了明显下降 B.只关注英语阅读和数学成绩的变化，并把它作为评价教育改革成果的标志， 这是很片面的 C.改进教育体制确实很难，想要在这个带有极大惰性的庞大官僚体制上作一番改动，需要大量金钱","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_34","order":34,"summary":"下各项为真，最不能质疑上述论证的是（）。 A.恒河猴 Y 染色体基因确实经历过早期高速的丧失过程，但在过去的 2500 万年内则未丢失任何一个基因 B.男性即使失去 Y 染色体也有可能继续生存下去，因为其他染色体有类似基因可以分担 Y 染色体的功能 C.人类进化过程中，可以找到单性繁殖或无性繁殖后代的方法，从而避免因基因缺失引发的繁殖风险 D.Y 染色体存在独特的回文结构，该结构具有自我修复功能，可以保持丢失基因的信息，实现基因再生【否据-例3】男性必须有Y，按照这种速度，Y消失，导致人类灭亡。BC否论，D否据。A类比推理最弱数据资料表明：“不让一个孩子落后”法案实施后，四年级、八年级学生的英语阅读科目和数学科目平均得分确实明显提高了。因此， 得出结论：这一教育改革法案在美国各地中小学取得了惊人的成就。以下哪项如果为真，对上述论证的质疑力度最弱？（） A.十二年级学生的英语阅读科目平均得分在同一时期出现了明显下降 B.只关注英语阅读和数学成绩的变化，并把它作为评价教育改革成果的标志， 这是很片面的 C.改进教育体制确实很难，想要在这个带有极大惰性的庞大官僚体制上作一番改动，需要大量金钱","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"、努力和时间 D.四年级、八年级学生的英语阅读科目和数学科目平均得分从 20 世纪 90 年代开始就在逐年按基本相同的比例提高，这种状况早在法案通过前就出现了【例4】无关项秒选C。A否据，B否据，D否论某专家对已故诺贝尔经济学奖得主的寿命进行统计， 发现他们的平均寿命是 85 岁其中超过 90 岁的占多数，还有不少过百岁的，去世时年龄最小的也高达 74 岁。该专家由此认为，获得诺贝尔经济学奖能使人长寿。 以下哪项如果为真，最能削弱上述专家的观点？ A．诺贝尔经济学奖只颁给在世的学者，这一颁奖规则对已经长寿的学者极为有利 B．获得诺贝尔奖能带来功成名就的巨大身心愉悦，而愉悦的身心状态可延年益寿 C．宏观经济学之父凯恩斯年仅 63 岁就去世了，很遗憾他没有获得诺贝尔经济学奖 D．获得诺贝尔物理学奖的学者寿命也很长，但他们都没有获得过诺贝尔经济学奖【因果-例1】经济奖使人长寿。A在世才能得到经济奖，因果倒置削弱。CD无关。B加强。研究显示，约 200 万年前，人类开始使用石器处理食物，例如切肉和捣碎植物。与此同时，人类逐渐演化形成较小的牙齿和脸型， 以及更弱的咀嚼肌和咬力。因此研究者推测，工","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_35","order":35,"summary":"、努力和时间 D.四年级、八年级学生的英语阅读科目和数学科目平均得分从 20 世纪 90 年代开始就在逐年按基本相同的比例提高，这种状况早在法案通过前就出现了【例4】无关项秒选C。A否据，B否据，D否论某专家对已故诺贝尔经济学奖得主的寿命进行统计， 发现他们的平均寿命是 85 岁其中超过 90 岁的占多数，还有不少过百岁的，去世时年龄最小的也高达 74 岁。该专家由此认为，获得诺贝尔经济学奖能使人长寿。 以下哪项如果为真，最能削弱上述专家的观点？ A．诺贝尔经济学奖只颁给在世的学者，这一颁奖规则对已经长寿的学者极为有利 B．获得诺贝尔奖能带来功成名就的巨大身心愉悦，而愉悦的身心状态可延年益寿 C．宏观经济学之父凯恩斯年仅 63 岁就去世了，很遗憾他没有获得诺贝尔经济学奖 D．获得诺贝尔物理学奖的学者寿命也很长，但他们都没有获得过诺贝尔经济学奖【因果-例1】经济奖使人长寿。A在世才能得到经济奖，因果倒置削弱。CD无关。B加强。研究显示，约 200 万年前，人类开始使用石器处理食物，例如切肉和捣碎植物。与此同时，人类逐渐演化形成较小的牙齿和脸型， 以及更弱的咀嚼肌和咬力。因此研究者推测，工","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"具的使用减弱了咀嚼的力量，从而导致人类脸型的变化。 以下哪项如果为真，最能削弱上述研究者的观点？ A．对与人类较为接近的灵长类动物进行研究，发现它们白天有一半时间用于咀嚼，它们的口腔肌肉非常发达、脸型也较大 B．200 万年前人类食物类型发生了变化，这加速了人类脸型的变化 C．在利用石器处理食物后，越来越多的食物经过了程度更高的处理，变得易于咀嚼 D．早期人类进化出较小的咀嚼结构，这一过程使其他变化成为可能，比如 大脑体积的增大【例2】工具的适用导致脸型变化。A咀嚼跟脸型有关，工具减弱咀嚼类比增强观点。B他因削弱。C没有提到脸型。D无关。真假推理 题型特征：题干中的论述有真有假，且真假未知 真假破案的解题突破口有两个逻辑关系，分别是矛盾关系和反对关系。 找突破口：先矛盾，再反对 看其余：一真其余全假，一假其余全真 判断突破口中两句话的真假（可选）。 矛盾关系 特点：矛盾包含一真一假 找矛盾的技巧：对象一致 （我没考一百分，全班所有人都考了一百分，不是矛盾，因为对象不一致） 四组矛盾关系： A 与-A A∩B 与-(A∩B) = -A 或-B 星期一和星期二我都去上班，矛盾后，不都去上班","date":"2023-12-09T08:27:05+08:00","objectID":"1ac95be61f7b37059dc21e33585c479c_36","order":36,"summary":"具的使用减弱了咀嚼的力量，从而导致人类脸型的变化。 以下哪项如果为真，最能削弱上述研究者的观点？ A．对与人类较为接近的灵长类动物进行研究，发现它们白天有一半时间用于咀嚼，它们的口腔肌肉非常发达、脸型也较大 B．200 万年前人类食物类型发生了变化，这加速了人类脸型的变化 C．在利用石器处理食物后，越来越多的食物经过了程度更高的处理，变得易于咀嚼 D．早期人类进化出较小的咀嚼结构，这一过程使其他变化成为可能，比如 大脑体积的增大【例2】工具的适用导致脸型变化。A咀嚼跟脸型有关，工具减弱咀嚼类比增强观点。B他因削弱。C没有提到脸型。D无关。真假推理 题型特征：题干中的论述有真有假，且真假未知 真假破案的解题突破口有两个逻辑关系，分别是矛盾关系和反对关系。 找突破口：先矛盾，再反对 看其余：一真其余全假，一假其余全真 判断突破口中两句话的真假（可选）。 矛盾关系 特点：矛盾包含一真一假 找矛盾的技巧：对象一致 （我没考一百分，全班所有人都考了一百分，不是矛盾，因为对象不一致） 四组矛盾关系： A 与-A A∩B 与-(A∩B) = -A 或-B 星期一和星期二我都去上班，矛盾后，不都去上班","tags":["CivilServant"],"title":"公务员行测--判断推理","url":"http://localhost:1313/posts/learn/judgmental-reasoning/"},{"categories":["learn"],"content":"类中心理解 (语句排序，语句填入，下文推断，细节判断，关键词提取）语句排序 做题思路： 先排除（首句和不可能独立可混合使用，不分先后），最后验证。 22布局：选项首个为aabb型，判断是否符合首个以排除50% 确定首句 下定义、背景知识引入常为首句的特征词、以及两个首句之间有内部的逻辑关系，常优先考虑其为首句 43布局：选项首个都不相同，或者就两个相同，abcd、aabc型 22布局、43布局时，也可以直接去文段寻找“不可能独立出现的词语”，即一定是处于脉络的铺垫引出部分。可以一眼锁定或者利用选项 转折之后的部分：但、但是、而、而是、不料等 并列之后的部分：也、并且、或、还、另外、另一方面等 结论性的部分：所以、显然、于是、以至于、以便、充分证明等 举例论证部分：比如、如、例如等 代指词：这个、其、该、这些、它们（特指有多个 事物）等 优先看并列和代指 看980有感：每次发现选项之间的大小后，排除选项。再从剩下选项中找到可突破点，每次都利用选项 或者直观的语句进行排除 题目：①另一位加拿大科学家发现，植物缺水时发出的响声大小和缺水程度是有相关性的，缺水越严重，发出的响声越大 ②倘若是因","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_0","order":0,"summary":"类中心理解 (语句排序，语句填入，下文推断，细节判断，关键词提取）语句排序 做题思路： 先排除（首句和不可能独立可混合使用，不分先后），最后验证。 22布局：选项首个为aabb型，判断是否符合首个以排除50% 确定首句 下定义、背景知识引入常为首句的特征词、以及两个首句之间有内部的逻辑关系，常优先考虑其为首句 43布局：选项首个都不相同，或者就两个相同，abcd、aabc型 22布局、43布局时，也可以直接去文段寻找“不可能独立出现的词语”，即一定是处于脉络的铺垫引出部分。可以一眼锁定或者利用选项 转折之后的部分：但、但是、而、而是、不料等 并列之后的部分：也、并且、或、还、另外、另一方面等 结论性的部分：所以、显然、于是、以至于、以便、充分证明等 举例论证部分：比如、如、例如等 代指词：这个、其、该、这些、它们（特指有多个 事物）等 优先看并列和代指 看980有感：每次发现选项之间的大小后，排除选项。再从剩下选项中找到可突破点，每次都利用选项 或者直观的语句进行排除 题目：①另一位加拿大科学家发现，植物缺水时发出的响声大小和缺水程度是有相关性的，缺水越严重，发出的响声越大 ②倘若是因","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"为植物缺水而有意发出这种声音的话，这种具有意识性的表现实在令人惊叹③通过进一步的测量和收集数据，他发现声音的源头在植物体内的输水管上，植物在缺水的情况下会发生微小的震动 ④20 世纪 70 年代，一位澳大利亚科学家研究了植物对气候环境的反应，发现在严重干旱时期，植物会发出一些奇特的声音 ⑤但是，当时还无法对这种现象进行合理的解释 将以上 5 个句子重新排列，语序正确的是（ ）。 A.②③⑤④① B.②①④③⑤ C.④①③②⑤D.④③①⑤②22布局，看②④，肯定④，不要看到另一位就觉得是并列，④③是问题+结果的脉络。①这就会让人产生对阶层问题的焦虑感，因为教育包含财富和知识的传递问题，它也更能反映这种焦虑 ②他们在保住自身阶层的同时，担心孩子不能继承自己的“能力”，不能迈向更高阶层，反而滑落到更低阶层③一方面，一些人渴望跨越自身阶层限制，实现人生“逆袭” ④在社会转型期，阶层分化加速，伴随而来的往往是经济增速放缓和阶层流动趋势下降的问题，由此产生许多人对阶层问题的幻想 ⑤另一方面，一些人恐惧于从自身阶层跌落，尤其是刚刚迈入中等收入群体的一批人⑥其中最简单的办法还是考取北清这一级别的名校，","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_1","order":1,"summary":"为植物缺水而有意发出这种声音的话，这种具有意识性的表现实在令人惊叹③通过进一步的测量和收集数据，他发现声音的源头在植物体内的输水管上，植物在缺水的情况下会发生微小的震动 ④20 世纪 70 年代，一位澳大利亚科学家研究了植物对气候环境的反应，发现在严重干旱时期，植物会发出一些奇特的声音 ⑤但是，当时还无法对这种现象进行合理的解释 将以上 5 个句子重新排列，语序正确的是（ ）。 A.②③⑤④① B.②①④③⑤ C.④①③②⑤D.④③①⑤②22布局，看②④，肯定④，不要看到另一位就觉得是并列，④③是问题+结果的脉络。①这就会让人产生对阶层问题的焦虑感，因为教育包含财富和知识的传递问题，它也更能反映这种焦虑 ②他们在保住自身阶层的同时，担心孩子不能继承自己的“能力”，不能迈向更高阶层，反而滑落到更低阶层③一方面，一些人渴望跨越自身阶层限制，实现人生“逆袭” ④在社会转型期，阶层分化加速，伴随而来的往往是经济增速放缓和阶层流动趋势下降的问题，由此产生许多人对阶层问题的幻想 ⑤另一方面，一些人恐惧于从自身阶层跌落，尤其是刚刚迈入中等收入群体的一批人⑥其中最简单的办法还是考取北清这一级别的名校，","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"进而跻身更高的知识层次和经济层次将上面的句子组成语意连贯的语段，排序最恰当的一项是（ ）。A.④③⑤⑥②① B.②④③⑥⑤① C.④③⑥⑤②①D.⑥④③⑤②①43布局，优先看这、其中。①的前面必定是⑤，因为害怕跌落。⑥的前面必定③。如果看的是其中，排除AD后，看首个是否能总领。选C。③⑤不是并列。选完后，有时间可以按顺序读是否通顺。语句填入 讲的一般，可以看看其他的横线在开头 总结全文（中心理解，首先考虑） 背景引入 衔接后文 横线在中间 承上启下 承上或启下 上下文的粘合剂 横线在结尾 总结全文（中心理解） 衔接上文（导致的最终结果） 针对问题，提出对策 题目：____。据了解，在 M 国，每 3 个上网的老年人中就有1 个有社交网络的账号。两年间，65 岁以上的社交网络用户增长了 150%。越来越多的老年人开始使用社交网络寻找老朋友，结识新朋友。一些 M 国老年人还会访问视频或者音频取代文字的社交网络，分享抗衰老心得。另外，一些社交网站除了为老年人提供线上交流服务外，还会定期组织同城活动，提供交通、房屋维修等服务。 下列最适合填入横线处的是（ ）。 A.社交网络为老年人的生活打开了","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_2","order":2,"summary":"进而跻身更高的知识层次和经济层次将上面的句子组成语意连贯的语段，排序最恰当的一项是（ ）。A.④③⑤⑥②① B.②④③⑥⑤① C.④③⑥⑤②①D.⑥④③⑤②①43布局，优先看这、其中。①的前面必定是⑤，因为害怕跌落。⑥的前面必定③。如果看的是其中，排除AD后，看首个是否能总领。选C。③⑤不是并列。选完后，有时间可以按顺序读是否通顺。语句填入 讲的一般，可以看看其他的横线在开头 总结全文（中心理解，首先考虑） 背景引入 衔接后文 横线在中间 承上启下 承上或启下 上下文的粘合剂 横线在结尾 总结全文（中心理解） 衔接上文（导致的最终结果） 针对问题，提出对策 题目：____。据了解，在 M 国，每 3 个上网的老年人中就有1 个有社交网络的账号。两年间，65 岁以上的社交网络用户增长了 150%。越来越多的老年人开始使用社交网络寻找老朋友，结识新朋友。一些 M 国老年人还会访问视频或者音频取代文字的社交网络，分享抗衰老心得。另外，一些社交网站除了为老年人提供线上交流服务外，还会定期组织同城活动，提供交通、房屋维修等服务。 下列最适合填入横线处的是（ ）。 A.社交网络为老年人的生活打开了","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"一扇窗户 B.社交网络在人们日常生活中应用越来越广C.社交网络使不少老年人越来越热衷于交友 D.社交网络让老年人更便捷地享受各种服务观点：老年人通过社交网络找朋友、分享新的、组织服务。CAB型，AB太长，选项肯定分别放入增加干扰，如CD。C没有体现老年人，即主体。____，最能代表一个时代的风貌，最能引领一个时代的风气。“文变染乎世情，兴废系乎时序。”在欧洲文艺复兴运动中，但丁、彼特拉克、薄伽丘、达·芬奇、拉斐尔、米开朗琪罗、蒙田、塞万提斯、莎士比亚等文艺巨人，发出了新时代的啼声，开启了人们的心灵，在谈到文艺复兴运动时，恩格斯说，这“是一个需要巨人而且产生了巨人——在思维能力、热情和性格方面，在多才多艺和学识渊博方面的巨人的时代”。在我国发展史上，包括文艺在内的文化发展同样与中华民族发展紧紧联系在一起。先秦时期，我国出现了百家争鸣的兴盛局面，开创了我国古代文化的一个鼎盛期，20 世纪初，在五四新文化运动中，发端于文艺领域的创新风潮对社会变革产生了重大影响，成为全民族思想解放运动的重要引擎。填入画横线部分最恰当的一项是： A.文艺是铸造灵魂的工程 B.文化是民族生存和发展的重要力量C.文","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_3","order":3,"summary":"一扇窗户 B.社交网络在人们日常生活中应用越来越广C.社交网络使不少老年人越来越热衷于交友 D.社交网络让老年人更便捷地享受各种服务观点：老年人通过社交网络找朋友、分享新的、组织服务。CAB型，AB太长，选项肯定分别放入增加干扰，如CD。C没有体现老年人，即主体。____，最能代表一个时代的风貌，最能引领一个时代的风气。“文变染乎世情，兴废系乎时序。”在欧洲文艺复兴运动中，但丁、彼特拉克、薄伽丘、达·芬奇、拉斐尔、米开朗琪罗、蒙田、塞万提斯、莎士比亚等文艺巨人，发出了新时代的啼声，开启了人们的心灵，在谈到文艺复兴运动时，恩格斯说，这“是一个需要巨人而且产生了巨人——在思维能力、热情和性格方面，在多才多艺和学识渊博方面的巨人的时代”。在我国发展史上，包括文艺在内的文化发展同样与中华民族发展紧紧联系在一起。先秦时期，我国出现了百家争鸣的兴盛局面，开创了我国古代文化的一个鼎盛期，20 世纪初，在五四新文化运动中，发端于文艺领域的创新风潮对社会变革产生了重大影响，成为全民族思想解放运动的重要引擎。填入画横线部分最恰当的一项是： A.文艺是铸造灵魂的工程 B.文化是民族生存和发展的重要力量C.文","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"艺是时代前进的号角 D.文艺创新是与时代脉搏同频共振的原文，时代的xx，又强调文艺，选C，D是同等地位了。B只是我国的情况。感觉语句填入得看另一个老师。注意是逗号需要粘合后文。而句号是引领全文____。新中国成立以来，很多画家借用西方的一些画法创作山水画，大多不太成功，也很难得到国人的认可。在这方面较为成功的是李可染和赖少其。他们都有深厚的传统文化功底，年轻时向传统大家学习，精研书法，长期写生。在打牢传统的各种基础后，李可染将光引入艺术表现，尤善用积墨画逆光；赖少其学习西方印象派等画法，借鉴西洋画的着色方式，和传统融合得很好。所以，他们笔下的祖国河山仍然体现出雄浑厚重、大气磅礴的中国精神。 填人画横线部分最恰当的一项是：A.中西融合是二十世纪中国画面对的世纪课题B.中国画具有独特的文化特质和内在发展逻辑C.中国画家借鉴外来艺术时需有良好的传统功底 D.借鉴西洋画艺术手法取得成功的中国画家很少A即指问题，又提到中西融合。C对策放开头不太行吧。另外在打牢基础后，引入艺术表现；融合传统。所以他们笔下的xxx可以体现顺承出融合重要。随着我国科技对经济社会发展贡献率的增大，以及科技介入生活程度的","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_4","order":4,"summary":"艺是时代前进的号角 D.文艺创新是与时代脉搏同频共振的原文，时代的xx，又强调文艺，选C，D是同等地位了。B只是我国的情况。感觉语句填入得看另一个老师。注意是逗号需要粘合后文。而句号是引领全文____。新中国成立以来，很多画家借用西方的一些画法创作山水画，大多不太成功，也很难得到国人的认可。在这方面较为成功的是李可染和赖少其。他们都有深厚的传统文化功底，年轻时向传统大家学习，精研书法，长期写生。在打牢传统的各种基础后，李可染将光引入艺术表现，尤善用积墨画逆光；赖少其学习西方印象派等画法，借鉴西洋画的着色方式，和传统融合得很好。所以，他们笔下的祖国河山仍然体现出雄浑厚重、大气磅礴的中国精神。 填人画横线部分最恰当的一项是：A.中西融合是二十世纪中国画面对的世纪课题B.中国画具有独特的文化特质和内在发展逻辑C.中国画家借鉴外来艺术时需有良好的传统功底 D.借鉴西洋画艺术手法取得成功的中国画家很少A即指问题，又提到中西融合。C对策放开头不太行吧。另外在打牢基础后，引入艺术表现；融合传统。所以他们笔下的xxx可以体现顺承出融合重要。随着我国科技对经济社会发展贡献率的增大，以及科技介入生活程度的","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"加深，普通人与科技的关系也变得更加密切。科普走进生活，越来越成为人们的普遍期待。而这又对科普创新提出了更高的要求。科普创新当然首先是要及时更新科普的理念和内容，把日新月异的科技发展成果通俗易懂地告诉民众。同时，它也意味着科普形式和手段的创新。增添文艺的元素，则是其题中应有之义，____。老一辈科学工作者十分善于借用文学艺术的力量。例如，当我们翻阅竺可桢先生《说飓风》《说云》等科普文章时，就会被其准确而又生动的文字所折服。填入画横部分最恰当的一项是： A.人们对科普作品文艺性的期，越来越高 B.文学艺术是推动科普创新的重要驱动力C.事实上，科普本身就具有文学性 D.如何兼顾科普内容和形式的创新是当务之急前文增添（原先没有），后文借用文学（借）。缺少拥有的阶段，选C，科普有文学性。BD读起来不通顺啊，还是看语感。浪漫的古人，常借助一些动植物来表达爱情，常见的有鸳鸯、凤凰、大雁、红豆、梧桐等。为什么梧桐会成为爱情的象征呢？可能原因有二，一是梧桐雌雄异株，其中“梧”为雄株，“桐”为雌株，因此古人看见梧桐树，便联想到比翼双飞的爱情。另外一个原因，梧桐树高大茂密，常引来一些鸟儿共筑爱巢，____。","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_5","order":5,"summary":"加深，普通人与科技的关系也变得更加密切。科普走进生活，越来越成为人们的普遍期待。而这又对科普创新提出了更高的要求。科普创新当然首先是要及时更新科普的理念和内容，把日新月异的科技发展成果通俗易懂地告诉民众。同时，它也意味着科普形式和手段的创新。增添文艺的元素，则是其题中应有之义，____。老一辈科学工作者十分善于借用文学艺术的力量。例如，当我们翻阅竺可桢先生《说飓风》《说云》等科普文章时，就会被其准确而又生动的文字所折服。填入画横部分最恰当的一项是： A.人们对科普作品文艺性的期，越来越高 B.文学艺术是推动科普创新的重要驱动力C.事实上，科普本身就具有文学性 D.如何兼顾科普内容和形式的创新是当务之急前文增添（原先没有），后文借用文学（借）。缺少拥有的阶段，选C，科普有文学性。BD读起来不通顺啊，还是看语感。浪漫的古人，常借助一些动植物来表达爱情，常见的有鸳鸯、凤凰、大雁、红豆、梧桐等。为什么梧桐会成为爱情的象征呢？可能原因有二，一是梧桐雌雄异株，其中“梧”为雄株，“桐”为雌株，因此古人看见梧桐树，便联想到比翼双飞的爱情。另外一个原因，梧桐树高大茂密，常引来一些鸟儿共筑爱巢，____。","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"是逗号，应该顺承上文（树鸟），而不是总结全文。宝石颜色有三个影响要素，即光源、宝石和观察者。不同的光源具有不同的光谱能量分布，因而照射到宝石上会使宝石呈现出不同的颜色；宝石由于自身内部的致色离子对光源光波的选择性吸收、反射、透射而呈现出不同的颜色；对于观察者而言，虽然人眼具有对可见光的灵敏分辨力，但对具体波长可见光的感知是因人而异的。也就是说，对同一宝石品种与观察者来说，____。 填入画横线部分最恰当的一句是（ ）。 A.宝石颜色会随照明光源的不同而发生改变 B.标准光源的选定对宝石颜色评价尤为关键C.提高观察者对可见光的灵敏分辨力十分必要 D.选择透光性好的宝石能获得更高的市场利润CAB结构，CD干扰选项。A其实有点废话，因为前文已经提到了。而B可以很好的顺承：在同一条件下，选择好光源。下文推断 做题策略：全文阅读，明白大致讲什么，不可直接锁定尾句，如选不出来，可以选项进行稍微造句，带回原文看看是否顺承。 尾句引出新主体 当尾句出现前文从来没有论述过的主体，抓住它，后文大概率是围绕其展开的。本质仍然是脉络的铺垫引出 2021 年 4 月 8 日，国家发展改革委印发《2021 年新型","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_6","order":6,"summary":"是逗号，应该顺承上文（树鸟），而不是总结全文。宝石颜色有三个影响要素，即光源、宝石和观察者。不同的光源具有不同的光谱能量分布，因而照射到宝石上会使宝石呈现出不同的颜色；宝石由于自身内部的致色离子对光源光波的选择性吸收、反射、透射而呈现出不同的颜色；对于观察者而言，虽然人眼具有对可见光的灵敏分辨力，但对具体波长可见光的感知是因人而异的。也就是说，对同一宝石品种与观察者来说，____。 填入画横线部分最恰当的一句是（ ）。 A.宝石颜色会随照明光源的不同而发生改变 B.标准光源的选定对宝石颜色评价尤为关键C.提高观察者对可见光的灵敏分辨力十分必要 D.选择透光性好的宝石能获得更高的市场利润CAB结构，CD干扰选项。A其实有点废话，因为前文已经提到了。而B可以很好的顺承：在同一条件下，选择好光源。下文推断 做题策略：全文阅读，明白大致讲什么，不可直接锁定尾句，如选不出来，可以选项进行稍微造句，带回原文看看是否顺承。 尾句引出新主体 当尾句出现前文从来没有论述过的主体，抓住它，后文大概率是围绕其展开的。本质仍然是脉络的铺垫引出 2021 年 4 月 8 日，国家发展改革委印发《2021 年新型","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"城镇化和城乡融合发展重点任务》，落实适用、经济、绿色、美观的新时期建筑方针，严格限制建设500 米以上超高层建筑，严禁建设“丑陋建筑”。建筑→丑陋建筑（新主体），并且应先介绍再展开再意义的脉络。话题思维 话题思维是下文推断的核心思维，即你原本的话题是否讲完了？你选择这个选项是否换话题了？ 注重逻辑性和时间性按照事物的事件发生顺序：本话题→原因，主体展开，意义危害，对策。之后再换话题 (接连引出） 现在生活条件越来越好，除了家里常备的油盐酱醋，蚝油也是一款家家必备的调料品之一，蚝油顾名思义是以鲜蚝为原料，经过煮熟取汁浓缩，加上辅料精制而成，色泽呈红褐色，形态呈半流质状，黏稠度比较适中，相比于酱油来说，营养价值就更高一些，鲜味也就更加浓郁。平时在家做菜时放一点蚝油，不但可以起到增香、提鲜的作用，还能增加菜品的色泽。由于蚝油可以作为日常提鲜、增鲜的主要调料，因此很多人把蚝油拿来代替生抽使用，不管做什么菜都会用上蚝油。但蚝油无论是制作工艺还是原材料，都和生抽的大为不同，使用方法也是有较大的区别。如果随便放蚝油，不仅起不到提鲜的效果，甚至会影响身体健康。末尾提出耗油的危害，后文应该优先衔接对策，","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_7","order":7,"summary":"城镇化和城乡融合发展重点任务》，落实适用、经济、绿色、美观的新时期建筑方针，严格限制建设500 米以上超高层建筑，严禁建设“丑陋建筑”。建筑→丑陋建筑（新主体），并且应先介绍再展开再意义的脉络。话题思维 话题思维是下文推断的核心思维，即你原本的话题是否讲完了？你选择这个选项是否换话题了？ 注重逻辑性和时间性按照事物的事件发生顺序：本话题→原因，主体展开，意义危害，对策。之后再换话题 (接连引出） 现在生活条件越来越好，除了家里常备的油盐酱醋，蚝油也是一款家家必备的调料品之一，蚝油顾名思义是以鲜蚝为原料，经过煮熟取汁浓缩，加上辅料精制而成，色泽呈红褐色，形态呈半流质状，黏稠度比较适中，相比于酱油来说，营养价值就更高一些，鲜味也就更加浓郁。平时在家做菜时放一点蚝油，不但可以起到增香、提鲜的作用，还能增加菜品的色泽。由于蚝油可以作为日常提鲜、增鲜的主要调料，因此很多人把蚝油拿来代替生抽使用，不管做什么菜都会用上蚝油。但蚝油无论是制作工艺还是原材料，都和生抽的大为不同，使用方法也是有较大的区别。如果随便放蚝油，不仅起不到提鲜的效果，甚至会影响身体健康。末尾提出耗油的危害，后文应该优先衔接对策，","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"其次是为什么出现这个危害。多对自己提问自问自答，猜测后文会是什么内容。 葡聚糖是现在人气极高，食品科学和工业界很看好的一种可溶性纤维。某些葡聚糖也似乎对于增强免疫力更有效果——但是任何的膳食纤维都会对健康大有裨益。与其花大钱去买“特别的”“增强免疫力”的纤维，多吃一些经济实惠的富含膳食纤维的食物是不是更划算?主体是膳食纤维食物。因为膳食纤维会让人类生活更好，有点生硬，并且是其意义。（哪些食物呢？）膳食纤维有蔬菜水果，感觉顺承通顺，对主体展开。食品行业是关系人民群众切身需求和经济社会和谐稳定的民生行业。但目前来看，我国食品供给体系总体呈现出中低端产品过剩、中高端和个性化产品供给严重不足的问题，消费者对国外产品的依赖程度越来越高。特别在当前速度换挡、结构调整、动力转换的经济新常态下，深入推进食品行业供给侧改革，是实现食品行业健康长远发展的必然选择。食品标准既是国家食品安全治理体系中的重要组成部分，又是引导食品生产质量的主要风向标，因此，深化食品行业供给侧结构性改革的关键在于构建一套先进的食品行业标准。引出新主体食品行业标准。那么应该如何构建这个标准呢？先看重点关注的问题，再解决这些问题，从","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_8","order":8,"summary":"其次是为什么出现这个危害。多对自己提问自问自答，猜测后文会是什么内容。 葡聚糖是现在人气极高，食品科学和工业界很看好的一种可溶性纤维。某些葡聚糖也似乎对于增强免疫力更有效果——但是任何的膳食纤维都会对健康大有裨益。与其花大钱去买“特别的”“增强免疫力”的纤维，多吃一些经济实惠的富含膳食纤维的食物是不是更划算?主体是膳食纤维食物。因为膳食纤维会让人类生活更好，有点生硬，并且是其意义。（哪些食物呢？）膳食纤维有蔬菜水果，感觉顺承通顺，对主体展开。食品行业是关系人民群众切身需求和经济社会和谐稳定的民生行业。但目前来看，我国食品供给体系总体呈现出中低端产品过剩、中高端和个性化产品供给严重不足的问题，消费者对国外产品的依赖程度越来越高。特别在当前速度换挡、结构调整、动力转换的经济新常态下，深入推进食品行业供给侧改革，是实现食品行业健康长远发展的必然选择。食品标准既是国家食品安全治理体系中的重要组成部分，又是引导食品生产质量的主要风向标，因此，深化食品行业供给侧结构性改革的关键在于构建一套先进的食品行业标准。引出新主体食品行业标准。那么应该如何构建这个标准呢？先看重点关注的问题，再解决这些问题，从","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"国外案例吸取经验。宏观具体展开（难题） 很多同学做下文推断题有一种误区，那就是上文论述过的东西下文就一定不能论述了，其实这是一种错误的思维，它可以进行宏观具体的展开。 宏观具体展开的难题， 往往本质上还是你的理解能力，读题的时候就要感觉出来作者写得很宏观，宽泛。看前句甚至前文来推断主要内容。 个人建议放弃，又难又浪费时间，或者从选项反推造句看看合不合适。 医学摄影是利用普通或特殊摄影成像设备，将被摄人体生命活动影像记录于感光材料或电子元件，它是用于医学科学的摄影技术，是科技的重要分支，也是摄影技术与医学科学交融的产物。随着科学技术的发展、医疗设备的进步，摄影技术在医学科学领域的应用日益广泛，医学科学进入了读图时代。医学摄影可以纵向延伸人们的视线，让你看到人体生命活动的微观世界；它又能横向拓宽人们的视野，让你看到平时看不到的生命活动影像。文章接下来最有可能介绍的是（ ）。 A.人体生命活动的微观世界 B.摄影技术在医学中的应用C.读图时代对摄影技术的要求D.摄影技术在非医学领域的优势观点：医学摄影很重要。后文应该也是紧扣医学摄影，选B；C的读图时代是因为摄影而引出来，只是附带品（个人理解","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_9","order":9,"summary":"国外案例吸取经验。宏观具体展开（难题） 很多同学做下文推断题有一种误区，那就是上文论述过的东西下文就一定不能论述了，其实这是一种错误的思维，它可以进行宏观具体的展开。 宏观具体展开的难题， 往往本质上还是你的理解能力，读题的时候就要感觉出来作者写得很宏观，宽泛。看前句甚至前文来推断主要内容。 个人建议放弃，又难又浪费时间，或者从选项反推造句看看合不合适。 医学摄影是利用普通或特殊摄影成像设备，将被摄人体生命活动影像记录于感光材料或电子元件，它是用于医学科学的摄影技术，是科技的重要分支，也是摄影技术与医学科学交融的产物。随着科学技术的发展、医疗设备的进步，摄影技术在医学科学领域的应用日益广泛，医学科学进入了读图时代。医学摄影可以纵向延伸人们的视线，让你看到人体生命活动的微观世界；它又能横向拓宽人们的视野，让你看到平时看不到的生命活动影像。文章接下来最有可能介绍的是（ ）。 A.人体生命活动的微观世界 B.摄影技术在医学中的应用C.读图时代对摄影技术的要求D.摄影技术在非医学领域的优势观点：医学摄影很重要。后文应该也是紧扣医学摄影，选B；C的读图时代是因为摄影而引出来，只是附带品（个人理解","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"，宏观具体展开不好理解）。 原文出题人的小心思， 先礼后兵 出题人经常把一个文段里面两个联系紧密的内容给你从中间剪开，只保留一半，此时要把另一半补齐，形成一套完整的行文脉络 出题人常见的小心思 总分文段：开头告诉你了总+分1+分2，后文只提及分1，则后文会有分2以形成完整的行文脉络。 古今时间对比文段：文段告诉你了过去怎样（常是有xx问题），则后文会叙述现在怎么样。（或者现在有问题，将来怎么样） 新旧事物对比文段：文段告诉你旧的事物是什么，则后文会叙述新的差异性事物是什么。 说话说一半，需要提升理解能力，灵活理解。 迄今为止，在地面实验中，量子密钥分发的点对点距离可达500 千米星级，而量子隐形传态可达 100 千米，那么如何在此基础上继续增加量子通信的距离呢？一个阶段性的解决方案是可信中继传输，我国建设的光纤总长超过 2000 千米的“京沪干线”是采用了这一方案，在可信中继方案中，需要人为保障中继站点的安全，而中继之间的线路则是安全的。这比传统通信手段中整条线路处处都是面临着信息泄露的风险而言，大幅提高了安全性。一个阶段性方案→一个长远的方案最不可能讲述 当文段问你以下最不可能论述的","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_10","order":10,"summary":"，宏观具体展开不好理解）。 原文出题人的小心思， 先礼后兵 出题人经常把一个文段里面两个联系紧密的内容给你从中间剪开，只保留一半，此时要把另一半补齐，形成一套完整的行文脉络 出题人常见的小心思 总分文段：开头告诉你了总+分1+分2，后文只提及分1，则后文会有分2以形成完整的行文脉络。 古今时间对比文段：文段告诉你了过去怎样（常是有xx问题），则后文会叙述现在怎么样。（或者现在有问题，将来怎么样） 新旧事物对比文段：文段告诉你旧的事物是什么，则后文会叙述新的差异性事物是什么。 说话说一半，需要提升理解能力，灵活理解。 迄今为止，在地面实验中，量子密钥分发的点对点距离可达500 千米星级，而量子隐形传态可达 100 千米，那么如何在此基础上继续增加量子通信的距离呢？一个阶段性的解决方案是可信中继传输，我国建设的光纤总长超过 2000 千米的“京沪干线”是采用了这一方案，在可信中继方案中，需要人为保障中继站点的安全，而中继之间的线路则是安全的。这比传统通信手段中整条线路处处都是面临着信息泄露的风险而言，大幅提高了安全性。一个阶段性方案→一个长远的方案最不可能讲述 当文段问你以下最不可能论述的","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"是哪个选项时， 常选上文已经完整具体论述过的或者选项本身离谱的，也可以排除可能会论述的 联想到当今跨文化接触中的问题，我们可以一如既往地视利玛窦为一个先驱，他使两个文明的沟通成为可能，他使用的工具是把理解中国文化视为己任（首先是掌握语言），努力在中国寻找和西方共通的思想和机制。以后几代的西方人，从传教士、外交家到商人，告别了利玛窦的信念，致力于寻找中西之间的差异，而中国也开始更多地强调中国文化的独特性。作者接下来最不可能讲述的是：（ ） A.利玛窦是如何寻找中西方共通的思想和机制的 B.中国相关学者是如何确定中国文化的独特性的 C.我们如何看待利玛窦的共通性和其他人的差异性 D.利玛窦之后的西方人是如何寻找中西之间差异的尾句已经说到差异性，不可能又掉头再将共通。并且其他选项都是讲差异。关键词填入 题型：文段是完整文段，但是问你以下哪些是文段的关键词这种题型正确率往往极低 ，个人建议放弃难题关键词提取的秒杀技巧，就是把它当成中心理解题来做，提取观点，从观点选关键字。实用技巧：观点锁定 不排除不确定的，排除一定不能选的 同等地位排除（以人为本） 根据新的刑事证据规则，鉴定检材的真实性和同一","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_11","order":11,"summary":"是哪个选项时， 常选上文已经完整具体论述过的或者选项本身离谱的，也可以排除可能会论述的 联想到当今跨文化接触中的问题，我们可以一如既往地视利玛窦为一个先驱，他使两个文明的沟通成为可能，他使用的工具是把理解中国文化视为己任（首先是掌握语言），努力在中国寻找和西方共通的思想和机制。以后几代的西方人，从传教士、外交家到商人，告别了利玛窦的信念，致力于寻找中西之间的差异，而中国也开始更多地强调中国文化的独特性。作者接下来最不可能讲述的是：（ ） A.利玛窦是如何寻找中西方共通的思想和机制的 B.中国相关学者是如何确定中国文化的独特性的 C.我们如何看待利玛窦的共通性和其他人的差异性 D.利玛窦之后的西方人是如何寻找中西之间差异的尾句已经说到差异性，不可能又掉头再将共通。并且其他选项都是讲差异。关键词填入 题型：文段是完整文段，但是问你以下哪些是文段的关键词这种题型正确率往往极低 ，个人建议放弃难题关键词提取的秒杀技巧，就是把它当成中心理解题来做，提取观点，从观点选关键字。实用技巧：观点锁定 不排除不确定的，排除一定不能选的 同等地位排除（以人为本） 根据新的刑事证据规则，鉴定检材的真实性和同一","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"性已经成为鉴定意见转化为定案根据的前提条件。这显然是我国刑事证据制度发生的重大变化。透过这一变化，我们可以发现司法改革的决策者们已经具有了一种新的理论认识：实物证据鉴真是司法鉴定程序启动的前提和基础；未经鉴真过程，任何专业人士对实物证据所作的“司法鉴定意见”都将是没有法律意义的；实物证据作为一种“送检材料”，在其真实性和同一性存在合理疑问的情况下，鉴定意见将不具有作为定案根据的资格。 这段文字中提取的关键词最恰当的是 A.刑事证据 实物证据鉴真 定案根据 B.司法改革 司法鉴定意见 定案根据C.鉴定检材 刑事证据制度 司法改革D.证据制度 司法鉴定程序 送检材料文段首先提出了新的刑事证据规则的内容是“鉴定检材的真实性和统一性”是“定案根据”的“前提条件”，接着根据“重大变化”和“这一变化”都可以得出后文的内容都是对第一句的解释说明，因此可以确定重点句就是第一句，而第一句中我们可以提取的关键词有“刑事证据规则”、“鉴定检材的真实性和统一性”和“定案根据”，对比选项，发现只有A选项提到了重点句中的其中两个关键词，根据话题一致这时就可以确定正确答案是A选项了。再来验证“鉴定检材的真实性和统一","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_12","order":12,"summary":"性已经成为鉴定意见转化为定案根据的前提条件。这显然是我国刑事证据制度发生的重大变化。透过这一变化，我们可以发现司法改革的决策者们已经具有了一种新的理论认识：实物证据鉴真是司法鉴定程序启动的前提和基础；未经鉴真过程，任何专业人士对实物证据所作的“司法鉴定意见”都将是没有法律意义的；实物证据作为一种“送检材料”，在其真实性和同一性存在合理疑问的情况下，鉴定意见将不具有作为定案根据的资格。 这段文字中提取的关键词最恰当的是 A.刑事证据 实物证据鉴真 定案根据 B.司法改革 司法鉴定意见 定案根据C.鉴定检材 刑事证据制度 司法改革D.证据制度 司法鉴定程序 送检材料文段首先提出了新的刑事证据规则的内容是“鉴定检材的真实性和统一性”是“定案根据”的“前提条件”，接着根据“重大变化”和“这一变化”都可以得出后文的内容都是对第一句的解释说明，因此可以确定重点句就是第一句，而第一句中我们可以提取的关键词有“刑事证据规则”、“鉴定检材的真实性和统一性”和“定案根据”，对比选项，发现只有A选项提到了重点句中的其中两个关键词，根据话题一致这时就可以确定正确答案是A选项了。再来验证“鉴定检材的真实性和统一","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"性”是否是“实物证据鉴真”的同义替换。后文说到了“实物证据鉴真”是“司法程序启动”的前提，对应第一句所说的前提，再往后看，“实物证据作为一种“送检材料”，即“检材”，而“鉴真”就是“鉴定真实性和同一性”，所以通过这两个对比可以确认“鉴定检材的真实性和统一性”就是“实物证据鉴真”的同义替换。农村金融需求是否满足，对农村发展的进程有极大影响。全面疏解农村地区信贷供给，是我国推进农业农村优先发展的重要一环。要不断完善金融支农的激励约束机制，加快农村金融回归“三农”本源的进程，促进金融资源向农业农村流动，以打通农村金融供需“梗阻”。持续推进农村金融供给侧结构性改革，增强农村金融服务农村实体经济的能力。同时，大力发展农村普惠金融，鼓励各金融机构为农业农村优先发展提供多层次、广覆盖、低成本、可持续的金融服务。 这段文字中提取的关键词最恰当的是： A.农村金融 农村发展 金融支农 B.农村金融 金融机构 金融服务C.农村金融 金融资源 农业农村 D.农村金融 普惠金融 服务农村我猜的：全篇强调农村金融，以及金融对农村发展的影响，以及金融支持农村的措施。上帝视角：A都是动词。精准扶贫不能仅仅专注个别事","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_13","order":13,"summary":"性”是否是“实物证据鉴真”的同义替换。后文说到了“实物证据鉴真”是“司法程序启动”的前提，对应第一句所说的前提，再往后看，“实物证据作为一种“送检材料”，即“检材”，而“鉴真”就是“鉴定真实性和同一性”，所以通过这两个对比可以确认“鉴定检材的真实性和统一性”就是“实物证据鉴真”的同义替换。农村金融需求是否满足，对农村发展的进程有极大影响。全面疏解农村地区信贷供给，是我国推进农业农村优先发展的重要一环。要不断完善金融支农的激励约束机制，加快农村金融回归“三农”本源的进程，促进金融资源向农业农村流动，以打通农村金融供需“梗阻”。持续推进农村金融供给侧结构性改革，增强农村金融服务农村实体经济的能力。同时，大力发展农村普惠金融，鼓励各金融机构为农业农村优先发展提供多层次、广覆盖、低成本、可持续的金融服务。 这段文字中提取的关键词最恰当的是： A.农村金融 农村发展 金融支农 B.农村金融 金融机构 金融服务C.农村金融 金融资源 农业农村 D.农村金融 普惠金融 服务农村我猜的：全篇强调农村金融，以及金融对农村发展的影响，以及金融支持农村的措施。上帝视角：A都是动词。精准扶贫不能仅仅专注个别事","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"实，埋头解决个别问题，而不知道把个别贫困或特殊贫困同经济社会发展的宏观背景联系起来。应当明确地认识到，虽然各种特殊贫困都有特殊的因素，但特殊贫困也是在当下信息社会背景下存在的。信息化和网络化中蕴含了十分丰富的资源和能量，应当大力扶持贫困人口或贫困群体尽快了解和适应信息化与网络化的新形势，通过技术培训和典型示范，把远离信息化和网络化的贫困人口引入这个历史进程之中。观点：精准扶贫如何做；认识到特殊贫困在信息社会下存在；应扶持xxx适应信息化，通过技术培训和典型示范。信息社会优于特殊贫困，因为有前者才有后者。树木年轮是气候学研究里最重要的代用指标，其定年方法准确可靠，气候敏感性与分辨率较高，被国际气候学研究广泛应用。干旱区与半干旱区是树木年轮研究工作的重点区域，我国在阿勒泰区域已经开展了大量的树木年轮研究工作，不过采样样本较少，气象数据年份较短，数据处理的精度存在问题，因此有必要开展新的树木年轮采样工作。随着全球气候变暖，阿勒泰区域的气候条件变化深刻，研究西伯利亚落叶松在气候变化下的生长情况，对于研究西利亚落叶松在应对全球变暖背景下如何发展和变化具有重要意义，对森林生长环境保护具有重要的借鉴","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_14","order":14,"summary":"实，埋头解决个别问题，而不知道把个别贫困或特殊贫困同经济社会发展的宏观背景联系起来。应当明确地认识到，虽然各种特殊贫困都有特殊的因素，但特殊贫困也是在当下信息社会背景下存在的。信息化和网络化中蕴含了十分丰富的资源和能量，应当大力扶持贫困人口或贫困群体尽快了解和适应信息化与网络化的新形势，通过技术培训和典型示范，把远离信息化和网络化的贫困人口引入这个历史进程之中。观点：精准扶贫如何做；认识到特殊贫困在信息社会下存在；应扶持xxx适应信息化，通过技术培训和典型示范。信息社会优于特殊贫困，因为有前者才有后者。树木年轮是气候学研究里最重要的代用指标，其定年方法准确可靠，气候敏感性与分辨率较高，被国际气候学研究广泛应用。干旱区与半干旱区是树木年轮研究工作的重点区域，我国在阿勒泰区域已经开展了大量的树木年轮研究工作，不过采样样本较少，气象数据年份较短，数据处理的精度存在问题，因此有必要开展新的树木年轮采样工作。随着全球气候变暖，阿勒泰区域的气候条件变化深刻，研究西伯利亚落叶松在气候变化下的生长情况，对于研究西利亚落叶松在应对全球变暖背景下如何发展和变化具有重要意义，对森林生长环境保护具有重要的借鉴","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"和指导作用。首局的限定相对来说没那么重要，需要从选项反窥首句。文段主要引出阿勒泰区域的情况。有学者认为，巫觋的地位在夏朝已经急剧下降。不过，巫觋在官方和民间的各种祭祀中仍然发挥作用，其参与的名称各异的前戏剧活动，一直延续到今天。现在我们在江西、贵州等地看到的“傩戏”或“地戏”，其将鬼神祭祀与戏剧融为一体的仪式，就多少包含了远古仪式的遗存。诚然，国家在每年春夏秋冬和各节令大典，及遇有战争之类重大事件时，还是会按例举行严肃的祭祀仪礼，但这些仪礼的效用与功能，早就发生了巨大变化。苏轼认为早在夏商周三代，各种祭祀性活动，就已包含非常明显的游戏或戏剧的因素，而祭祀神灵、祖先这一原初动机，反渐渐演变为依附性的功能。 这段文字所在的文章，论述主题最可能是：（ ）。 A.巫术 B.祭祀 C.戏剧 D.礼仪观点：（仪礼的）效用发生变化，祭祀转换为戏剧。细节判断 常见错误 细节判断中，找正确的选项不难，难的是如何判断一个选项是否是错误的。需要注意的是，一定不可以本末倒置，做题的时候不是去思考它属于哪种错误，真真切切感受它有错就可以。 做题的时候，先读文段还是先读选项没有绝对的说法，具体题目具体分析 错误类","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_15","order":15,"summary":"和指导作用。首局的限定相对来说没那么重要，需要从选项反窥首句。文段主要引出阿勒泰区域的情况。有学者认为，巫觋的地位在夏朝已经急剧下降。不过，巫觋在官方和民间的各种祭祀中仍然发挥作用，其参与的名称各异的前戏剧活动，一直延续到今天。现在我们在江西、贵州等地看到的“傩戏”或“地戏”，其将鬼神祭祀与戏剧融为一体的仪式，就多少包含了远古仪式的遗存。诚然，国家在每年春夏秋冬和各节令大典，及遇有战争之类重大事件时，还是会按例举行严肃的祭祀仪礼，但这些仪礼的效用与功能，早就发生了巨大变化。苏轼认为早在夏商周三代，各种祭祀性活动，就已包含非常明显的游戏或戏剧的因素，而祭祀神灵、祖先这一原初动机，反渐渐演变为依附性的功能。 这段文字所在的文章，论述主题最可能是：（ ）。 A.巫术 B.祭祀 C.戏剧 D.礼仪观点：（仪礼的）效用发生变化，祭祀转换为戏剧。细节判断 常见错误 细节判断中，找正确的选项不难，难的是如何判断一个选项是否是错误的。需要注意的是，一定不可以本末倒置，做题的时候不是去思考它属于哪种错误，真真切切感受它有错就可以。 做题的时候，先读文段还是先读选项没有绝对的说法，具体题目具体分析 错误类","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"型：偷换时态、偷换概念、偷换范围、偷换逻辑、强加对比、绝对化、语义相悖、无中生有 偷换时态 过去时、现在时、将来时的替换 过去时态：已经，已，曾，了，过... 现在时态：正，正在，在...中，现，现在... 将来时态：将，要，不久，很快... 中国妇女发展基金会将委托专业金融机构对中国女足发展基金进行管理和运作，其收益部分用于资助中国女子足球队改善生活和训练条件，开展交流合作，培养选拔后备力量。 D.中国女足发展基金，已确定了管理机制和运作规则 偷换概念 文段提到相关概念，但是对所提到的主客体及其动作、状态等相关要素进行替换 一战结束以后，中国海外移民掀起第三个高潮，其主要流向仍是东南亚，直接动力是东南亚的经济繁荣。20 世纪初以来，西方工业革命所带动的新兴产业的发展，陆续波及其东南亚的殖民地。东南亚经济发展刺激了对劳动力的需求的增长，廉价劳动力从中国南方不断涌入东南亚。B.华人廉价劳工移民东南亚主要从事工业革命以来的新兴产业 偷换范围 要确保选项和原文讨论的是同一件事，不能缩小、扩大、更换话题 5G 时代的到来，标志着中国移动通信技术跃升至全球领先地位。这对中国网络文化抓住中国技术领","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_16","order":16,"summary":"型：偷换时态、偷换概念、偷换范围、偷换逻辑、强加对比、绝对化、语义相悖、无中生有 偷换时态 过去时、现在时、将来时的替换 过去时态：已经，已，曾，了，过... 现在时态：正，正在，在...中，现，现在... 将来时态：将，要，不久，很快... 中国妇女发展基金会将委托专业金融机构对中国女足发展基金进行管理和运作，其收益部分用于资助中国女子足球队改善生活和训练条件，开展交流合作，培养选拔后备力量。 D.中国女足发展基金，已确定了管理机制和运作规则 偷换概念 文段提到相关概念，但是对所提到的主客体及其动作、状态等相关要素进行替换 一战结束以后，中国海外移民掀起第三个高潮，其主要流向仍是东南亚，直接动力是东南亚的经济繁荣。20 世纪初以来，西方工业革命所带动的新兴产业的发展，陆续波及其东南亚的殖民地。东南亚经济发展刺激了对劳动力的需求的增长，廉价劳动力从中国南方不断涌入东南亚。B.华人廉价劳工移民东南亚主要从事工业革命以来的新兴产业 偷换范围 要确保选项和原文讨论的是同一件事，不能缩小、扩大、更换话题 5G 时代的到来，标志着中国移动通信技术跃升至全球领先地位。这对中国网络文化抓住中国技术领","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"先契机、“引领全球文化”具有划时代的历史意义。5G 时代是智能终端应用更为广泛、智能思维极尽挥洒、创意创新充分涌现的好时机，“智能制造”“智能服务”“智能产业”“智能文化”“无人文化”等无处不在。B.5G 时代中国引领全球文化 偷换逻辑 偷换因果关系、前提关系、并列关系、转折关系等逻辑关系 生长在水中或水边的动植物的遗体是最易被保存下来的，因为保存动植物遗体的必要条件是快速掩埋，而在淤泥不断淤积的海洋、河流乃至湖泊中，动植物的遗体以及其他东西能够被快速掩埋。 B.只有生长在水中或水边的动植物的遗体才能被保存下来D.只要被快速掩埋，动植物遗体就能被保存D保存遗体必须快速掩埋，倒置了。强加对比 文段并没有进行主体、程度的对比，但是选项添加了对比 一项新研究发现，低温能通过将所谓的“坏”脂肪转化为“好”脂肪帮助人体燃烧卡路里。这一理论基于两种脂肪的不同特性。我们都再熟悉不过的讨厌的白色脂肪会吸收额外的卡路里并将它们储存在肚子、腰间和大腿中。但成年人还有少量的另一种“健康脂肪”，这种褐色脂肪专门燃烧卡路里同时产生热量。婴儿有大量褐色脂肪来保暖，褐色脂肪多的成年人也更苗条。D.婴儿体内的褐色脂肪","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_17","order":17,"summary":"先契机、“引领全球文化”具有划时代的历史意义。5G 时代是智能终端应用更为广泛、智能思维极尽挥洒、创意创新充分涌现的好时机，“智能制造”“智能服务”“智能产业”“智能文化”“无人文化”等无处不在。B.5G 时代中国引领全球文化 偷换逻辑 偷换因果关系、前提关系、并列关系、转折关系等逻辑关系 生长在水中或水边的动植物的遗体是最易被保存下来的，因为保存动植物遗体的必要条件是快速掩埋，而在淤泥不断淤积的海洋、河流乃至湖泊中，动植物的遗体以及其他东西能够被快速掩埋。 B.只有生长在水中或水边的动植物的遗体才能被保存下来D.只要被快速掩埋，动植物遗体就能被保存D保存遗体必须快速掩埋，倒置了。强加对比 文段并没有进行主体、程度的对比，但是选项添加了对比 一项新研究发现，低温能通过将所谓的“坏”脂肪转化为“好”脂肪帮助人体燃烧卡路里。这一理论基于两种脂肪的不同特性。我们都再熟悉不过的讨厌的白色脂肪会吸收额外的卡路里并将它们储存在肚子、腰间和大腿中。但成年人还有少量的另一种“健康脂肪”，这种褐色脂肪专门燃烧卡路里同时产生热量。婴儿有大量褐色脂肪来保暖，褐色脂肪多的成年人也更苗条。D.婴儿体内的褐色脂肪","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"更多 绝对化 绝对化指个体认为某一事物必定会发生或一定不会发生等程度过重的错误 当众羞辱学生，以冷酷的惩罚性体验“培养”了学生的自卑，仇恨甚至社会攻击倾向，而侵害了自尊心，信任能力和集体归属感。一次当众羞辱就是对人的尊严的一次践踏，反复的羞辱体验则将导致人格尊严的丧失。而人类社会最重要的价值——爱，道德，公民品格与社会凝聚力——都有赖于人对自我，对他人的尊严的确认与珍视。C.学生有了自卑，仇恨甚至社会攻击倾向，就会走向犯罪 语义相悖 指完全错误的表达，和文段表达的意思相悖 比目鱼的眼睛为什么会长到同一边去呢？有人认为，比目鱼眼睛的移动是由头骨变形造成的，但比目鱼的额骨位于眼睛的上方，与眼睛没有直接接触。有学者推测，比目鱼眼睛的移动是由于眼睛下方有限区域内分裂的细胞之间空间拥挤，驱使其上方的眼睛向上移动。最新研究通过在比目鱼移动眼下方区域注射细胞分裂抑制剂，培养出了眼睛不移动、两眼保持对称的比目鱼稚鱼，并发现其左右额骨仍然保持对称。而且发现比目鱼眼睛哪一方分裂细胞数明显多于上方区域，则那一方的眼睛会移动，如鲆类是右眼，鲽类则是左眼。B.比目鱼额骨的扭转不仅是眼睛向上移动的结果，而且会影响","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_18","order":18,"summary":"更多 绝对化 绝对化指个体认为某一事物必定会发生或一定不会发生等程度过重的错误 当众羞辱学生，以冷酷的惩罚性体验“培养”了学生的自卑，仇恨甚至社会攻击倾向，而侵害了自尊心，信任能力和集体归属感。一次当众羞辱就是对人的尊严的一次践踏，反复的羞辱体验则将导致人格尊严的丧失。而人类社会最重要的价值——爱，道德，公民品格与社会凝聚力——都有赖于人对自我，对他人的尊严的确认与珍视。C.学生有了自卑，仇恨甚至社会攻击倾向，就会走向犯罪 语义相悖 指完全错误的表达，和文段表达的意思相悖 比目鱼的眼睛为什么会长到同一边去呢？有人认为，比目鱼眼睛的移动是由头骨变形造成的，但比目鱼的额骨位于眼睛的上方，与眼睛没有直接接触。有学者推测，比目鱼眼睛的移动是由于眼睛下方有限区域内分裂的细胞之间空间拥挤，驱使其上方的眼睛向上移动。最新研究通过在比目鱼移动眼下方区域注射细胞分裂抑制剂，培养出了眼睛不移动、两眼保持对称的比目鱼稚鱼，并发现其左右额骨仍然保持对称。而且发现比目鱼眼睛哪一方分裂细胞数明显多于上方区域，则那一方的眼睛会移动，如鲆类是右眼，鲽类则是左眼。B.比目鱼额骨的扭转不仅是眼睛向上移动的结果，而且会影响","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"比目鱼眼睛的移动 无中生有 文段中完全没有提及某一概念 近些年来，我国网络游戏市场规模不断扩大，行业版图快速扩张，“搞代码”“做游戏”“写程序”的 IT 工程师，都成了众人口中的“香饽饽”职业。一份最新的报告数据显示，2018年第一季度，中国网络游戏市场维持稳定增长，市场规模达 643.3 亿元，各大游戏厂商纷纷加大网游出海业务布局。毫无疑问，我国网络游戏市场正在快速奔跑。C.越来越多企业选择跨行业加入网络游戏市场 特殊题型 有无提及 题型：以下哪项有没有被提及。不要求你判断正误，选项往往是很短的，可优先看选项 鬼斧神工，天机独运。别处的山，都是亲亲热热地手拉着手，臂挽着臂，唯有张家界的山，彼此保持头角峥嵘的独立，谁也不待见谁。别处的峰，再陡再险也能踩在脚下，唯有张家界，以她的危崖崩壁，拒绝从猿到人的一切趾印。每柱岩峰，都青筋裸露、血性十足地直插霄汉。而峰巅的每处缝隙，每尺泥士，又必定有苍松或翠柏，亭亭如盖地笑傲尘寰。银崖翠冠，站远了看，犹如放大的苏州盆景。曲壑蟠涧，更增添无限空蒙幽翠。风吹过，一啸百吟；云漫开，万千气韵。 上述语段对张家界的山水描写没有提到的是（ ）。 A.山峰的形态","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_19","order":19,"summary":"比目鱼眼睛的移动 无中生有 文段中完全没有提及某一概念 近些年来，我国网络游戏市场规模不断扩大，行业版图快速扩张，“搞代码”“做游戏”“写程序”的 IT 工程师，都成了众人口中的“香饽饽”职业。一份最新的报告数据显示，2018年第一季度，中国网络游戏市场维持稳定增长，市场规模达 643.3 亿元，各大游戏厂商纷纷加大网游出海业务布局。毫无疑问，我国网络游戏市场正在快速奔跑。C.越来越多企业选择跨行业加入网络游戏市场 特殊题型 有无提及 题型：以下哪项有没有被提及。不要求你判断正误，选项往往是很短的，可优先看选项 鬼斧神工，天机独运。别处的山，都是亲亲热热地手拉着手，臂挽着臂，唯有张家界的山，彼此保持头角峥嵘的独立，谁也不待见谁。别处的峰，再陡再险也能踩在脚下，唯有张家界，以她的危崖崩壁，拒绝从猿到人的一切趾印。每柱岩峰，都青筋裸露、血性十足地直插霄汉。而峰巅的每处缝隙，每尺泥士，又必定有苍松或翠柏，亭亭如盖地笑傲尘寰。银崖翠冠，站远了看，犹如放大的苏州盆景。曲壑蟠涧，更增添无限空蒙幽翠。风吹过，一啸百吟；云漫开，万千气韵。 上述语段对张家界的山水描写没有提到的是（ ）。 A.山峰的形态","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":" B.峰顶的松柏 C.岩峰的走向D.山壑与山涧“走向”为地质学名词，指地质构造上岩层、矿层、山脉等延伸的方向难题的对比择优 细节判断题的难题，很多时候都是需要对比择优的，即有的选项是小瑕疵，有的选项是大问题，这种情况下，小瑕疵也能选 一个地区物质的贫困，往往与其精神的贫乏、文化的落后息息相关。正是时下很多地方乡村文化的整体性衰落，导致民众很难获得足够丰富、正常的文化滋养和精神润泽。 由上述文字不能推出： A.乡土中国的发展亟需精神扶贫 B.中国乡村出现了物质与精神的“双重贫困” C.与硬件建设相比，流动在硬件背后的“文化流”更为重要 D.有必要从文化层面重建乡土中国虽然B没有强调精神，但是C没有乡村必错。逻辑填空 逻辑填空要学好，三方面少不了，一是提升理解能力，读懂作者所表达；二是分析文段脉络找对应；三是投入精力勤积累。 要对比择优，很多成语实词的选填往往是不完美的，甚至可能出现错误和小错误这种情况 辨析的前提是多者在宏观意思上相同才辨析，不要一上来直接抓辨析点 多个词语先挑简单的空，实词和成语先看成语 四大契合 契合解释说明 文段出现举例子等解释说明时（常出现如，例如，比如等）,空格","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_20","order":20,"summary":" B.峰顶的松柏 C.岩峰的走向D.山壑与山涧“走向”为地质学名词，指地质构造上岩层、矿层、山脉等延伸的方向难题的对比择优 细节判断题的难题，很多时候都是需要对比择优的，即有的选项是小瑕疵，有的选项是大问题，这种情况下，小瑕疵也能选 一个地区物质的贫困，往往与其精神的贫乏、文化的落后息息相关。正是时下很多地方乡村文化的整体性衰落，导致民众很难获得足够丰富、正常的文化滋养和精神润泽。 由上述文字不能推出： A.乡土中国的发展亟需精神扶贫 B.中国乡村出现了物质与精神的“双重贫困” C.与硬件建设相比，流动在硬件背后的“文化流”更为重要 D.有必要从文化层面重建乡土中国虽然B没有强调精神，但是C没有乡村必错。逻辑填空 逻辑填空要学好，三方面少不了，一是提升理解能力，读懂作者所表达；二是分析文段脉络找对应；三是投入精力勤积累。 要对比择优，很多成语实词的选填往往是不完美的，甚至可能出现错误和小错误这种情况 辨析的前提是多者在宏观意思上相同才辨析，不要一上来直接抓辨析点 多个词语先挑简单的空，实词和成语先看成语 四大契合 契合解释说明 文段出现举例子等解释说明时（常出现如，例如，比如等）,空格","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"所填成语实词要契合后文的解释说明 除了“设计最短路线”“避开交通拥堵”之外，部分提供导航服务的企业，在安排线路时还渗入了其他_____，比如他们会让用户绕行一些企业暂时缺乏数据的路线，以_____收集信息。 依次填入画横线部分最恰当的一项是（ ）。 A.理念 尝试 B.想法 上报 C.思路 补充 D.考量 协助让用户绕行，企业有点小心思，排除AC。上报是向上级汇报，而不是用户才是上级。契合具体展开 文段出现后文完整语句可以填进空格，同样可以形成一个完整句子时，所填成语诗词要和后文完整语句契合。 迭代思维，大数据思维……关于互联网思维的众多阐释尤其是实践心得，都有价值。不过，互联网思维并不是万能的救命稻草，抓住了就能_____。如果罔顾互联网思维的本质，迷惑于它的表象，盲目套用这个“万能公式”，结果只会_____。用好互联网思维，还要洗去它被打扮的妆容，看清“素颜”，需要立足于“互联网给我们带来的改变”去思考，也需要_____，从自身的特点来挑选和利用。 依次填入画横线部分最恰当的一项是（ ）。 A.起死回生 适得其反 量体裁衣 B.化险为夷 事与愿违 随机应变C.转危为安 拔苗助长 随","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_21","order":21,"summary":"所填成语实词要契合后文的解释说明 除了“设计最短路线”“避开交通拥堵”之外，部分提供导航服务的企业，在安排线路时还渗入了其他_____，比如他们会让用户绕行一些企业暂时缺乏数据的路线，以_____收集信息。 依次填入画横线部分最恰当的一项是（ ）。 A.理念 尝试 B.想法 上报 C.思路 补充 D.考量 协助让用户绕行，企业有点小心思，排除AC。上报是向上级汇报，而不是用户才是上级。契合具体展开 文段出现后文完整语句可以填进空格，同样可以形成一个完整句子时，所填成语诗词要和后文完整语句契合。 迭代思维，大数据思维……关于互联网思维的众多阐释尤其是实践心得，都有价值。不过，互联网思维并不是万能的救命稻草，抓住了就能_____。如果罔顾互联网思维的本质，迷惑于它的表象，盲目套用这个“万能公式”，结果只会_____。用好互联网思维，还要洗去它被打扮的妆容，看清“素颜”，需要立足于“互联网给我们带来的改变”去思考，也需要_____，从自身的特点来挑选和利用。 依次填入画横线部分最恰当的一项是（ ）。 A.起死回生 适得其反 量体裁衣 B.化险为夷 事与愿违 随机应变C.转危为安 拔苗助长 随","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"遇而安 D.妙手回春 欲速不达 量力而行救命-\u003e起死回生；从自身的特点来利用（量体裁衣）契合主谓宾性质 文段横线的内容，主语、谓语、宾语三者的性质要相同，可以跳出题目思考具体有什么性质。 移动终端快餐化、碎片化阅读受到大学生的推崇，但松散的阅读习惯很难使人构建_____的思想体系。在浮躁的社会环境中，经典著作虽然能够对人有潜移默化的影响，但却不能像实用书籍那样_____，这也是部分读者远离经典的原因。A.完整 立竿见影 B.深刻 行之有效 C.系统 屡试不爽D.宏大 学以致用松散的习惯-\u003e完整的体系甲骨文发现后，学者们通过对殷墟甲骨文的研究，证明了《史记•殷本纪》的可信，证实了司马迁撰写的商代历史绝非_____，从而极大地提高了《史记》中有关夏朝历史记载的可信度。考古学家和历史学家正以《史记•夏本纪》的记载为_____，探寻夏代的历史文化，目前已取得了可观的成绩。因此，用出土文物去印证古代典籍，重建夏商周三代文明的可信历史，甲骨文起了举足轻重的作用。A.虚构 线索：探寻（寻找）线索在一些城市的流调报告中，相继出现了“只提地点不提人”的信息公布新方式，得到了舆论的高度_____。在新增确","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_22","order":22,"summary":"遇而安 D.妙手回春 欲速不达 量力而行救命-\u003e起死回生；从自身的特点来利用（量体裁衣）契合主谓宾性质 文段横线的内容，主语、谓语、宾语三者的性质要相同，可以跳出题目思考具体有什么性质。 移动终端快餐化、碎片化阅读受到大学生的推崇，但松散的阅读习惯很难使人构建_____的思想体系。在浮躁的社会环境中，经典著作虽然能够对人有潜移默化的影响，但却不能像实用书籍那样_____，这也是部分读者远离经典的原因。A.完整 立竿见影 B.深刻 行之有效 C.系统 屡试不爽D.宏大 学以致用松散的习惯-\u003e完整的体系甲骨文发现后，学者们通过对殷墟甲骨文的研究，证明了《史记•殷本纪》的可信，证实了司马迁撰写的商代历史绝非_____，从而极大地提高了《史记》中有关夏朝历史记载的可信度。考古学家和历史学家正以《史记•夏本纪》的记载为_____，探寻夏代的历史文化，目前已取得了可观的成绩。因此，用出土文物去印证古代典籍，重建夏商周三代文明的可信历史，甲骨文起了举足轻重的作用。A.虚构 线索：探寻（寻找）线索在一些城市的流调报告中，相继出现了“只提地点不提人”的信息公布新方式，得到了舆论的高度_____。在新增确","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"诊病例的流调报告中隐去患者的个人信息，改为以涉及区域和场所信息披露为主，这一做法受到了不少媒体和网民的称赞，“不提人”更显对人的_____。A.关注 体谅 B.认可 尊重 C.评价 关爱 D.肯定 重视“不提人”-\u003e尊重隐私权-\u003e尊重从企业成长理论的角度分析，多元化经营是企业成长的结果，是企业实现发展壮大的重要途径。多元化的经营能够帮助企业实现规模经济向范围经济转变的目标，同时又可以降低资产的_____，提高企业能力。在利益和效率的_____下，多元化经营成为众多企业的选择。 A.流动性 推动 B.封闭性 带领 C.风险性 引领 D.专属性 驱动多元化-\u003e单一性-\u003e专属性。封闭性对应开放。契合比喻 当文段出现了很形象的比喻用法时，抓准比喻，契合比喻性质，往往可以秒杀题。 从符号化到数字化，信息在人类进化和文明发展中的重要性毋庸置疑。如果说符号化产生了知识的“宝库”，那么作为数字化的产物，大数据将成为人类的“超级矿藏”，其资源性、基础性与战略性的价值已经_____。为应对大数据时代的到来，国际竞争正在悄然展开。A.略胜一筹 B.初露峥嵘 C.不可胜数 D.今非昔比文中提到了“信息是很重要","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_23","order":23,"summary":"诊病例的流调报告中隐去患者的个人信息，改为以涉及区域和场所信息披露为主，这一做法受到了不少媒体和网民的称赞，“不提人”更显对人的_____。A.关注 体谅 B.认可 尊重 C.评价 关爱 D.肯定 重视“不提人”-\u003e尊重隐私权-\u003e尊重从企业成长理论的角度分析，多元化经营是企业成长的结果，是企业实现发展壮大的重要途径。多元化的经营能够帮助企业实现规模经济向范围经济转变的目标，同时又可以降低资产的_____，提高企业能力。在利益和效率的_____下，多元化经营成为众多企业的选择。 A.流动性 推动 B.封闭性 带领 C.风险性 引领 D.专属性 驱动多元化-\u003e单一性-\u003e专属性。封闭性对应开放。契合比喻 当文段出现了很形象的比喻用法时，抓准比喻，契合比喻性质，往往可以秒杀题。 从符号化到数字化，信息在人类进化和文明发展中的重要性毋庸置疑。如果说符号化产生了知识的“宝库”，那么作为数字化的产物，大数据将成为人类的“超级矿藏”，其资源性、基础性与战略性的价值已经_____。为应对大数据时代的到来，国际竞争正在悄然展开。A.略胜一筹 B.初露峥嵘 C.不可胜数 D.今非昔比文中提到了“信息是很重要","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"的”，“大数据将成为‘超级矿藏’”，因此该空应体现“大数据价值巨大”的含义。A项“略胜一筹”指两相比较，稍微好一些，文中未体现“大数据与其他事物相比而自身优越”的含义，排除。C项“不可胜数”形容数量很多，显然此处没有“数量多少”的含义，且与空前的“价值”不搭配，排除。D项“今非昔比”形容现在比起过去，变化很大，文中未体现“今昔”“变化”的含义，排除。B项“初露峥嵘”指不寻常之处刚刚显露出来，符合文意。因此答案为B。尊重原文，怎么能选C？？，比喻形容矿藏资源丰富前驱者们深厚的学养和科学态度，对_____当下学界弥漫着的浮泛学风，有着深刻的现实意义。他们严谨扎实的作风和科学求实的态度，永远也不会过时，仍然是当代比较文学研究者应当继承和学习的。但这绝不意味着，我们要重复前人的劳动，_____地重走前人已经走过的道路。 A.改正 按部就班 B.矫正 如法炮制C.纠正 心安理得 D.匡正 亦步亦趋道路-\u003e走路-\u003e亦步亦趋电影是“文化名片”，生动地展示着一个国家的形象；也是“文化底片”，形象地显影着一个国家的_____；电影是“文化芯片”，深刻地_____着一个国家的精神密码。电影并不提供解决方案","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_24","order":24,"summary":"的”，“大数据将成为‘超级矿藏’”，因此该空应体现“大数据价值巨大”的含义。A项“略胜一筹”指两相比较，稍微好一些，文中未体现“大数据与其他事物相比而自身优越”的含义，排除。C项“不可胜数”形容数量很多，显然此处没有“数量多少”的含义，且与空前的“价值”不搭配，排除。D项“今非昔比”形容现在比起过去，变化很大，文中未体现“今昔”“变化”的含义，排除。B项“初露峥嵘”指不寻常之处刚刚显露出来，符合文意。因此答案为B。尊重原文，怎么能选C？？，比喻形容矿藏资源丰富前驱者们深厚的学养和科学态度，对_____当下学界弥漫着的浮泛学风，有着深刻的现实意义。他们严谨扎实的作风和科学求实的态度，永远也不会过时，仍然是当代比较文学研究者应当继承和学习的。但这绝不意味着，我们要重复前人的劳动，_____地重走前人已经走过的道路。 A.改正 按部就班 B.矫正 如法炮制C.纠正 心安理得 D.匡正 亦步亦趋道路-\u003e走路-\u003e亦步亦趋电影是“文化名片”，生动地展示着一个国家的形象；也是“文化底片”，形象地显影着一个国家的_____；电影是“文化芯片”，深刻地_____着一个国家的精神密码。电影并不提供解决方案","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"，但却让陌生的心灵相通，成为我们彼此贴近、_____对方的“通行证”。A.内涵 传递 理解 B.底蕴 揭示 抵达 C.神采 谱写 拥抱 D.气质 建构 接纳文化底片-\u003e底蕴；通行证-\u003e抵达让学生接受马克思主义，离不开必要的灌输，但这不等于搞填鸭式的“硬灌输”。要注重启发式教育，引导学生发现问题、分析问题、思考问题，在不断启发中让学生_____得出结论。A.潜移默化 B.举一反三C.水到渠成 D.融会贯通硬灌输-\u003e软灌输-\u003e渠-\u003e水到渠成科技是国家强盛之基，科技成果是科技发展水平的外在表现。当下，我国在多个关键核心技术上依旧面临“卡脖子”的问题，如何用好科技成果评价这个（），支持一线科技人员潜心研究，激发科技人员（ ），是加快实现国家科技自立自强的关键。A.指挥棒 积极性 B.发动机 内驱力 C.火车头 新动能 D.风向标 创造性第一空，横线处是对“科技成果评价”的比喻，能够形象生动地体现出“科技成果评价”的作用。根据文段“我国在多个关键核心技术上依旧面临‘卡脖子’的问题”，而“如何用好科技成果评价”“是加快实现国家科技自主自强的关键”，可知“科技成果评价”有助于我国有针对性的解决“卡脖","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_25","order":25,"summary":"，但却让陌生的心灵相通，成为我们彼此贴近、_____对方的“通行证”。A.内涵 传递 理解 B.底蕴 揭示 抵达 C.神采 谱写 拥抱 D.气质 建构 接纳文化底片-\u003e底蕴；通行证-\u003e抵达让学生接受马克思主义，离不开必要的灌输，但这不等于搞填鸭式的“硬灌输”。要注重启发式教育，引导学生发现问题、分析问题、思考问题，在不断启发中让学生_____得出结论。A.潜移默化 B.举一反三C.水到渠成 D.融会贯通硬灌输-\u003e软灌输-\u003e渠-\u003e水到渠成科技是国家强盛之基，科技成果是科技发展水平的外在表现。当下，我国在多个关键核心技术上依旧面临“卡脖子”的问题，如何用好科技成果评价这个（），支持一线科技人员潜心研究，激发科技人员（ ），是加快实现国家科技自立自强的关键。A.指挥棒 积极性 B.发动机 内驱力 C.火车头 新动能 D.风向标 创造性第一空，横线处是对“科技成果评价”的比喻，能够形象生动地体现出“科技成果评价”的作用。根据文段“我国在多个关键核心技术上依旧面临‘卡脖子’的问题”，而“如何用好科技成果评价”“是加快实现国家科技自主自强的关键”，可知“科技成果评价”有助于我国有针对性的解决“卡脖","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"子”的问题，故“科技成果评价”具有一定的指引作用、引领作用。A 项“指挥棒”原指乐队指挥﹑交通警指挥棍之意，现比喻能起指挥、引导作用的事物，符合文意，保留；B 项“发动机”原指提供动力的机械，可也比喻为动力源泉，文中“科技成果评价”并非源头性作用，不合文意，排除；C 项“火车头”比喻起带头作用或领导作用的人或事物，文段并未表明“成果评价”是领导带头人物，程度过重，排除；D 项“风向标”本意为一种测定风来向的设备，后来引申为某种事物的发展趋势和方向，不合文意，排除。第二空，代入验证，“激发科研人员积极性”，符合文意，当选。三大注重 注重主谓宾 一定要看准一个完整语句里面，谁是主语，谁是谓语，谁是宾语，很多同学往往读得很快，很容易忽略这个点。 注重程度轻重 横线中填入的成语实词，一定要和文段的程度轻重匹配，不可过轻或过重 注重情感色彩 要注重文段的褒贬，中性的情感色彩，不能褒贬混用 注重主谓宾访古是十分感人的经历，尤其是当我们踏上古代文献中_____的地点时。亲手触摸庄重威严的利簋，秀丽铭文好像把我们拉回到三千年前牧野之战的场景，_____中描绘的古代社会面貌在脑海中清晰了起来，我们感受到","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_26","order":26,"summary":"子”的问题，故“科技成果评价”具有一定的指引作用、引领作用。A 项“指挥棒”原指乐队指挥﹑交通警指挥棍之意，现比喻能起指挥、引导作用的事物，符合文意，保留；B 项“发动机”原指提供动力的机械，可也比喻为动力源泉，文中“科技成果评价”并非源头性作用，不合文意，排除；C 项“火车头”比喻起带头作用或领导作用的人或事物，文段并未表明“成果评价”是领导带头人物，程度过重，排除；D 项“风向标”本意为一种测定风来向的设备，后来引申为某种事物的发展趋势和方向，不合文意，排除。第二空，代入验证，“激发科研人员积极性”，符合文意，当选。三大注重 注重主谓宾 一定要看准一个完整语句里面，谁是主语，谁是谓语，谁是宾语，很多同学往往读得很快，很容易忽略这个点。 注重程度轻重 横线中填入的成语实词，一定要和文段的程度轻重匹配，不可过轻或过重 注重情感色彩 要注重文段的褒贬，中性的情感色彩，不能褒贬混用 注重主谓宾访古是十分感人的经历，尤其是当我们踏上古代文献中_____的地点时。亲手触摸庄重威严的利簋，秀丽铭文好像把我们拉回到三千年前牧野之战的场景，_____中描绘的古代社会面貌在脑海中清晰了起来，我们感受到","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"了历史迎面扑来的强烈震颤。这种感觉，对于考古学家来说可谓一种致命的“诱惑”。然而，身为一名严谨科学的从业者，必须对这种诱惑保持足够的警惕，维护考古记录的_____，这是一名考古学者的自警，也是整个考古学学科的自尊。A.如雷贯耳 刀光剑影 客观性 B.如数家珍 白纸黑字 严肃性C.司空见惯 鼓角齐鸣 主体性 D.耳熟能详 只言片语 独立性铭文(主语)-\u003e文字-\u003e只言片语(白纸黑字指的是证据)注重程度轻重横线中填入的成语实词，一定要和文段的程度轻重匹配，不可过轻或过重 随着年轻人不断搬至新城，古城的活力日减，如何用新鲜血液激活（）的古城？恐怕没有比组织年轻人徒步“走读”更好的方式了，通过开展一系列活动来激发年轻一代的主人翁意识，是（ ）古城的重要一步。 A.濒危 还原 B.衰颓 挽救 C.退化 重启D.落寞 复苏活力日减-\u003e还未消亡-\u003e排除ABC（（身体、精神等）衰弱颓废。）。活力复苏。注重情感⾊彩要注重文段的褒贬，中性的情感色彩，不能褒贬混用 国学如果停留在如此浅层次的形式复古，无异于_____，甚至会把国学弄成与现代文明相对抗的姿态，凡事不问好坏对错，一切以东西古今划界。凡是古人的都是","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_27","order":27,"summary":"了历史迎面扑来的强烈震颤。这种感觉，对于考古学家来说可谓一种致命的“诱惑”。然而，身为一名严谨科学的从业者，必须对这种诱惑保持足够的警惕，维护考古记录的_____，这是一名考古学者的自警，也是整个考古学学科的自尊。A.如雷贯耳 刀光剑影 客观性 B.如数家珍 白纸黑字 严肃性C.司空见惯 鼓角齐鸣 主体性 D.耳熟能详 只言片语 独立性铭文(主语)-\u003e文字-\u003e只言片语(白纸黑字指的是证据)注重程度轻重横线中填入的成语实词，一定要和文段的程度轻重匹配，不可过轻或过重 随着年轻人不断搬至新城，古城的活力日减，如何用新鲜血液激活（）的古城？恐怕没有比组织年轻人徒步“走读”更好的方式了，通过开展一系列活动来激发年轻一代的主人翁意识，是（ ）古城的重要一步。 A.濒危 还原 B.衰颓 挽救 C.退化 重启D.落寞 复苏活力日减-\u003e还未消亡-\u003e排除ABC（（身体、精神等）衰弱颓废。）。活力复苏。注重情感⾊彩要注重文段的褒贬，中性的情感色彩，不能褒贬混用 国学如果停留在如此浅层次的形式复古，无异于_____，甚至会把国学弄成与现代文明相对抗的姿态，凡事不问好坏对错，一切以东西古今划界。凡是古人的都是","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"好的，哪怕骑驴;凡是现代的都是“非我族类”,都该保持距离。如此下去，国学非但不会被这些人“发扬光大”，相反可能会走入狭隘化、极端化、边缘化的境地，钻进狭小天地里_____，与文明发展割断脉络，把自己变成了一块“化石”。 A.缘木求鱼 蓬荜生辉 B.掩耳盗铃 纤尘不染C.刻舟求剑 皮里阳秋 D.买椟还珠 孤芳自赏贬义-\u003e孤芳自赏。（皮里阳秋：藏在人们心中的褒贬。）诗歌是一门语言艺术，它的材料就是语言，而任何一种语言系统都有巨大的（），诗歌语言也不例外，诗人生活在特定的语言环境中，要表达任何审美意识，都不得不运用（）的语言，即广义的“陈言”，因为从理论上讲，前人从未使用过的崭新语言是无法进行交流的。A.严密性 相沿成习 B.稳定性 循规蹈矩 C.严谨性 陈陈相因 D.稳固性 约定俗成约定俗成：指某种事物的名称或社会习惯是由人们通过长期实践而认定或形成的；相沿成习：成为习惯；陈陈相因：沿袭老一套，没有改进。稳固才不容易改变。渲染：言词、文字过度吹嘘夸大。 三大内部关系 前后文递进 当出现表达递进的关键词时，注意体现这种递进，拿不准时排除一定不是递进的。 常见的递进关键词：甚至、更、更加、尤其","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_28","order":28,"summary":"好的，哪怕骑驴;凡是现代的都是“非我族类”,都该保持距离。如此下去，国学非但不会被这些人“发扬光大”，相反可能会走入狭隘化、极端化、边缘化的境地，钻进狭小天地里_____，与文明发展割断脉络，把自己变成了一块“化石”。 A.缘木求鱼 蓬荜生辉 B.掩耳盗铃 纤尘不染C.刻舟求剑 皮里阳秋 D.买椟还珠 孤芳自赏贬义-\u003e孤芳自赏。（皮里阳秋：藏在人们心中的褒贬。）诗歌是一门语言艺术，它的材料就是语言，而任何一种语言系统都有巨大的（），诗歌语言也不例外，诗人生活在特定的语言环境中，要表达任何审美意识，都不得不运用（）的语言，即广义的“陈言”，因为从理论上讲，前人从未使用过的崭新语言是无法进行交流的。A.严密性 相沿成习 B.稳定性 循规蹈矩 C.严谨性 陈陈相因 D.稳固性 约定俗成约定俗成：指某种事物的名称或社会习惯是由人们通过长期实践而认定或形成的；相沿成习：成为习惯；陈陈相因：沿袭老一套，没有改进。稳固才不容易改变。渲染：言词、文字过度吹嘘夸大。 三大内部关系 前后文递进 当出现表达递进的关键词时，注意体现这种递进，拿不准时排除一定不是递进的。 常见的递进关键词：甚至、更、更加、尤其","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"等 人工智能听起来很遥远，其实已经_____到我们的日常工作和生活中了。人工智能的应用，让生活更便捷、更有乐趣，节约时间、解放体力，甚至未来机器将_____人类进行一些基础性的劳作，这个场景令人憧憬。 A.渗透 替代 B.融入 协助 C.深入 取代 D.运用 辅助主动替代，被动取代。机器应该智能到主动替代。同义并列及不绝对性 当题干中出现一个成语实词后紧跟顿号的情况，为同义并列的表达。 中国古代技术的西传，为欧洲农业、手工业的改进和提高创造了条件，这成为后来英国工业革命兴起的隐形因素。同时，我们有理由相信，一个民族越是思想活跃、眼界开阔，技术的产生越如雨后春笋，从而（ ）时代；越是（ ）、满足现状，技术越会被禁锢，从而被时代遗弃。 A.引领 固步自封 B.推动 畏首畏尾 C.超越 墨守成规 D.开启 抱残守缺与满足现状并列-\u003e固步自封：比喻保守，安于现状，不求进步；抱残守缺：形容思想保守，不肯接受新事物。踏上实现第二个百年奋斗目标新的赶考之路，交出更加优异的答卷，就要使理想信念强大无比，全党的马克思主义信仰_____，共产主义远大理想豪迈澎湃，理想信念的洪流冲决一切阻碍我们前进的围堰和","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_29","order":29,"summary":"等 人工智能听起来很遥远，其实已经_____到我们的日常工作和生活中了。人工智能的应用，让生活更便捷、更有乐趣，节约时间、解放体力，甚至未来机器将_____人类进行一些基础性的劳作，这个场景令人憧憬。 A.渗透 替代 B.融入 协助 C.深入 取代 D.运用 辅助主动替代，被动取代。机器应该智能到主动替代。同义并列及不绝对性 当题干中出现一个成语实词后紧跟顿号的情况，为同义并列的表达。 中国古代技术的西传，为欧洲农业、手工业的改进和提高创造了条件，这成为后来英国工业革命兴起的隐形因素。同时，我们有理由相信，一个民族越是思想活跃、眼界开阔，技术的产生越如雨后春笋，从而（ ）时代；越是（ ）、满足现状，技术越会被禁锢，从而被时代遗弃。 A.引领 固步自封 B.推动 畏首畏尾 C.超越 墨守成规 D.开启 抱残守缺与满足现状并列-\u003e固步自封：比喻保守，安于现状，不求进步；抱残守缺：形容思想保守，不肯接受新事物。踏上实现第二个百年奋斗目标新的赶考之路，交出更加优异的答卷，就要使理想信念强大无比，全党的马克思主义信仰_____，共产主义远大理想豪迈澎湃，理想信念的洪流冲决一切阻碍我们前进的围堰和","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"堤坝。交出更加优异的答卷，就要常怀远虑、_____，始终谦虚谨慎、不骄不燥、艰苦奋斗，不为任何风险所惧，不为任何干扰所惑，不懈推进中华民族伟大复兴。A.坚定无比 忧国忧民 B.坚如磐石 居安思危C.坚强如铁 殚精竭虑 D.毫不动摇 常思过往思考未来-\u003e居安思危。常思过往反义词了。“为调研而调研”等现象的出现，很大程度上就在于调研不深入、不具体。现实中，有人了解情况习惯于大而化之、_____;有人调研习惯于走设计路线，_____。这些心中不揣问题、脚下不沾泥土的错误做法，导致调研不深、不实、不细、不准，最终也会无效。A.粗枝大叶 按部就班 B.走马观花 表里不一 C.轻描淡写 循规蹈矩 D.避重就轻 按图索骥大而化之：形容做事马虎，不仔细。粗枝大叶同义词情绪是本能，每个人每天都会有各种情绪产生。情绪产生之后，是被情绪_____，还是运用情绪优化自己，这就考验一个人的情商。情商绝对不是逢迎拍马，口是心非，_____，也绝对不是否认自己的情绪，或者认为自己不高兴是无所谓的。 A.摆布 滔滔不绝 B.俘虏 巧言令色 C.折磨 人云亦云 D.控制 能言善辩逢迎拍马：迎合；口是心非：虚假-\u003e贬义。","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_30","order":30,"summary":"堤坝。交出更加优异的答卷，就要常怀远虑、_____，始终谦虚谨慎、不骄不燥、艰苦奋斗，不为任何风险所惧，不为任何干扰所惑，不懈推进中华民族伟大复兴。A.坚定无比 忧国忧民 B.坚如磐石 居安思危C.坚强如铁 殚精竭虑 D.毫不动摇 常思过往思考未来-\u003e居安思危。常思过往反义词了。“为调研而调研”等现象的出现，很大程度上就在于调研不深入、不具体。现实中，有人了解情况习惯于大而化之、_____;有人调研习惯于走设计路线，_____。这些心中不揣问题、脚下不沾泥土的错误做法，导致调研不深、不实、不细、不准，最终也会无效。A.粗枝大叶 按部就班 B.走马观花 表里不一 C.轻描淡写 循规蹈矩 D.避重就轻 按图索骥大而化之：形容做事马虎，不仔细。粗枝大叶同义词情绪是本能，每个人每天都会有各种情绪产生。情绪产生之后，是被情绪_____，还是运用情绪优化自己，这就考验一个人的情商。情商绝对不是逢迎拍马，口是心非，_____，也绝对不是否认自己的情绪，或者认为自己不高兴是无所谓的。 A.摆布 滔滔不绝 B.俘虏 巧言令色 C.折磨 人云亦云 D.控制 能言善辩逢迎拍马：迎合；口是心非：虚假-\u003e贬义。","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"巧言令色：形容花言巧语，假装和善，向人讨好。人云亦云：别人说什么，自己也跟着说什么。形容没有主见，随声附和。居天下之广居，立天下之正位，行天下之大道。面对国家间、文化间的差异，中国主张_____、开放包容、互学互鉴；面对经济全球化大潮，中国致力于_____开放合作、开放创新、开放共享的世界经济；面对人类共同挑战，中国秉持共商共建共享的的全球治理观，_____国际关系民主化······习近平总书记强调：我们要_____时代风云，把握时代大势，站在人类发展前沿积极探索关系人类前途命运的重大问题，为应对当今世界面临的全球性挑战、解决人类面临的共性问题贡献中国智慧、中国方案。 A.携手共进 建造 推进 紧跟 B.合作共赢 打造 促进 关注C.求同存异 共建 倡导 洞察 D.和平崛起 构建 力挺 识别开放包容：开放，递进到互学互鉴：互相学习。从不同中找相同，然后包容，然后互相学习。如果你的生活中没有伟大、高贵的人和有智慧的人怎么办?请不要变得麻木，不要_____，不要放弃向生活学习的机会。因为至少在你的周围还有树，特别是大树，它会教会你许多东西。一棵大树，就是你的亲人和老师，而且也可以毫不夸张地","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_31","order":31,"summary":"巧言令色：形容花言巧语，假装和善，向人讨好。人云亦云：别人说什么，自己也跟着说什么。形容没有主见，随声附和。居天下之广居，立天下之正位，行天下之大道。面对国家间、文化间的差异，中国主张_____、开放包容、互学互鉴；面对经济全球化大潮，中国致力于_____开放合作、开放创新、开放共享的世界经济；面对人类共同挑战，中国秉持共商共建共享的的全球治理观，_____国际关系民主化······习近平总书记强调：我们要_____时代风云，把握时代大势，站在人类发展前沿积极探索关系人类前途命运的重大问题，为应对当今世界面临的全球性挑战、解决人类面临的共性问题贡献中国智慧、中国方案。 A.携手共进 建造 推进 紧跟 B.合作共赢 打造 促进 关注C.求同存异 共建 倡导 洞察 D.和平崛起 构建 力挺 识别开放包容：开放，递进到互学互鉴：互相学习。从不同中找相同，然后包容，然后互相学习。如果你的生活中没有伟大、高贵的人和有智慧的人怎么办?请不要变得麻木，不要_____，不要放弃向生活学习的机会。因为至少在你的周围还有树，特别是大树，它会教会你许多东西。一棵大树，就是你的亲人和老师，而且也可以毫不夸张地","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"说，它就是伟大、高贵和有智慧的人。 A.自以为是 B.茫然失措 C.随波逐流 D.自暴自弃根据文段“不要变得麻木，不要……，不要放弃向生活学习的机会”可知空格处应该填一个与变得麻木、放弃学习并列的成分。A项“自以为是”指总以为自己是对的，这与文段的语意明显偏离，排除；B项“茫然失措”指心中迷惑，不知怎么办才好，本身有麻木之意，对应的正是“不要变得麻木”，排除；C项“随波逐流”比喻没有坚定的立场，缺乏判断是非的能力，只能随着别人走。能够作为并列成分填入且符合题干语意。D项“自暴自弃”指自己瞧不起自己，甘于落后或堕落，本身有放弃学习之意，对应的正是“不要放弃向生活学习”，排除。故正确答案为C。顿号表达同义并列，其实是一种“底线抓手”，没有任何对应的时候，可考虑同义并列，当出现更明显的对应时，可以不同义，也就是顿号的同义并列有“不绝对性”。 从个人无意识、（）的影像记录，到组织严密、目标明确、系统全面的深度追踪，纪实摄影体现出见证人类社会发展的历史价值。个人生存状态、家庭生活变迁、社会文明进程、国家发展历程、时代步伐变迁等，纪实摄影建构的“记忆银行”，（）了人们的视觉感官，为我们提供了生动逼","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_32","order":32,"summary":"说，它就是伟大、高贵和有智慧的人。 A.自以为是 B.茫然失措 C.随波逐流 D.自暴自弃根据文段“不要变得麻木，不要……，不要放弃向生活学习的机会”可知空格处应该填一个与变得麻木、放弃学习并列的成分。A项“自以为是”指总以为自己是对的，这与文段的语意明显偏离，排除；B项“茫然失措”指心中迷惑，不知怎么办才好，本身有麻木之意，对应的正是“不要变得麻木”，排除；C项“随波逐流”比喻没有坚定的立场，缺乏判断是非的能力，只能随着别人走。能够作为并列成分填入且符合题干语意。D项“自暴自弃”指自己瞧不起自己，甘于落后或堕落，本身有放弃学习之意，对应的正是“不要放弃向生活学习”，排除。故正确答案为C。顿号表达同义并列，其实是一种“底线抓手”，没有任何对应的时候，可考虑同义并列，当出现更明显的对应时，可以不同义，也就是顿号的同义并列有“不绝对性”。 从个人无意识、（）的影像记录，到组织严密、目标明确、系统全面的深度追踪，纪实摄影体现出见证人类社会发展的历史价值。个人生存状态、家庭生活变迁、社会文明进程、国家发展历程、时代步伐变迁等，纪实摄影建构的“记忆银行”，（）了人们的视觉感官，为我们提供了生动逼","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"真的历史见证。 A.碎片化 延伸 B.零散化 重塑 C.浅表化 拓展D.娱乐化 刺激根据“从个人...系统全面”可知，横线处所填词语应该与横线后语义相反，表示缺乏严密的组织、明确的目标以及非系统全面的意思，存在对应关系。A项“碎片化”、B项“零散化”均可表示不够全面、不够系统之意，保留。C项“浅表化”、D项“娱乐化”不符合语境，且不能形容“影像记录”，排除。延伸感官。前后文反义 当出现引导反义的关键词时， 注重前后的意思相反。 常见的引导反义的关键词：但是、但、然而、却等 2019 年以来，“双百行动”与“综合改革试点”为地方国企改革注入了新动力，踩下了加速器。地方国企改革正推向纵深，包括从单项改革向综合改革推进，从容易改的层面向较难改的层面推进，从修修补补向（）推进。 A.脱胎换骨 B.洗心革面 C.清身洁己 D.阳春白雪“国企改革”，由“向”可知，待填词与“修修补补”构成递进，词义相近，程度更重，待填词应表示改革程度深。对应选项，A项“脱胎换骨”比喻痛改前非，重新来过，侧重强调改变程度深，与“修修补补”构成递进，当选。B项“洗心革面”指去除旧思想，改变旧面貌，比喻坏人物彻底悔改，文","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_33","order":33,"summary":"真的历史见证。 A.碎片化 延伸 B.零散化 重塑 C.浅表化 拓展D.娱乐化 刺激根据“从个人...系统全面”可知，横线处所填词语应该与横线后语义相反，表示缺乏严密的组织、明确的目标以及非系统全面的意思，存在对应关系。A项“碎片化”、B项“零散化”均可表示不够全面、不够系统之意，保留。C项“浅表化”、D项“娱乐化”不符合语境，且不能形容“影像记录”，排除。延伸感官。前后文反义 当出现引导反义的关键词时， 注重前后的意思相反。 常见的引导反义的关键词：但是、但、然而、却等 2019 年以来，“双百行动”与“综合改革试点”为地方国企改革注入了新动力，踩下了加速器。地方国企改革正推向纵深，包括从单项改革向综合改革推进，从容易改的层面向较难改的层面推进，从修修补补向（）推进。 A.脱胎换骨 B.洗心革面 C.清身洁己 D.阳春白雪“国企改革”，由“向”可知，待填词与“修修补补”构成递进，词义相近，程度更重，待填词应表示改革程度深。对应选项，A项“脱胎换骨”比喻痛改前非，重新来过，侧重强调改变程度深，与“修修补补”构成递进，当选。B项“洗心革面”指去除旧思想，改变旧面貌，比喻坏人物彻底悔改，文","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"中搭配对象为“国企改革”，搭配不当，排除；C项“清身洁己”比喻保持自身节操，身体力行，D项“阳春白雪”比喻高深的不通俗的文学艺术，两项均不符合文意，排除。我们通过守正创新形成了中国特色社会主义理论体系，守正就不能偏离马克思主义、社会主义，但不是（），还要往前发展、与时俱进，否则就是僵化的、陈旧的、过时的。 A.刻舟求剑 B.缘木求鱼 C.邯郸学步 D.削足适履（）对比往前发展，与时俱进。刻舟求剑：比喻办事刻板拘泥，不知根据实际情况的发展处理问题。削足适履：比喻不合理地迁就现有条件，或不顾具体条件地生搬硬套。缘木求鱼：行事的方向、方法不对，必将劳而无功，贬义。年轻人应该更好地认识自己、了解各个专业，选择自己真正擅长、真正愿意去（）的方向。热情善谈的人适合当老师，天生大大咧咧的人可能不太适合做医生。不感兴趣的话，在影视鉴赏或媒体创意中也会（），感兴趣的话，在复杂的数学公式和化学方程式中也一样可以自得其乐。 A.努力 束手无策 B.追求 心猿意马 C.实践 郁郁寡欢 D.钻研 索然无味自得其乐-\u003e不快乐-\u003e郁郁寡欢。索然无味还要再推一步才能得到不快乐。特殊：语境相反 文段有可能出现分成两个大","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_34","order":34,"summary":"中搭配对象为“国企改革”，搭配不当，排除；C项“清身洁己”比喻保持自身节操，身体力行，D项“阳春白雪”比喻高深的不通俗的文学艺术，两项均不符合文意，排除。我们通过守正创新形成了中国特色社会主义理论体系，守正就不能偏离马克思主义、社会主义，但不是（），还要往前发展、与时俱进，否则就是僵化的、陈旧的、过时的。 A.刻舟求剑 B.缘木求鱼 C.邯郸学步 D.削足适履（）对比往前发展，与时俱进。刻舟求剑：比喻办事刻板拘泥，不知根据实际情况的发展处理问题。削足适履：比喻不合理地迁就现有条件，或不顾具体条件地生搬硬套。缘木求鱼：行事的方向、方法不对，必将劳而无功，贬义。年轻人应该更好地认识自己、了解各个专业，选择自己真正擅长、真正愿意去（）的方向。热情善谈的人适合当老师，天生大大咧咧的人可能不太适合做医生。不感兴趣的话，在影视鉴赏或媒体创意中也会（），感兴趣的话，在复杂的数学公式和化学方程式中也一样可以自得其乐。 A.努力 束手无策 B.追求 心猿意马 C.实践 郁郁寡欢 D.钻研 索然无味自得其乐-\u003e不快乐-\u003e郁郁寡欢。索然无味还要再推一步才能得到不快乐。特殊：语境相反 文段有可能出现分成两个大","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"部分，两个大部分整体相反，要有宏观思维。 心理学上有个概念叫曝光效应，是指人们会对自己熟悉的事物产生好感，会有“（）”的感觉。曝光效应就是广告营销的心理学基础。不过（），心理学上还有一个概念叫“过度曝光”，研究发现，一个事物在被试面前连续呈现 10 到20 次后会增加好感度，但是超过这个次数，反而会让被试产生厌烦感。 A.似曾相识 不言而喻 B.情有独钟 无独有偶C.心旷神怡 如出一辙 D.如沐春风 物极必反不过，转折出不好-\u003e物极必反三大谬误 局部谬误 很多同学逻辑填空做不好，找不到对应，最大的一个问题便是眼光过于的\"局限\"，只盯着一个局部看，没有宏观的文章把握，我把这种错误称作\"局部谬误\"。 搭配不当 顾名思义，所填入的成语实词和原文的搭配是有问题的。 分割谬误 当文段有大量内容并列时，很多同学往往将其割裂开来看，往往会犯错误，应该注意其\"整体性\"。 局部谬误1915 年，爱因斯坦提出了广义相对论，他认为引力是时空扭曲的结果。在过去的一个世纪，广义相对论的那些看似（）的预言一一被验证。其中一个最（）的预言是，当中子星和黑洞等大质量天体相互碰撞时，时空结构会出现波动。这类事件引发的涟","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_35","order":35,"summary":"部分，两个大部分整体相反，要有宏观思维。 心理学上有个概念叫曝光效应，是指人们会对自己熟悉的事物产生好感，会有“（）”的感觉。曝光效应就是广告营销的心理学基础。不过（），心理学上还有一个概念叫“过度曝光”，研究发现，一个事物在被试面前连续呈现 10 到20 次后会增加好感度，但是超过这个次数，反而会让被试产生厌烦感。 A.似曾相识 不言而喻 B.情有独钟 无独有偶C.心旷神怡 如出一辙 D.如沐春风 物极必反不过，转折出不好-\u003e物极必反三大谬误 局部谬误 很多同学逻辑填空做不好，找不到对应，最大的一个问题便是眼光过于的\"局限\"，只盯着一个局部看，没有宏观的文章把握，我把这种错误称作\"局部谬误\"。 搭配不当 顾名思义，所填入的成语实词和原文的搭配是有问题的。 分割谬误 当文段有大量内容并列时，很多同学往往将其割裂开来看，往往会犯错误，应该注意其\"整体性\"。 局部谬误1915 年，爱因斯坦提出了广义相对论，他认为引力是时空扭曲的结果。在过去的一个世纪，广义相对论的那些看似（）的预言一一被验证。其中一个最（）的预言是，当中子星和黑洞等大质量天体相互碰撞时，时空结构会出现波动。这类事件引发的涟","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"漪会渗透到时空中，（）到很远的地方。A.石破天惊 别出心裁 扩散 B.荒诞不经 雄心勃勃 投射C.异想天开 引人注目 传播 D.遥不可及 广为人知 弥漫第一步，分析第一空。根据文意可知，文中介绍的广义相对论预言在当时是非常超前大胆，难以被人所理解的。A项“石破天惊”比喻诗文、议论不同凡响或事件发展出奇而惊人，和“预言”搭配不当，排除A项。B项“荒诞不经”指非常荒谬，不合情理，符合文意。C项“异想天开”比喻想法离奇，实现不了，符合文意。D项“遥不可及”指很远很远，非常遥远、难以得到的东西，不符合文意，排除D项。在我国逻辑哲学的研究刚刚起步时，人们致力于引进、学习西方逻辑哲学理论。因此，部分学者产生一种（），似乎西方逻辑哲学的理论就是逻辑哲学的唯一真理。他们对待西方逻辑哲学理论，不是采取批判的态度，去其糟粕，取其精华，并以之作为构建我国逻辑哲学的素材，而是全盘照搬，（）。 A.错觉 奉为圭臬 B.误解 肃然起敬 C.倾向 人云亦云 D.认识 顶礼膜拜第一空，由“似乎西方逻辑哲学的理论就是逻辑哲学的唯一真理”可知，部分学者对逻辑哲学的认知发生了偏差，待填词应表示出现偏差之意，且感情色彩消极。","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_36","order":36,"summary":"漪会渗透到时空中，（）到很远的地方。A.石破天惊 别出心裁 扩散 B.荒诞不经 雄心勃勃 投射C.异想天开 引人注目 传播 D.遥不可及 广为人知 弥漫第一步，分析第一空。根据文意可知，文中介绍的广义相对论预言在当时是非常超前大胆，难以被人所理解的。A项“石破天惊”比喻诗文、议论不同凡响或事件发展出奇而惊人，和“预言”搭配不当，排除A项。B项“荒诞不经”指非常荒谬，不合情理，符合文意。C项“异想天开”比喻想法离奇，实现不了，符合文意。D项“遥不可及”指很远很远，非常遥远、难以得到的东西，不符合文意，排除D项。在我国逻辑哲学的研究刚刚起步时，人们致力于引进、学习西方逻辑哲学理论。因此，部分学者产生一种（），似乎西方逻辑哲学的理论就是逻辑哲学的唯一真理。他们对待西方逻辑哲学理论，不是采取批判的态度，去其糟粕，取其精华，并以之作为构建我国逻辑哲学的素材，而是全盘照搬，（）。 A.错觉 奉为圭臬 B.误解 肃然起敬 C.倾向 人云亦云 D.认识 顶礼膜拜第一空，由“似乎西方逻辑哲学的理论就是逻辑哲学的唯一真理”可知，部分学者对逻辑哲学的认知发生了偏差，待填词应表示出现偏差之意，且感情色彩消极。","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"对应选项，C项“倾向”和D项“认识”侧重对逻辑哲学有了了解，感情色彩中性，不符合文意，排除。第二空，由“，”可知，待填词与“全盘照搬”构成并列，词义相近，感情色彩一致，应表示把西方逻辑哲学理论全部当成我国构建逻辑哲学的素材之意。对应选项，A项“奉为圭臬”指把某些言论或事物奉为准则，感情色彩消极，置于文段可以体现出我国构建逻辑哲学时全部照搬西方理论，符合文意，当选。B项“肃然起敬”形容产生严肃敬仰的感情，感情色彩积极且不符合文意，排除。教师是课堂的主导，因此，教学信息化软硬件系统的使用大多取决于教师。但教师在常年的教学中，已形成了一套（）、驾轻就熟的教学方法，如果让他们放弃现成的方法，去学习新的软硬件系统，需要花费大量的时间和精力，有时甚至要（）整门课程的教学组织方式和内容。因此，如果没有合理的激励机制，很多老师对于新系统是（）的。A.完整 颠覆 望而却步 B.严密 改变 踌躇不前C.系统 推翻 漠不关心 D.复杂 重构 畏首畏尾第一空，由“、”可知，待填词与“驾轻就熟”并列，“驾轻就熟”意为对事情熟悉，做起来轻松便捷，再由“如果让他们放弃现成的方法”可知，目前教师在教学中已经有了一套熟","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_37","order":37,"summary":"对应选项，C项“倾向”和D项“认识”侧重对逻辑哲学有了了解，感情色彩中性，不符合文意，排除。第二空，由“，”可知，待填词与“全盘照搬”构成并列，词义相近，感情色彩一致，应表示把西方逻辑哲学理论全部当成我国构建逻辑哲学的素材之意。对应选项，A项“奉为圭臬”指把某些言论或事物奉为准则，感情色彩消极，置于文段可以体现出我国构建逻辑哲学时全部照搬西方理论，符合文意，当选。B项“肃然起敬”形容产生严肃敬仰的感情，感情色彩积极且不符合文意，排除。教师是课堂的主导，因此，教学信息化软硬件系统的使用大多取决于教师。但教师在常年的教学中，已形成了一套（）、驾轻就熟的教学方法，如果让他们放弃现成的方法，去学习新的软硬件系统，需要花费大量的时间和精力，有时甚至要（）整门课程的教学组织方式和内容。因此，如果没有合理的激励机制，很多老师对于新系统是（）的。A.完整 颠覆 望而却步 B.严密 改变 踌躇不前C.系统 推翻 漠不关心 D.复杂 重构 畏首畏尾第一空，由“、”可知，待填词与“驾轻就熟”并列，“驾轻就熟”意为对事情熟悉，做起来轻松便捷，再由“如果让他们放弃现成的方法”可知，目前教师在教学中已经有了一套熟","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"悉的、完备的的教学方法，待填词应体现完备之意。对应选项，A项“完整”、B项“严密”、C项“系统”均可以体现教师目前有适合自己的教学方法，保留。D项“复杂”意为繁多而杂，代入文段强调目前的教学方式多且杂，不符合文意，排除。第二空，由“甚至”可知，待填词与“花费大量的时间和精力”构成递进，程度更重，应表示重新形成新的教学组织方式和内容之意。对应选项，A项“颠覆”、C项“推翻”均可体现重新形成新的教学方法，保留。B项“改变”强调在旧教学方法上作出变动，程度较轻，排除。第三空，由“因此，如果没有合理的激励机制”可知，待填词表示没有激励机制造成的结果，由文意可知，教师有自己熟悉的教学方式，且适应新系统代价很大，如果奖励机制不合理，教师不会愿意尝试新系统，待填词应表示不敢、不想做某事之意。A项“望而却步”意为遇到力不能及的事而往后退缩，能体现教师由于付出的代价大而内心不愿意去主动适应新系统之意，符合文意，当选。C项“漠不关心”指对人或事物冷淡，一点也不关心，文段并无体现关心之意，不符合文意，排除。故本题答案为A项。搭配不当顾名思义，所填入的成语实词和原文的搭配是有问题的。 大多数人都是围绕要做的事","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_38","order":38,"summary":"悉的、完备的的教学方法，待填词应体现完备之意。对应选项，A项“完整”、B项“严密”、C项“系统”均可以体现教师目前有适合自己的教学方法，保留。D项“复杂”意为繁多而杂，代入文段强调目前的教学方式多且杂，不符合文意，排除。第二空，由“甚至”可知，待填词与“花费大量的时间和精力”构成递进，程度更重，应表示重新形成新的教学组织方式和内容之意。对应选项，A项“颠覆”、C项“推翻”均可体现重新形成新的教学方法，保留。B项“改变”强调在旧教学方法上作出变动，程度较轻，排除。第三空，由“因此，如果没有合理的激励机制”可知，待填词表示没有激励机制造成的结果，由文意可知，教师有自己熟悉的教学方式，且适应新系统代价很大，如果奖励机制不合理，教师不会愿意尝试新系统，待填词应表示不敢、不想做某事之意。A项“望而却步”意为遇到力不能及的事而往后退缩，能体现教师由于付出的代价大而内心不愿意去主动适应新系统之意，符合文意，当选。C项“漠不关心”指对人或事物冷淡，一点也不关心，文段并无体现关心之意，不符合文意，排除。故本题答案为A项。搭配不当顾名思义，所填入的成语实词和原文的搭配是有问题的。 大多数人都是围绕要做的事","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"情而非身体的自然节奏来安排自己的时间。每天的工作任务、上下班的交通、社交活动和孩子的日程安排经常（）了我们，我们的时间安排不可避免地与人体生物钟发生（）。 A.支配 冲突 B.干扰 矛盾C.影响 混淆 D.主宰 混乱大多数人、经常-\u003e程度深，排除BC，发生冲突搭配。分割谬误当文段有大量内容并列时，很多同学往往将其割裂开来看，往往会犯错误，应该注意其\"整体性\"。 基础研究是科技创新的（），除了探索自然奥秘、拓展人类的认知边界，基础研究也是破解“卡脖子”难题的关键开关。根深才能叶茂，基础认知不（），原理机制不清楚，就很难做出原创性、革命性、颠覆性的关键核心技术。以我国的“人造太阳”为例，它之所以能（）创造出 1.2 亿摄氏度“燃烧”101 秒，1.6 亿摄氏度“燃烧”20 秒的世界纪录，就源自科研人员对核物理规律更深层次的理解与把握。 A.源头 清晰 接连 B.核心 深入 迅速C.基石 全面 持续D.结果 完整 一直第三空，应该是接连出现成果。特殊技巧 原因导致后果，保持⼀致 当题干出现因果逻辑时，原因导致了某个结果，则这个结果一定要和原图吻合。 敏感于固定搭配 掌握常见的固定搭配，有时候","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_39","order":39,"summary":"情而非身体的自然节奏来安排自己的时间。每天的工作任务、上下班的交通、社交活动和孩子的日程安排经常（）了我们，我们的时间安排不可避免地与人体生物钟发生（）。 A.支配 冲突 B.干扰 矛盾C.影响 混淆 D.主宰 混乱大多数人、经常-\u003e程度深，排除BC，发生冲突搭配。分割谬误当文段有大量内容并列时，很多同学往往将其割裂开来看，往往会犯错误，应该注意其\"整体性\"。 基础研究是科技创新的（），除了探索自然奥秘、拓展人类的认知边界，基础研究也是破解“卡脖子”难题的关键开关。根深才能叶茂，基础认知不（），原理机制不清楚，就很难做出原创性、革命性、颠覆性的关键核心技术。以我国的“人造太阳”为例，它之所以能（）创造出 1.2 亿摄氏度“燃烧”101 秒，1.6 亿摄氏度“燃烧”20 秒的世界纪录，就源自科研人员对核物理规律更深层次的理解与把握。 A.源头 清晰 接连 B.核心 深入 迅速C.基石 全面 持续D.结果 完整 一直第三空，应该是接连出现成果。特殊技巧 原因导致后果，保持⼀致 当题干出现因果逻辑时，原因导致了某个结果，则这个结果一定要和原图吻合。 敏感于固定搭配 掌握常见的固定搭配，有时候","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"可帮助解题 保障基础性 没有相应的语境时，不求最好和完美，确保基础保障即可 多对多对应 经常会出现多者并列和多者并列的对应，此时要注意一一对应。 原因导致后果，保持⼀致使用大数据，一旦安全无法保障，大数据就会产生极大的（），不仅侵害广大用户的切身利益，也会给行业发展蒙上阴影。数据隐私保护固然离不开技术，但我们也不能过于（）技术。只有加强顶层设计，多方形成合力，才更靠谱。A.破坏力 青睐 B.杀伤力 迷信 C.威慑力 推崇 D.冲击力 倚仗第一空。根据第一句提示信息“不仅侵害广大用户的切身利益，也会给行业发展蒙上阴影”可知，大数据会对用户和行业带来巨大的损失和危害，第一空词语情感偏消极。A项“破坏力”是指使损害，损坏，符合文意。B项“杀伤力”指射杀目标，破坏目标的能力，符合文意。C项“威慑力”通常指用武力或威势使对方感到恐惧的力量；D项“冲击力”是指物体相互碰撞时出现的力，这两项均无法直接导致危害的产生，排除C项和D项。第二空。根据文段语义信息，可知我们不能太过于依赖大数据技术，第二空情感倾向应偏消极。A项“青睐”是用正眼相看，指喜爱或重视，且多为褒义词，排除A项。B项“迷信”多指迷失自","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_40","order":40,"summary":"可帮助解题 保障基础性 没有相应的语境时，不求最好和完美，确保基础保障即可 多对多对应 经常会出现多者并列和多者并列的对应，此时要注意一一对应。 原因导致后果，保持⼀致使用大数据，一旦安全无法保障，大数据就会产生极大的（），不仅侵害广大用户的切身利益，也会给行业发展蒙上阴影。数据隐私保护固然离不开技术，但我们也不能过于（）技术。只有加强顶层设计，多方形成合力，才更靠谱。A.破坏力 青睐 B.杀伤力 迷信 C.威慑力 推崇 D.冲击力 倚仗第一空。根据第一句提示信息“不仅侵害广大用户的切身利益，也会给行业发展蒙上阴影”可知，大数据会对用户和行业带来巨大的损失和危害，第一空词语情感偏消极。A项“破坏力”是指使损害，损坏，符合文意。B项“杀伤力”指射杀目标，破坏目标的能力，符合文意。C项“威慑力”通常指用武力或威势使对方感到恐惧的力量；D项“冲击力”是指物体相互碰撞时出现的力，这两项均无法直接导致危害的产生，排除C项和D项。第二空。根据文段语义信息，可知我们不能太过于依赖大数据技术，第二空情感倾向应偏消极。A项“青睐”是用正眼相看，指喜爱或重视，且多为褒义词，排除A项。B项“迷信”多指迷失自","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"性，而盲目地信从，表述情感和语义符合文意。敏感于固定搭配作为智能城市基础设施的重要组成，雄安新区区块链的开发应用一直在悄然进行，从基础架构的 （）到应用落地的（），无不昭示打造“智能之城”的雄心抱负。A.规划 成功不居 B.搭建 牛刀小试C.建立 初露锋芒 D.运行 崭露头角搭建架构保障基础性近年来，一批优秀的中国企业和中国品牌在国际市场成功（），品牌美誉度和忠诚度快速提升。这充分说明，只要依靠创新、下足功夫，中国品牌一定可以（）世界知名品牌。 A.转型 媲美 B.崛起 超越C.突围 比肩 D.亮相 领先超越，领先不符合现实。市场中突围。多对多对应管理者往往对直观信息熟视无睹，对数字情有独钟。结果，他们就可能（）一些关键线索，不能真正了解到对方的优势和劣势。由此导致的结果，要么是“ （）”，要么是“交友不慎”。 A.遗漏 铤而走险 B.轻视 畏首畏尾 C.丢失 误入歧途 D.忽略 坐失良机劣势-\u003e交友不慎，优势-\u003e坐失良机习近平总书记指出：“环境就是民生，青山就是美丽，蓝天也是幸福。要像保护眼睛一样保护生态环境，像对待生命一样对待生态环境，把不损害生态环境作为发展的（）。”“在生态环境","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_41","order":41,"summary":"性，而盲目地信从，表述情感和语义符合文意。敏感于固定搭配作为智能城市基础设施的重要组成，雄安新区区块链的开发应用一直在悄然进行，从基础架构的 （）到应用落地的（），无不昭示打造“智能之城”的雄心抱负。A.规划 成功不居 B.搭建 牛刀小试C.建立 初露锋芒 D.运行 崭露头角搭建架构保障基础性近年来，一批优秀的中国企业和中国品牌在国际市场成功（），品牌美誉度和忠诚度快速提升。这充分说明，只要依靠创新、下足功夫，中国品牌一定可以（）世界知名品牌。 A.转型 媲美 B.崛起 超越C.突围 比肩 D.亮相 领先超越，领先不符合现实。市场中突围。多对多对应管理者往往对直观信息熟视无睹，对数字情有独钟。结果，他们就可能（）一些关键线索，不能真正了解到对方的优势和劣势。由此导致的结果，要么是“ （）”，要么是“交友不慎”。 A.遗漏 铤而走险 B.轻视 畏首畏尾 C.丢失 误入歧途 D.忽略 坐失良机劣势-\u003e交友不慎，优势-\u003e坐失良机习近平总书记指出：“环境就是民生，青山就是美丽，蓝天也是幸福。要像保护眼睛一样保护生态环境，像对待生命一样对待生态环境，把不损害生态环境作为发展的（）。”“在生态环境","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"保护上一定要算大账、算长远账、算整体账、算综合账，不能因小失大、寅吃卯粮、急功近利、（）。” A.基础 一叶障目 B.根本 杀鸡取卵 C.目标 沽名钓誉 D.底线 顾此失彼大帐-\u003e因小失大；长远账-\u003e寅吃卯粮；综合帐-\u003e综合-\u003e顾此失彼：只考虑单个传统戏曲中所蕴含的价值理念以及（）的表演节奏，很难与当代青年人的生活节奏与审美趣味相合拍。因而，关于戏曲衰亡的声音（）。事实上，戏曲相对于互联网时代知识文化的（）、快餐式传播，其可重复欣赏和耐咀嚼的品格显得更为可贵，其特有的艺术价值决定了它不可能退出历史舞台，更不会走向消亡。 A.不疾不徐 如雷贯耳 碎片化 B.从容不迫 不绝于耳 肤浅化C.四平八稳 甚嚣尘上 机械化 D.慢条斯理 此起彼伏 泡沫化第三空：本空为并列关系。根据顿号可知，本空为并列关系。空处与“快餐式传播”对应，应与其语义相近，又根据“可重复欣赏和耐咀嚼的品格显得更为可贵”可知，空处与“可重复欣赏”语义相反，表达“快且不重复”的意思。 A选项“碎片化”指完整的东西破成诸多零块；B选项“泡沫化”指像泡沫一样，外表光鲜，容易转瞬即逝。二者均符合文意，保留。C选项“肤浅化”指局限于表","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_42","order":42,"summary":"保护上一定要算大账、算长远账、算整体账、算综合账，不能因小失大、寅吃卯粮、急功近利、（）。” A.基础 一叶障目 B.根本 杀鸡取卵 C.目标 沽名钓誉 D.底线 顾此失彼大帐-\u003e因小失大；长远账-\u003e寅吃卯粮；综合帐-\u003e综合-\u003e顾此失彼：只考虑单个传统戏曲中所蕴含的价值理念以及（）的表演节奏，很难与当代青年人的生活节奏与审美趣味相合拍。因而，关于戏曲衰亡的声音（）。事实上，戏曲相对于互联网时代知识文化的（）、快餐式传播，其可重复欣赏和耐咀嚼的品格显得更为可贵，其特有的艺术价值决定了它不可能退出历史舞台，更不会走向消亡。 A.不疾不徐 如雷贯耳 碎片化 B.从容不迫 不绝于耳 肤浅化C.四平八稳 甚嚣尘上 机械化 D.慢条斯理 此起彼伏 泡沫化第三空：本空为并列关系。根据顿号可知，本空为并列关系。空处与“快餐式传播”对应，应与其语义相近，又根据“可重复欣赏和耐咀嚼的品格显得更为可贵”可知，空处与“可重复欣赏”语义相反，表达“快且不重复”的意思。 A选项“碎片化”指完整的东西破成诸多零块；B选项“泡沫化”指像泡沫一样，外表光鲜，容易转瞬即逝。二者均符合文意，保留。C选项“肤浅化”指局限于表","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":"面的、浅薄，不深刻，常用于观点、认识、体会、理论等等；D选项“机械化”指使用机械装备以节省人力的生产方式，也指事物如机械动作般缺少变化。二者均不能体现“快且不重复”的意思，不合文意，排除。第二空：本空为修饰关系。空处与“声音”搭配。B选项“此起彼伏”指这里起来，那里下去；形容接连不断，可以与“声音”搭配，符合文意，保留。A选项“如雷贯耳”形容人的名声大。与“声音”搭配不当，排除。如何学逻辑填空 学好前文的出题逻辑 成语实词的积累 学习词义 辨析类似词语 总结适用语境，精确匹配 恭喜你结束了言语理解，🎊，最后做一道题吧美好只是个幻影，我们总是尝试着把生活中所有美好的一切，都据为己有。总是觉得世间万物的馈赠都是理所应当。而当现实的残酷降临在自身的时候，我们总是在抱怨上天的不公平。而我们不知不觉地发现身边总是有些默默无闻的人，他们不骄不躁，总是在失败中学会总结。不是不说故事的人没有故事，即使你的故事辛酸坎坷，让聆听者潸然泪下，不会在故事中汲取教训，你也永远都是一个说故事的人。站在二十年后，你是否会对今天的喟叹而唏嘘不已，对不满足如今的自己而悲伤流泪，而对这样的曾经演变成二十年后的自己万般无奈","date":"2023-11-26T00:30:16+08:00","objectID":"656778a6ed842f7373e7bccb0af0220c_43","order":43,"summary":"面的、浅薄，不深刻，常用于观点、认识、体会、理论等等；D选项“机械化”指使用机械装备以节省人力的生产方式，也指事物如机械动作般缺少变化。二者均不能体现“快且不重复”的意思，不合文意，排除。第二空：本空为修饰关系。空处与“声音”搭配。B选项“此起彼伏”指这里起来，那里下去；形容接连不断，可以与“声音”搭配，符合文意，保留。A选项“如雷贯耳”形容人的名声大。与“声音”搭配不当，排除。如何学逻辑填空 学好前文的出题逻辑 成语实词的积累 学习词义 辨析类似词语 总结适用语境，精确匹配 恭喜你结束了言语理解，🎊，最后做一道题吧美好只是个幻影，我们总是尝试着把生活中所有美好的一切，都据为己有。总是觉得世间万物的馈赠都是理所应当。而当现实的残酷降临在自身的时候，我们总是在抱怨上天的不公平。而我们不知不觉地发现身边总是有些默默无闻的人，他们不骄不躁，总是在失败中学会总结。不是不说故事的人没有故事，即使你的故事辛酸坎坷，让聆听者潸然泪下，不会在故事中汲取教训，你也永远都是一个说故事的人。站在二十年后，你是否会对今天的喟叹而唏嘘不已，对不满足如今的自己而悲伤流泪，而对这样的曾经演变成二十年后的自己万般无奈","tags":["CivilServant"],"title":"公务员行测--言语理解下","url":"http://localhost:1313/posts/learn/speech-understanding-2/"},{"categories":["learn"],"content":" 这个老师不细讲选项的其他错误地方，有点不好，考试肯定要所有选项都看（做多了除外），讲完六大观点，却不在后面深化（有时候会），偏正讲的怪怪的。可能需要多看多理解吧。建议早几个月多看几遍，临考确实来不及深化。不喜欢阿里木江，对比下来还是继续看完吧。另外付费加群后，有好心的小伙伴可以帮你解答问题，或者忽略你的问题 逻辑填空不行，只讲知识点，直接利用知识点看选项，不会解释每个选项。有没有推荐的逻辑填空。需要积累。 没时间推荐不看，凭语感选择，毕竟你是中国人。 以人文本，具体为主准备知识 国考主要考逻辑填空、中心理解逻辑填空 形式：题干+问法+选项 题干为文段但是其中挖去1-4个成语/实词 形成空格 问法为填入画横线/括号部分最恰当的一项是？ 选项为单选，四个选项 需理解文段，选出被挖去的成语/实词 中心理解 形式：题干+问法+选项 题干是完整文段，需要整体阅读理解 问法常为这段文字给我们的启示是？这段文字主要介绍？这段文字的核心观点是？这段文字意在强调？最适合做这段文字标题的是？等等目的是让你理解文段的问法 选项为单选，四个选项，需理解文段，选出文段核心意思 语句填入 形式：题干+问法+选项","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_0","order":0,"summary":" 这个老师不细讲选项的其他错误地方，有点不好，考试肯定要所有选项都看（做多了除外），讲完六大观点，却不在后面深化（有时候会），偏正讲的怪怪的。可能需要多看多理解吧。建议早几个月多看几遍，临考确实来不及深化。不喜欢阿里木江，对比下来还是继续看完吧。另外付费加群后，有好心的小伙伴可以帮你解答问题，或者忽略你的问题 逻辑填空不行，只讲知识点，直接利用知识点看选项，不会解释每个选项。有没有推荐的逻辑填空。需要积累。 没时间推荐不看，凭语感选择，毕竟你是中国人。 以人文本，具体为主准备知识 国考主要考逻辑填空、中心理解逻辑填空 形式：题干+问法+选项 题干为文段但是其中挖去1-4个成语/实词 形成空格 问法为填入画横线/括号部分最恰当的一项是？ 选项为单选，四个选项 需理解文段，选出被挖去的成语/实词 中心理解 形式：题干+问法+选项 题干是完整文段，需要整体阅读理解 问法常为这段文字给我们的启示是？这段文字主要介绍？这段文字的核心观点是？这段文字意在强调？最适合做这段文字标题的是？等等目的是让你理解文段的问法 选项为单选，四个选项，需理解文段，选出文段核心意思 语句填入 形式：题干+问法+选项","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":" 题干为文段，但是挖去了其中的一句完整句子，形成空格 问法为填入画横线/括号部分最恰当的一句是？ 选项为单选，四个选项，需理解文段及空格上下文，选出被挖去的句子 语句排序 形式：题干+问法+选项 题干是多个独立且乱序的句子，需要对句子按照合理顺序进行排序 问法是将以上句子重新排列，顺序最恰当正确的一组是？ 选项为选项为单选，四个选项，每个选项都是一组句子顺序 下文推断 形式题干+问法选项 题干是完整的文段，需要整体阅读理解 问法为这段文字接下最可排讲述/谈论的是？ 选项为单选，四个选项，需要选出下文可能出现的完整语句 细节判断 形式：题干+问法+选项 题干是完整的文段，需要整体阅读 问法为下列说法与原文相符/不符的是？以下无法从上述文字得知的是？以下概括文中未涉及的是？等等需要和文段部分内容一一对应的问法。 选项为单选，四个选项，需要和文段进行一一对应 脉络剖析-基础 基本概述 什么叫脉络？其实就是写文章的思维，如果你要表达你的观点，在一篇完整的文章里面，不可能一上来什么都不说，直接说观点，一定是一步一步引出来的，因为写文章的基础思路，就是让读者能够充分体会你想表达的东西，所以一定要尽","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_1","order":1,"summary":" 题干为文段，但是挖去了其中的一句完整句子，形成空格 问法为填入画横线/括号部分最恰当的一句是？ 选项为单选，四个选项，需理解文段及空格上下文，选出被挖去的句子 语句排序 形式：题干+问法+选项 题干是多个独立且乱序的句子，需要对句子按照合理顺序进行排序 问法是将以上句子重新排列，顺序最恰当正确的一组是？ 选项为选项为单选，四个选项，每个选项都是一组句子顺序 下文推断 形式题干+问法选项 题干是完整的文段，需要整体阅读理解 问法为这段文字接下最可排讲述/谈论的是？ 选项为单选，四个选项，需要选出下文可能出现的完整语句 细节判断 形式：题干+问法+选项 题干是完整的文段，需要整体阅读 问法为下列说法与原文相符/不符的是？以下无法从上述文字得知的是？以下概括文中未涉及的是？等等需要和文段部分内容一一对应的问法。 选项为单选，四个选项，需要和文段进行一一对应 脉络剖析-基础 基本概述 什么叫脉络？其实就是写文章的思维，如果你要表达你的观点，在一篇完整的文章里面，不可能一上来什么都不说，直接说观点，一定是一步一步引出来的，因为写文章的基础思路，就是让读者能够充分体会你想表达的东西，所以一定要尽","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"可能铺垫。 常见的脉络顺承方式：代指（这，其，之，此）;转折（但是，而，而是...)；结论（所以，由xx可得...）；相同话题等 三大原则 顺承说意义，后面的意义不重要，这是观点提出的方式（重要性提观点） 顺承引出新话题，若后文反复论述新话题，则后文内容重要；若夏然而止提一下，则不重要 珊瑚的每一“树”可能包含着数十万计的微小珊瑚个体。每个珊瑚虫又带有少量的光合藻类，这些藻类为珊瑚提供食物，帮助其保持健康。当水温仅比平常上升几度时，面对环境压力的珊瑚虫会把藻类驱逐出去，先前的整支珊瑚群会变白——这就是珊瑚白化。如果水温不能及时回冷，那么珊瑚可能会死于饥饿或感染。即使珊瑚能逃过一劫，也要耗费约十年时间才能完全复原。 这段文字意在说明： A.白化是珊瑚主动应对环境压力的结果 B.光合藻类对于珊瑚保持健康至关重要C.珊瑚礁是一个复杂又脆弱的生态群落 D.海洋升温对珊瑚的生存产生严重威胁 顺承引出新话题，但是处于结尾，则重要不重要都有可能，具体情况具体分析，这里考虑出题人截取文章的思维 中心理解 以人为本 基本概述何为以人为本？这里的人指的就是出题人 很多同学都有一个误区，言语理解主观理解去做","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_2","order":2,"summary":"可能铺垫。 常见的脉络顺承方式：代指（这，其，之，此）;转折（但是，而，而是...)；结论（所以，由xx可得...）；相同话题等 三大原则 顺承说意义，后面的意义不重要，这是观点提出的方式（重要性提观点） 顺承引出新话题，若后文反复论述新话题，则后文内容重要；若夏然而止提一下，则不重要 珊瑚的每一“树”可能包含着数十万计的微小珊瑚个体。每个珊瑚虫又带有少量的光合藻类，这些藻类为珊瑚提供食物，帮助其保持健康。当水温仅比平常上升几度时，面对环境压力的珊瑚虫会把藻类驱逐出去，先前的整支珊瑚群会变白——这就是珊瑚白化。如果水温不能及时回冷，那么珊瑚可能会死于饥饿或感染。即使珊瑚能逃过一劫，也要耗费约十年时间才能完全复原。 这段文字意在说明： A.白化是珊瑚主动应对环境压力的结果 B.光合藻类对于珊瑚保持健康至关重要C.珊瑚礁是一个复杂又脆弱的生态群落 D.海洋升温对珊瑚的生存产生严重威胁 顺承引出新话题，但是处于结尾，则重要不重要都有可能，具体情况具体分析，这里考虑出题人截取文章的思维 中心理解 以人为本 基本概述何为以人为本？这里的人指的就是出题人 很多同学都有一个误区，言语理解主观理解去做","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"题，其实这个是不对的，言语理解确实是理解为王，但是这个理解一定不能和出题人相悖，你怎么想的并不重要，出题人表达的才是最重要的，也就是我常说的不要和出题入扳手航。但是难点就在于，什么才是出题人想表达的东西呢？为此，宝哥总结了观点提出的六大方式，旨在让大家直接和出题人进行对话。主要看观点，中心思想。 （一旦观点找错，直接选错） 万能解题公式 熟练掌握观点提出的六大方式，分析文段结构，锁定观点。 找到观点发出的主语和宏观限定。 匹配选项，排除干扰。（主要匹配观点的同义词，同词，如题目的神经元） 观点提出的六大方式 必要性提出观点 当题干中出现：只有（G观点）才，除非（G）否则不 等标志词以及基础，假设，前提，关键，必不可少，依赖，离不开等词语，可表达必要性，被必要主体是观点 设问提出观点（难题） 需要关注文段是否在解释设问，若重点在于解释设问，设问直接锁定观点，答案就是对问题的解释/回答 本质就是作者的主观性，也就是写作的目的性 题目：提到青少年面临的威胁，引人注目的新科技总是比那些熟悉和难以改变的问题更容易成为人们关注的焦点，这种偏差可能会使我们的感知发生偏离。除了使用手机导致糟糕的睡眠质","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_3","order":3,"summary":"题，其实这个是不对的，言语理解确实是理解为王，但是这个理解一定不能和出题人相悖，你怎么想的并不重要，出题人表达的才是最重要的，也就是我常说的不要和出题入扳手航。但是难点就在于，什么才是出题人想表达的东西呢？为此，宝哥总结了观点提出的六大方式，旨在让大家直接和出题人进行对话。主要看观点，中心思想。 （一旦观点找错，直接选错） 万能解题公式 熟练掌握观点提出的六大方式，分析文段结构，锁定观点。 找到观点发出的主语和宏观限定。 匹配选项，排除干扰。（主要匹配观点的同义词，同词，如题目的神经元） 观点提出的六大方式 必要性提出观点 当题干中出现：只有（G观点）才，除非（G）否则不 等标志词以及基础，假设，前提，关键，必不可少，依赖，离不开等词语，可表达必要性，被必要主体是观点 设问提出观点（难题） 需要关注文段是否在解释设问，若重点在于解释设问，设问直接锁定观点，答案就是对问题的解释/回答 本质就是作者的主观性，也就是写作的目的性 题目：提到青少年面临的威胁，引人注目的新科技总是比那些熟悉和难以改变的问题更容易成为人们关注的焦点，这种偏差可能会使我们的感知发生偏离。除了使用手机导致糟糕的睡眠质","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"量，家庭冲突也是造成青少年心理健康问题的一个重要原因，艾伦说：“不仅冲突和压力会影响大脑，缺乏温暖和社会支持同样会影响大脑”，有这么多证据都表明，其他因素会对青少年产生影响，为什么我们还只是担心手机？ 这段文字旨在强调（ ）。 A.手机成瘾并非我们唯一需要关注的问题 B.当今青少年的身心健康面临着诸多威胁 C.熟悉和难以改变的问题对青少年的健康威胁更大 D.青少年缺乏温暖和社会支持的问题亟待引起重视很多动物有着颜色古怪的眼睛，为什么人没有呢？眼睛的颜色其实是指虹膜的颜色，即眼睛中的一圈环状肌肉的颜色。如果虹膜中含有大量的色素，眼睛就会呈现黑褐色。随着黑色素含量的降低，眼睛就会呈现出淡褐色、绿色或蓝色。当瞳孔扩张时，虹膜处于收缩状态，由于黑色素的密度变大，眼睛的颜色便会加深一些；当瞳孔收缩时，虹膜便会舒张，眼睛的颜色也会因此变浅。不过，无论虹膜如何舒张或收缩，人类的眼睛也不可能是五颜六色的。这段文字主要解释了（ ）。 A.为什么是黑色素决定人眼颜色的深浅 B.为什么是瞳孔的张缩决定眼睛的颜色C.为什么人的眼睛不可能是五颜六色的 D.为什么人眼颜色不会像动物那样古怪解释，有点不符合设问解题","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_4","order":4,"summary":"量，家庭冲突也是造成青少年心理健康问题的一个重要原因，艾伦说：“不仅冲突和压力会影响大脑，缺乏温暖和社会支持同样会影响大脑”，有这么多证据都表明，其他因素会对青少年产生影响，为什么我们还只是担心手机？ 这段文字旨在强调（ ）。 A.手机成瘾并非我们唯一需要关注的问题 B.当今青少年的身心健康面临着诸多威胁 C.熟悉和难以改变的问题对青少年的健康威胁更大 D.青少年缺乏温暖和社会支持的问题亟待引起重视很多动物有着颜色古怪的眼睛，为什么人没有呢？眼睛的颜色其实是指虹膜的颜色，即眼睛中的一圈环状肌肉的颜色。如果虹膜中含有大量的色素，眼睛就会呈现黑褐色。随着黑色素含量的降低，眼睛就会呈现出淡褐色、绿色或蓝色。当瞳孔扩张时，虹膜处于收缩状态，由于黑色素的密度变大，眼睛的颜色便会加深一些；当瞳孔收缩时，虹膜便会舒张，眼睛的颜色也会因此变浅。不过，无论虹膜如何舒张或收缩，人类的眼睛也不可能是五颜六色的。这段文字主要解释了（ ）。 A.为什么是黑色素决定人眼颜色的深浅 B.为什么是瞳孔的张缩决定眼睛的颜色C.为什么人的眼睛不可能是五颜六色的 D.为什么人眼颜色不会像动物那样古怪解释，有点不符合设问解题","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"，选D了。注意转折，”不过“与其他物种相比，人类拥有非凡的认知能力。人脑究竟有什么独到之处，使得我们脱颖而出呢？脑容量是一个显而易见的候选者：如果大脑是产生意识认知的部位，更大的脑容量则意味着更高的认知能力，但大象有着比人类更大的脑容量，却不具备像我们一样灵活而复杂的行为。这是为什么呢？对于这个问题有一个简单的解释，首先，我们是灵长类，能够将大量神经元装进较小的大脑皮层里；其次，人类大脑的能量消耗可谓奢侈，只占不到2%的体重，却占了至少 20%的代谢率。而其他动物在野外摄取生肉中获取的能量，并不足以支持如此丰富的大脑皮层神经元活动。 这段文字旨在说明（ ）。 A.脑容量不能决定物种的认知水平 B.人类在认知能力上有绝对的优越性C.人脑认知能力的形成十分复杂 D.生理因素决定了人类认知水平的优势用提炼的观点/论证结果锁定选项，再利用选项反窥观点的正确性。要回答问题，选B不应该提对策给观点(三大) 开门见山给对策（直接对策） 当出现要 、需、需要、亟需、必须、应该、能够等；以及：如果（D对策）就；只要（D）就时，直接表明作者观点 题目：小剧场的“小”首先体现在物理空间的“小”。一般来讲，小","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_5","order":5,"summary":"，选D了。注意转折，”不过“与其他物种相比，人类拥有非凡的认知能力。人脑究竟有什么独到之处，使得我们脱颖而出呢？脑容量是一个显而易见的候选者：如果大脑是产生意识认知的部位，更大的脑容量则意味着更高的认知能力，但大象有着比人类更大的脑容量，却不具备像我们一样灵活而复杂的行为。这是为什么呢？对于这个问题有一个简单的解释，首先，我们是灵长类，能够将大量神经元装进较小的大脑皮层里；其次，人类大脑的能量消耗可谓奢侈，只占不到2%的体重，却占了至少 20%的代谢率。而其他动物在野外摄取生肉中获取的能量，并不足以支持如此丰富的大脑皮层神经元活动。 这段文字旨在说明（ ）。 A.脑容量不能决定物种的认知水平 B.人类在认知能力上有绝对的优越性C.人脑认知能力的形成十分复杂 D.生理因素决定了人类认知水平的优势用提炼的观点/论证结果锁定选项，再利用选项反窥观点的正确性。要回答问题，选B不应该提对策给观点(三大) 开门见山给对策（直接对策） 当出现要 、需、需要、亟需、必须、应该、能够等；以及：如果（D对策）就；只要（D）就时，直接表明作者观点 题目：小剧场的“小”首先体现在物理空间的“小”。一般来讲，小","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"剧场在物理空间的容纳度上是小的，演出空间基本上在 2000 平方米左右，观众席在 500 座以下，最为常见的为200至300个座位。参演人数不多，一般为 2 至 6 人，有时也会有独角戏。这就决定了演剧空间的紧凑性和观演关系的紧密性。因此，小剧场不宜过度渲染舞台美术的宏阔与震撼效果，而应该关注思想性、艺术形式表达或创新探索维度等戏剧艺术的本体呈现。用英国著名戏剧家彼得·布鲁克的话来说：“你若要看到什么有质量的东西，就得创造一个空的空间。”小剧场便是以鲜活的、新颖的方式传递内容、意义、表达、语言和音乐等核心艺术元素的存在。 这段文字意在说明（ ）。 A.小剧场营造出了一个空的艺术创作空间 B.物理空间的小决定了小剧场创作的特点C.小剧场创作应更关注戏剧艺术本体呈现 D.小剧场具有更加多元化方向的创作取向反复强调艺术 是重点做法+危害/意义给对策 阐述一个做法或者没有一个做法，会导致负面/正面结果。对策就是做法，危害/意义不重要 题目：网络语言，尤其是当下流行的一些新潮网络语言，对汉语的发展是促进还是阻碍，是汉语文化的精华还是糟粕，得让其在不断的冲突中接受时间和实践的检验。而为了保护汉语，","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_6","order":6,"summary":"剧场在物理空间的容纳度上是小的，演出空间基本上在 2000 平方米左右，观众席在 500 座以下，最为常见的为200至300个座位。参演人数不多，一般为 2 至 6 人，有时也会有独角戏。这就决定了演剧空间的紧凑性和观演关系的紧密性。因此，小剧场不宜过度渲染舞台美术的宏阔与震撼效果，而应该关注思想性、艺术形式表达或创新探索维度等戏剧艺术的本体呈现。用英国著名戏剧家彼得·布鲁克的话来说：“你若要看到什么有质量的东西，就得创造一个空的空间。”小剧场便是以鲜活的、新颖的方式传递内容、意义、表达、语言和音乐等核心艺术元素的存在。 这段文字意在说明（ ）。 A.小剧场营造出了一个空的艺术创作空间 B.物理空间的小决定了小剧场创作的特点C.小剧场创作应更关注戏剧艺术本体呈现 D.小剧场具有更加多元化方向的创作取向反复强调艺术 是重点做法+危害/意义给对策 阐述一个做法或者没有一个做法，会导致负面/正面结果。对策就是做法，危害/意义不重要 题目：网络语言，尤其是当下流行的一些新潮网络语言，对汉语的发展是促进还是阻碍，是汉语文化的精华还是糟粕，得让其在不断的冲突中接受时间和实践的检验。而为了保护汉语，","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"保证其固有的纯洁性而一味地摒弃打压某些带有消极影响的网络语言，甚至制定相关规定性条文条款来限制网络语言的发展，有时非但不能抑制，反而会起到相反的作用。这段文字意在说明： A.网络语言的发展不宜通过行政手段干预B.汉语的传承离不开网络语言的不断创新C.网络语言的生命力需要依靠时间来检验D.新生的网络语言可能影响汉语的纯洁性”甚至“标递进，看递进的内容当人脑在发育阶段接触到视觉刺激，也就是通过眼睛看到外界事物时，视皮层上的神经元会被激活，也就是说这些神经元会对不同的图像特征如颜色、形状、亮度、朝向、距离等进行加工。如果人正处于视觉功能的发育关键期，而视觉神经元未被充分激活，未来在看到某些图像特征时就不会产生反应或反应比较弱，导致看不见或看不清。这段文字最适合作为下列哪个观点的论据？ A.人体的不同机能存在着不同的发育关键期 B.人体功能发育不充分有可能造成终生影响C.图像特征对视皮层神经元的激活至关重要 D.错过发育关键期有可能丧失部分人体机能解释，人体机能是什么意思：可以指神经元。这题太牵强了否定型对策 直接否定这个对策，常见的有不可以（做），不能（做），不要（做），禁止（做） 题目：科","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_7","order":7,"summary":"保证其固有的纯洁性而一味地摒弃打压某些带有消极影响的网络语言，甚至制定相关规定性条文条款来限制网络语言的发展，有时非但不能抑制，反而会起到相反的作用。这段文字意在说明： A.网络语言的发展不宜通过行政手段干预B.汉语的传承离不开网络语言的不断创新C.网络语言的生命力需要依靠时间来检验D.新生的网络语言可能影响汉语的纯洁性”甚至“标递进，看递进的内容当人脑在发育阶段接触到视觉刺激，也就是通过眼睛看到外界事物时，视皮层上的神经元会被激活，也就是说这些神经元会对不同的图像特征如颜色、形状、亮度、朝向、距离等进行加工。如果人正处于视觉功能的发育关键期，而视觉神经元未被充分激活，未来在看到某些图像特征时就不会产生反应或反应比较弱，导致看不见或看不清。这段文字最适合作为下列哪个观点的论据？ A.人体的不同机能存在着不同的发育关键期 B.人体功能发育不充分有可能造成终生影响C.图像特征对视皮层神经元的激活至关重要 D.错过发育关键期有可能丧失部分人体机能解释，人体机能是什么意思：可以指神经元。这题太牵强了否定型对策 直接否定这个对策，常见的有不可以（做），不能（做），不要（做），禁止（做） 题目：科","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"举是一种复杂的文化现象。然而，在现代中国人对传统事物的看法中，科举大概也是被误解最深的制度。我们不应忽略科举制的历史性，试想在传统社会，能构想出其他更好的选才制度来吗？古代的中国统治者和许多文化巨人并不是没有看到科举制的局限和弊端，也不都是因循守旧之辈。但经过反复比较，最后还是选择了科举制，这实际上是一种择善而从。古代一些学者批评科举取士并不等于反对科举制度。从古代到近代的学者对科举制的批判主要是对应试现象、对考试内容和形式的批判，特别是对八股取士的批判，很少有人否定科举制本身。这段文字意在强调（ ）。A.古代学者对科举制的肯定多过否定B.科举制的弊端并非来自其制度本身C.科举制是当时历史条件下的理性选择 D.应从现实情况出发多角度评价科举制解释，但表转折。后面是其补充利用他者经验提观点 只要他者经验是成功的，可借鉴的，且文段作者没有提出自己的观点，则重点借鉴 题目：关于“天鹅都是白色的”这一假说，通常我们应该一只一只地调查天鹅的颜色。这种通过积累个别观察来验证假说或推导出定律的方法称为“归纳法”。但基于归纳法的推论不能带来可靠的正确性，哲学家波普提出了不依赖于归纳法的科学方法。他认为","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_8","order":8,"summary":"举是一种复杂的文化现象。然而，在现代中国人对传统事物的看法中，科举大概也是被误解最深的制度。我们不应忽略科举制的历史性，试想在传统社会，能构想出其他更好的选才制度来吗？古代的中国统治者和许多文化巨人并不是没有看到科举制的局限和弊端，也不都是因循守旧之辈。但经过反复比较，最后还是选择了科举制，这实际上是一种择善而从。古代一些学者批评科举取士并不等于反对科举制度。从古代到近代的学者对科举制的批判主要是对应试现象、对考试内容和形式的批判，特别是对八股取士的批判，很少有人否定科举制本身。这段文字意在强调（ ）。A.古代学者对科举制的肯定多过否定B.科举制的弊端并非来自其制度本身C.科举制是当时历史条件下的理性选择 D.应从现实情况出发多角度评价科举制解释，但表转折。后面是其补充利用他者经验提观点 只要他者经验是成功的，可借鉴的，且文段作者没有提出自己的观点，则重点借鉴 题目：关于“天鹅都是白色的”这一假说，通常我们应该一只一只地调查天鹅的颜色。这种通过积累个别观察来验证假说或推导出定律的方法称为“归纳法”。但基于归纳法的推论不能带来可靠的正确性，哲学家波普提出了不依赖于归纳法的科学方法。他认为","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"，试图证明假说是错误的才是科学的研究。例如，即使只找到了一只黑天鹅，也能证明“天鹅都是白色的”这一假说是错误的。虽然基于归纳法的验证通常是不可靠的，但如果证伪的话，则是可靠的。通过反复“设定一个用来解决问题的假说，寻找其反例来证伪假说，再设立新的假说······”，就可以进行科学的研究。 这段文字意在说明（ ）。 A.科学的方法应是“可归纳” B.科学的方法应是“可证伪” C.科学的方法应是“不可证伪” D.科学的方法应是“不可归纳”不可证伪？要符合观点：试图证明假说是错误的才是科学的研究人在社会上生活，当然有适应现实的必要，但这不该是教育的主要目的，蒙田说，“学习不是为了适应外界，而是为了丰富自己。”孔子也主张学习是“为己”而非“为人”的事情。古往今来的哲人都强调，学习是为了发展自己内在的精神能力，从而在外部现实面前获得自由。当然，这只是一种内在自由，但是，正是凭借这种内在自由，这些独立人格和独立思考的能力，那些优秀的灵魂和头脑对于改变人类社会的现实发生了伟大的作用。这段话想表达（ ）。 A.教育的目的是让人适应社会 B.学习是为了发展个人的内在精神能力C.人的内在自由对改变人类社会","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_9","order":9,"summary":"，试图证明假说是错误的才是科学的研究。例如，即使只找到了一只黑天鹅，也能证明“天鹅都是白色的”这一假说是错误的。虽然基于归纳法的验证通常是不可靠的，但如果证伪的话，则是可靠的。通过反复“设定一个用来解决问题的假说，寻找其反例来证伪假说，再设立新的假说······”，就可以进行科学的研究。 这段文字意在说明（ ）。 A.科学的方法应是“可归纳” B.科学的方法应是“可证伪” C.科学的方法应是“不可证伪” D.科学的方法应是“不可归纳”不可证伪？要符合观点：试图证明假说是错误的才是科学的研究人在社会上生活，当然有适应现实的必要，但这不该是教育的主要目的，蒙田说，“学习不是为了适应外界，而是为了丰富自己。”孔子也主张学习是“为己”而非“为人”的事情。古往今来的哲人都强调，学习是为了发展自己内在的精神能力，从而在外部现实面前获得自由。当然，这只是一种内在自由，但是，正是凭借这种内在自由，这些独立人格和独立思考的能力，那些优秀的灵魂和头脑对于改变人类社会的现实发生了伟大的作用。这段话想表达（ ）。 A.教育的目的是让人适应社会 B.学习是为了发展个人的内在精神能力C.人的内在自由对改变人类社会","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"的现实具有伟大的作用D.教育的主要目的是让学生摆脱现实的束缚，而非适应现实注意脉络顺承，他者观点(学习是为了发展自己内在的精神能力)不一定就是答案传统的文明标准有三个，即文字、青铜器和城市。但后来许多考古学家发现，由于区域不同，文明的差异也很大，这个判断标准不但行不通，还会给考古工作带来阻碍。现如今，国际上对文明的判断标准主要是：已进入国家社会形态，具有一套礼仪系统和统治管理制度。良渚文化虽没有青铜器和较为成熟的文字，但具有早期国家社会形态和较为完整的礼仪系统以及管理制度，还具有许多东方文明的因素。有良渚文化考古研究员甚至认为，良渚文化是东方早期一个集大成的文明。这段文字意在强调：A.城市应该成为认定文明的首要标准B.良渚文化符合通行的文明判断标准C.传统的文明评判标准仍具有现实意义D.良渚文化颠覆了传统上对文明的认识D应该是文明标准，全文都在强调文明标准重要性提观点 其一：当题干中出现：事物+意义，没有事物+危害时，事物名词 其二：当题干中出现表达xx很重要的标志词，如：独特优势，显著提升，重要角色，有很大帮助，带来很多意义等等，可以以重要性表达观点（需灵活理解） 给找不到观点兜底 ","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_10","order":10,"summary":"的现实具有伟大的作用D.教育的主要目的是让学生摆脱现实的束缚，而非适应现实注意脉络顺承，他者观点(学习是为了发展自己内在的精神能力)不一定就是答案传统的文明标准有三个，即文字、青铜器和城市。但后来许多考古学家发现，由于区域不同，文明的差异也很大，这个判断标准不但行不通，还会给考古工作带来阻碍。现如今，国际上对文明的判断标准主要是：已进入国家社会形态，具有一套礼仪系统和统治管理制度。良渚文化虽没有青铜器和较为成熟的文字，但具有早期国家社会形态和较为完整的礼仪系统以及管理制度，还具有许多东方文明的因素。有良渚文化考古研究员甚至认为，良渚文化是东方早期一个集大成的文明。这段文字意在强调：A.城市应该成为认定文明的首要标准B.良渚文化符合通行的文明判断标准C.传统的文明评判标准仍具有现实意义D.良渚文化颠覆了传统上对文明的认识D应该是文明标准，全文都在强调文明标准重要性提观点 其一：当题干中出现：事物+意义，没有事物+危害时，事物名词 其二：当题干中出现表达xx很重要的标志词，如：独特优势，显著提升，重要角色，有很大帮助，带来很多意义等等，可以以重要性表达观点（需灵活理解） 给找不到观点兜底 ","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"题目：传统村落是珍贵的农耕文明遗产。当前，传统村落面临的当务之急依然是严格保护。随着信息化、智能化时代的到来，让传统村落融入未来，在新格局下进行功能定位，重新融入城乡发展，是今后的一个重要议题。因为发展才能体现传统村落的价值，发展才会让传统村落传承下去。未来，历史村镇将和现代城市更加紧密地融合在一起，并作为乡村振兴战略中的特色保护类和重要聚焦点，在未来的城乡格局中扮演重要的角色，带动城乡发展。这段文字意在说明： A.发展才会让传统村落传承下去 B.传统村落将在未来的城乡格局中扮演重要的角色C.传统村落要在城乡融合背景下实现不断发展D.传统村落急需严格保护强调融入，并且保护是宏观概念本身观点性 (本源） 出现作者认为、我认为、由此观之等标志词以及 总结、转折以后引出评价性、观点性的句子，本身就是观点句 题目：在互联网风靡的当下，直播不再是“网红”和明星的专利，作家直播卖书，已经在一些电商平台悄然兴起。在不久前的“世界读书日”，国内文学界、出版界迎来了直播最密集的一天。多位作家来到直播间，和读者分享知识，有的也带货售书。只不过，就卖书数量而言，作家们的直播效果还是比不上“顶流”专业主播。 ","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_11","order":11,"summary":"题目：传统村落是珍贵的农耕文明遗产。当前，传统村落面临的当务之急依然是严格保护。随着信息化、智能化时代的到来，让传统村落融入未来，在新格局下进行功能定位，重新融入城乡发展，是今后的一个重要议题。因为发展才能体现传统村落的价值，发展才会让传统村落传承下去。未来，历史村镇将和现代城市更加紧密地融合在一起，并作为乡村振兴战略中的特色保护类和重要聚焦点，在未来的城乡格局中扮演重要的角色，带动城乡发展。这段文字意在说明： A.发展才会让传统村落传承下去 B.传统村落将在未来的城乡格局中扮演重要的角色C.传统村落要在城乡融合背景下实现不断发展D.传统村落急需严格保护强调融入，并且保护是宏观概念本身观点性 (本源） 出现作者认为、我认为、由此观之等标志词以及 总结、转折以后引出评价性、观点性的句子，本身就是观点句 题目：在互联网风靡的当下，直播不再是“网红”和明星的专利，作家直播卖书，已经在一些电商平台悄然兴起。在不久前的“世界读书日”，国内文学界、出版界迎来了直播最密集的一天。多位作家来到直播间，和读者分享知识，有的也带货售书。只不过，就卖书数量而言，作家们的直播效果还是比不上“顶流”专业主播。 ","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"这段文字意在说明（ ）。 A.作家们也开始走进直播间 B.作家直播带货不敌专业主播C.作家直播的前景非常看好 D.专业主播的带货能力非常强选观点，不是文段意思，A只是现状观点的深刻剖析 观点的统一性 没有任何规定一个文段中作者只能表达一次观点，为了让大家对于作者表达的观点印象深刻，真实情况是一个文段里面往往会反复提及观点。 也没有任何规定一个文段中作者只能用一种方式表达观点，所以真实情况是一个文段多种观点的表达形式并存。 但是有一个核心不变的是，多次表达，只是为了强调重复或相互补充，不可能一个文段出现多种截然不同的观点，称之为观点的统一性。 题目：科学研究起源于哲学，而哲学研究所建立的逻辑化正是科学方法的一个关键内容。在使用哲学的逻辑化开展科学研究的过程中，定量化是必不可少的。没有定量化，就无法通过归纳建立模型，也无法通过对模型的演绎做出预言，并被进一步的观测或者实验检验。数学研究所建立的各种计算方法和工具，使得科学研究和现在一般意义上的哲学研究分道扬镳，而科学研究的定量化又使得科学研究的成果能够得到实际应用，这是科学和哲学彻底分离的最显著标志。这段文字意在强调： A.科学与哲学的渊源","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_12","order":12,"summary":"这段文字意在说明（ ）。 A.作家们也开始走进直播间 B.作家直播带货不敌专业主播C.作家直播的前景非常看好 D.专业主播的带货能力非常强选观点，不是文段意思，A只是现状观点的深刻剖析 观点的统一性 没有任何规定一个文段中作者只能表达一次观点，为了让大家对于作者表达的观点印象深刻，真实情况是一个文段里面往往会反复提及观点。 也没有任何规定一个文段中作者只能用一种方式表达观点，所以真实情况是一个文段多种观点的表达形式并存。 但是有一个核心不变的是，多次表达，只是为了强调重复或相互补充，不可能一个文段出现多种截然不同的观点，称之为观点的统一性。 题目：科学研究起源于哲学，而哲学研究所建立的逻辑化正是科学方法的一个关键内容。在使用哲学的逻辑化开展科学研究的过程中，定量化是必不可少的。没有定量化，就无法通过归纳建立模型，也无法通过对模型的演绎做出预言，并被进一步的观测或者实验检验。数学研究所建立的各种计算方法和工具，使得科学研究和现在一般意义上的哲学研究分道扬镳，而科学研究的定量化又使得科学研究的成果能够得到实际应用，这是科学和哲学彻底分离的最显著标志。这段文字意在强调： A.科学与哲学的渊源","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"及区别 B.定量化在科学研究中的意义C.开展科学研究的基本方法D.哲学和数学对科学研究的贡献必要性+顺承提出观点=\u003e逻辑化关键，定量化关键。并且反复强调定量化。观点的要素性 在中心理解中，所有的要素可以按照以下重要程度进行排序：对策\u003e观点\u003e问题\u003e其他，核心是一种工作思维，注意是在文中的观点，而不是选项的重要程度 对策中，以直接对策（开门见山）最为重要 观点中，表达重要性的弱观点，不一定比问题重要，具体情况具体分析（本质是谈意义选观点和谈危害选问题） 题目：在科研领域，人们也喜欢庆祝大新闻，比如证实了黑洞的存在、发明了编辑DNA 的方法等。与之相比，一些耗时多年、极其艰辛的研究却鲜为人知，因为它们没有带来决定性的结果，似乎不能为解决科学问题提供任何证据，尽管它们能让我们离答案更近一步。这些没有得到预期结果的研究被称为“零结果”，它们驱使我们前进，让我们避免重复同样的错误，为未来的研究指引方向。如果没有它们，科学的发展可能放缓甚至受阻。我们可以从中学到很多东西，然而它们通常不会被发表。这不仅会导致科研效率低下，也显示当前的科学出版流程可能存在很大问题。这段文字意在（ ）。 A.揭示“零结果","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_13","order":13,"summary":"及区别 B.定量化在科学研究中的意义C.开展科学研究的基本方法D.哲学和数学对科学研究的贡献必要性+顺承提出观点=\u003e逻辑化关键，定量化关键。并且反复强调定量化。观点的要素性 在中心理解中，所有的要素可以按照以下重要程度进行排序：对策\u003e观点\u003e问题\u003e其他，核心是一种工作思维，注意是在文中的观点，而不是选项的重要程度 对策中，以直接对策（开门见山）最为重要 观点中，表达重要性的弱观点，不一定比问题重要，具体情况具体分析（本质是谈意义选观点和谈危害选问题） 题目：在科研领域，人们也喜欢庆祝大新闻，比如证实了黑洞的存在、发明了编辑DNA 的方法等。与之相比，一些耗时多年、极其艰辛的研究却鲜为人知，因为它们没有带来决定性的结果，似乎不能为解决科学问题提供任何证据，尽管它们能让我们离答案更近一步。这些没有得到预期结果的研究被称为“零结果”，它们驱使我们前进，让我们避免重复同样的错误，为未来的研究指引方向。如果没有它们，科学的发展可能放缓甚至受阻。我们可以从中学到很多东西，然而它们通常不会被发表。这不仅会导致科研效率低下，也显示当前的科学出版流程可能存在很大问题。这段文字意在（ ）。 A.揭示“零结果","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"”的价值 B.指出科研领域存在的偏见C.反思忽视“零结果”的问题 D.说明科研发展过程中的复杂性做法+危害提出观点=\u003e没有它们和不会发表，导致效率低下；。主要讲的是危害，问题；强调零结果。科学技术的迅猛发展带来日益突出的信息安全问题。信息安全事关国家安全和社会稳定。互联网核心技术是我们最大的“命门”，核心技术受制于人是我们最大的隐患。据海关数据显示，2018 年全年我国进口芯片数量为 4175.7 亿件，进口金额达到3120.58 亿美元。这一数字不仅超过原油这一战略物资，还超过了农产品、铁矿石、铜、铜矿石和医药品的总和。这充分说明，我们的芯片制造水平比世界先进水平还落后很多。而互联网企业即便规模再大、市值再高，如果核心元器件严重依赖外国，那么这个供应链的命门就掌握在别人手里。这段文字意在强调（ ）。 A.当前我国信息安全问题日益严峻 B.应该加快对互联网核心技术的掌握C.芯片技术受制于人将带来巨大隐患 D.自研核心技术是我国企业的发展方向重要性、必要性提出观点=\u003e信息安全重要，核心技术重要。强调核心；芯片在而前面，并且芯片是问题，文中提出解决办法了，选对策。文段开篇介绍了科技发展带来","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_14","order":14,"summary":"”的价值 B.指出科研领域存在的偏见C.反思忽视“零结果”的问题 D.说明科研发展过程中的复杂性做法+危害提出观点=\u003e没有它们和不会发表，导致效率低下；。主要讲的是危害，问题；强调零结果。科学技术的迅猛发展带来日益突出的信息安全问题。信息安全事关国家安全和社会稳定。互联网核心技术是我们最大的“命门”，核心技术受制于人是我们最大的隐患。据海关数据显示，2018 年全年我国进口芯片数量为 4175.7 亿件，进口金额达到3120.58 亿美元。这一数字不仅超过原油这一战略物资，还超过了农产品、铁矿石、铜、铜矿石和医药品的总和。这充分说明，我们的芯片制造水平比世界先进水平还落后很多。而互联网企业即便规模再大、市值再高，如果核心元器件严重依赖外国，那么这个供应链的命门就掌握在别人手里。这段文字意在强调（ ）。 A.当前我国信息安全问题日益严峻 B.应该加快对互联网核心技术的掌握C.芯片技术受制于人将带来巨大隐患 D.自研核心技术是我国企业的发展方向重要性、必要性提出观点=\u003e信息安全重要，核心技术重要。强调核心；芯片在而前面，并且芯片是问题，文中提出解决办法了，选对策。文段开篇介绍了科技发展带来","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"信息安全问题的大背景，并提出网络安全的重要性。接着通过程度词‘最”,强调互联网 核心技术的重要性及我国存在互联网核心技术受制于人的隐患。之后列举芯片进口数量这一数据，进一步强调我国互联网核心技术落后于世界先进水平。尾句通过反面论证“如果……那么……”,再次强调互联网核心技术不能依赖国外。因此，文段 为“提出问题+提出对策”的行文脉络，意在强调我国应将互联网核心技术掌握在自己手中，对应B项。A项，“安全问题”为问题表述，且对应文段首句背景铺垫部分，非重点，排除；C项，“巨大隐患”为问题表述，且“芯片技术”对应列数据部分的内容，非重点，排除；D项，“核心技术”及“我国企业*范围扩大，脱离主题词“互联网””,排除。故正确答案为B。观点的具体性 当文段存在多个观点时，哪个观点更微观，更具体，就重点在哪个观点，反之。 题目：据有关报道，基因编辑技术可被用于彻底治疗抑郁症或早年性痴呆症。但专家提醒，这有可能抹杀患者的创造力，基因编辑技术的应用也或将引发道德方面的问题。因为基因编辑技术一旦得到普及，父母就会利用它“优化”自己的孩子，经过改造的基因必然会遗传给后代，就会出现电影中的“转基因人”。研究人","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_15","order":15,"summary":"信息安全问题的大背景，并提出网络安全的重要性。接着通过程度词‘最”,强调互联网 核心技术的重要性及我国存在互联网核心技术受制于人的隐患。之后列举芯片进口数量这一数据，进一步强调我国互联网核心技术落后于世界先进水平。尾句通过反面论证“如果……那么……”,再次强调互联网核心技术不能依赖国外。因此，文段 为“提出问题+提出对策”的行文脉络，意在强调我国应将互联网核心技术掌握在自己手中，对应B项。A项，“安全问题”为问题表述，且对应文段首句背景铺垫部分，非重点，排除；C项，“巨大隐患”为问题表述，且“芯片技术”对应列数据部分的内容，非重点，排除；D项，“核心技术”及“我国企业*范围扩大，脱离主题词“互联网””,排除。故正确答案为B。观点的具体性 当文段存在多个观点时，哪个观点更微观，更具体，就重点在哪个观点，反之。 题目：据有关报道，基因编辑技术可被用于彻底治疗抑郁症或早年性痴呆症。但专家提醒，这有可能抹杀患者的创造力，基因编辑技术的应用也或将引发道德方面的问题。因为基因编辑技术一旦得到普及，父母就会利用它“优化”自己的孩子，经过改造的基因必然会遗传给后代，就会出现电影中的“转基因人”。研究人","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"员说，“一旦开始了这种做法，就无法回头了，我们绝不能跨越这个界限。”人类可以利用基因编辑技术来治疗疾病，生产出造福于人类的食物、药品等，但这项技术若得不到合理利用便会造成各类问题。在科学技术迅猛发展的今天，只有保持清醒的头脑，才能使人类不断进步。 这段文字意在强调： A.滥用基因编辑技术后果不堪设想B.“转基因人”将引发严重的伦理问题C.使用科学技术的前提是保持清醒的头脑D.基因编辑技术在医学方面存在一定局限性他者提观点=\u003e基因技术双刃剑；必要性提观点=\u003e保持清醒的头脑。保持清醒的头脑去利用基因编辑技术，后者更具体，并且多处提到。在 20 世纪 90 年代，地面蜂窝移动通信（GSM 和CMDA）和低轨道卫星通信（铱星系统）在全球是竞争关系。虽然地面移动通信从 2G 到3G、4G 和5G 得到了快速发展及广泛应用，但只覆盖约 20%的陆地面积和 6%的地球表面积。由于人类活动空间日益拓展，行业及军事应用愈发广泛，人们对具有覆盖范围广、受地理条件限制小等特性的卫星通信的需求越来越强烈。因此，卫星通信与地面移动通信在 5G/6G 走向互补关系，共同构建覆盖全球的星地融合通信网络是大势所趋。这","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_16","order":16,"summary":"员说，“一旦开始了这种做法，就无法回头了，我们绝不能跨越这个界限。”人类可以利用基因编辑技术来治疗疾病，生产出造福于人类的食物、药品等，但这项技术若得不到合理利用便会造成各类问题。在科学技术迅猛发展的今天，只有保持清醒的头脑，才能使人类不断进步。 这段文字意在强调： A.滥用基因编辑技术后果不堪设想B.“转基因人”将引发严重的伦理问题C.使用科学技术的前提是保持清醒的头脑D.基因编辑技术在医学方面存在一定局限性他者提观点=\u003e基因技术双刃剑；必要性提观点=\u003e保持清醒的头脑。保持清醒的头脑去利用基因编辑技术，后者更具体，并且多处提到。在 20 世纪 90 年代，地面蜂窝移动通信（GSM 和CMDA）和低轨道卫星通信（铱星系统）在全球是竞争关系。虽然地面移动通信从 2G 到3G、4G 和5G 得到了快速发展及广泛应用，但只覆盖约 20%的陆地面积和 6%的地球表面积。由于人类活动空间日益拓展，行业及军事应用愈发广泛，人们对具有覆盖范围广、受地理条件限制小等特性的卫星通信的需求越来越强烈。因此，卫星通信与地面移动通信在 5G/6G 走向互补关系，共同构建覆盖全球的星地融合通信网络是大势所趋。这","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"段文字旨在说明：A 低轨道卫星通信与地面蜂窝移动通信由竞争转为互补B.地面蜂窝移动通信与低轨道卫星通信相比覆盖范围小C.低轨道卫星通信与地面蜂窝移动通信是全球竞争关系D.卫星通信与地面移动通信共同构建全球星地融合网络重要性提出互补和构建融合网络。后者更具体商业设计也许越来越被赋予艺术创作和欣赏的价值，但它根本的出发点和落脚点永远是把产品的特质用艺术的方式展现给顾客。如果一项商业设计不能让人联想到产品并对之产生好感，即使它再精美、再具创意，也不能算是成功的设计。说到底，广告在创意之外最重要的还是关联性，我们不想被一个美轮美奂的作品吸引，结果却看不出它与所代言的商品之间存在任何联系。 对这段文字概括最准确的是： A.独特的创意并非成就商业设计的绝对要素 B.对于设计来说，吸引顾客应该是第一位的C.成功的设计必须能够艺术地展现产品特质 D.商业设计应尽量强调广告与产品的关联性必要性提出特质用艺术展现；必要性提出特质和艺术的关联性。前者做法，后者性质。前者更具体。虽然大篇幅关联性吗？观点的转换性 观点有多种表达方式，对策仅仅是其中的一种，你不能限制出题人用什么方法去表达选项中的观点。（所以文段","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_17","order":17,"summary":"段文字旨在说明：A 低轨道卫星通信与地面蜂窝移动通信由竞争转为互补B.地面蜂窝移动通信与低轨道卫星通信相比覆盖范围小C.低轨道卫星通信与地面蜂窝移动通信是全球竞争关系D.卫星通信与地面移动通信共同构建全球星地融合网络重要性提出互补和构建融合网络。后者更具体商业设计也许越来越被赋予艺术创作和欣赏的价值，但它根本的出发点和落脚点永远是把产品的特质用艺术的方式展现给顾客。如果一项商业设计不能让人联想到产品并对之产生好感，即使它再精美、再具创意，也不能算是成功的设计。说到底，广告在创意之外最重要的还是关联性，我们不想被一个美轮美奂的作品吸引，结果却看不出它与所代言的商品之间存在任何联系。 对这段文字概括最准确的是： A.独特的创意并非成就商业设计的绝对要素 B.对于设计来说，吸引顾客应该是第一位的C.成功的设计必须能够艺术地展现产品特质 D.商业设计应尽量强调广告与产品的关联性必要性提出特质用艺术展现；必要性提出特质和艺术的关联性。前者做法，后者性质。前者更具体。虽然大篇幅关联性吗？观点的转换性 观点有多种表达方式，对策仅仅是其中的一种，你不能限制出题人用什么方法去表达选项中的观点。（所以文段","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"的观点可以转换成选项中的任何形式，得出前文的六大方式。） 题目：乡村文化复兴的关键在于外生变量，城市居民是重要的外生变量，满足和激发其对乡村文化的需求至关重要。凸显原生态的乡村自然环境和原生态的乡村人文环境，不仅可以满足城市居民的体验需要以及对乡村的浪漫想象，也有助于乡土文化的传承和保护。在乡村旅游规划中，应尽量减少人工雕琢的痕迹和外来文化的移植，通过营造和保持乡村自然环境、作物植被、聚落形态、乡村建筑、生产方式、风俗习惯，再现乡村优美的田园风光，浓郁的乡土文化，使乡村更像乡村。这段文字重在说明： A.乡村旅游体验的真实性需求B.城市居民旅游的沉浸式需求C.乡村经济发展中应凸显人文性 D.乡村旅游规划中应重视独特性重要性提出满足城市居民需求；做法+意义提出凸显原生态；直接对策提出应保持原样。转换成真实性。印刷史，特点也可以指有什么问题。观点的偏向性 （难题） 当同时存在多个观点并列（存在宏观，具体，选具体），找寻作者对于观点重点的倾向 可以采用论证法（即观点一定需要反复论证，论证一定用于观点） 也可以多观点结合求同 题目：全球化的时代里，语言的规范性要求越来越高，可以预见，许多小方言区","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_18","order":18,"summary":"的观点可以转换成选项中的任何形式，得出前文的六大方式。） 题目：乡村文化复兴的关键在于外生变量，城市居民是重要的外生变量，满足和激发其对乡村文化的需求至关重要。凸显原生态的乡村自然环境和原生态的乡村人文环境，不仅可以满足城市居民的体验需要以及对乡村的浪漫想象，也有助于乡土文化的传承和保护。在乡村旅游规划中，应尽量减少人工雕琢的痕迹和外来文化的移植，通过营造和保持乡村自然环境、作物植被、聚落形态、乡村建筑、生产方式、风俗习惯，再现乡村优美的田园风光，浓郁的乡土文化，使乡村更像乡村。这段文字重在说明： A.乡村旅游体验的真实性需求B.城市居民旅游的沉浸式需求C.乡村经济发展中应凸显人文性 D.乡村旅游规划中应重视独特性重要性提出满足城市居民需求；做法+意义提出凸显原生态；直接对策提出应保持原样。转换成真实性。印刷史，特点也可以指有什么问题。观点的偏向性 （难题） 当同时存在多个观点并列（存在宏观，具体，选具体），找寻作者对于观点重点的倾向 可以采用论证法（即观点一定需要反复论证，论证一定用于观点） 也可以多观点结合求同 题目：全球化的时代里，语言的规范性要求越来越高，可以预见，许多小方言区","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"将逐渐消失，“五里不同音、十里不同调”的格局将逐步改变，直到形成若干稳定的大方言区。然而，语言并非只有交际属性，它还有文化属性，每一种方言或语言，都承载了一段历史、一种文化。这种历史和文化，与特定的语言或方言形成共生关系，换成别的语言或方言表达就变了味，失去了许多内涵。假如歌曲《十送红军》没有了乡音，莫言的小说没有了高密话，赵本山小品没有了东北腔调，恐怕许多意蕴和趣味就消失了。 这段文字意在强调： A.全球化时代语言的统一和规范是大势所趋B.方言相对于普通话而言具有更强的表现力C.保护方言在全球化背景下具有特殊的意义D.历史文化与特定语言的共生关系正在消失重要性+顺承提出文化属性和语言或方言形成共生关系，换一种就变味。例子强调没有方言会怎么样，并且全文强调方言。因此偏向换一种就变味，要保护方言。D只提到特定语言，共生关系指的是相互依赖，而不是少了它就不行了。成功不是衡量人生价值的最高标准，比成功更重要的是，一个人要有丰富的内在，有自己的真性情和真兴趣，有自己真正喜欢做的事。只要你有自己真正喜欢做的事，你就在任何情况下都会感到充实和踏实。那些仅仅追求外在成功的人实际上是没有真正喜欢做的事","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_19","order":19,"summary":"将逐渐消失，“五里不同音、十里不同调”的格局将逐步改变，直到形成若干稳定的大方言区。然而，语言并非只有交际属性，它还有文化属性，每一种方言或语言，都承载了一段历史、一种文化。这种历史和文化，与特定的语言或方言形成共生关系，换成别的语言或方言表达就变了味，失去了许多内涵。假如歌曲《十送红军》没有了乡音，莫言的小说没有了高密话，赵本山小品没有了东北腔调，恐怕许多意蕴和趣味就消失了。 这段文字意在强调： A.全球化时代语言的统一和规范是大势所趋B.方言相对于普通话而言具有更强的表现力C.保护方言在全球化背景下具有特殊的意义D.历史文化与特定语言的共生关系正在消失重要性+顺承提出文化属性和语言或方言形成共生关系，换一种就变味。例子强调没有方言会怎么样，并且全文强调方言。因此偏向换一种就变味，要保护方言。D只提到特定语言，共生关系指的是相互依赖，而不是少了它就不行了。成功不是衡量人生价值的最高标准，比成功更重要的是，一个人要有丰富的内在，有自己的真性情和真兴趣，有自己真正喜欢做的事。只要你有自己真正喜欢做的事，你就在任何情况下都会感到充实和踏实。那些仅仅追求外在成功的人实际上是没有真正喜欢做的事","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"，他们真正喜欢的只是名利，一旦在名利场上受挫，内在的空虚就暴露无遗。这段文字的主旨是： A.成功就是做好自己喜欢做的事B.人生价值的最高标准难以确定C.追逐名利的人是得不到成功的D.兴趣是人们得到幸福的源泉直接对策提出要有内在，有真兴趣，有喜欢的事。强调喜欢的事。D望文生义了，并且没有强调兴趣。目前中国教育仍存在乱收费现象，收费名目繁多，家庭教育支出在家庭个人消费中比例过高，家庭子女教育负担沉重。在北京，一个孩子从小学到高中毕业，各种和教育相关的费用保守的测算超过 10 万元。这段话表述的主要观点是：（ ） A.目前中国教育仍存在乱收费现象B.中国青少年教育目前存在的主要问题是乱收费 C.中国目前教育存在的问题是家庭子女教育负担沉重 D.中国教育目前存在的问题是教育收费名目繁多我感觉选C。原文出处？，我觉得突出子女负担重，讲师认为10万突出金额的乱收费，并且AB同义，从AB中只能选A。一般而言，城市群之间的交通干线分布着许多城市，聚集着大量产业和人口，从而构成经济带。加强经济带规划和经济带上城市建设，是建设现代化区域发展体系和促进区域协调发展的重要方面。为此，应依托重要交通干线聚集经济","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_20","order":20,"summary":"，他们真正喜欢的只是名利，一旦在名利场上受挫，内在的空虚就暴露无遗。这段文字的主旨是： A.成功就是做好自己喜欢做的事B.人生价值的最高标准难以确定C.追逐名利的人是得不到成功的D.兴趣是人们得到幸福的源泉直接对策提出要有内在，有真兴趣，有喜欢的事。强调喜欢的事。D望文生义了，并且没有强调兴趣。目前中国教育仍存在乱收费现象，收费名目繁多，家庭教育支出在家庭个人消费中比例过高，家庭子女教育负担沉重。在北京，一个孩子从小学到高中毕业，各种和教育相关的费用保守的测算超过 10 万元。这段话表述的主要观点是：（ ） A.目前中国教育仍存在乱收费现象B.中国青少年教育目前存在的主要问题是乱收费 C.中国目前教育存在的问题是家庭子女教育负担沉重 D.中国教育目前存在的问题是教育收费名目繁多我感觉选C。原文出处？，我觉得突出子女负担重，讲师认为10万突出金额的乱收费，并且AB同义，从AB中只能选A。一般而言，城市群之间的交通干线分布着许多城市，聚集着大量产业和人口，从而构成经济带。加强经济带规划和经济带上城市建设，是建设现代化区域发展体系和促进区域协调发展的重要方面。为此，应依托重要交通干线聚集经济","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"要素，形成纵向或横向的经济发展轴，充分发挥其对统筹区域协调发展的作用。比如，沿海经济带、长江经济带、陇海兰新经济带和京广京哈经济带等已经集聚了大量人口、产业，城市分布也比较密集，形成了比较明显的经济发展轴，已成为承东启西、连南贯北的经济主骨架。这段文字意在说明：A.经济带建设对区域协调发展具有重要意义 B.我国区域经济发展应以城市群建设为依托C.交通干线承担着聚集经济要素的重大使命D.形成经济发展轴是城市群建设的长远目标做法+意义提出加强规划和建设；直接对策提出依托干线聚集要素，形成发展轴，发挥其（干线？发展轴？）的统筹。我觉得选C。有争议直接跳过，原文，讲师说的例子不太好，应该依托干线才能形成发展轴，明显干线重要。观点的对比性 正常做题的时候，当只有一个选项体现观点，那么直接锁定这个选项（除非选项是相悖的），不用过于去抠细节；但是如果多个选项都体现了观点，那么一定要对比抠细节 题目：近年来，随着微博、微信等网络社交媒体的迅速发展，有关食品的谣言甚嚣尘上，给人们的日常生活带来很大困扰。在日前召开的中国食品辟谣论坛上，中国食品谣言智能预警处理平台正式上线，被寄予了破解食品谣言满天飞现状的","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_21","order":21,"summary":"要素，形成纵向或横向的经济发展轴，充分发挥其对统筹区域协调发展的作用。比如，沿海经济带、长江经济带、陇海兰新经济带和京广京哈经济带等已经集聚了大量人口、产业，城市分布也比较密集，形成了比较明显的经济发展轴，已成为承东启西、连南贯北的经济主骨架。这段文字意在说明：A.经济带建设对区域协调发展具有重要意义 B.我国区域经济发展应以城市群建设为依托C.交通干线承担着聚集经济要素的重大使命D.形成经济发展轴是城市群建设的长远目标做法+意义提出加强规划和建设；直接对策提出依托干线聚集要素，形成发展轴，发挥其（干线？发展轴？）的统筹。我觉得选C。有争议直接跳过，原文，讲师说的例子不太好，应该依托干线才能形成发展轴，明显干线重要。观点的对比性 正常做题的时候，当只有一个选项体现观点，那么直接锁定这个选项（除非选项是相悖的），不用过于去抠细节；但是如果多个选项都体现了观点，那么一定要对比抠细节 题目：近年来，随着微博、微信等网络社交媒体的迅速发展，有关食品的谣言甚嚣尘上，给人们的日常生活带来很大困扰。在日前召开的中国食品辟谣论坛上，中国食品谣言智能预警处理平台正式上线，被寄予了破解食品谣言满天飞现状的","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"厚望。健全和完善食品安全举报的平台和机制，把举报机制纳入食品谣言智能预警处理平台，从而对食品谣言治理进行闭环管理，才能真正建立消费者对食品安全的信心。 这段文字意在强调： A.有关食品的谣言甚嚣尘上，辟谣预警平台应运而生 B.食品安全谣言泛溢，建立举报机制已经刻不容缓 C.治理食品安全谣言，不能仅仅依靠辟谣预警平台 D.治理食品安全谣言，须先重视其举报平台及相应机制提醒自己，仔细阅读，平台是处理平台，机制是举报机制。中国综合实力的增强，是中国模式创造的世界奇迹。而中国模式又是中国传统文化的产物，是中国传统文化智慧在当今中国的升华。2008 年金融危机后，世界各领域的“中国元素”在不断增多，并不断被越来越多的各国民众所接纳。虽然这种“中国元素”在相当大程度上是通过中国经济实力在发挥作用，但是支撑中国经济发展的却是传统文化因素。传统的人文精神，使“中国元素”在更广阔的领域内逐渐展现出更加令人瞩目的价值。这段文字意在说明： A.不断创新中国模式才能推动中国综合实力的逐步提高 B.应充分发挥国内雄厚的文化资源优势以打造文化强国 C.“中国元素”的广泛传播有助于中国国家形象的提升 D.文化软实力","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_22","order":22,"summary":"厚望。健全和完善食品安全举报的平台和机制，把举报机制纳入食品谣言智能预警处理平台，从而对食品谣言治理进行闭环管理，才能真正建立消费者对食品安全的信心。 这段文字意在强调： A.有关食品的谣言甚嚣尘上，辟谣预警平台应运而生 B.食品安全谣言泛溢，建立举报机制已经刻不容缓 C.治理食品安全谣言，不能仅仅依靠辟谣预警平台 D.治理食品安全谣言，须先重视其举报平台及相应机制提醒自己，仔细阅读，平台是处理平台，机制是举报机制。中国综合实力的增强，是中国模式创造的世界奇迹。而中国模式又是中国传统文化的产物，是中国传统文化智慧在当今中国的升华。2008 年金融危机后，世界各领域的“中国元素”在不断增多，并不断被越来越多的各国民众所接纳。虽然这种“中国元素”在相当大程度上是通过中国经济实力在发挥作用，但是支撑中国经济发展的却是传统文化因素。传统的人文精神，使“中国元素”在更广阔的领域内逐渐展现出更加令人瞩目的价值。这段文字意在说明： A.不断创新中国模式才能推动中国综合实力的逐步提高 B.应充分发挥国内雄厚的文化资源优势以打造文化强国 C.“中国元素”的广泛传播有助于中国国家形象的提升 D.文化软实力","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"对提高中国在世界的影响力不可或缺重要性提出文化的重要性；转折提出本身观点文化是经济的支撑。B是用文化打造国家，有点做法的意思。D是指出文化的重要性。临床医学教授格林斯潘认为，儿童的自我意识发展完全取决于父母与孩子的同理心关系，只有当父母能够持续、连贯、准确地读懂幼儿的情绪状态并做出有效回应时，孩子才能学会以同样的方式去回应。这种同理心的联系，拓展了孩子的心智，帮助他走进身边的情感与社交世界，给予他温暖和喜悦，而这正是培养信任所需要的。这种联系也带给孩子以自信，相信自己可以对他人产生影响，相信自己的意向也可以通过互动的方式，得到他人的积极回应。这段文字意在强调：A.父母的情绪回应对孩子自我意识发展至关重要 B.同理心是儿童获得智力与情感发展的坚实基础C.儿童的自我意识发展离不开与父母的积极互动 D.准确地识别儿童的情绪状态是父母的核心任务他者提出父母与孩子同理心关系，具体是父母孩子互相回应。这种同理心的联系扩展前文的互相回应。主要强调有互动，有两个人。B只是说明同理心的重要性，没有说这种联系，这种互动。主语及宏观限定的秒杀 主语及宏观限定是属锦上添花作用的东西，但是有时候我们也可以反其道","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_23","order":23,"summary":"对提高中国在世界的影响力不可或缺重要性提出文化的重要性；转折提出本身观点文化是经济的支撑。B是用文化打造国家，有点做法的意思。D是指出文化的重要性。临床医学教授格林斯潘认为，儿童的自我意识发展完全取决于父母与孩子的同理心关系，只有当父母能够持续、连贯、准确地读懂幼儿的情绪状态并做出有效回应时，孩子才能学会以同样的方式去回应。这种同理心的联系，拓展了孩子的心智，帮助他走进身边的情感与社交世界，给予他温暖和喜悦，而这正是培养信任所需要的。这种联系也带给孩子以自信，相信自己可以对他人产生影响，相信自己的意向也可以通过互动的方式，得到他人的积极回应。这段文字意在强调：A.父母的情绪回应对孩子自我意识发展至关重要 B.同理心是儿童获得智力与情感发展的坚实基础C.儿童的自我意识发展离不开与父母的积极互动 D.准确地识别儿童的情绪状态是父母的核心任务他者提出父母与孩子同理心关系，具体是父母孩子互相回应。这种同理心的联系扩展前文的互相回应。主要强调有互动，有两个人。B只是说明同理心的重要性，没有说这种联系，这种互动。主语及宏观限定的秒杀 主语及宏观限定是属锦上添花作用的东西，但是有时候我们也可以反其道","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"而行之，用其锁定选项，以达到秒杀的效果 面对老城区面积大、老龄人口多的“两老”问题，某市经过近10 年的创新探索，走出了一条全领域、全局性、成体系、成规模的“睦邻家园”建设之路。目前，该市内已建成60个睦邻中心，形成了“1510”睦邻服务圈：居民步行 15 分钟就能到达一个睦邻中心，每个睦邻中心至少有 10 个以上服务项目。用党建联盟“大联动”，打造“大睦邻”社区格局，使高档社区和老旧小区之间的门打开了，为居民共享公共设施提供了新思路。 最适合做这段文字标题的是（ ）。 A.睦邻建设，老城区更有新服务 B.创新建设，覆盖大面积的城区C.幸福养老，社区公共设施再上新 D.打通门户，社区家园实现“大联动”他者提出睦邻之路；做法+意义提出党建联动，打造睦邻。D主语应该是党建，也不对。强调睦邻+主语是老城区。原文脉络剖析-提升 脉络的顺承 顺承后的内容重要。见基础部分。 顺承后的内容不重要。见基础部分。 逐步引出。逐步引出是常见的一个行文脉络，其特点是一步一步引出想要表达的内容，是一种常见的且极其顺畅的行文脉络 牡丹和玉兰都不会在正月里开花，但是《岁朝图》里却出现这两种花卉，并且都代表“玉堂富","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_24","order":24,"summary":"而行之，用其锁定选项，以达到秒杀的效果 面对老城区面积大、老龄人口多的“两老”问题，某市经过近10 年的创新探索，走出了一条全领域、全局性、成体系、成规模的“睦邻家园”建设之路。目前，该市内已建成60个睦邻中心，形成了“1510”睦邻服务圈：居民步行 15 分钟就能到达一个睦邻中心，每个睦邻中心至少有 10 个以上服务项目。用党建联盟“大联动”，打造“大睦邻”社区格局，使高档社区和老旧小区之间的门打开了，为居民共享公共设施提供了新思路。 最适合做这段文字标题的是（ ）。 A.睦邻建设，老城区更有新服务 B.创新建设，覆盖大面积的城区C.幸福养老，社区公共设施再上新 D.打通门户，社区家园实现“大联动”他者提出睦邻之路；做法+意义提出党建联动，打造睦邻。D主语应该是党建，也不对。强调睦邻+主语是老城区。原文脉络剖析-提升 脉络的顺承 顺承后的内容重要。见基础部分。 顺承后的内容不重要。见基础部分。 逐步引出。逐步引出是常见的一个行文脉络，其特点是一步一步引出想要表达的内容，是一种常见的且极其顺畅的行文脉络 牡丹和玉兰都不会在正月里开花，但是《岁朝图》里却出现这两种花卉，并且都代表“玉堂富","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"贵”的意思。古人为了让这些花不按时令盛开，想到了一个办法，叫唐花，有时也写成火字旁的“煻”，煻就是烧火的意思，类似我们今天的温室技术。冬天在温室里加温，催花早放。这样的技术其实在汉代就已经有了，不过在汉代的时候更多是为了满足皇帝冬天吃蔬菜的需求。 这段文字意在说明： A.《岁朝图》里牡丹和玉兰花的象征意义B.“唐花”这一专门术语的由来以及含义C.我国古代已经出现了实用的温室技术D.温室技术源于皇帝冬天吃蔬菜的需求牡丹-\u003e唐花-\u003e温室技术-\u003e在汉代就有了。“不过”是弱转折，并且没有说源于。顺承中的代指+总结。在脉络顺承的过程中，写作的人为了引出想要论述的名词，往往会一开始拆开讲解，所以可以利用这一点，让写作的人帮你总结 想知道人如何感受、思考、判断，但又无法看到大脑怎样作业，大脑就成了一个无法打开的黑箱。给这个黑箱输入一个刺激，通过分析输出的变化来推测其内部工作的过程，这便是利用黑箱方法从事研究的基本逻辑。它至今在心理和行为研究中占统治性地位。其应用的极端形式是把人脑和计算机进行对比。其实通过“输入——输出”的变化来解释大脑的研究方法是不得已之举。但凡对输入到输出的变化有合理化解释的模型","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_25","order":25,"summary":"贵”的意思。古人为了让这些花不按时令盛开，想到了一个办法，叫唐花，有时也写成火字旁的“煻”，煻就是烧火的意思，类似我们今天的温室技术。冬天在温室里加温，催花早放。这样的技术其实在汉代就已经有了，不过在汉代的时候更多是为了满足皇帝冬天吃蔬菜的需求。 这段文字意在说明： A.《岁朝图》里牡丹和玉兰花的象征意义B.“唐花”这一专门术语的由来以及含义C.我国古代已经出现了实用的温室技术D.温室技术源于皇帝冬天吃蔬菜的需求牡丹-\u003e唐花-\u003e温室技术-\u003e在汉代就有了。“不过”是弱转折，并且没有说源于。顺承中的代指+总结。在脉络顺承的过程中，写作的人为了引出想要论述的名词，往往会一开始拆开讲解，所以可以利用这一点，让写作的人帮你总结 想知道人如何感受、思考、判断，但又无法看到大脑怎样作业，大脑就成了一个无法打开的黑箱。给这个黑箱输入一个刺激，通过分析输出的变化来推测其内部工作的过程，这便是利用黑箱方法从事研究的基本逻辑。它至今在心理和行为研究中占统治性地位。其应用的极端形式是把人脑和计算机进行对比。其实通过“输入——输出”的变化来解释大脑的研究方法是不得已之举。但凡对输入到输出的变化有合理化解释的模型","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"，便可以被认为是真的。但这类解释与大脑真实活动吻合的程度是难以充分证明的。 这段文字意在（ ）。A.说明使用黑箱方法进行大脑研究是有先天缺陷的B.介绍黑箱方法的基本逻辑和原理C.批评将人脑和计算机对比的方法过于机械、牵强 D.呼吁大脑研究应引进新的技术和方法D过度延伸了（但有些题目貌似也可以过度延伸？）。脉络：黑箱基本逻辑-\u003e方法的地位-\u003e对比-\u003e不得已之举。最后一句观点：黑箱难以解释真实活动。①交代了一下黑箱方法的大背景，是一种很重要的方法，②是作者观点，他认为黑箱方法虽然很厉害，但是如果研究大脑的话还是不够准确偏正 什么叫偏正？即xx的xx，如好吃的水果、我最爱的电影等 偏正的特点？ 具有宏观高度概括性 类偏正：转换为偏正的非偏正形式，如：如何长高=长高的方式方法 偏正的展开性 既然偏正有宏观概括性，那么我们怎么对其进行微观还原呢？ 偏正的展开一：精讲（即将一个主体讲清楚，全文或重点围绕） 偏正的展开二：数量（即将多个主体罗列讲出，每一个主体不一定全文或重点围绕） tips：研究人员发现，实验结果展示，不是例子 题目：每个城市都有一个“最优规模”，它取决于城市规模正反两个效用的相互","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_26","order":26,"summary":"，便可以被认为是真的。但这类解释与大脑真实活动吻合的程度是难以充分证明的。 这段文字意在（ ）。A.说明使用黑箱方法进行大脑研究是有先天缺陷的B.介绍黑箱方法的基本逻辑和原理C.批评将人脑和计算机对比的方法过于机械、牵强 D.呼吁大脑研究应引进新的技术和方法D过度延伸了（但有些题目貌似也可以过度延伸？）。脉络：黑箱基本逻辑-\u003e方法的地位-\u003e对比-\u003e不得已之举。最后一句观点：黑箱难以解释真实活动。①交代了一下黑箱方法的大背景，是一种很重要的方法，②是作者观点，他认为黑箱方法虽然很厉害，但是如果研究大脑的话还是不够准确偏正 什么叫偏正？即xx的xx，如好吃的水果、我最爱的电影等 偏正的特点？ 具有宏观高度概括性 类偏正：转换为偏正的非偏正形式，如：如何长高=长高的方式方法 偏正的展开性 既然偏正有宏观概括性，那么我们怎么对其进行微观还原呢？ 偏正的展开一：精讲（即将一个主体讲清楚，全文或重点围绕） 偏正的展开二：数量（即将多个主体罗列讲出，每一个主体不一定全文或重点围绕） tips：研究人员发现，实验结果展示，不是例子 题目：每个城市都有一个“最优规模”，它取决于城市规模正反两个效用的相互","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"对比。正面效用主要是城市的集聚效用，负面效用则包括交通拥堵、环境污染、房价高昂、基础设施不足等。经济集聚在提高劳动生产率的同时，也会使城市的土地和住房价格上涨，企业的生产成本和居民的生活成本均会有所上升。此外，城市的拥挤、污染等问题都会抵消城市扩张带来的好处。最终，只有当一个城市所带来的正效应超过其生产或生活成本时，企业和居民才会留在这个城市。相应地，城市的最优规模就是最大化劳动生产率的规模。 这段文字主要介绍（ ）。 A.为何城市应该保持动态平衡 B.什么是城市的最优规模C.城市发展受资源环境的限制 D.要防止城市过分集中的情况最优规模取决于正反-\u003e介绍正反-\u003e正反影响-\u003e最终-\u003e相应地，进一步总结什么是最优规模。军事指挥员在未来战场上的谋优制胜能力取决于其军事思维发展水平，而要形成良好的军事思维能力，必须把战争制胜机理搞透。不同的战争形态，遵循不同的制胜机理，需要不同的思维方式。凡是罔顾军事实践发展、囿于陈旧观念的军队，必然会在战争中受到惩罚。事实证明，按照机械化条件下作战方式培养出来的指挥员，如果固守传统思维，是不能打赢信息化战争的。不清楚未来作战的制胜机理，就不能在实战化训练中","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_27","order":27,"summary":"对比。正面效用主要是城市的集聚效用，负面效用则包括交通拥堵、环境污染、房价高昂、基础设施不足等。经济集聚在提高劳动生产率的同时，也会使城市的土地和住房价格上涨，企业的生产成本和居民的生活成本均会有所上升。此外，城市的拥挤、污染等问题都会抵消城市扩张带来的好处。最终，只有当一个城市所带来的正效应超过其生产或生活成本时，企业和居民才会留在这个城市。相应地，城市的最优规模就是最大化劳动生产率的规模。 这段文字主要介绍（ ）。 A.为何城市应该保持动态平衡 B.什么是城市的最优规模C.城市发展受资源环境的限制 D.要防止城市过分集中的情况最优规模取决于正反-\u003e介绍正反-\u003e正反影响-\u003e最终-\u003e相应地，进一步总结什么是最优规模。军事指挥员在未来战场上的谋优制胜能力取决于其军事思维发展水平，而要形成良好的军事思维能力，必须把战争制胜机理搞透。不同的战争形态，遵循不同的制胜机理，需要不同的思维方式。凡是罔顾军事实践发展、囿于陈旧观念的军队，必然会在战争中受到惩罚。事实证明，按照机械化条件下作战方式培养出来的指挥员，如果固守传统思维，是不能打赢信息化战争的。不清楚未来作战的制胜机理，就不能在实战化训练中","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"及时增添反映未来作战的新要素、新内容、新手段，导调就只能在“老一套”上转圈圈，就无法引领参训官兵确立符合未来作战需要的思维。 这段文字意在强调： A.信息化战争对参战人员提出的新要求B.提升指挥员军事思维发展水平的途径C.培养方式对提升军事指挥员素质的影响 D.研究战争制胜机理对军事指挥员的意义必要性+否定性对策提出战争制胜机理重要，直接对策+做法+危害给对策提出不同思维方式，不能固守思维。B的途径很好的展示了数量展开，途径包括机理和思维。D的意义不能提出思维。原文偏正的修饰及总分性 偏正是由两部分组成，A的 B，A与B的地位其实是不同的，这里分成两种情况：修饰性偏正：A对B是修饰、形容的关系。如：晴朗的天空，独家的课程等，A与B同时出现时，B比A更重要 总分性偏正：A与B是总分关系。如：考上公务员的志向，攀登高峰的勇气等，A与B都很重要，A具体，B宏观总结 题目：从特定意义上说，决策的过程就是抢抓机遇，将可能性变为现实的过程。机遇从来都是公正的，机遇一旦到来，就看谁能审时度势，及早地发现它，抓住它；能否抓住它，又关键看谁具有立断立行的智慧和勇气，凡是决策，没有不存在风险的，若想等到有","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_28","order":28,"summary":"及时增添反映未来作战的新要素、新内容、新手段，导调就只能在“老一套”上转圈圈，就无法引领参训官兵确立符合未来作战需要的思维。 这段文字意在强调： A.信息化战争对参战人员提出的新要求B.提升指挥员军事思维发展水平的途径C.培养方式对提升军事指挥员素质的影响 D.研究战争制胜机理对军事指挥员的意义必要性+否定性对策提出战争制胜机理重要，直接对策+做法+危害给对策提出不同思维方式，不能固守思维。B的途径很好的展示了数量展开，途径包括机理和思维。D的意义不能提出思维。原文偏正的修饰及总分性 偏正是由两部分组成，A的 B，A与B的地位其实是不同的，这里分成两种情况：修饰性偏正：A对B是修饰、形容的关系。如：晴朗的天空，独家的课程等，A与B同时出现时，B比A更重要 总分性偏正：A与B是总分关系。如：考上公务员的志向，攀登高峰的勇气等，A与B都很重要，A具体，B宏观总结 题目：从特定意义上说，决策的过程就是抢抓机遇，将可能性变为现实的过程。机遇从来都是公正的，机遇一旦到来，就看谁能审时度势，及早地发现它，抓住它；能否抓住它，又关键看谁具有立断立行的智慧和勇气，凡是决策，没有不存在风险的，若想等到有","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"百分之百的把握再拍板，恐怕时机早已逝去了。这段文字主要说明： A.应该掌握时机果断决策以免错失机遇B.决策者的智慧和勇气是决策成败的关键C.有了充分的把握再决策已丧失最好的时机D.决策者主要考虑如何将可能性变为现实必要性提出立断立行的智慧和勇气；做法+危害提出不能百分百再决定。C是充分，不符合完全。B是没有强调智慧和勇气，而是强调立断立行。偏正的选项反推 当我们无法确定一个选项是否是文段正确答案时，可采取偏正的选项反推，逆向验证这个选项是否是正确答案。 题目：物质都是由分子、原子构成的，原子又包括核外带负电的电子和带正电的原子核。当物质温度过高或者因为其他原因，核外电子吸收能量，摆脱了原子核的束缚，成为自由电子，物质就变成了自由电子和带电离子，这种状态下的物质就被叫做等离子体。火就是以等离子体的形态出现的，这是物质的第四种形态，看起来和气体有些像，因此也被叫做超气态。火是物质燃烧过程中所进行的强烈氧化反应，其能量以光和热的形式释放。换句话说，火其实是能量的一种存在形式，是氢、碳、氧和其他物质混合而成的。如果想生火，可燃物、足够高的温度和氧化剂缺一不可。 这段文字主要介绍的是： A.火的","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_29","order":29,"summary":"百分之百的把握再拍板，恐怕时机早已逝去了。这段文字主要说明： A.应该掌握时机果断决策以免错失机遇B.决策者的智慧和勇气是决策成败的关键C.有了充分的把握再决策已丧失最好的时机D.决策者主要考虑如何将可能性变为现实必要性提出立断立行的智慧和勇气；做法+危害提出不能百分百再决定。C是充分，不符合完全。B是没有强调智慧和勇气，而是强调立断立行。偏正的选项反推 当我们无法确定一个选项是否是文段正确答案时，可采取偏正的选项反推，逆向验证这个选项是否是正确答案。 题目：物质都是由分子、原子构成的，原子又包括核外带负电的电子和带正电的原子核。当物质温度过高或者因为其他原因，核外电子吸收能量，摆脱了原子核的束缚，成为自由电子，物质就变成了自由电子和带电离子，这种状态下的物质就被叫做等离子体。火就是以等离子体的形态出现的，这是物质的第四种形态，看起来和气体有些像，因此也被叫做超气态。火是物质燃烧过程中所进行的强烈氧化反应，其能量以光和热的形式释放。换句话说，火其实是能量的一种存在形式，是氢、碳、氧和其他物质混合而成的。如果想生火，可燃物、足够高的温度和氧化剂缺一不可。 这段文字主要介绍的是： A.火的","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"主要特点 B.火的生成条件C.火的根本性质D.火的存在状态B只最后讲了，不符合偏正精讲和数量。C一直强调是xx是xx，数量展开转折的剖析 转折是中心理解错误的重区，很多学过机构理论的同学，对于转折过于看重，有时候直接凭借局部的转折秒选答案。会导致有时候能做对，有时候又做不对了，归根到底是转折有局部性。 A但是B，在这一句话中，作者确实是强调B的，如果这一句话恰好是观点，那么他就是答案。但是很多时候，B并不是观点，所以还是要具体题目具体分析。 强转折即前后话题转折意味浓厚 辩证是有好有坏才是辩证。 弱转折仍有转折作用，但是不强烈，倾向于补充说明 人体严密的免疫防御系统，会在细菌入侵时引起炎症反应，白细胞和大量“防御斗士”对病原体展开攻击，防御的一方通常会胜利。理论上讲，“刺激”消除后，炎症反应会逐渐消失，组织回到正常状态。但在某些特定情况下，炎症依然会持续，这种低度炎症不像通常的炎症那样可以明显感觉到它的存在，其更像人体内未被完全熄灭的“火苗”。机体通过炎症反应抵抗病原体的过程，保障了人类的生存，但是科学家发现，这种低度炎症会缩短生命，促进许多年龄相关性症状，如认知衰退、神经变性、动脉粥","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_30","order":30,"summary":"主要特点 B.火的生成条件C.火的根本性质D.火的存在状态B只最后讲了，不符合偏正精讲和数量。C一直强调是xx是xx，数量展开转折的剖析 转折是中心理解错误的重区，很多学过机构理论的同学，对于转折过于看重，有时候直接凭借局部的转折秒选答案。会导致有时候能做对，有时候又做不对了，归根到底是转折有局部性。 A但是B，在这一句话中，作者确实是强调B的，如果这一句话恰好是观点，那么他就是答案。但是很多时候，B并不是观点，所以还是要具体题目具体分析。 强转折即前后话题转折意味浓厚 辩证是有好有坏才是辩证。 弱转折仍有转折作用，但是不强烈，倾向于补充说明 人体严密的免疫防御系统，会在细菌入侵时引起炎症反应，白细胞和大量“防御斗士”对病原体展开攻击，防御的一方通常会胜利。理论上讲，“刺激”消除后，炎症反应会逐渐消失，组织回到正常状态。但在某些特定情况下，炎症依然会持续，这种低度炎症不像通常的炎症那样可以明显感觉到它的存在，其更像人体内未被完全熄灭的“火苗”。机体通过炎症反应抵抗病原体的过程，保障了人类的生存，但是科学家发现，这种低度炎症会缩短生命，促进许多年龄相关性症状，如认知衰退、神经变性、动脉粥","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"样硬化等。不过，引起和维持这些变化的机制，目前尚不能明确。 这段文字主要介绍： A.人体免疫系统的防御机制B.低度炎症的发生机制与影响C.细菌对人类生存的影响 D.年龄相关性症状的研究现状做法+危害提出低度炎症会缩短生命。并且两个但都是好转折成坏，强调低度炎症的影响。如果能够做好南极生态环境的承受力评估，并严格执行有关规定，南极旅游造成的生态影响就可以得到有效控制。因为与南极大陆极为广袤的地域相比，游客活动的地域仅为总面积的 3%左右。而如何管理好长期设在南极的科考站，才是更为棘手的问题，尤其是一些被废弃的科考站，已对南极生态环境造成了新的威胁。 这段文字意在强调（ ）A.南极生态环境评估的意义B.南极生态旅游的发展前景C.南极生态环境管理机制的必要性 D.南极科考站对当地生态环境的影响重要性提出要做好承受力评估；本身观点提出科考站更棘手。强调科考站，尊重原文。地位的感知 文段地位两者（多者）地位相当，反复联系 一个文段里面A与B反复的出现，互相联系，两者都是十分重要的，常见的错误选项就是择一而谈 什么叫做高频词？要注意局部性，参考弱转折。 民众是否爱好学术，直接影响到学术本身的升沉；","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_31","order":31,"summary":"样硬化等。不过，引起和维持这些变化的机制，目前尚不能明确。 这段文字主要介绍： A.人体免疫系统的防御机制B.低度炎症的发生机制与影响C.细菌对人类生存的影响 D.年龄相关性症状的研究现状做法+危害提出低度炎症会缩短生命。并且两个但都是好转折成坏，强调低度炎症的影响。如果能够做好南极生态环境的承受力评估，并严格执行有关规定，南极旅游造成的生态影响就可以得到有效控制。因为与南极大陆极为广袤的地域相比，游客活动的地域仅为总面积的 3%左右。而如何管理好长期设在南极的科考站，才是更为棘手的问题，尤其是一些被废弃的科考站，已对南极生态环境造成了新的威胁。 这段文字意在强调（ ）A.南极生态环境评估的意义B.南极生态旅游的发展前景C.南极生态环境管理机制的必要性 D.南极科考站对当地生态环境的影响重要性提出要做好承受力评估；本身观点提出科考站更棘手。强调科考站，尊重原文。地位的感知 文段地位两者（多者）地位相当，反复联系 一个文段里面A与B反复的出现，互相联系，两者都是十分重要的，常见的错误选项就是择一而谈 什么叫做高频词？要注意局部性，参考弱转折。 民众是否爱好学术，直接影响到学术本身的升沉；","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"而学人不唤起国人对学术的自觉，“文德”不能与民分享，则“民德”就会堕落，“文德”本身也会变成无源之水、无根之木，也就没了提升的基础。为了使“文德”更好地转化为“民德”，蔡元培提出了以大学为社会文化中心的主张。这段文字意在说明： A.大学是“文德”的中心 B.“民德”是“文德”的本源C.“文德”与“民德”的双向关联D.“文德”对“民德”有提升作用他者经验提出以大学为社会中心。但是选项没有，从文段地位看到民众影响学术；文德影响民德。两者互相影响。进项的地位感知当选项出现多个名词的时候，其重点倾向往往是不同的，可以利用选项中的地位差异进行排除 网红效应。C的区别应该是两者地位相当，都占有一定文段才能选。 多元化指的是有多种类型，融合是多变一。 文段内容的展开 对于一个宏观总结性的内容，涉及到宏观到具体，涉及到两种文段的结构。由文段到选项。 单层次展开 后文围绕同一主体，背景限定进行展开，进行更加具体的，详细的展开 不讲道理的话语逻辑是值得警惕的，长期处于这样的言论状态中，难免影响理性表达。好的公共表达应该是温和理性的，即便是带有情绪的话语，也应该对事不对人。言论自由是我们的权利，但说负责的话","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_32","order":32,"summary":"而学人不唤起国人对学术的自觉，“文德”不能与民分享，则“民德”就会堕落，“文德”本身也会变成无源之水、无根之木，也就没了提升的基础。为了使“文德”更好地转化为“民德”，蔡元培提出了以大学为社会文化中心的主张。这段文字意在说明： A.大学是“文德”的中心 B.“民德”是“文德”的本源C.“文德”与“民德”的双向关联D.“文德”对“民德”有提升作用他者经验提出以大学为社会中心。但是选项没有，从文段地位看到民众影响学术；文德影响民德。两者互相影响。进项的地位感知当选项出现多个名词的时候，其重点倾向往往是不同的，可以利用选项中的地位差异进行排除 网红效应。C的区别应该是两者地位相当，都占有一定文段才能选。 多元化指的是有多种类型，融合是多变一。 文段内容的展开 对于一个宏观总结性的内容，涉及到宏观到具体，涉及到两种文段的结构。由文段到选项。 单层次展开 后文围绕同一主体，背景限定进行展开，进行更加具体的，详细的展开 不讲道理的话语逻辑是值得警惕的，长期处于这样的言论状态中，难免影响理性表达。好的公共表达应该是温和理性的，即便是带有情绪的话语，也应该对事不对人。言论自由是我们的权利，但说负责的话","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"也是我们的义务，没有限度的自由只会带来人与人之间的不信任感，使得社会缺少应有的共识。公共平台是自我言语表达的载体，体现着发言者的个人素养，作为受过良好教育的现代公民，当有这份责任意识。 这段文字意在说明（ ）。 A.公共表达时更应遵守对事不对人的原则 B.遵循讲道理的话语逻辑是理性表达的前提C.公民在公共平台上应有理性表达的义务 D.有限的自由空间是人们建立信任感的基础做法+危害提出要讲道理的话语逻辑；开门见山提出公共表达是温和理性对事不对人，要有限度的自由；重要性提出公共平台是言语表达的载体，总的来说就是公共平台要注意公共表达，对事不对人（讲道理）。公共平台更具体，公共表达宏观。谈及中国的历史，单说“魏”或“晋”时，似无出奇之处，但如果把“魏”和“晋”连在一起说出来，一个光照千古的神奇概念就骤然出现：魏晋风度。与汉朝的敦实厚重、三国的慷慨激荡、唐朝的盛大开放、宋朝的清丽婉约不同，魏晋人物以率性不羁、旷达玄远著称。这是当时整个社会的精神时尚和审美追求，魏晋也因此而成为中国历史上空前绝后和争议最大的时代。这是一篇文章的开头部分，据此推测，这篇文章谈论的重点应该是（）。A.魏晋时期的社会环","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_33","order":33,"summary":"也是我们的义务，没有限度的自由只会带来人与人之间的不信任感，使得社会缺少应有的共识。公共平台是自我言语表达的载体，体现着发言者的个人素养，作为受过良好教育的现代公民，当有这份责任意识。 这段文字意在说明（ ）。 A.公共表达时更应遵守对事不对人的原则 B.遵循讲道理的话语逻辑是理性表达的前提C.公民在公共平台上应有理性表达的义务 D.有限的自由空间是人们建立信任感的基础做法+危害提出要讲道理的话语逻辑；开门见山提出公共表达是温和理性对事不对人，要有限度的自由；重要性提出公共平台是言语表达的载体，总的来说就是公共平台要注意公共表达，对事不对人（讲道理）。公共平台更具体，公共表达宏观。谈及中国的历史，单说“魏”或“晋”时，似无出奇之处，但如果把“魏”和“晋”连在一起说出来，一个光照千古的神奇概念就骤然出现：魏晋风度。与汉朝的敦实厚重、三国的慷慨激荡、唐朝的盛大开放、宋朝的清丽婉约不同，魏晋人物以率性不羁、旷达玄远著称。这是当时整个社会的精神时尚和审美追求，魏晋也因此而成为中国历史上空前绝后和争议最大的时代。这是一篇文章的开头部分，据此推测，这篇文章谈论的重点应该是（）。A.魏晋时期的社会环","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"境 B.魏晋时期的文学成就C.魏晋人物及其精神风貌 D.魏晋风度对后世的影响本身观点提出魏晋风度，魏晋人物的率性不羁。反复强调人物：这是，因此。并且人物更加具体。D的偏正只有最后一句话。多层次展开 (CAB并列系列） 当文段出现并列结构的时候，则一定会有以下内容： C--总括的内容，A--并列的第一个分述，B--并列的第二个分述 也、同时、并且、内容并列（危害，意义） 则我们可以直接根据文段去推测正确答案，有以下的情况 最佳答案---A+B CAB的最佳答案，就是把A和B完整地并列列出来，但是这种情况往往受限于字数，可以常用观点去锁定选项，选项反窥观点 题目： 孩子的学习任务较重，如果近距离用眼程度过强，持续用眼时间过长，就会造成眼睛睫状肌过度收缩且长期处于痉挛状态，导致看远处时不能很快放松、调节，产生头晕、眼胀、视力下降等疲劳症状，这种表现被称为假性近视。出现假性近视时，可通过充分休息缓解睫状肌麻痹，使视力恢复。但若长此以往，假性近视会因为眼轴增长而发展为真性近视。上述文段主要说明了: A.预防假性近视的方法 B.假性近视的症状及后果C.假性近视的原因及其种类D.假性近视与真性近视的","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_34","order":34,"summary":"境 B.魏晋时期的文学成就C.魏晋人物及其精神风貌 D.魏晋风度对后世的影响本身观点提出魏晋风度，魏晋人物的率性不羁。反复强调人物：这是，因此。并且人物更加具体。D的偏正只有最后一句话。多层次展开 (CAB并列系列） 当文段出现并列结构的时候，则一定会有以下内容： C--总括的内容，A--并列的第一个分述，B--并列的第二个分述 也、同时、并且、内容并列（危害，意义） 则我们可以直接根据文段去推测正确答案，有以下的情况 最佳答案---A+B CAB的最佳答案，就是把A和B完整地并列列出来，但是这种情况往往受限于字数，可以常用观点去锁定选项，选项反窥观点 题目： 孩子的学习任务较重，如果近距离用眼程度过强，持续用眼时间过长，就会造成眼睛睫状肌过度收缩且长期处于痉挛状态，导致看远处时不能很快放松、调节，产生头晕、眼胀、视力下降等疲劳症状，这种表现被称为假性近视。出现假性近视时，可通过充分休息缓解睫状肌麻痹，使视力恢复。但若长此以往，假性近视会因为眼轴增长而发展为真性近视。上述文段主要说明了: A.预防假性近视的方法 B.假性近视的症状及后果C.假性近视的原因及其种类D.假性近视与真性近视的","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"关系假性近视的表现-\u003e解决措施但不解决的后果。从学理的角度来说，知识产权诉前行为保全是指为及时制止正在实施或即将实施的侵害权利人知识产权或有侵害之虞的行为，而在当事人起诉前根据其申请，由法院签发的一种禁止行为人为或不为一定行为的强制性命令。它属于知识产权侵权救济的一种暂时性措施，有着维权“及时雨”的功能。有别于传统财产权侵权，知识产权客体的易复制性与极易扩散性，使得知识产权人改变了过去倚重事后救济来保护权力的习惯。在当前国家加大知识产权保护力度、建立知识产权侵权惩罚性赔偿制度的背景下，及时有效地制止侵权比等到切实的损害结果发生后的救济更加有效。 这段文字主要介绍了知识产权诉前行为保全的：A.救济原则与法律依据B.研究背景与实施过程C.法律效力与赔偿策略D.法理概念与司法功能看选项知并列。不要强求观点去看整体：诉前行为的定义+其功能+其意义。语言和文化一样，很少是自给自足的，故词语的借用自古至今都是常见的语言现象。但当外来词汇进入一个国家后，当地民族会在适应吸收新成分的同时，不自觉地变异和改造其原貌。随着时间的推移，外来词汇会逐渐本土化，日久天长，源流模糊，体用隔断，变异迭生。一旦借词身","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_35","order":35,"summary":"关系假性近视的表现-\u003e解决措施但不解决的后果。从学理的角度来说，知识产权诉前行为保全是指为及时制止正在实施或即将实施的侵害权利人知识产权或有侵害之虞的行为，而在当事人起诉前根据其申请，由法院签发的一种禁止行为人为或不为一定行为的强制性命令。它属于知识产权侵权救济的一种暂时性措施，有着维权“及时雨”的功能。有别于传统财产权侵权，知识产权客体的易复制性与极易扩散性，使得知识产权人改变了过去倚重事后救济来保护权力的习惯。在当前国家加大知识产权保护力度、建立知识产权侵权惩罚性赔偿制度的背景下，及时有效地制止侵权比等到切实的损害结果发生后的救济更加有效。 这段文字主要介绍了知识产权诉前行为保全的：A.救济原则与法律依据B.研究背景与实施过程C.法律效力与赔偿策略D.法理概念与司法功能看选项知并列。不要强求观点去看整体：诉前行为的定义+其功能+其意义。语言和文化一样，很少是自给自足的，故词语的借用自古至今都是常见的语言现象。但当外来词汇进入一个国家后，当地民族会在适应吸收新成分的同时，不自觉地变异和改造其原貌。随着时间的推移，外来词汇会逐渐本土化，日久天长，源流模糊，体用隔断，变异迭生。一旦借词身","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"上的“异域特征”(诸如音素、音节的构成等)在使用者的意识里淡化或消失，它们就会被当地人视为自己母语中的一部分。 这段文字重在说明： A.外来词汇对本民族语言和文化的影响 B.本民族语言吸收改造外来词汇的方式C.外来词汇使用的普遍性及本土化过程 D.外来词汇在母语中淡化与消失的原因词语借用常见，外来词汇本土化。B只是提高了本土化。还是要注重整体，而不是观点。《新青年》创刊时名为《青年杂志》，因与《上海青年》杂志的名称部分雷同，从第二卷第一号开始，正式改名为《新青年》。这次更名本是被迫与无奈之举，但在陈独秀的巧妙处理下，却成为促进刊物发展的绝佳机遇。在更名后第一期杂志的篇首，刊登了陈独秀的文章，重新定义了“新青年”这一概念，提出要以“生理心理”的标准，而非“年龄”来区分新旧青年。这一期杂志还刊登了一则通告，告知读者杂志更名事宜。变被动为主动，赋予“新青年”三个字鲜明的时代意义与先锋的思想价值，也让《新青年》有了更加精准的办刊定位。这段文字中的“巧妙处理”指的是： A.精准定位受众，激发情感共鸣 B.采取差异策略，力求独树一帜C.明晰用户心理，精准投放内容 D.借助事件传播，创造全新概念重新","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_36","order":36,"summary":"上的“异域特征”(诸如音素、音节的构成等)在使用者的意识里淡化或消失，它们就会被当地人视为自己母语中的一部分。 这段文字重在说明： A.外来词汇对本民族语言和文化的影响 B.本民族语言吸收改造外来词汇的方式C.外来词汇使用的普遍性及本土化过程 D.外来词汇在母语中淡化与消失的原因词语借用常见，外来词汇本土化。B只是提高了本土化。还是要注重整体，而不是观点。《新青年》创刊时名为《青年杂志》，因与《上海青年》杂志的名称部分雷同，从第二卷第一号开始，正式改名为《新青年》。这次更名本是被迫与无奈之举，但在陈独秀的巧妙处理下，却成为促进刊物发展的绝佳机遇。在更名后第一期杂志的篇首，刊登了陈独秀的文章，重新定义了“新青年”这一概念，提出要以“生理心理”的标准，而非“年龄”来区分新旧青年。这一期杂志还刊登了一则通告，告知读者杂志更名事宜。变被动为主动，赋予“新青年”三个字鲜明的时代意义与先锋的思想价值，也让《新青年》有了更加精准的办刊定位。这段文字中的“巧妙处理”指的是： A.精准定位受众，激发情感共鸣 B.采取差异策略，力求独树一帜C.明晰用户心理，精准投放内容 D.借助事件传播，创造全新概念重新","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"定义概念，告知更名，变被动为主动的结果。A延伸了，D看到概念反推传播。表并列：不仅如此、也、选项并列、并且选C C即带有高度总括性的内容，可以概括A与B, 当没有A+B的完美答案时，选C 题目： 我国在经济快速发展的同时，培育和形成了全球少有的超大规模内需市场。与小规模经济体相比，超大规模经济体在全球经济运行中通常发挥着“锚”的作用。改革开放以来，我国之所以能够成功应对亚洲金融危机、国际金融危机等的冲击，一定程度上就得益于此。另外，超大规模市场的多样性意味着更强的内部稳定性。产业发展、区域发展的差异性可以减少冲击的影响，局部的内部冲击不易在全国形成共振效应；部分行业、部分区域发展面临困境，并不会对宏观经济总体稳定产生巨大冲击。 这段文字意在说明： A.我国既是经济全球化的受益者也是贡献者 B.多措并举对保障内需市场稳定有重大意义C.超大规模市场有助于我国经济保持稳定 D.超大规模经济体助力全球经济平稳运行主语是超大规模内需市场。锚的作用，我国能应对全球危机的冲击，我国内部稳定。农业正在向着多元化的方向发展，如今思考农产品的生产，就要一定程度上跳脱“非涨即跌”的二元思维。市场规律固然重要","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_37","order":37,"summary":"定义概念，告知更名，变被动为主动的结果。A延伸了，D看到概念反推传播。表并列：不仅如此、也、选项并列、并且选C C即带有高度总括性的内容，可以概括A与B, 当没有A+B的完美答案时，选C 题目： 我国在经济快速发展的同时，培育和形成了全球少有的超大规模内需市场。与小规模经济体相比，超大规模经济体在全球经济运行中通常发挥着“锚”的作用。改革开放以来，我国之所以能够成功应对亚洲金融危机、国际金融危机等的冲击，一定程度上就得益于此。另外，超大规模市场的多样性意味着更强的内部稳定性。产业发展、区域发展的差异性可以减少冲击的影响，局部的内部冲击不易在全国形成共振效应；部分行业、部分区域发展面临困境，并不会对宏观经济总体稳定产生巨大冲击。 这段文字意在说明： A.我国既是经济全球化的受益者也是贡献者 B.多措并举对保障内需市场稳定有重大意义C.超大规模市场有助于我国经济保持稳定 D.超大规模经济体助力全球经济平稳运行主语是超大规模内需市场。锚的作用，我国能应对全球危机的冲击，我国内部稳定。农业正在向着多元化的方向发展，如今思考农产品的生产，就要一定程度上跳脱“非涨即跌”的二元思维。市场规律固然重要","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"，而农产品市场的细分领域实际上还未大量开发。如果能够针对这些需求来生产具有特色的农产品，就能一定程度上摆脱农产品价格波动的困扰。从宏观角度说，农产品价格短期内波动的本质原因是农产品产能的集中释放，而其关键因素是农产品的供给量大，品质相似。理解了这一层就可以发现，其实面对的问题并不完全是农产品市场价格的起伏不定，而是产业结构、生产方式需要深度调整。这段文字意在（ ）。 A.提出应对农产品价格波动的思路 B.分析农产品市场的供需关系C.阐述农产品细分市场的开发前景 D.揭示农业多元化发展的原因问题：价格波动。做法：生产特色产品，产业结构、生产方式调整。问题+做法，优先做法，但是选项没有，选问题。A可以偏正展开实现技术要素高效配置是高标准市场体系建设的战略使命。技术要素市场化改革为建设高标准市场体系带来内生动力。发展完善技术要素市场，对现有市场体系提出了更高要求，例如需要更加健全的产权保护制度，更加公平的市场竞争环境，更为成熟的劳动力、资本要素市场以及更加包容的市场监管。此外，由于市场管理与创新管理的部门分割，技术要素市场化改革必然要求高标准市场体系建设要着力解决深层次的体制机制障碍、更加有","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_38","order":38,"summary":"，而农产品市场的细分领域实际上还未大量开发。如果能够针对这些需求来生产具有特色的农产品，就能一定程度上摆脱农产品价格波动的困扰。从宏观角度说，农产品价格短期内波动的本质原因是农产品产能的集中释放，而其关键因素是农产品的供给量大，品质相似。理解了这一层就可以发现，其实面对的问题并不完全是农产品市场价格的起伏不定，而是产业结构、生产方式需要深度调整。这段文字意在（ ）。 A.提出应对农产品价格波动的思路 B.分析农产品市场的供需关系C.阐述农产品细分市场的开发前景 D.揭示农业多元化发展的原因问题：价格波动。做法：生产特色产品，产业结构、生产方式调整。问题+做法，优先做法，但是选项没有，选问题。A可以偏正展开实现技术要素高效配置是高标准市场体系建设的战略使命。技术要素市场化改革为建设高标准市场体系带来内生动力。发展完善技术要素市场，对现有市场体系提出了更高要求，例如需要更加健全的产权保护制度，更加公平的市场竞争环境，更为成熟的劳动力、资本要素市场以及更加包容的市场监管。此外，由于市场管理与创新管理的部门分割，技术要素市场化改革必然要求高标准市场体系建设要着力解决深层次的体制机制障碍、更加有","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"效地统筹市场体系与创新体系的关系、协调科技与经济社会发展的关系。重要性提出技术要素是战略使命；技术要素要求市场体系，要求高标准市场体系。目前，我国自主选育品种播种面积占 95%以上，良种对粮食增产贡献率已超过45%，为粮食连年丰收和重要农产品稳产保供提供了关键支撑。然而，我国种业自主创新水平与发达国家还有差距，一些品种、领域和环节会影响农业发展速度、质量和效益。这就要求我们加强农业种质资源保护利用，加快推进关键核心技术攻关，缩小玉米、大豆等品种和国际先进水平的差距，确保重要农产品种源自主可控。同时，打通种子生产、加工、销售、技术服务等环节，逐步完善产学研用深度融合的创新链条，加快提升种业产业化水平，让一粒粒好种子长成农民的致富希望。 最适合做这段文字标题的是：A.打造种子这枚农业“芯片” B.要让创新为中国农业赋能C.种出农民致富的新希望 D.种业产业化发展的启示种业指的是种子，观点是直接对策。B只谈到农业。选A或B 当文段出现并列结构，选项却没有（A+B) 或者C，不可直接用片面排除，可以勉强去选A或B。 本质上仍然是以人为本。 题目： 二十世纪六七十年代，世界上香菇、木耳、灵芝等食","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_39","order":39,"summary":"效地统筹市场体系与创新体系的关系、协调科技与经济社会发展的关系。重要性提出技术要素是战略使命；技术要素要求市场体系，要求高标准市场体系。目前，我国自主选育品种播种面积占 95%以上，良种对粮食增产贡献率已超过45%，为粮食连年丰收和重要农产品稳产保供提供了关键支撑。然而，我国种业自主创新水平与发达国家还有差距，一些品种、领域和环节会影响农业发展速度、质量和效益。这就要求我们加强农业种质资源保护利用，加快推进关键核心技术攻关，缩小玉米、大豆等品种和国际先进水平的差距，确保重要农产品种源自主可控。同时，打通种子生产、加工、销售、技术服务等环节，逐步完善产学研用深度融合的创新链条，加快提升种业产业化水平，让一粒粒好种子长成农民的致富希望。 最适合做这段文字标题的是：A.打造种子这枚农业“芯片” B.要让创新为中国农业赋能C.种出农民致富的新希望 D.种业产业化发展的启示种业指的是种子，观点是直接对策。B只谈到农业。选A或B 当文段出现并列结构，选项却没有（A+B) 或者C，不可直接用片面排除，可以勉强去选A或B。 本质上仍然是以人为本。 题目： 二十世纪六七十年代，世界上香菇、木耳、灵芝等食","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"用菌和药用菌人工栽培基本都以木材为原料，在我国每年仅栽培香菇一项就要砍伐阔叶林1000 万立方米以上，从而产生了严重的生态问题和“菌林矛盾”。由此我国开始了“以草代木”栽培食药用菌研究，1986年，终于成功培育出可做栽培食药用菌培养基的草本植物——菌草，并逐渐摸索出一套运用菌草栽培食药用菌和生产菌物饲料、菌物肥料的综合技术。菌草技术开辟了“菌”与“草”交叉科学研究与应用新领域，为保护生态环境，促进可持续发展开辟了新途径。这段文字意在说明，菌草技术： A.有助于解决“菌林矛盾”的难题 B.是我国食药用菌栽培的原创技术C.为食药用菌栽培提供了新的思路 D.为保护阔叶林资源开辟了新途径问题：生态矛盾+菌林矛盾。对策：食药用菌研究。C比较片面，没有提到解决生态问题，自己猜的。要推动老旧小区的适老化改造和无障碍环境建设，关键是提升整个社会对适老化改造的思想认识，实现适老化改造特别是居家适老化改造“心理无障碍”。要多渠道、全方位宣传引导居家适老化改造的政策与价值，转变老人、子女和社会对居家适老化改造的认知；同时，要通过养老服务中心、居家养老服务中心等载体，打造居家适老化改造样板房，强化直观感受，转","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_40","order":40,"summary":"用菌和药用菌人工栽培基本都以木材为原料，在我国每年仅栽培香菇一项就要砍伐阔叶林1000 万立方米以上，从而产生了严重的生态问题和“菌林矛盾”。由此我国开始了“以草代木”栽培食药用菌研究，1986年，终于成功培育出可做栽培食药用菌培养基的草本植物——菌草，并逐渐摸索出一套运用菌草栽培食药用菌和生产菌物饲料、菌物肥料的综合技术。菌草技术开辟了“菌”与“草”交叉科学研究与应用新领域，为保护生态环境，促进可持续发展开辟了新途径。这段文字意在说明，菌草技术： A.有助于解决“菌林矛盾”的难题 B.是我国食药用菌栽培的原创技术C.为食药用菌栽培提供了新的思路 D.为保护阔叶林资源开辟了新途径问题：生态矛盾+菌林矛盾。对策：食药用菌研究。C比较片面，没有提到解决生态问题，自己猜的。要推动老旧小区的适老化改造和无障碍环境建设，关键是提升整个社会对适老化改造的思想认识，实现适老化改造特别是居家适老化改造“心理无障碍”。要多渠道、全方位宣传引导居家适老化改造的政策与价值，转变老人、子女和社会对居家适老化改造的认知；同时，要通过养老服务中心、居家养老服务中心等载体，打造居家适老化改造样板房，强化直观感受，转","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"变老人的传统观念，让老人逐步形成“为养老服务买单”、让子女形成更加关注父母居家养老环境的社会意识，提升适老化改造的家庭主观能动性。 这段文字强调要： A.平衡主体利益，因地制宜推动适老化改造 B.统筹各方资源，激活适老化改造的多元力量C.补位标准规范，提升适老化改造的品质与效率 D.加强宣传引导，做到适老化改造“心理无障碍”必要性提出对适老化改造的思想认识；对策提出要宣传，打造样板房。以人为本！符合内容！语言学是研究语言结构模式与演化规律的学科，对“模式”与“规律”的探求是语言学与其他科学的共同目标。然而，光有科学的目标还远远不够，演绎与归纳、定性与定量、描写与解释、假设与检验等现代科学在方法论上的共同特征，正是我国传统语言学所欠缺的。与此同时，中国语言学还面临着国际化问题，我们在国际语言学学术共同体中的声音还很微弱。造成这种局面的原因，并不能完全归结于研究对象的不同，以及国际学术语言是英语的语言藩篱，也存在研究理念与研究方法的问题。不能归结于xx，以及xx，也（而是）存在方法的问题。极小点并列 当在大量的并列中，取并列中的一些小点，是正确选项的概率很小 题目： 我们要结合我国发展需要","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_41","order":41,"summary":"变老人的传统观念，让老人逐步形成“为养老服务买单”、让子女形成更加关注父母居家养老环境的社会意识，提升适老化改造的家庭主观能动性。 这段文字强调要： A.平衡主体利益，因地制宜推动适老化改造 B.统筹各方资源，激活适老化改造的多元力量C.补位标准规范，提升适老化改造的品质与效率 D.加强宣传引导，做到适老化改造“心理无障碍”必要性提出对适老化改造的思想认识；对策提出要宣传，打造样板房。以人为本！符合内容！语言学是研究语言结构模式与演化规律的学科，对“模式”与“规律”的探求是语言学与其他科学的共同目标。然而，光有科学的目标还远远不够，演绎与归纳、定性与定量、描写与解释、假设与检验等现代科学在方法论上的共同特征，正是我国传统语言学所欠缺的。与此同时，中国语言学还面临着国际化问题，我们在国际语言学学术共同体中的声音还很微弱。造成这种局面的原因，并不能完全归结于研究对象的不同，以及国际学术语言是英语的语言藩篱，也存在研究理念与研究方法的问题。不能归结于xx，以及xx，也（而是）存在方法的问题。极小点并列 当在大量的并列中，取并列中的一些小点，是正确选项的概率很小 题目： 我们要结合我国发展需要","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"和可能，做好我国数字经济发展顶层设计和体制机制建设。要加强形势研判，抓住机遇，赢得主动。各级领导干部要提高数字经济思维能力和专业素质，增强发展数字经济本领，强化安全意识，推动数字经济更好服务和融入新发展格局。要提高全民全社会数字素养和技能，夯实我国数字经济发展社会基础。 这段文字意在说明：（ ）。 A.数字经济事关国家发展大局 B.要把发展数字经济自主权牢牢掌握在自己手中C.数字经济影响程度之深前所未有 D.数字经济有利于推动各级资源要素快速流动观点：数字经济很重要。B太片面了，只是极小点，甚至都没讲。C没有谈影响。特殊题型 题目：以英国为例，据英国全国志愿组织理事会统计，受财政紧缩政策影响，2012年度政府对慈善组织的资助减少了 13 亿英镑，较前一年下降8%。为此，英国的慈善组织不得不以更加“企业化”的管理模式来应对资金困局。在开源方面，主要是拓宽筹资渠道，比如开展房屋租赁、培训课程、慈善商店等慈善性质的交易活动；在节流方面，主要举措是加强组织内部管理。因此，虽然欧洲经济大环境不好，但调查数据称，英国 2011～2012 年度的慈善组织经营性收入仍然有 213 亿英镑。 这段文字意","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_42","order":42,"summary":"和可能，做好我国数字经济发展顶层设计和体制机制建设。要加强形势研判，抓住机遇，赢得主动。各级领导干部要提高数字经济思维能力和专业素质，增强发展数字经济本领，强化安全意识，推动数字经济更好服务和融入新发展格局。要提高全民全社会数字素养和技能，夯实我国数字经济发展社会基础。 这段文字意在说明：（ ）。 A.数字经济事关国家发展大局 B.要把发展数字经济自主权牢牢掌握在自己手中C.数字经济影响程度之深前所未有 D.数字经济有利于推动各级资源要素快速流动观点：数字经济很重要。B太片面了，只是极小点，甚至都没讲。C没有谈影响。特殊题型 题目：以英国为例，据英国全国志愿组织理事会统计，受财政紧缩政策影响，2012年度政府对慈善组织的资助减少了 13 亿英镑，较前一年下降8%。为此，英国的慈善组织不得不以更加“企业化”的管理模式来应对资金困局。在开源方面，主要是拓宽筹资渠道，比如开展房屋租赁、培训课程、慈善商店等慈善性质的交易活动；在节流方面，主要举措是加强组织内部管理。因此，虽然欧洲经济大环境不好，但调查数据称，英国 2011～2012 年度的慈善组织经营性收入仍然有 213 亿英镑。 这段文字意","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"在说明： A.慈善组织应当减少对政府的依赖 B.慈善组织应不断改善自身管理模式C.开源和节流对慈善组织管理缺一不可 D.经济形势对慈善组织的发展影响较大C不够具体，应该时拓宽渠道、加强管理。C管理模式AB两个方面。不要想当然。我国科普工作虽然取得了很大进步，可是科普读物，无论数量还是质量，与发达国家还有着数量级的差距。在一些社会关注的重大问题上，科学家更应该主动站出来讲话。要把科学语言转化为老百姓听得懂的语言，实事求是讲真话。如果连科学家都不愿意、不敢讲话，任由真相缺失、谣言扩散，那么势必会引起公众的恐慌和困惑。上述文字意在强调：A.科普工作应该通俗化，接地气 B.我国科普读物数量少，质量差C.科学家负有做科普工作的义务 D.科学家应坚持求真务实的原则科学家在重大问题上应该主动讲真话。D没有提到主动。C可以进行偏正的展开问题 CAB和偏正的展开有什么关系？ CAB是文段到选项，如果文段出现并列结构，就可以用CAB把文段浓缩成选项；偏正的展开是选项到文段，知道选项是偏正模式，就可以回推文段应该是怎么样的。 其中偏正数量的展开，回归到文段便是CAB形式；CAB形式的选C，浓缩成选项就是偏正","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_43","order":43,"summary":"在说明： A.慈善组织应当减少对政府的依赖 B.慈善组织应不断改善自身管理模式C.开源和节流对慈善组织管理缺一不可 D.经济形势对慈善组织的发展影响较大C不够具体，应该时拓宽渠道、加强管理。C管理模式AB两个方面。不要想当然。我国科普工作虽然取得了很大进步，可是科普读物，无论数量还是质量，与发达国家还有着数量级的差距。在一些社会关注的重大问题上，科学家更应该主动站出来讲话。要把科学语言转化为老百姓听得懂的语言，实事求是讲真话。如果连科学家都不愿意、不敢讲话，任由真相缺失、谣言扩散，那么势必会引起公众的恐慌和困惑。上述文字意在强调：A.科普工作应该通俗化，接地气 B.我国科普读物数量少，质量差C.科学家负有做科普工作的义务 D.科学家应坚持求真务实的原则科学家在重大问题上应该主动讲真话。D没有提到主动。C可以进行偏正的展开问题 CAB和偏正的展开有什么关系？ CAB是文段到选项，如果文段出现并列结构，就可以用CAB把文段浓缩成选项；偏正的展开是选项到文段，知道选项是偏正模式，就可以回推文段应该是怎么样的。 其中偏正数量的展开，回归到文段便是CAB形式；CAB形式的选C，浓缩成选项就是偏正","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"结构 CAB中选A或B，这个和观点的偏向性有什么关系？具体性呢？你能总结出几种选A或B做合理情况？ 当文段出现并列时，可以利用观点的偏向性和具体性确定重要元素 文段中的A，B本质上是一个意思。如：提升灵活性，降低死板性 观点是CAB结构，选项只有一个选项体现观点，只要不相悖，也可以选 对比的剖析 古今时间对比 用时间标志词去体现这种差异性 常见的标志词：过去...现在...，A时期...，B时期不一样了；现在...将来...等 很长一段时间，中国文学海外传播主要依赖有规模有体系的经典作品译介，这些译介在推动中国文学走出去的过程中发挥了重要作用，但有时也会出现译介书目和目标读者的喜好、接受度之间有差距的情况，从而影响译介和推广的效果。而如今，类型文学海外传播则更注重市场需求，有时候甚至表现出从“译出”到“译入”的变化，即不是先译好了再推送，而是对方主动译入。据称，中国网络小说的许多海外读者因为等不及人工翻译，便通过机器翻译来实时阅读中文更新内容，这种如饥似渴的阅读需求是中国文学走出去的根本动力。以前文学传播的问题，现在解决办法是注重市场需求时间顺承与古今时间对比 文段出现多个时间点时，不","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_44","order":44,"summary":"结构 CAB中选A或B，这个和观点的偏向性有什么关系？具体性呢？你能总结出几种选A或B做合理情况？ 当文段出现并列时，可以利用观点的偏向性和具体性确定重要元素 文段中的A，B本质上是一个意思。如：提升灵活性，降低死板性 观点是CAB结构，选项只有一个选项体现观点，只要不相悖，也可以选 对比的剖析 古今时间对比 用时间标志词去体现这种差异性 常见的标志词：过去...现在...，A时期...，B时期不一样了；现在...将来...等 很长一段时间，中国文学海外传播主要依赖有规模有体系的经典作品译介，这些译介在推动中国文学走出去的过程中发挥了重要作用，但有时也会出现译介书目和目标读者的喜好、接受度之间有差距的情况，从而影响译介和推广的效果。而如今，类型文学海外传播则更注重市场需求，有时候甚至表现出从“译出”到“译入”的变化，即不是先译好了再推送，而是对方主动译入。据称，中国网络小说的许多海外读者因为等不及人工翻译，便通过机器翻译来实时阅读中文更新内容，这种如饥似渴的阅读需求是中国文学走出去的根本动力。以前文学传播的问题，现在解决办法是注重市场需求时间顺承与古今时间对比 文段出现多个时间点时，不","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"可盲目判断其为时间对比 时间顺承特点：A时间点...B时间点...C时间点...，展现一个事物顺着时间发展 时间对比特点：A时间点...B时间点有差异，展现一个事物的前后差异性 在古代，对未知世界的恐惧感不只属于儿童。中世纪的绘图师们在绘制地图时，并不把未知地带留为空白，而是画上海蛇和想象中的怪兽，并标记“记外有龙”。几个世纪以来，探险家们穿越大洋，攀登高山、逐渐在地图上把这些想象替换成了真实的标记，现如今，我们可以从外太空拍摄照片、感叹地球之美。通信网络造就了“地球村”，世界变得越来越小了。这段文字的核心观点是： A.科技让世界更美好 B.知识是治疗恐惧的良药C.读万卷书，行万里路 D.吾生也有涯，而知也无涯古代，绘图师害怕，几个世纪，探索后不害怕，现在，觉得地球美丽，变小了。害怕-\u003e不害怕-\u003e欣赏。主要是不恐惧了选B，A是时间对比可以选。新旧（传统）事物对比 文段常用旧的/传统/通常的事物，引出目前新的事物，仍然是对比引出差异性 传统理论认为，人类祖先由于气候变化、树木减少，被迫离开树栖环境，选择在地面上直立行走。一项最新研究则认为，早期人类直立行走源自现今非洲东部和南部崎岖山脉地","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_45","order":45,"summary":"可盲目判断其为时间对比 时间顺承特点：A时间点...B时间点...C时间点...，展现一个事物顺着时间发展 时间对比特点：A时间点...B时间点有差异，展现一个事物的前后差异性 在古代，对未知世界的恐惧感不只属于儿童。中世纪的绘图师们在绘制地图时，并不把未知地带留为空白，而是画上海蛇和想象中的怪兽，并标记“记外有龙”。几个世纪以来，探险家们穿越大洋，攀登高山、逐渐在地图上把这些想象替换成了真实的标记，现如今，我们可以从外太空拍摄照片、感叹地球之美。通信网络造就了“地球村”，世界变得越来越小了。这段文字的核心观点是： A.科技让世界更美好 B.知识是治疗恐惧的良药C.读万卷书，行万里路 D.吾生也有涯，而知也无涯古代，绘图师害怕，几个世纪，探索后不害怕，现在，觉得地球美丽，变小了。害怕-\u003e不害怕-\u003e欣赏。主要是不恐惧了选B，A是时间对比可以选。新旧（传统）事物对比 文段常用旧的/传统/通常的事物，引出目前新的事物，仍然是对比引出差异性 传统理论认为，人类祖先由于气候变化、树木减少，被迫离开树栖环境，选择在地面上直立行走。一项最新研究则认为，早期人类直立行走源自现今非洲东部和南部崎岖山脉地","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"区，该地形是上新世时期火山喷发和构造板块移动形成的。人类的祖先被岩石地形和峡谷所吸引，这里可提供良好的庇护栖息地，同时有机会诱捕猎物；这种环境要求早期人类具备直立行走和攀岩的能力，因此人类祖先最终逐渐进化为两足直立行走。最新研究认为：人类是被地形吸引而进化为两足。没有重点提到因为地形变化，而是因为地形的优势。差异主体对比 文段常用两个具有差异性的主体进行对比，常见的有外国对比中国；动物对比人类等，主要体现对主体的归属感 原产于美洲西部的鲁冰花，英文名为“Lupin”，在希腊文里是悲苦的意思，通常生长在贫瘠的田野、乡间的小路，生命力强。而在我国台湾高山地区，鲁冰花常跟茶树种在一起，据说可以帮助茶树健康生长，并且可以使茶叶芳香甜美。另外，鲁冰花死后肥沃了土地，让茶树长得更加茂盛。鲁冰花这种坚忍不拔、大公无私、“化作春泥更护花”的精神，正如同世间最真挚的母爱。所以，它可以用来象征母爱，作为母亲节儿女献给母亲最好的礼物。这段文字意在说明： A.鲁冰花成为母爱之花的缘由 B.鲁冰花的原产地及生长特性C.鲁冰花为何常与茶树种在一起 D.鲁冰花在中西文化中的不同含义重点强调我国，对国家的归属感。伽马","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_46","order":46,"summary":"区，该地形是上新世时期火山喷发和构造板块移动形成的。人类的祖先被岩石地形和峡谷所吸引，这里可提供良好的庇护栖息地，同时有机会诱捕猎物；这种环境要求早期人类具备直立行走和攀岩的能力，因此人类祖先最终逐渐进化为两足直立行走。最新研究认为：人类是被地形吸引而进化为两足。没有重点提到因为地形变化，而是因为地形的优势。差异主体对比 文段常用两个具有差异性的主体进行对比，常见的有外国对比中国；动物对比人类等，主要体现对主体的归属感 原产于美洲西部的鲁冰花，英文名为“Lupin”，在希腊文里是悲苦的意思，通常生长在贫瘠的田野、乡间的小路，生命力强。而在我国台湾高山地区，鲁冰花常跟茶树种在一起，据说可以帮助茶树健康生长，并且可以使茶叶芳香甜美。另外，鲁冰花死后肥沃了土地，让茶树长得更加茂盛。鲁冰花这种坚忍不拔、大公无私、“化作春泥更护花”的精神，正如同世间最真挚的母爱。所以，它可以用来象征母爱，作为母亲节儿女献给母亲最好的礼物。这段文字意在说明： A.鲁冰花成为母爱之花的缘由 B.鲁冰花的原产地及生长特性C.鲁冰花为何常与茶树种在一起 D.鲁冰花在中西文化中的不同含义重点强调我国，对国家的归属感。伽马","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"射线是人们认识原子核的“探针”。不同于传统的离线伽马谱学测量，在束伽马谱学测量是在大科学装置的加速器上，利用多探头多角度的伽马探测器组成的高分辨伽马探测阵列开展在束伽马谱学测量，并进行相关核科学的前沿课题研究，是目前世界上各大核物理实验室均采用的重要研究手段。我国在在束伽马谱学研究平台整合与升级方面已迈出关键一步。通过多方合作，共建的新探测阵列探测器单元数量由 15 个提高到50 个，将进一步提升整个实验终端探测能力，预计将会在核结构研究领域取得更丰富更高水平的研究成果，同时该探测阵列也将应用于核反应、核天体、核技术应用等领域。 这段文字主要讲的是（ ）。 A.在束伽马谱学测量的应用领域非常广泛 B.我国开始布局建设新一代伽马探测阵列C.在束伽马谱学测量对于核物理研究意义重大 D.伽马射线在用于原子核研究方面又有新进展重点强调我国的在束伽马谱学研究平台---探测阵列探测更进一步。C核物理片面，还有核应用。D没有我国。三大文段 因果类文段 什么叫因果类文段？文段的目的是给一个事物探寻发生的原因，为因果/果因结构，文段一定要是大篇幅重点谈论原因的才可归为因果文段。 选项优先性 果因阐明-\u003e","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_47","order":47,"summary":"射线是人们认识原子核的“探针”。不同于传统的离线伽马谱学测量，在束伽马谱学测量是在大科学装置的加速器上，利用多探头多角度的伽马探测器组成的高分辨伽马探测阵列开展在束伽马谱学测量，并进行相关核科学的前沿课题研究，是目前世界上各大核物理实验室均采用的重要研究手段。我国在在束伽马谱学研究平台整合与升级方面已迈出关键一步。通过多方合作，共建的新探测阵列探测器单元数量由 15 个提高到50 个，将进一步提升整个实验终端探测能力，预计将会在核结构研究领域取得更丰富更高水平的研究成果，同时该探测阵列也将应用于核反应、核天体、核技术应用等领域。 这段文字主要讲的是（ ）。 A.在束伽马谱学测量的应用领域非常广泛 B.我国开始布局建设新一代伽马探测阵列C.在束伽马谱学测量对于核物理研究意义重大 D.伽马射线在用于原子核研究方面又有新进展重点强调我国的在束伽马谱学研究平台---探测阵列探测更进一步。C核物理片面，还有核应用。D没有我国。三大文段 因果类文段 什么叫因果类文段？文段的目的是给一个事物探寻发生的原因，为因果/果因结构，文段一定要是大篇幅重点谈论原因的才可归为因果文段。 选项优先性 果因阐明-\u003e","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"果的因-\u003e因果并列-\u003e果因单论 最佳答案：果因阐明 即讲因果完全给你说清楚。具体结果+具体原因 变与乱似乎是一对孪生兄弟，凡是剧烈变动的时代，往往也是混乱失序的时代。不过，变与乱的结果往往差别很大：有些社会最终走过动荡的变革时期，逐步确立了新的体制和秩序；有些社会则缺乏变革因素的增量积累机制，无法形成新的体制和秩序，只能通过恢复旧秩序而结束混乱局面。晚明时期，几乎各个领域都出现了新因素、新趋向，在带来生机与活力的同时，也加剧了社会矛盾、贫富分化、政局动荡、道德失范。换句话说，晚明时代虽然出现了一些不可逆的新变化，却未能引发根本性的制度变迁，终于在变与乱的交缠中走向灭亡。这句话意在说明： A.变乱交织、无力变革是明朝覆灭的原因 B.变革往往带来混乱，同时也蕴含生机C.晚明的灭亡具有历史的必然性 D.新旧制度往往是相互交替、互为因果的变与乱的结果差别很大：好/坏-\u003e晚明在变乱交缠中灭亡。D指的是相互，文中只是新到旧，旧到旧，并未提到互相转换。次选答案：果的因 思考一下，为什么果的因次选？因为能进行偏正的展开 套路题，看是否是因果题，看结尾有无顺承：由此、于是、从而、引出，看选项是否有主体的","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_48","order":48,"summary":"果的因-\u003e因果并列-\u003e果因单论 最佳答案：果因阐明 即讲因果完全给你说清楚。具体结果+具体原因 变与乱似乎是一对孪生兄弟，凡是剧烈变动的时代，往往也是混乱失序的时代。不过，变与乱的结果往往差别很大：有些社会最终走过动荡的变革时期，逐步确立了新的体制和秩序；有些社会则缺乏变革因素的增量积累机制，无法形成新的体制和秩序，只能通过恢复旧秩序而结束混乱局面。晚明时期，几乎各个领域都出现了新因素、新趋向，在带来生机与活力的同时，也加剧了社会矛盾、贫富分化、政局动荡、道德失范。换句话说，晚明时代虽然出现了一些不可逆的新变化，却未能引发根本性的制度变迁，终于在变与乱的交缠中走向灭亡。这句话意在说明： A.变乱交织、无力变革是明朝覆灭的原因 B.变革往往带来混乱，同时也蕴含生机C.晚明的灭亡具有历史的必然性 D.新旧制度往往是相互交替、互为因果的变与乱的结果差别很大：好/坏-\u003e晚明在变乱交缠中灭亡。D指的是相互，文中只是新到旧，旧到旧，并未提到互相转换。次选答案：果的因 思考一下，为什么果的因次选？因为能进行偏正的展开 套路题，看是否是因果题，看结尾有无顺承：由此、于是、从而、引出，看选项是否有主体的","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"原因。 过去的营销是漏斗效应，传统媒体上的广告让受众从很宽的漏斗口进入，买单的到了漏斗的底端。网红的营销则是涟漪效应，每个波纹和波纹之间会有碰撞，影响面更宽，影响的深度更深。网红通过树立个人品牌、贯彻自我的生活方式吸引粉丝，粉丝可能对传统广告是排斥的，但是乐于模仿偶像而消费。在社交平台上，粉丝之间的沟通渠道打通了，他们甚至不仅仅购物，而且乐于把自己的喜好传播给别人，每一次点赞、评论、转发，涟漪就扩散一次。网红营销的涟漪效应让其影响广泛。与套路不太一样。因果并列 当没有以上两个选项的时候，可以退而求其次，选择出现结果A+原因B的选项，选项不一定是在探讨两者的因果关系 距今 200 万~100 万年前，在类人猿向现代智人进化期间，人类祖先的大脑就进化出了支持合作的功能，以支持狩猎活动。这使人类祖先前额皮层里的记忆与思考中心变得比其他灵长类动物的更发达。随着群体变得比个体更强大，大脑不断进化出管理更大群体的能力，群体之间的竞争就变得比个体之间的竞争更重要，同时拥有更多合作性个体的群体发展得更好，这一进化使得利他意识、伦理观、良知和尊严意识发展起来。进化出支持合作让中心更发达；进化出管理能力并","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_49","order":49,"summary":"原因。 过去的营销是漏斗效应，传统媒体上的广告让受众从很宽的漏斗口进入，买单的到了漏斗的底端。网红的营销则是涟漪效应，每个波纹和波纹之间会有碰撞，影响面更宽，影响的深度更深。网红通过树立个人品牌、贯彻自我的生活方式吸引粉丝，粉丝可能对传统广告是排斥的，但是乐于模仿偶像而消费。在社交平台上，粉丝之间的沟通渠道打通了，他们甚至不仅仅购物，而且乐于把自己的喜好传播给别人，每一次点赞、评论、转发，涟漪就扩散一次。网红营销的涟漪效应让其影响广泛。与套路不太一样。因果并列 当没有以上两个选项的时候，可以退而求其次，选择出现结果A+原因B的选项，选项不一定是在探讨两者的因果关系 距今 200 万~100 万年前，在类人猿向现代智人进化期间，人类祖先的大脑就进化出了支持合作的功能，以支持狩猎活动。这使人类祖先前额皮层里的记忆与思考中心变得比其他灵长类动物的更发达。随着群体变得比个体更强大，大脑不断进化出管理更大群体的能力，群体之间的竞争就变得比个体之间的竞争更重要，同时拥有更多合作性个体的群体发展得更好，这一进化使得利他意识、伦理观、良知和尊严意识发展起来。进化出支持合作让中心更发达；进化出管理能力并","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"让其他好东西发展起来。曾经，考古似乎和现代社会相隔甚远，对普通人来说有些遥不可及。近年来，随着考古发现的深入、考古手段的进步、考古知识的普及，考古不再是生僻冷门的领域，而是与每个人产生了越来越多的联系。考古和社会有什么关系？和我们有什么联系？再次审视这些问题，我们的心中有了更丰富的答案一文明的人类总是热衷于考古，就是想把压缩在泥土里的历史挖掘出来、舒展开来进行窥探，因为一个个考古新发现，能为国家和民族历史提供例证，为社会发展提供文化源泉，成为爱国主义教育载体，成为经济建设的亮丽品牌，不断增强国家和民族的文化自信。考公新发现的重要性或者因为考古发现所以xxx。主语是考古发现。考古发现，增强我们的文化自信：选项是发现的意义，因果并列型。果因单论 当没有以上的情况时，单独把结果或者原因拿出来，也有可能是正确答案。还是对比择优和以人为本的思维 选结果和原因看，哪个更重要是看原因是否导致好的结果，夸原因选原因，如果结果和原因都是客观的来说选结果。看哪个更重要。 月球是距离地球最近的天体，但是如何从地球飞到月球并不是一个简单的问题，虽然早在 30 多年前阿波罗航天员就已经登上月球，但是今天人类重返","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_50","order":50,"summary":"让其他好东西发展起来。曾经，考古似乎和现代社会相隔甚远，对普通人来说有些遥不可及。近年来，随着考古发现的深入、考古手段的进步、考古知识的普及，考古不再是生僻冷门的领域，而是与每个人产生了越来越多的联系。考古和社会有什么关系？和我们有什么联系？再次审视这些问题，我们的心中有了更丰富的答案一文明的人类总是热衷于考古，就是想把压缩在泥土里的历史挖掘出来、舒展开来进行窥探，因为一个个考古新发现，能为国家和民族历史提供例证，为社会发展提供文化源泉，成为爱国主义教育载体，成为经济建设的亮丽品牌，不断增强国家和民族的文化自信。考公新发现的重要性或者因为考古发现所以xxx。主语是考古发现。考古发现，增强我们的文化自信：选项是发现的意义，因果并列型。果因单论 当没有以上的情况时，单独把结果或者原因拿出来，也有可能是正确答案。还是对比择优和以人为本的思维 选结果和原因看，哪个更重要是看原因是否导致好的结果，夸原因选原因，如果结果和原因都是客观的来说选结果。看哪个更重要。 月球是距离地球最近的天体，但是如何从地球飞到月球并不是一个简单的问题，虽然早在 30 多年前阿波罗航天员就已经登上月球，但是今天人类重返","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"月球不能简单地重复阿波罗登月的方式。因为今天人类重返月球比当年阿波罗登月要复杂和困难，不仅飞往月球的人数比阿波罗飞行要多得多，而且人们到达月球后不是简单地进行探险和考察，而是要在月球上建造基地，要对月球进行全面的开发和利用，还要在月球上长期的工作和生活。这段文字旨在说明（ ）。 A.人类重返月球所肩负的使命更艰巨 B.人类重返月球所面临的环境更加复杂C.人类登月的目的是开辟新的生存空间 D.人类对月球的开发和利用尚待时日因为困难，重返月球不能简单的重复，主语是重返月球。A的使命可以数量展开。中微子是宇宙中除了光子之外数量最为众多的基本粒子，但是人类对于中微子的研究开始得却较晚，原因就在于这种粒子可以自由来去，极少与其他物质发生相互作用，因而极难探测。此前，人类根本没有觉察到这种基本粒子的存在。尽管每秒都有数以万亿计的中微子以近乎光速的速度穿过人类的身体，人类却对这些无所知觉。从概率上来说，一个中微子可以穿越一光年的铅而不发生一次碰撞。这段文字意在强调：A.中微子是宇宙中数量众多的基本粒子 B.人类对于中微子的研究开始得比较晚C.中微子的运行速度快得超乎想象 D.中微子的存在很难被感知或","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_51","order":51,"summary":"月球不能简单地重复阿波罗登月的方式。因为今天人类重返月球比当年阿波罗登月要复杂和困难，不仅飞往月球的人数比阿波罗飞行要多得多，而且人们到达月球后不是简单地进行探险和考察，而是要在月球上建造基地，要对月球进行全面的开发和利用，还要在月球上长期的工作和生活。这段文字旨在说明（ ）。 A.人类重返月球所肩负的使命更艰巨 B.人类重返月球所面临的环境更加复杂C.人类登月的目的是开辟新的生存空间 D.人类对月球的开发和利用尚待时日因为困难，重返月球不能简单的重复，主语是重返月球。A的使命可以数量展开。中微子是宇宙中除了光子之外数量最为众多的基本粒子，但是人类对于中微子的研究开始得却较晚，原因就在于这种粒子可以自由来去，极少与其他物质发生相互作用，因而极难探测。此前，人类根本没有觉察到这种基本粒子的存在。尽管每秒都有数以万亿计的中微子以近乎光速的速度穿过人类的身体，人类却对这些无所知觉。从概率上来说，一个中微子可以穿越一光年的铅而不发生一次碰撞。这段文字意在强调：A.中微子是宇宙中数量众多的基本粒子 B.人类对于中微子的研究开始得比较晚C.中微子的运行速度快得超乎想象 D.中微子的存在很难被感知或","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"探测观点：中微子自由来去，极难探测，导致研究较晚，文段讲的比较客观，没有强调因，所以选果。从另一个角度看：研究开始较晚，此前，人类根本没有察觉，说明现在察觉到了，D却说很难感知。实用技巧 抓准原因结果，对比择优 做题的时候，一定要清楚文段给的原因和结果是什么，往往出题人会在这里给你设置错误选项 近年来，随着艺术类院校、专业招生规模的扩大，艺考日渐火爆。除了部分真心热爱艺术的考生，有相当一部分是因为自身文化课分数不高，转而在高中最后一个阶段突击艺术，以求借助艺考进入对文化课要求不高的本科院校。 上述文字意在说明： A.艺术类院校录取分数线不高 B.艺考考生良莠不齐C.不是所有艺考考生都热爱艺术D.艺术类院校专业招生规模扩大的原因A是文化课分数不高。借助选项 如果不能一眼看出来是原因类文段，可以借助选项，当选项在给你讨论原因时，可以逆向思考一下其是否为原因类文段 特殊题型 多因并列 文段的特征是存在多个原因的并列 在美国，学术界、工商界、主管部门和多数消费者倾向于认为用豆浆代替牛奶是一种更健康的选择。不过，绝大多数西方人很不喜欢豆味，所以美国的豆浆有进一步去除或掩盖豆味的操作，而中国人就会","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_52","order":52,"summary":"探测观点：中微子自由来去，极难探测，导致研究较晚，文段讲的比较客观，没有强调因，所以选果。从另一个角度看：研究开始较晚，此前，人类根本没有察觉，说明现在察觉到了，D却说很难感知。实用技巧 抓准原因结果，对比择优 做题的时候，一定要清楚文段给的原因和结果是什么，往往出题人会在这里给你设置错误选项 近年来，随着艺术类院校、专业招生规模的扩大，艺考日渐火爆。除了部分真心热爱艺术的考生，有相当一部分是因为自身文化课分数不高，转而在高中最后一个阶段突击艺术，以求借助艺考进入对文化课要求不高的本科院校。 上述文字意在说明： A.艺术类院校录取分数线不高 B.艺考考生良莠不齐C.不是所有艺考考生都热爱艺术D.艺术类院校专业招生规模扩大的原因A是文化课分数不高。借助选项 如果不能一眼看出来是原因类文段，可以借助选项，当选项在给你讨论原因时，可以逆向思考一下其是否为原因类文段 特殊题型 多因并列 文段的特征是存在多个原因的并列 在美国，学术界、工商界、主管部门和多数消费者倾向于认为用豆浆代替牛奶是一种更健康的选择。不过，绝大多数西方人很不喜欢豆味，所以美国的豆浆有进一步去除或掩盖豆味的操作，而中国人就会","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"觉得这样一点儿豆浆味也没有。对奶味的偏好和对豆味的排斥，是豆浆在西方不够受欢迎的主要原因。此外，豆浆在保存过程中比牛奶容易发生聚集下沉，这也给豆浆成为牛奶那样的方便食品带来了难度。保存难度高，加上市场需求量不是那么大，导致美国豆浆的价格远远高于牛奶。 对这段文字的主旨概括最准确的是（ ）。 A.豆浆相比牛奶而言是一种更健康的选择 B.指出豆浆打入美国市场所必需的技术手段C.剖析豆浆在美国市场上价格偏高的原因 D.分析豆浆在西方不受欢迎的原因做两遍错两边。。。观点：保存难度高、市场需求小导致价格高。不受欢迎只是市场需求小的因。对于生活在浅海的硬骨鱼类来说，鱼鳔非常重要，可以帮助其调整浮力，实现上浮或下潜。但是对于深海鱼来说，充满气的鱼鳔像是脆弱的气球，在外部巨大水压的挤压下，会炸成碎片。因此，很多深海鱼在进化过程中“舍弃”了鱼鳔这个“危险”的部件，转而依靠某些脂类提供浮力。相比于浅海中的鱼，深海鱼的骨骼和肌肉含量都比较少，脂质和胶质相对较多。此外，深海鱼骨骼中软骨的比例也远高于浅海鱼。对于深海鱼来说，这些都是为了适应深海生活所作出的必要的“妥协”。毕竟相比于骨骼和肌肉，脂质和胶质能更好地","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_53","order":53,"summary":"觉得这样一点儿豆浆味也没有。对奶味的偏好和对豆味的排斥，是豆浆在西方不够受欢迎的主要原因。此外，豆浆在保存过程中比牛奶容易发生聚集下沉，这也给豆浆成为牛奶那样的方便食品带来了难度。保存难度高，加上市场需求量不是那么大，导致美国豆浆的价格远远高于牛奶。 对这段文字的主旨概括最准确的是（ ）。 A.豆浆相比牛奶而言是一种更健康的选择 B.指出豆浆打入美国市场所必需的技术手段C.剖析豆浆在美国市场上价格偏高的原因 D.分析豆浆在西方不受欢迎的原因做两遍错两边。。。观点：保存难度高、市场需求小导致价格高。不受欢迎只是市场需求小的因。对于生活在浅海的硬骨鱼类来说，鱼鳔非常重要，可以帮助其调整浮力，实现上浮或下潜。但是对于深海鱼来说，充满气的鱼鳔像是脆弱的气球，在外部巨大水压的挤压下，会炸成碎片。因此，很多深海鱼在进化过程中“舍弃”了鱼鳔这个“危险”的部件，转而依靠某些脂类提供浮力。相比于浅海中的鱼，深海鱼的骨骼和肌肉含量都比较少，脂质和胶质相对较多。此外，深海鱼骨骼中软骨的比例也远高于浅海鱼。对于深海鱼来说，这些都是为了适应深海生活所作出的必要的“妥协”。毕竟相比于骨骼和肌肉，脂质和胶质能更好地","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"帮助鱼类对抗巨大的压力。最适合做这段文字标题的是： A.深海鱼竟是“软骨头” B.抗压，从鱼鳔的“断舍离”开始C.精通以柔克刚的深海鱼 D.深海压力，无法承受之痛原文，C过度延伸了，要切合原文！！！除非没得选小篇幅原因 文段不是看到原因，就是原因类文段的，很多时候原因只是提一下，不重要 唐代以前，我国产茶地区和饮茶风俗主要是在南方。到了唐玄宗开元年间，北方饮茶风俗随着佛教禅宗的兴起而盛行起来，北方盛行饮茶的风气极大促进了南方茶叶生产和南北茶叶贸易的迅速发展。当时，茶叶产量与全国人口平均消费水平都是相当高的。唐代茶叶经济的繁荣，是陆羽能够写出《茶经》的社会基础。据《茶经》不完全统计，当时已有8个道（或可称为茶产区）43 个郡、44 个县生产茶叶。 以上材料的中心主旨是：（ ）。 A.茶文化兴起于我国的南方 B.茶文化的兴盛与禅宗有关 C.《茶经》出现的时代环境 D.唐代茶叶经济高度繁荣观点：唐代经济繁荣的是茶经的社会基础，强调前面的重要性，并且后面只是例子，不是强调茶经。纯问题类文段 选项与文段的双循环 当选项是问题时，文段是问题 当选项是正面对策时，文段是问题或者对策 当选项是反面对策","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_54","order":54,"summary":"帮助鱼类对抗巨大的压力。最适合做这段文字标题的是： A.深海鱼竟是“软骨头” B.抗压，从鱼鳔的“断舍离”开始C.精通以柔克刚的深海鱼 D.深海压力，无法承受之痛原文，C过度延伸了，要切合原文！！！除非没得选小篇幅原因 文段不是看到原因，就是原因类文段的，很多时候原因只是提一下，不重要 唐代以前，我国产茶地区和饮茶风俗主要是在南方。到了唐玄宗开元年间，北方饮茶风俗随着佛教禅宗的兴起而盛行起来，北方盛行饮茶的风气极大促进了南方茶叶生产和南北茶叶贸易的迅速发展。当时，茶叶产量与全国人口平均消费水平都是相当高的。唐代茶叶经济的繁荣，是陆羽能够写出《茶经》的社会基础。据《茶经》不完全统计，当时已有8个道（或可称为茶产区）43 个郡、44 个县生产茶叶。 以上材料的中心主旨是：（ ）。 A.茶文化兴起于我国的南方 B.茶文化的兴盛与禅宗有关 C.《茶经》出现的时代环境 D.唐代茶叶经济高度繁荣观点：唐代经济繁荣的是茶经的社会基础，强调前面的重要性，并且后面只是例子，不是强调茶经。纯问题类文段 选项与文段的双循环 当选项是问题时，文段是问题 当选项是正面对策时，文段是问题或者对策 当选项是反面对策","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"时，文段是这个对策+问题危害 当文段只是问题时，选项是问题或对策； 当文段是对策时，选项是对策（及其转换） 可以进行反窥观点 总括问题 当文段是纯问题文段时，出题人可能就是想考你的概括能力，即让你用精简的话语总括文段中心内容 要在一个本就是俗的东西上融入雅的东西，喜剧演员都深谙其道，但有的只是简单地披上了雅的外衣，有的却在孜孜以求地追求雅的内核。无论如何，大家的目的都是一致的，那就是喜剧的本质——笑。离开了这一点，喜剧也就不成为喜剧。可悲的是，有些喜剧人陷入雅俗之间，找不准自己创作的方向，既想满足俗，又想迎合雅，结果反而丢掉了喜剧的特质。这段文字主要批评了喜剧创作中的哪种倾向？（ ）A.一味迎合观众而流于庸俗 B.过分追求雅的形式而忽视了内容C.偏离了给人带来欢乐的宗旨 D.无法准确把握观众的需求观点：（喜剧人）陷入雅俗之间，丢掉喜剧特质。题目问到批评，可知问题类文段。文中强调果：喜剧特质（离开笑，喜剧不是喜剧；都是为了笑）。选C当下的家庭教育中，“教育超量”与教育不足同时存在。有些家长唯恐自己的孩子“输在起跑线上”，为孩子报了多个辅导班、兴趣班，给孩子造成很重的负担。也有家长认为孩子","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_55","order":55,"summary":"时，文段是这个对策+问题危害 当文段只是问题时，选项是问题或对策； 当文段是对策时，选项是对策（及其转换） 可以进行反窥观点 总括问题 当文段是纯问题文段时，出题人可能就是想考你的概括能力，即让你用精简的话语总括文段中心内容 要在一个本就是俗的东西上融入雅的东西，喜剧演员都深谙其道，但有的只是简单地披上了雅的外衣，有的却在孜孜以求地追求雅的内核。无论如何，大家的目的都是一致的，那就是喜剧的本质——笑。离开了这一点，喜剧也就不成为喜剧。可悲的是，有些喜剧人陷入雅俗之间，找不准自己创作的方向，既想满足俗，又想迎合雅，结果反而丢掉了喜剧的特质。这段文字主要批评了喜剧创作中的哪种倾向？（ ）A.一味迎合观众而流于庸俗 B.过分追求雅的形式而忽视了内容C.偏离了给人带来欢乐的宗旨 D.无法准确把握观众的需求观点：（喜剧人）陷入雅俗之间，丢掉喜剧特质。题目问到批评，可知问题类文段。文中强调果：喜剧特质（离开笑，喜剧不是喜剧；都是为了笑）。选C当下的家庭教育中，“教育超量”与教育不足同时存在。有些家长唯恐自己的孩子“输在起跑线上”，为孩子报了多个辅导班、兴趣班，给孩子造成很重的负担。也有家长认为孩子","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"还小，不必学什么，让孩子自由成长就行。这种自然教育的观念，与西方教育思想的影响有关。卢梭在《爱弥儿》中就讲，“要放任无为，才能一切有为”“你开头什么都不教，结果反而会创造一切教育奇迹”，卢梭的这些说法有一定的启发性，但其片面性也是显而易见的。事实上，卢梭本人也不是“按照”他的教育观念成长的。 这段文字意在说明（ ）。A.家庭教育不应偏信、执着于某一具体理论B.如何把握家庭教育的尺度始终是一道难题C.片面强调教育“超量”“减量”都不可取 D.“教育超量”与教育不足都有其生存的土壤观点：（家庭教育中），超量和不足同时存在。文段整体都是问题，选问题或对策。B虽然谈到问题，都不够具体，并且有对策优先对策。C包括观点提到的超量和不足。宏观限定只是锦上添花，不能直接排除。合理，精简解决问题 言语的提出对策和申论不同，不需要你动用积累、经验进行对策的细化，因为细化以后反而不满足以人为本的思想 调查发现，“花呗”“借呗”“京东白条”等便捷的小额借贷平台，迎合甚至刺激了部分大学生“先消费，再分期还贷”的理念，一些大学生通过负债借贷维持超前消费。与此相应，炫富、挥霍等消费行为在大学生中时有发生，“名媛”“","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_56","order":56,"summary":"还小，不必学什么，让孩子自由成长就行。这种自然教育的观念，与西方教育思想的影响有关。卢梭在《爱弥儿》中就讲，“要放任无为，才能一切有为”“你开头什么都不教，结果反而会创造一切教育奇迹”，卢梭的这些说法有一定的启发性，但其片面性也是显而易见的。事实上，卢梭本人也不是“按照”他的教育观念成长的。 这段文字意在说明（ ）。A.家庭教育不应偏信、执着于某一具体理论B.如何把握家庭教育的尺度始终是一道难题C.片面强调教育“超量”“减量”都不可取 D.“教育超量”与教育不足都有其生存的土壤观点：（家庭教育中），超量和不足同时存在。文段整体都是问题，选问题或对策。B虽然谈到问题，都不够具体，并且有对策优先对策。C包括观点提到的超量和不足。宏观限定只是锦上添花，不能直接排除。合理，精简解决问题 言语的提出对策和申论不同，不需要你动用积累、经验进行对策的细化，因为细化以后反而不满足以人为本的思想 调查发现，“花呗”“借呗”“京东白条”等便捷的小额借贷平台，迎合甚至刺激了部分大学生“先消费，再分期还贷”的理念，一些大学生通过负债借贷维持超前消费。与此相应，炫富、挥霍等消费行为在大学生中时有发生，“名媛”“","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"土豪”等词语风行网络，成为个别大学生羡慕不劳而获生活的“幻想目标”。D.新模式下的超前消费D应该对超前消费进行介绍，而文段都是问题。双十一即将来临，很多商家推出“保价”承诺来吸引消费者，然而，保价真的靠谱吗？江苏省消保委表示，结合往年经验，商品有保价承诺也不保险。有消费者发现自己购买的商品降价了，向商家寻求补偿时被拒。客服的理由通常是，店铺和平台优惠券、限时活动以及赠品等均不在保价范围内。也有商家为了规避保价规则，下架原商品，重新上新的购买链接或者只是更改商品名称。下列表述契合文段中心的是（ ）。 A.监管部门应加大对于商家的监控力度 B.莫让消费者掉入“双十一”保价陷阱C.商家推出的保价承诺充满风险和套路 D.消费者根本享受不到商家的保价服务观点：（双十一期间）报价承诺不保险。BC都是问题，但是B有宏观限定。观点类文段 文段提出了作者的观点，需要熟练掌握观点提出的六大方式 以观解问即观点是为了解决问题，往往其行文脉络是引出问题+解决问题 当前我国正处于人口结构高速转变的时期，农村人力资源开发将需要同时面临“农村劳动力转移的难度加大”与“农村劳动力存量的整体素质趋于降低”两大问题。从农","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_57","order":57,"summary":"土豪”等词语风行网络，成为个别大学生羡慕不劳而获生活的“幻想目标”。D.新模式下的超前消费D应该对超前消费进行介绍，而文段都是问题。双十一即将来临，很多商家推出“保价”承诺来吸引消费者，然而，保价真的靠谱吗？江苏省消保委表示，结合往年经验，商品有保价承诺也不保险。有消费者发现自己购买的商品降价了，向商家寻求补偿时被拒。客服的理由通常是，店铺和平台优惠券、限时活动以及赠品等均不在保价范围内。也有商家为了规避保价规则，下架原商品，重新上新的购买链接或者只是更改商品名称。下列表述契合文段中心的是（ ）。 A.监管部门应加大对于商家的监控力度 B.莫让消费者掉入“双十一”保价陷阱C.商家推出的保价承诺充满风险和套路 D.消费者根本享受不到商家的保价服务观点：（双十一期间）报价承诺不保险。BC都是问题，但是B有宏观限定。观点类文段 文段提出了作者的观点，需要熟练掌握观点提出的六大方式 以观解问即观点是为了解决问题，往往其行文脉络是引出问题+解决问题 当前我国正处于人口结构高速转变的时期，农村人力资源开发将需要同时面临“农村劳动力转移的难度加大”与“农村劳动力存量的整体素质趋于降低”两大问题。从农","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"业农村发展的要求出发，今后一个时期，开发农村人力资源，优化农村人力资本结构必须着眼于提升农村人力资源的自我发展能力和辐射带动能力，通过“以点带面”加快促进农村劳动者整体素质的提高，从而有效缓解当前人力资源日益短缺的问题，促进农业农村平稳发展。这段文字作者主要强调的是： A.当前我国农村人力资源开发的问题 B.农村劳动者整体素质提升的策略C.当前农村人力资源日益短缺的问题 D.农村劳动力资源短缺的解决办法观点：优化农村人力资本结构必须。。。平稳发展。有对策就不要选问题了，排除AC。文中强调人力资源，选D近年来我国中小学音乐课程在许多地区还是没有受到足够的重视，教材内容不能与时俱进，一些音乐教师只注重技能培养而忽略了音乐教育的主旨首先应当是“树德立志”。在教授学生一部音乐作品之前，教师首先应该理解其中所表现的道德思想，然后以多样化的形式对学生的身心进行正面教育。作为音乐教师当以此为己任，使孩子们真正热爱音乐，在他们的心灵中种下一颗真、善、美的健康种子。 这段文字意在强调：A.音乐教育应注重作品的道德教化B.教师应以培养孩子真善美为己任C.音乐教育以强调树德立志为主旨 D.音乐教育的内容、主","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_58","order":58,"summary":"业农村发展的要求出发，今后一个时期，开发农村人力资源，优化农村人力资本结构必须着眼于提升农村人力资源的自我发展能力和辐射带动能力，通过“以点带面”加快促进农村劳动者整体素质的提高，从而有效缓解当前人力资源日益短缺的问题，促进农业农村平稳发展。这段文字作者主要强调的是： A.当前我国农村人力资源开发的问题 B.农村劳动者整体素质提升的策略C.当前农村人力资源日益短缺的问题 D.农村劳动力资源短缺的解决办法观点：优化农村人力资本结构必须。。。平稳发展。有对策就不要选问题了，排除AC。文中强调人力资源，选D近年来我国中小学音乐课程在许多地区还是没有受到足够的重视，教材内容不能与时俱进，一些音乐教师只注重技能培养而忽略了音乐教育的主旨首先应当是“树德立志”。在教授学生一部音乐作品之前，教师首先应该理解其中所表现的道德思想，然后以多样化的形式对学生的身心进行正面教育。作为音乐教师当以此为己任，使孩子们真正热爱音乐，在他们的心灵中种下一颗真、善、美的健康种子。 这段文字意在强调：A.音乐教育应注重作品的道德教化B.教师应以培养孩子真善美为己任C.音乐教育以强调树德立志为主旨 D.音乐教育的内容、主","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"旨都需转变观点：（教师）应以理解德，多样化教育为己任，让孩子热爱音乐。C不是对策。表达观点文段并不给你引出问题 只是单纯表达作者的态度观点 问题应该是合理精简，或者解决问题的对策。二者不可能都在选项中，需要进行排除。 美国坦普尔大学研究人员以 2500 多名志愿者为对象，利用计算机对影响未来财富的决定性因素进行排名。这些因素包括：年龄、职业、教育、种族、性别、身高地理位置以及延迟“即刻满足”的能力(自控力)等。结果显示，职业和教育是预测高收入的最重要因素，其次是所处地理位置和性别，紧跟其后的就是人的自控能力，它对收入的预测性明显超过年龄、种族和身高等因素。研究人员认为，重视儿童自控力的培养有助挖掘孩子未来的赚钱潜力。最适合做这段文字标题的是： A.性格决定命运B.自控力强的人更富有C.财富从孩子抓起 D.神奇的财富猎手观点：重视（儿童）自控力有助于赚钱。强调自控力，成人也可以自控力培养。对策的合理性（难题）出现问题文段时， 可以去反推对策，但是对策一定要具有合理性，不能盲目推对策，此类题往往是难题 常见的错误对策：对策不具有针对性、对策本身有误、站位错误（选项站的位子不对）等 题目： ","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_59","order":59,"summary":"旨都需转变观点：（教师）应以理解德，多样化教育为己任，让孩子热爱音乐。C不是对策。表达观点文段并不给你引出问题 只是单纯表达作者的态度观点 问题应该是合理精简，或者解决问题的对策。二者不可能都在选项中，需要进行排除。 美国坦普尔大学研究人员以 2500 多名志愿者为对象，利用计算机对影响未来财富的决定性因素进行排名。这些因素包括：年龄、职业、教育、种族、性别、身高地理位置以及延迟“即刻满足”的能力(自控力)等。结果显示，职业和教育是预测高收入的最重要因素，其次是所处地理位置和性别，紧跟其后的就是人的自控能力，它对收入的预测性明显超过年龄、种族和身高等因素。研究人员认为，重视儿童自控力的培养有助挖掘孩子未来的赚钱潜力。最适合做这段文字标题的是： A.性格决定命运B.自控力强的人更富有C.财富从孩子抓起 D.神奇的财富猎手观点：重视（儿童）自控力有助于赚钱。强调自控力，成人也可以自控力培养。对策的合理性（难题）出现问题文段时， 可以去反推对策，但是对策一定要具有合理性，不能盲目推对策，此类题往往是难题 常见的错误对策：对策不具有针对性、对策本身有误、站位错误（选项站的位子不对）等 题目： ","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"成绩要求相对较低，导致部分考生视艺考为进入高等学府的“绿色通道”或迅速成名的捷径，于是扎堆报考、突击报考等现象也就随之出现。另外，由于高中教学与艺考不能有效衔接，一个巨大的艺考培训市场应运而生，但市场内部存在行业垄断、恶性竞争、干扰院校招考正常秩序等乱象，破坏了艺术类专业招生和培养的健康生态。对此，教育部门应针对时弊，对艺术类专业招生加强规范，严格入校管理，进一步完善优化招录程序。这段文字意在说明（ ）。A.“艺考”不等于“易考” B.艺术类专业招生亟待规范C.艺术人才更需提升文化素养D.教育部门应多举措促进艺考公平观点：教育部门对艺术类专业招生xxx。D艺考公平不对，看仔细！长期以来，考试大纲规定了考试的内容、范围、知识点，规定了各学科知识点的考试权重，规定了各个知识点的考试题型，其“标准”明确、具体、直观，对教师教学的导向极其强烈。一方面，它缩小了国家课程标准关于各学科教学内容的范围；另一方面，它规定了各学科知识点在考试中的权重，教师的学科教学活动“做题化”“训练化”倾向越发严重。在考试大纲的这种强大的导向下，教学过程几乎“窄化”“异化”成了考试训练过程，让教育教学活动陷入应试教育","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_60","order":60,"summary":"成绩要求相对较低，导致部分考生视艺考为进入高等学府的“绿色通道”或迅速成名的捷径，于是扎堆报考、突击报考等现象也就随之出现。另外，由于高中教学与艺考不能有效衔接，一个巨大的艺考培训市场应运而生，但市场内部存在行业垄断、恶性竞争、干扰院校招考正常秩序等乱象，破坏了艺术类专业招生和培养的健康生态。对此，教育部门应针对时弊，对艺术类专业招生加强规范，严格入校管理，进一步完善优化招录程序。这段文字意在说明（ ）。A.“艺考”不等于“易考” B.艺术类专业招生亟待规范C.艺术人才更需提升文化素养D.教育部门应多举措促进艺考公平观点：教育部门对艺术类专业招生xxx。D艺考公平不对，看仔细！长期以来，考试大纲规定了考试的内容、范围、知识点，规定了各学科知识点的考试权重，规定了各个知识点的考试题型，其“标准”明确、具体、直观，对教师教学的导向极其强烈。一方面，它缩小了国家课程标准关于各学科教学内容的范围；另一方面，它规定了各学科知识点在考试中的权重，教师的学科教学活动“做题化”“训练化”倾向越发严重。在考试大纲的这种强大的导向下，教学过程几乎“窄化”“异化”成了考试训练过程，让教育教学活动陷入应试教育","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"的“泥潭”无力自拔。 这段文字意在说明： A.考试大纲的强导向作用亟待弱化 B.考试大纲的存在不符合时代要求C.考试大纲的出现强化了应试教育 D.考试大纲偏离了素质教育的要求观点：考试大纲强大的导向下，教学过程。。。无力自拔。A考试大纲就是用来导向的，站位不对。对策不行，就选问题咯。为了消灭农田里的害虫，人类发明了三万种以上的农药，虽暂时控制了虫害，但同时消灭了昆虫的天敌，消灭了蜜蜂，导致一些蔬菜瓜果不能传粉，杂草会与庄稼争营养、水分和空间，于是有人发明了除草剂，除草剂虽然暂时控制了杂草，但也促进了杂草进化，使之变得更难对付，更糟糕的是，除草剂同时也消灭了土壤中的有益微生物，一些原本具有固氮能力的固氮菌，乃至将多余氮素还原为大气中氮气的反硝化细菌也遭到了伤害，没有杂草呵护，农田变成光板地，雨季非常容易造成水土流失。 这段文字重在说明： A.农业的发展不能过度依赖现代科技B.研制精准杀灭虫害农药的紧迫性C.既有农业生态系统被扰乱后的危害 D.现代农业技术有利有弊观点：消灭害虫的一系列后果。A没提到现代科技，农药也有可能是以前的。B三万种农药仍不行，难以研制，摆烂，并且紧迫性没体现。D没提","date":"2023-11-19T22:34:44+08:00","objectID":"9ff92341478399cb6f874b443bee0d76_61","order":61,"summary":"的“泥潭”无力自拔。 这段文字意在说明： A.考试大纲的强导向作用亟待弱化 B.考试大纲的存在不符合时代要求C.考试大纲的出现强化了应试教育 D.考试大纲偏离了素质教育的要求观点：考试大纲强大的导向下，教学过程。。。无力自拔。A考试大纲就是用来导向的，站位不对。对策不行，就选问题咯。为了消灭农田里的害虫，人类发明了三万种以上的农药，虽暂时控制了虫害，但同时消灭了昆虫的天敌，消灭了蜜蜂，导致一些蔬菜瓜果不能传粉，杂草会与庄稼争营养、水分和空间，于是有人发明了除草剂，除草剂虽然暂时控制了杂草，但也促进了杂草进化，使之变得更难对付，更糟糕的是，除草剂同时也消灭了土壤中的有益微生物，一些原本具有固氮能力的固氮菌，乃至将多余氮素还原为大气中氮气的反硝化细菌也遭到了伤害，没有杂草呵护，农田变成光板地，雨季非常容易造成水土流失。 这段文字重在说明： A.农业的发展不能过度依赖现代科技B.研制精准杀灭虫害农药的紧迫性C.既有农业生态系统被扰乱后的危害 D.现代农业技术有利有弊观点：消灭害虫的一系列后果。A没提到现代科技，农药也有可能是以前的。B三万种农药仍不行，难以研制，摆烂，并且紧迫性没体现。D没提","tags":["CivilServant"],"title":"公务员行测--言语理解上","url":"http://localhost:1313/posts/learn/speech-understanding/"},{"categories":["learn"],"content":"注意：手机端视频跳转不会直接跳转到讲解部分，需要电脑端！！已更新较为详细的解释。统计术语 基期量与现期量 作为对比参照的时期称为基期，相对于基期的称为现期 增长量 基期量与现期量增长（降低/减少的）绝对量 增长量 = 现期量-基期量 增长率 增长率=$\\frac{increment}{period_{base}} = \\frac{period_{base}-period_{now}}{period_{base}}$ $increment$：增长量 $period_{base}$：现期量 $period_{now}$：基期量 减少率 = -增长率 年均增长量 年均增长量=$\\frac{period_{newest}-period_{oldest}}{newest-oldest}$ $period_{newest}$：最近的年份 $period_{oldest}$：最久的年份 年均增长率 现期量=$period_{base}\\times(1+年均增长率)^n$，其中n为相差年份 同比环比 同比：与历史同期比较，实际上是指与历年的同一时期相比较。 环比：与上个统计周期比较，实际上是指“与紧紧","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_0","order":0,"summary":"注意：手机端视频跳转不会直接跳转到讲解部分，需要电脑端！！已更新较为详细的解释。统计术语 基期量与现期量 作为对比参照的时期称为基期，相对于基期的称为现期 增长量 基期量与现期量增长（降低/减少的）绝对量 增长量 = 现期量-基期量 增长率 增长率=$\\frac{increment}{period_{base}} = \\frac{period_{base}-period_{now}}{period_{base}}$ $increment$：增长量 $period_{base}$：现期量 $period_{now}$：基期量 减少率 = -增长率 年均增长量 年均增长量=$\\frac{period_{newest}-period_{oldest}}{newest-oldest}$ $period_{newest}$：最近的年份 $period_{oldest}$：最久的年份 年均增长率 现期量=$period_{base}\\times(1+年均增长率)^n$，其中n为相差年份 同比环比 同比：与历史同期比较，实际上是指与历年的同一时期相比较。 环比：与上个统计周期比较，实际上是指“与紧紧","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"相邻的统计周期相比较”。 比重、倍数、平均数、百分数、成数、翻番 比重=$\\frac{part}{all}$ 倍数：A是B的$\\frac{A}{B}$倍 平均数：平均数=总数÷总份数 百分点是百分数的单位，用于百位数加减 成表示十分之一 翻一番为原来的2倍，翻n番为原来的$2^n$倍 顺差、逆差 顺差：出口\u003e进口 逆差：进口\u003e出口 GDP=增加值 速算技巧 截位直除 选项首位均不同，保留两位；选项首位有相同的，保留三位 选项之间误差在 10%以上，保留两位 ；选项之间误差在 10%以内，保留三位 一步除式：只估算分母，保留三位；多步连除：分子分母同时截位，分开估算/交叉估算 关于多步截除的增长率估算$\\frac{1+0.11}{1+0.08} \\approx1+0.03(0.11-0.08)$乘法估算：乘法一大一小，各按比例缩放（粗算不需要，首位均不同） $99\\uparrow+101\\downarrow \\approx100*100$ 特殊分数 $\\frac{1}{2}=50$% $\\frac{1}{3}=33.3$% $\\frac{1}{4}=25$% $\\frac{1}{5}=2","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_1","order":1,"summary":"相邻的统计周期相比较”。 比重、倍数、平均数、百分数、成数、翻番 比重=$\\frac{part}{all}$ 倍数：A是B的$\\frac{A}{B}$倍 平均数：平均数=总数÷总份数 百分点是百分数的单位，用于百位数加减 成表示十分之一 翻一番为原来的2倍，翻n番为原来的$2^n$倍 顺差、逆差 顺差：出口\u003e进口 逆差：进口\u003e出口 GDP=增加值 速算技巧 截位直除 选项首位均不同，保留两位；选项首位有相同的，保留三位 选项之间误差在 10%以上，保留两位 ；选项之间误差在 10%以内，保留三位 一步除式：只估算分母，保留三位；多步连除：分子分母同时截位，分开估算/交叉估算 关于多步截除的增长率估算$\\frac{1+0.11}{1+0.08} \\approx1+0.03(0.11-0.08)$乘法估算：乘法一大一小，各按比例缩放（粗算不需要，首位均不同） $99\\uparrow+101\\downarrow \\approx100*100$ 特殊分数 $\\frac{1}{2}=50$% $\\frac{1}{3}=33.3$% $\\frac{1}{4}=25$% $\\frac{1}{5}=2","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"0$% $\\frac{1}{6}=16.7$% $\\frac{1}{7}=13.4$% $\\frac{1}{8}=12.5$% $\\frac{1}{9}=11.1$% $\\frac{1}{10}=10$% markdown % 不能显示，以下所有都化为小数点 题目：2011 年前十一个月，某省高新技术产业完成总产值 3763.00 亿元，实现增加 值 896.31 亿元。增加值同比增长 30.74%，比规模以上工业增加值高 11.64 个百 分点，占规模以上工业增加值的比重达到 25.32%。【练 5】2010 年前十一个月，该省规模以上工业增加值约为多少亿元？A.2972 B.3540 C.3865 D.43731，注意上下式子对应的东西要一致：求出今年的规模以上的GDP，再根据规模以上的增长率求去年的GDP；而不是求今年的高新GDP，再根据1+规模以上的增长率.$\\frac{\\frac{896}{0.25}}{1+0.3-0.11}$2015 年我国高技术制造业实现主营业务收入 116048.9 亿元，比 2010 年增长 108.2%；占全部制造业企业的比重为 12.8%，比 2","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_2","order":2,"summary":"0$% $\\frac{1}{6}=16.7$% $\\frac{1}{7}=13.4$% $\\frac{1}{8}=12.5$% $\\frac{1}{9}=11.1$% $\\frac{1}{10}=10$% markdown % 不能显示，以下所有都化为小数点 题目：2011 年前十一个月，某省高新技术产业完成总产值 3763.00 亿元，实现增加 值 896.31 亿元。增加值同比增长 30.74%，比规模以上工业增加值高 11.64 个百 分点，占规模以上工业增加值的比重达到 25.32%。【练 5】2010 年前十一个月，该省规模以上工业增加值约为多少亿元？A.2972 B.3540 C.3865 D.43731，注意上下式子对应的东西要一致：求出今年的规模以上的GDP，再根据规模以上的增长率求去年的GDP；而不是求今年的高新GDP，再根据1+规模以上的增长率.$\\frac{\\frac{896}{0.25}}{1+0.3-0.11}$2015 年我国高技术制造业实现主营业务收入 116048.9 亿元，比 2010 年增长 108.2%；占全部制造业企业的比重为 12.8%，比 2","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"010 年提高 0.8 个百分点。2015 年我国高技术制造业实现利润总额 7233.7 亿元，比 2010 年增长 165.5%，增幅比 其他制造业平均水平高出 11.5 个百分点；高技术制造业利润总额占全部制造业 的比重为 13.1%，比 2010 年提高 0.5 个百分点。 【练 3】2010 年，我国制造业实现利润总额约多少万亿元？ A．1.3 B．1.7 C．2.2 D．2.82，$\\frac{profit_{2015}}{1+1.655} \\div 比重_{2010}\\approx \\frac{7233\\times8}{2.655}\\approx \\frac{56^+}{2.655}$分数比较 视频地址方法一 ①分子大，分母小，直接判断分数大 ②分子分母同大，看变化速度， 分子变化大，选分子大；分母变化大，选分母小 方法二：直除比较 优先直除首位，其次看变化速度 题目：2014 年我国粮食种植面积 11274 万公顷，比上年增加 78 万公顷。棉花种植面积 422 万公顷，减少 13 万公顷。油料种植面积 1408 万公顷，增加 6 万公顷。 糖料种植面积 191 万公顷、","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_3","order":3,"summary":"010 年提高 0.8 个百分点。2015 年我国高技术制造业实现利润总额 7233.7 亿元，比 2010 年增长 165.5%，增幅比 其他制造业平均水平高出 11.5 个百分点；高技术制造业利润总额占全部制造业 的比重为 13.1%，比 2010 年提高 0.5 个百分点。 【练 3】2010 年，我国制造业实现利润总额约多少万亿元？ A．1.3 B．1.7 C．2.2 D．2.82，$\\frac{profit_{2015}}{1+1.655} \\div 比重_{2010}\\approx \\frac{7233\\times8}{2.655}\\approx \\frac{56^+}{2.655}$分数比较 视频地址方法一 ①分子大，分母小，直接判断分数大 ②分子分母同大，看变化速度， 分子变化大，选分子大；分母变化大，选分母小 方法二：直除比较 优先直除首位，其次看变化速度 题目：2014 年我国粮食种植面积 11274 万公顷，比上年增加 78 万公顷。棉花种植面积 422 万公顷，减少 13 万公顷。油料种植面积 1408 万公顷，增加 6 万公顷。 糖料种植面积 191 万公顷、","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"减少 9 万公顷。 全年棉花产量 616 万吨，比上年减产 2.2%。油料产量 3517 万吨，与上年持平。糖料产量 13403 万吨，减产 2.5%。茶叶产量 209 万吨，增产 8.7%。 【例 4】将不同作物按 2014 年单位种植面积产量由高到低排序，下列正确的是 A．棉花——油料——糖料 B．棉花——糖料——油料 C．糖料——油料——棉花 D．糖料——棉花——油料棉花：$\\frac{616}{422} \\approx \\frac{4+2}{4} \\approx 1^+$，油料：$\\frac{3517}{1408} \\approx \\frac{28+7}{14} \\approx 2^+$，糖料：$\\frac{13403}{191} \\gg 2$重点题型 简单题 直接计算和直接查找题目：截至 2012 年底，在网民增长速度逐步放缓的背景下，网络购物应用依然呈 现迅猛增长的势头，网络购物使用率提升至 42.9%，全年网络购物用户增加 4807 万，用户绝对增长量超出上年 1463 万。网上支付使用率提升至 39.2%，全年用 户增长 5389 万。网上银行使用率提升至 39.2%，","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_4","order":4,"summary":"减少 9 万公顷。 全年棉花产量 616 万吨，比上年减产 2.2%。油料产量 3517 万吨，与上年持平。糖料产量 13403 万吨，减产 2.5%。茶叶产量 209 万吨，增产 8.7%。 【例 4】将不同作物按 2014 年单位种植面积产量由高到低排序，下列正确的是 A．棉花——油料——糖料 B．棉花——糖料——油料 C．糖料——油料——棉花 D．糖料——棉花——油料棉花：$\\frac{616}{422} \\approx \\frac{4+2}{4} \\approx 1^+$，油料：$\\frac{3517}{1408} \\approx \\frac{28+7}{14} \\approx 2^+$，糖料：$\\frac{13403}{191} \\gg 2$重点题型 简单题 直接计算和直接查找题目：截至 2012 年底，在网民增长速度逐步放缓的背景下，网络购物应用依然呈 现迅猛增长的势头，网络购物使用率提升至 42.9%，全年网络购物用户增加 4807 万，用户绝对增长量超出上年 1463 万。网上支付使用率提升至 39.2%，全年用 户增长 5389 万。网上银行使用率提升至 39.2%，","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"比上年底提升 6.9 个百分点。 70.6%的网民使用台式电脑上网，相比上年底下降了近三个百分点，使用笔记本 电脑上网的网民比例与上年底相比略有降低，为 45.9%。 【练 7】2012 年我国网民使用台式电脑上网的比例比使用笔记本电脑上网的比例高A.近 3 个百分点 B.近 3% C.24.7% D.24.7 个百分点1，百分数加减是百分点。$0.706-0.459=$增长率相关 增长率相关增长率=$\\frac{increment}{period_{base}} = \\frac{period_{base}-period_{now}}{period_{base}}$ 现期量=$period_{base} \\times (1 + r)$ 基期量=$\\frac{period_{now}}{1 + r} = period_{now} − increment$ 技巧：截位直除 题目：【练 9】按 2011 年的人口自然增长率计算，预计 2012 年的人口约为（ ）万人。A．135382 B．135409 C．141129 D．1412021，$2010年 \\times r = 2011年-20","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_5","order":5,"summary":"比上年底提升 6.9 个百分点。 70.6%的网民使用台式电脑上网，相比上年底下降了近三个百分点，使用笔记本 电脑上网的网民比例与上年底相比略有降低，为 45.9%。 【练 7】2012 年我国网民使用台式电脑上网的比例比使用笔记本电脑上网的比例高A.近 3 个百分点 B.近 3% C.24.7% D.24.7 个百分点1，百分数加减是百分点。$0.706-0.459=$增长率相关 增长率相关增长率=$\\frac{increment}{period_{base}} = \\frac{period_{base}-period_{now}}{period_{base}}$ 现期量=$period_{base} \\times (1 + r)$ 基期量=$\\frac{period_{now}}{1 + r} = period_{now} − increment$ 技巧：截位直除 题目：【练 9】按 2011 年的人口自然增长率计算，预计 2012 年的人口约为（ ）万人。A．135382 B．135409 C．141129 D．1412021，$2010年 \\times r = 2011年-20","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"10年 \\Rightarrow 134091 \\times 0.0048 = 13475-134091 = 644$。$2011年 \\times r = (2010年+增长量) \\times r = 增长量+增长量 \\times r \\Rightarrow 644 + 0.644\\times 5$间隔增长率 间隔增长率题型特征：间隔一年，2017 年比 2015 年增长率，2016 年第一季度比 2014 年第一季度增长率。公式：$R = 𝑟_1 + 𝑟_2 + 𝑟_1 \\times 𝑟_2$（𝑟1和𝑟2是较大两个年份的增长率）大胆估算𝑟1 × 𝑟2的技巧：$r_1 \\times r_2 = \\frac{a}{100} \\times \\frac{b}{100} = \\frac{\\frac{ab}{100}}{100} $ r1 × r2，一个化为分数，一个不变 r1和r2均小于 10%， r1 × r2 \u0026lt; 1%，大胆估算 2014 年全国社会物流总额 213.5 万亿元，同比增长 7.9%，比上年回落 1.6 个百分点。 【例 3】2012 年上半年全国社会物流总额约为多少万亿","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_6","order":6,"summary":"10年 \\Rightarrow 134091 \\times 0.0048 = 13475-134091 = 644$。$2011年 \\times r = (2010年+增长量) \\times r = 增长量+增长量 \\times r \\Rightarrow 644 + 0.644\\times 5$间隔增长率 间隔增长率题型特征：间隔一年，2017 年比 2015 年增长率，2016 年第一季度比 2014 年第一季度增长率。公式：$R = 𝑟_1 + 𝑟_2 + 𝑟_1 \\times 𝑟_2$（𝑟1和𝑟2是较大两个年份的增长率）大胆估算𝑟1 × 𝑟2的技巧：$r_1 \\times r_2 = \\frac{a}{100} \\times \\frac{b}{100} = \\frac{\\frac{ab}{100}}{100} $ r1 × r2，一个化为分数，一个不变 r1和r2均小于 10%， r1 × r2 \u0026lt; 1%，大胆估算 2014 年全国社会物流总额 213.5 万亿元，同比增长 7.9%，比上年回落 1.6 个百分点。 【例 3】2012 年上半年全国社会物流总额约为多少万亿","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"元？（ ） A．93 B．102 C．75 D．86累计总额即上半年为第二季度，给2014求2012。$r=r_1+r_2+r_1r_2\\approx0.178+0.09\\times0.09 \\approx 0.186$，$\\frac{101.5}{12}\\approx 80^+$，D混合增长率 混合增长率混合增长率：大小居中，偏向基期量大的 中间=两边的平均数（左边\u0026lt;中间\u0026lt;右边） 一般题目都是给定当年的量和增长率，缺少左/右的增长率 精确求混合 题目：2013 年 3 月末，主要金融机构及小型农村金融机构、外资银行人民币房地产贷款余额 12.98 万亿元，同比增长 16.4%。地产开发贷款余额 1.04 万亿元， 同比增长 21.4%。房产开发贷款余额 3.2 万亿元，同比增长 12.3%。个人购房贷款余额 8.57 万亿元，同比增长 17.4%。保障性住房开发贷款余额 6140 亿元，同 比增长 42.4%。【例 2】2013 年 3 月末，房地产开发贷款余额同比增速约为（ ）。A.14.4% B.12.3% C.19.3% D.21.4%例2，房产3.2万亿，12.3","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_7","order":7,"summary":"元？（ ） A．93 B．102 C．75 D．86累计总额即上半年为第二季度，给2014求2012。$r=r_1+r_2+r_1r_2\\approx0.178+0.09\\times0.09 \\approx 0.186$，$\\frac{101.5}{12}\\approx 80^+$，D混合增长率 混合增长率混合增长率：大小居中，偏向基期量大的 中间=两边的平均数（左边\u0026lt;中间\u0026lt;右边） 一般题目都是给定当年的量和增长率，缺少左/右的增长率 精确求混合 题目：2013 年 3 月末，主要金融机构及小型农村金融机构、外资银行人民币房地产贷款余额 12.98 万亿元，同比增长 16.4%。地产开发贷款余额 1.04 万亿元， 同比增长 21.4%。房产开发贷款余额 3.2 万亿元，同比增长 12.3%。个人购房贷款余额 8.57 万亿元，同比增长 17.4%。保障性住房开发贷款余额 6140 亿元，同 比增长 42.4%。【例 2】2013 年 3 月末，房地产开发贷款余额同比增速约为（ ）。A.14.4% B.12.3% C.19.3% D.21.4%例2，房产3.2万亿，12.3","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"%，地产1.04万亿，21.4%。3.2\u003e1.04 =\u003e 房地产12.3%\u0026lt; x \u0026lt;(12.3+21.4)/2%【例 4】2013 年第三季度社会物流总额同比增速高于第四季度(T/F)1，累计前三季度(158.1，9.5%)+累计前二季度(101.5，9.1) =\u003e三季度\u003e9.5%；累计前四季度(213.5，9.5%)+累计前三季度(158.1，9.5%)=\u003e四季度=9.5%年均增长率 年均增长率年均增长率计算：代入特殊值(答案的居中值：10 20 )年均增长率比较：比较每个$\\frac{period_{newest}}{period_{oldest}}$的值关于怎么数年份：问 2013-2017 年的年均增长率，如果没有给出 2012 年的 具体值，那么以 2013 年为基期，求 4 年的年均增长；如果给出了 2012 年的具体 值，那么以 2012 年为基期，求 5 年的年均增长。$11^2=121,12^2=144,13^2=169,14^2=196,15^2=225,16^2=256$年均增长量 $=\\frac{现期量-基期量}{间隔年份}$ 年均增长率 $现期量=","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_8","order":8,"summary":"%，地产1.04万亿，21.4%。3.2\u003e1.04 =\u003e 房地产12.3%\u0026lt; x \u0026lt;(12.3+21.4)/2%【例 4】2013 年第三季度社会物流总额同比增速高于第四季度(T/F)1，累计前三季度(158.1，9.5%)+累计前二季度(101.5，9.1) =\u003e三季度\u003e9.5%；累计前四季度(213.5，9.5%)+累计前三季度(158.1，9.5%)=\u003e四季度=9.5%年均增长率 年均增长率年均增长率计算：代入特殊值(答案的居中值：10 20 )年均增长率比较：比较每个$\\frac{period_{newest}}{period_{oldest}}$的值关于怎么数年份：问 2013-2017 年的年均增长率，如果没有给出 2012 年的 具体值，那么以 2013 年为基期，求 4 年的年均增长；如果给出了 2012 年的具体 值，那么以 2012 年为基期，求 5 年的年均增长。$11^2=121,12^2=144,13^2=169,14^2=196,15^2=225,16^2=256$年均增长量 $=\\frac{现期量-基期量}{间隔年份}$ 年均增长率 $现期量=","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"基期量\\times(1+年均增长率)^n$，其中n为相差年份 题目：【例 4】(2013 年江苏)若不考虑价格因素，则 2003-2011 年九年，江苏金融业增加值年均增速 Vj、第三产业增加值年均增速 Vs、地区国内生产总值年均增速 Vg 的大小关系是： A. Vs＞Vj＞Vg B. Vj＞Vg＞Vs C. Vj＞Vs＞Vg D. Vs＞Vg＞Vj1。如果第一年到最后一年的增长率大，平均到每一年就大，所以看第一年到最后一年的增长率。$\\frac{2600}{370}\\approx7^+ \u003e \\frac{20842}{3891}\\approx5^+ \u003e \\frac{49110}{10606}\\approx5^-$，可以首位直除增长量相关 增长量相关增长量 = 现期量 − 基期量 = 基期量 × r = 现期量/(1 + r) × r解题技巧:特殊分数 现期/(1+特殊分数) = 现期/(特殊分数+1) 现期/(1+1/8) = 现期/9 现期/(1-1/8) = 现期/7 截位直除法 现期量 × r /(1 + r) 增长量大小比较：现期值大，增长率大，大大则大。 一大一小，近似比较现","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_9","order":9,"summary":"基期量\\times(1+年均增长率)^n$，其中n为相差年份 题目：【例 4】(2013 年江苏)若不考虑价格因素，则 2003-2011 年九年，江苏金融业增加值年均增速 Vj、第三产业增加值年均增速 Vs、地区国内生产总值年均增速 Vg 的大小关系是： A. Vs＞Vj＞Vg B. Vj＞Vg＞Vs C. Vj＞Vs＞Vg D. Vs＞Vg＞Vj1。如果第一年到最后一年的增长率大，平均到每一年就大，所以看第一年到最后一年的增长率。$\\frac{2600}{370}\\approx7^+ \u003e \\frac{20842}{3891}\\approx5^+ \u003e \\frac{49110}{10606}\\approx5^-$，可以首位直除增长量相关 增长量相关增长量 = 现期量 − 基期量 = 基期量 × r = 现期量/(1 + r) × r解题技巧:特殊分数 现期/(1+特殊分数) = 现期/(特殊分数+1) 现期/(1+1/8) = 现期/9 现期/(1-1/8) = 现期/7 截位直除法 现期量 × r /(1 + r) 增长量大小比较：现期值大，增长率大，大大则大。 一大一小，近似比较现","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"期量 × r 的值 $\\frac{Ar_1}{1+r_1}$和 $\\frac{Br_2}{1+r_2}$ 忽略底部，看分子乘积 r1和r2的差距在20%以内可以忽略底部 r1和r2的差距在20%以上，列出完整式子进行估算 如果两个乘积比较接近，列出完整式子进行估算 正大于负 题目：【练 8】2011～2017 年，全国二手车交易量同比增量低于 80 万辆的年份有几个？ A．3 B．4 C．5 D．7不等于求年平均增长率，需要求2011年：$\\frac{682}{1.124} - 682 \u0026lt; 80$2011 年前十一个月，某省高新技术产业完成总产值 3763.00 亿元，实现增加 值 896.31 亿元。增加值同比增长 30.74%，比规模以上工业增加值高 11.64 个百 分点，占规模以上工业增加值的比重达到 25.32%。【练 10】若该省高新技术产业增加值保持同样的增长速度，则 2012 年前十一个月高新技术产业增加值比 2010 年同期约增加多少亿元： A．210.7 B．486.3 C．275.5 D．685.62012-2010=2011增长量+2012增长量=$\\fr","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_10","order":10,"summary":"期量 × r 的值 $\\frac{Ar_1}{1+r_1}$和 $\\frac{Br_2}{1+r_2}$ 忽略底部，看分子乘积 r1和r2的差距在20%以内可以忽略底部 r1和r2的差距在20%以上，列出完整式子进行估算 如果两个乘积比较接近，列出完整式子进行估算 正大于负 题目：【练 8】2011～2017 年，全国二手车交易量同比增量低于 80 万辆的年份有几个？ A．3 B．4 C．5 D．7不等于求年平均增长率，需要求2011年：$\\frac{682}{1.124} - 682 \u0026lt; 80$2011 年前十一个月，某省高新技术产业完成总产值 3763.00 亿元，实现增加 值 896.31 亿元。增加值同比增长 30.74%，比规模以上工业增加值高 11.64 个百 分点，占规模以上工业增加值的比重达到 25.32%。【练 10】若该省高新技术产业增加值保持同样的增长速度，则 2012 年前十一个月高新技术产业增加值比 2010 年同期约增加多少亿元： A．210.7 B．486.3 C．275.5 D．685.62012-2010=2011增长量+2012增长量=$\\fr","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"ac{896}{1+0.3}+896\\times0.3 \\approx 270+896/130 \\approx 270+200^+$2010 年，我国机电产品出口 9334.3 亿美元，同比增加 30.9%;高新技术产品出口 4924.1 亿美元，同比增长 30.7%。船舶、汽车零部件出口保持较快增长，其中船舶出口同比增长 44.5%，汽车零部件出口同比增长 44.1%。 2010 年，机电产品进口额达到 6603.1 亿美元，同比增长 34.4%，高新技术产品进口额达到 4126.7 亿美元，同比增长 33.2%。【例 9】问题：在 2010 年我国进出口贸易中，下列哪一项的同比增长金额最高？ A．机电产品出口 B．高新技术产品出口 C．机电产品进口 D．高新技术产品进口增长率近似，看现期×增长率，9000\u003e6600\u003e4924\u003e4126，A。如果看高新技术进出口增长量，需要列出完整式子比重相关 基期比重比重 = $\\frac{A}{B} \\times \\frac{1+b}{1+a}$,不化简好记一点$\\frac{\\frac{A}{1+a}}{\\frac{B}{1+b}}$题目：201","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_11","order":11,"summary":"ac{896}{1+0.3}+896\\times0.3 \\approx 270+896/130 \\approx 270+200^+$2010 年，我国机电产品出口 9334.3 亿美元，同比增加 30.9%;高新技术产品出口 4924.1 亿美元，同比增长 30.7%。船舶、汽车零部件出口保持较快增长，其中船舶出口同比增长 44.5%，汽车零部件出口同比增长 44.1%。 2010 年，机电产品进口额达到 6603.1 亿美元，同比增长 34.4%，高新技术产品进口额达到 4126.7 亿美元，同比增长 33.2%。【例 9】问题：在 2010 年我国进出口贸易中，下列哪一项的同比增长金额最高？ A．机电产品出口 B．高新技术产品出口 C．机电产品进口 D．高新技术产品进口增长率近似，看现期×增长率，9000\u003e6600\u003e4924\u003e4126，A。如果看高新技术进出口增长量，需要列出完整式子比重相关 基期比重比重 = $\\frac{A}{B} \\times \\frac{1+b}{1+a}$,不化简好记一点$\\frac{\\frac{A}{1+a}}{\\frac{B}{1+b}}$题目：201","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"5 年，江西规模以上工业增加值 7268.9 亿元，比上年增长 9.2%。分轻重 工业看，轻工业增加值 2731.2 亿元，增长 7.7%；重工业增加值 4537.7 亿元， 增长 10.1%。 【例 5】2014 年江西省重工业增加值占规模以上工业增加值的比重为（ ）。 A．56.7% B．62.4% C．61.9% D．68.3%例5，BC近似则分母保留3位，分子不变$\\frac{4537}{7270}\\times\\frac{1+0.092}{1+0.101}$，又因为B是现期比重$\\frac{4537}{7270}\\approx 62^+$,干扰项，直接推C两期比重 两期比重变化看部分的增长率大于整体的增长率则比重增大，否则比重减少 $去年：\\frac{X_{part}}{Y_{all}} \u003e 今年：\\frac{X_{part}(1+a)}{Y_{all}(1+b)} \\Rightarrow \\frac{1+a}{1+b} \\Rightarrow a\u003eb 比重 \\uparrow$ 比重上升也可以反推部分增速快 两期比重差(百分点)：$\\frac{A}{B} - \\frac{A}{","date":"2023-11-12T00:49:46+08:00","objectID":"db25ae21926131699a4f58a21cd0c11b_12","order":12,"summary":"5 年，江西规模以上工业增加值 7268.9 亿元，比上年增长 9.2%。分轻重 工业看，轻工业增加值 2731.2 亿元，增长 7.7%；重工业增加值 4537.7 亿元， 增长 10.1%。 【例 5】2014 年江西省重工业增加值占规模以上工业增加值的比重为（ ）。 A．56.7% B．62.4% C．61.9% D．68.3%例5，BC近似则分母保留3位，分子不变$\\frac{4537}{7270}\\times\\frac{1+0.092}{1+0.101}$，又因为B是现期比重$\\frac{4537}{7270}\\approx 62^+$,干扰项，直接推C两期比重 两期比重变化看部分的增长率大于整体的增长率则比重增大，否则比重减少 $去年：\\frac{X_{part}}{Y_{all}} \u003e 今年：\\frac{X_{part}(1+a)}{Y_{all}(1+b)} \\Rightarrow \\frac{1+a}{1+b} \\Rightarrow a\u003eb 比重 \\uparrow$ 比重上升也可以反推部分增速快 两期比重差(百分点)：$\\frac{A}{B} - \\frac{A}{","tags":["CivilServant"],"title":"公务员行测--资料分析","url":"http://localhost:1313/posts/learn/data-analysis/"},{"categories":["learn"],"content":"已更新详细解释。再更新：已解决Katex/mathjax使用转义字符无法显示的问题（使用\u0026lt;div\u003emath \u0026lt;div/\u003e）解题技巧 代入排除法 ※ 代入排除法题型：多位数问题、余数问题、年龄问题、不定方程、不会做的多位数问题将一个三位数的个位数字和百位数字调换后所得的三位数与原三位数的和是1070，差是198，这个三位数是：A．218 B．327 C．436 D．524解：436代入得634+436=1070，634-436=198余数问题一批武警战士平均分成若干小组值勤。如果每 4 人一组，恰好余 1 人；如果每 5 人一组，恰好也余 1 人；如果每 6 人一组，恰好还是余 1 人。这批武警战士至少有（ ）人。A．121 B．101 C．81 D．61解：精准空降到 43:15，至少，优先带入最少的值即61，符合秒D数字特性 奇偶性 数字特性奇/偶 ± 奇/偶 = 偶 奇 ± 偶 = 奇 奇 × 奇 = 奇 偶 × any = 偶 使用场景：知差求和、知和求差；二倍类、平均分；不定方程题目：某次测验有 50 道判断题，每做对一题得 3 分，不做或做错一题倒扣1分，某学生共","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_0","order":0,"summary":"已更新详细解释。再更新：已解决Katex/mathjax使用转义字符无法显示的问题（使用\u0026lt;div\u003emath \u0026lt;div/\u003e）解题技巧 代入排除法 ※ 代入排除法题型：多位数问题、余数问题、年龄问题、不定方程、不会做的多位数问题将一个三位数的个位数字和百位数字调换后所得的三位数与原三位数的和是1070，差是198，这个三位数是：A．218 B．327 C．436 D．524解：436代入得634+436=1070，634-436=198余数问题一批武警战士平均分成若干小组值勤。如果每 4 人一组，恰好余 1 人；如果每 5 人一组，恰好也余 1 人；如果每 6 人一组，恰好还是余 1 人。这批武警战士至少有（ ）人。A．121 B．101 C．81 D．61解：精准空降到 43:15，至少，优先带入最少的值即61，符合秒D数字特性 奇偶性 数字特性奇/偶 ± 奇/偶 = 偶 奇 ± 偶 = 奇 奇 × 奇 = 奇 偶 × any = 偶 使用场景：知差求和、知和求差；二倍类、平均分；不定方程题目：某次测验有 50 道判断题，每做对一题得 3 分，不做或做错一题倒扣1分，某学生共","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"得82分，问答对题数和答错题数（包括不做）相差多少？（ ）A.33 B.39 C.17 D.16练1，$x+y=50,x-y=?$ ，因为奇/偶 ± 奇/偶 = 偶，所以x-y必为偶，即对于相同的数相加为偶数，则相减也为偶数。选D母亲现在的年龄个位数跟十位数对调再减 10 岁就是儿子的年龄， 再过 3 年母亲的年龄就是儿子年龄的 2 倍，则母亲现在的年龄是（）。A.53 B.52 C.43 D.42例2，$x+3=oven$ ，则$x$必为奇，排除BD，代入A，符合题意。整除判定 整除判定，原理在前面几分钟2，4，8 整除及其余数判定法则 一个数能被 2(或 5)整除，当且仅当末一位数字能被 2(或者 5)整除； 一个数能被 4(或者 25)整除，当且仅当末两位数字能被 4(或者 25)整除； 一个数能被 8(或者 125)整除，当且仅当末三位数字能被 8(或者 125)整除； 3，9 整除判定基本法则 一个数字能被 3 整除，当且仅当其各位数字之和能被 3 整除； 一个数字能被 9 整除，当且仅当其各位数字之和能被 9 整除； 使用场景：题目出现 2、4、8、3、9 等的倍数。 题目","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_1","order":1,"summary":"得82分，问答对题数和答错题数（包括不做）相差多少？（ ）A.33 B.39 C.17 D.16练1，$x+y=50,x-y=?$ ，因为奇/偶 ± 奇/偶 = 偶，所以x-y必为偶，即对于相同的数相加为偶数，则相减也为偶数。选D母亲现在的年龄个位数跟十位数对调再减 10 岁就是儿子的年龄， 再过 3 年母亲的年龄就是儿子年龄的 2 倍，则母亲现在的年龄是（）。A.53 B.52 C.43 D.42例2，$x+3=oven$ ，则$x$必为奇，排除BD，代入A，符合题意。整除判定 整除判定，原理在前面几分钟2，4，8 整除及其余数判定法则 一个数能被 2(或 5)整除，当且仅当末一位数字能被 2(或者 5)整除； 一个数能被 4(或者 25)整除，当且仅当末两位数字能被 4(或者 25)整除； 一个数能被 8(或者 125)整除，当且仅当末三位数字能被 8(或者 125)整除； 3，9 整除判定基本法则 一个数字能被 3 整除，当且仅当其各位数字之和能被 3 整除； 一个数字能被 9 整除，当且仅当其各位数字之和能被 9 整除； 使用场景：题目出现 2、4、8、3、9 等的倍数。 题目","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"出现倍数、分数、百分数、比例、分组（7男5女一组：7：5）等字眼。 题目中出现“各个数位之和” 题目：一个四位数“□□□□”分别能被 15、12 和 10 除尽，且被这三个数除尽时所得的三个商的和为 1365，问四位数“□□□□”中四个数字的和是多少？A．17 B．16 C．15 D．14例4，设值可以考虑公倍数，15，12，10的公倍数为60，设四位数为$60x$，则$4x+5x+6x=1365$，解得C。或者根据15是3的倍数，则四位数是3的倍数，根据整除判断法则，四位数之和也为3的倍数，C。倍数关系 倍数关系若 a：b = m：n，或 $\\frac{a}{b} = \\frac{m}{n}$ 或者 $𝑎 = \\tfrac{m}{n}b$（m、n 互质，m：n 不能继续约分）。 则 a 是 m 的倍数；b 是 n 的倍数；a + b 是 m + n 的倍数；a – b 是 m – n 的倍数 例：男是女生的9/4倍 $\\Leftrightarrow$ 男：女 = 9：4 $\\Leftrightarrow$ a：b=9：4 $\\Leftrightarrow$ 男是9的倍数，女是4的倍数","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_2","order":2,"summary":"出现倍数、分数、百分数、比例、分组（7男5女一组：7：5）等字眼。 题目中出现“各个数位之和” 题目：一个四位数“□□□□”分别能被 15、12 和 10 除尽，且被这三个数除尽时所得的三个商的和为 1365，问四位数“□□□□”中四个数字的和是多少？A．17 B．16 C．15 D．14例4，设值可以考虑公倍数，15，12，10的公倍数为60，设四位数为$60x$，则$4x+5x+6x=1365$，解得C。或者根据15是3的倍数，则四位数是3的倍数，根据整除判断法则，四位数之和也为3的倍数，C。倍数关系 倍数关系若 a：b = m：n，或 $\\frac{a}{b} = \\frac{m}{n}$ 或者 $𝑎 = \\tfrac{m}{n}b$（m、n 互质，m：n 不能继续约分）。 则 a 是 m 的倍数；b 是 n 的倍数；a + b 是 m + n 的倍数；a – b 是 m – n 的倍数 例：男是女生的9/4倍 $\\Leftrightarrow$ 男：女 = 9：4 $\\Leftrightarrow$ a：b=9：4 $\\Leftrightarrow$ 男是9的倍数，女是4的倍数","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":" $\\Leftrightarrow$ 总人数是9+4的倍数，男女之差是9-4的倍数 使用场景：倍数、百分数、比例、分组（7男5女一组：7：5）题目：甲乙两队举行智力抢答赛，两队平均得分为 92 分，其中甲队平均得分 88 分，乙队平均得分为 94 分，则甲、乙两队人数之和可能是（ ）。A.20 B.21 C.23 D.25例14(十字交叉，两队平均)，常规解法：$88x+94y=92x+92y \\rightarrow x=2y$ 即$x+y$为3的倍数，B。十字交叉：$\\begin{matrix} \u002688\u0026+4 \u0026N\\ 92\u0026 \u0026 \\ \u002694\u0026-2\u00262N \\end{matrix}$，总和为$3N$两个派出所某月内共受理案件 160 起，其中甲派出所受理的案件中17%是刑事案件，乙派出所受理的案件中有20%是刑事案件，问乙派出所在这个月中共受理多少起非刑事案件？A.48 B.60 C.72 D.96练4（不可约分得总数），因为$0.17=\\frac{17}{100}$，而17是奇数，所以不可约分，得甲总案件数为100，则乙总案件数为60，$60\\times0.8=48$某汽车厂商生产甲、","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_3","order":3,"summary":" $\\Leftrightarrow$ 总人数是9+4的倍数，男女之差是9-4的倍数 使用场景：倍数、百分数、比例、分组（7男5女一组：7：5）题目：甲乙两队举行智力抢答赛，两队平均得分为 92 分，其中甲队平均得分 88 分，乙队平均得分为 94 分，则甲、乙两队人数之和可能是（ ）。A.20 B.21 C.23 D.25例14(十字交叉，两队平均)，常规解法：$88x+94y=92x+92y \\rightarrow x=2y$ 即$x+y$为3的倍数，B。十字交叉：$\\begin{matrix} \u002688\u0026+4 \u0026N\\ 92\u0026 \u0026 \\ \u002694\u0026-2\u00262N \\end{matrix}$，总和为$3N$两个派出所某月内共受理案件 160 起，其中甲派出所受理的案件中17%是刑事案件，乙派出所受理的案件中有20%是刑事案件，问乙派出所在这个月中共受理多少起非刑事案件？A.48 B.60 C.72 D.96练4（不可约分得总数），因为$0.17=\\frac{17}{100}$，而17是奇数，所以不可约分，得甲总案件数为100，则乙总案件数为60，$60\\times0.8=48$某汽车厂商生产甲、","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"乙、丙三种车型,其中乙型产量的 3 倍与丙型产量的 6 倍之和等于甲型产量的 4 倍，甲型产量与乙型产量的2倍之和等于丙型产量的 7 倍。则甲、乙、丙三型产量之比为( )?A.5:4:3 B.4:3:2 C.4:2:1 D.3:2:1二倍之和$\\ne$之和二倍，$4a=3b+6c,a+2b=7c\\ne2(a+b)=7c$，根据前式，$3b+6c$必为3得倍数，所以a为3得倍数，秒D方程法 方程法设未知数的原则：在同等情况下，优先设所求的量 设中间变量、份数(有分数、百分数、比例倍数特征) 优先设小不设大 题型：和差倍比问题、鸡兔同笼、盈亏问题、工程问题、经济利润问题、 行程问题等等。题目：公司销售部门共有甲、乙、丙、丁四个销售小组，本年度甲组销售金额是该部门销售金额总数的 1/3，乙组销售金额是另外三个小组总额的 1/4，丙组销售金额比丁组销售金额多 200 万元，比甲组少 200 万元。问销售部门销售总金额是多少万元？（ ）A.1800 B.2400 C.3000 D.3600例5，乙是另外三组的1/4倍，则乙/总=1/5，甲是总的1/3倍，所以设总数为$15x$，则甲$5x$，乙$","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_4","order":4,"summary":"乙、丙三种车型,其中乙型产量的 3 倍与丙型产量的 6 倍之和等于甲型产量的 4 倍，甲型产量与乙型产量的2倍之和等于丙型产量的 7 倍。则甲、乙、丙三型产量之比为( )?A.5:4:3 B.4:3:2 C.4:2:1 D.3:2:1二倍之和$\\ne$之和二倍，$4a=3b+6c,a+2b=7c\\ne2(a+b)=7c$，根据前式，$3b+6c$必为3得倍数，所以a为3得倍数，秒D方程法 方程法设未知数的原则：在同等情况下，优先设所求的量 设中间变量、份数(有分数、百分数、比例倍数特征) 优先设小不设大 题型：和差倍比问题、鸡兔同笼、盈亏问题、工程问题、经济利润问题、 行程问题等等。题目：公司销售部门共有甲、乙、丙、丁四个销售小组，本年度甲组销售金额是该部门销售金额总数的 1/3，乙组销售金额是另外三个小组总额的 1/4，丙组销售金额比丁组销售金额多 200 万元，比甲组少 200 万元。问销售部门销售总金额是多少万元？（ ）A.1800 B.2400 C.3000 D.3600例5，乙是另外三组的1/4倍，则乙/总=1/5，甲是总的1/3倍，所以设总数为$15x$，则甲$5x$，乙$","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"3x$，设丙c丁d，则$(5x-200)_c+(5x-400)_d=7x\\Rightarrow x=200$有甲、乙两瓶盐水，其浓度分别为 16%和 25%；质量分别为 600 克和 240 克，若向这两瓶溶液中加入等量的水，使他们的浓度相同，则需要向这两瓶盐水中分别加入的水量为（）。A.320 克 B. 360 克 C. 370 克 D. 377 克练5，两个分数相等的快速解法，$\\frac{a}{b} = \\frac{c}{d} = \\frac{a+c}{b+d} = \\frac{a-c}{b-d}$ 约掉x，即$\\frac{96}{600+x}=\\frac{60}{240+x}\\Rightarrow \\frac{96-60}{600-240}=\\frac{1}{10}\\Rightarrow \\frac{96}{600+360}\\Rightarrow 360g$，常规解法就是十字相乘求方程。基础篇 不定方程 不定方程限制性不定方程解析顺序：尾数法 3x+5y=41：（10=5，10，15，20，...）y必为0，5结尾，x则需要令0+3x=1；5+3x=1 因子倍数 29x+24y","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_5","order":5,"summary":"3x$，设丙c丁d，则$(5x-200)_c+(5x-400)_d=7x\\Rightarrow x=200$有甲、乙两瓶盐水，其浓度分别为 16%和 25%；质量分别为 600 克和 240 克，若向这两瓶溶液中加入等量的水，使他们的浓度相同，则需要向这两瓶盐水中分别加入的水量为（）。A.320 克 B. 360 克 C. 370 克 D. 377 克练5，两个分数相等的快速解法，$\\frac{a}{b} = \\frac{c}{d} = \\frac{a+c}{b+d} = \\frac{a-c}{b-d}$ 约掉x，即$\\frac{96}{600+x}=\\frac{60}{240+x}\\Rightarrow \\frac{96-60}{600-240}=\\frac{1}{10}\\Rightarrow \\frac{96}{600+360}\\Rightarrow 360g$，常规解法就是十字相乘求方程。基础篇 不定方程 不定方程限制性不定方程解析顺序：尾数法 3x+5y=41：（10=5，10，15，20，...）y必为0，5结尾，x则需要令0+3x=1；5+3x=1 因子倍数 29x+24y","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"=900：y是12的倍数，先找最大的倍数（3，4，5，...，12），则x是12的倍数 11a+7b=121：7b=11(11-a)$\\rightarrow$ b=11,a=4 奇偶特性 3x+4y=20：x必须偶数（看左边有无必为偶数，即乘偶数必为偶数） 代入排除 题型：限制性不定方程（组），未知数必须是正整数，例如未知数是人、桌子、 盒子、笔等。 非限制性不定方程（组），未知数不限制必须是整数，例如钱、时间， 重量等，此类题型出题巧妙，技巧性强。 题目：小刚买了 3 支钢笔、一个笔记本、2 瓶墨水，花去 35 元钱，小强 在同一家店买同样的 5 支钢笔，1 个笔记本，3 瓶墨水花去 52 元钱，则买 1 支钢笔、1 个笔记本、1 瓶墨水共需（）元。A．9 B．12 C．15 D．18例6，遇到无穷解给难约分的赋0，一般x+y+z的形式 or 约分方程得到特定形式（难题会难想）$3x+y+2z=35;5x+y+3z=52$，$x$比较难约分，设0，解得$x+y+z=18$工程问题 ※ 工程问题公式：工作总量w＝效率e×时间t解题方法：画表格给定时间型：①赋值总量为时间的公倍数②求出各","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_6","order":6,"summary":"=900：y是12的倍数，先找最大的倍数（3，4，5，...，12），则x是12的倍数 11a+7b=121：7b=11(11-a)$\\rightarrow$ b=11,a=4 奇偶特性 3x+4y=20：x必须偶数（看左边有无必为偶数，即乘偶数必为偶数） 代入排除 题型：限制性不定方程（组），未知数必须是正整数，例如未知数是人、桌子、 盒子、笔等。 非限制性不定方程（组），未知数不限制必须是整数，例如钱、时间， 重量等，此类题型出题巧妙，技巧性强。 题目：小刚买了 3 支钢笔、一个笔记本、2 瓶墨水，花去 35 元钱，小强 在同一家店买同样的 5 支钢笔，1 个笔记本，3 瓶墨水花去 52 元钱，则买 1 支钢笔、1 个笔记本、1 瓶墨水共需（）元。A．9 B．12 C．15 D．18例6，遇到无穷解给难约分的赋0，一般x+y+z的形式 or 约分方程得到特定形式（难题会难想）$3x+y+2z=35;5x+y+3z=52$，$x$比较难约分，设0，解得$x+y+z=18$工程问题 ※ 工程问题公式：工作总量w＝效率e×时间t解题方法：画表格给定时间型：①赋值总量为时间的公倍数②求出各","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"自的效率③分析求解一项工程，甲单独30天完成，乙单独45天完成，两人合作几天完成。w e t 90 得出3 30 90 得出2 45 得到 3+2 90/5=18 效率制约型：①赋值效率②直接赋值各自效率比值③分析求解题型：效率比 提高20%，则1：1.2=5：6 42台机器，则1：1：1：... 某一部分工程，甲3天，乙5天，则甲：乙=5：3 一项工程，甲和乙的效率比为2：3，合作8天完成，甲单独几天完成？w e t 5*8=40 2 8 3 题目：两根同样长的木炭，燃烧完一根粗的木炭需要 2 小时，燃烧完一根细的木炭需要 1 小时。现同时点燃这两根木炭，若干分钟后将两根木炭同时熄灭，发现粗木炭的剩余长度是细木炭的剩余长度的 2 倍，则燃烧了（）分钟。A. 35 B. 40 C. 45 D. 50例4，时间效率型，表格就不列了，方程为$2-x=2(2-2x)\\Rightarrow x=\\frac{2}{3}h$A 工程队的效率是 B 工程队的 2 倍，某工程交给两队共同完成需要 6 天。如果两队的工作效率均提高一倍，且 B 队中途休息了 1 天，问要保证工程按原来的时间完成，A 队中","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_7","order":7,"summary":"自的效率③分析求解一项工程，甲单独30天完成，乙单独45天完成，两人合作几天完成。w e t 90 得出3 30 90 得出2 45 得到 3+2 90/5=18 效率制约型：①赋值效率②直接赋值各自效率比值③分析求解题型：效率比 提高20%，则1：1.2=5：6 42台机器，则1：1：1：... 某一部分工程，甲3天，乙5天，则甲：乙=5：3 一项工程，甲和乙的效率比为2：3，合作8天完成，甲单独几天完成？w e t 5*8=40 2 8 3 题目：两根同样长的木炭，燃烧完一根粗的木炭需要 2 小时，燃烧完一根细的木炭需要 1 小时。现同时点燃这两根木炭，若干分钟后将两根木炭同时熄灭，发现粗木炭的剩余长度是细木炭的剩余长度的 2 倍，则燃烧了（）分钟。A. 35 B. 40 C. 45 D. 50例4，时间效率型，表格就不列了，方程为$2-x=2(2-2x)\\Rightarrow x=\\frac{2}{3}h$A 工程队的效率是 B 工程队的 2 倍，某工程交给两队共同完成需要 6 天。如果两队的工作效率均提高一倍，且 B 队中途休息了 1 天，问要保证工程按原来的时间完成，A 队中","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"途最多可以休息几天？A．4 B．3 C．2 D．1例6，按原来的时间完成，即6天，只需要计算B在6天内能干的工作量，让A干剩下的工作量即可。B翻一倍并且休息一天，干了$5\\times2=10$，A翻一倍需要干$(18-10)/4=2$天，可以休息4天。某件刺绣产品，需要效率相当的三名绣工 8 天才能完成；绣品完成 50%时，一人有事提前离开，绣品由剩下的两人继续完成；绣品完成 75%时，又有一人离开，绣品由最后剩下的那个人做完。那么，完成该件绣品一共用了（） 天。A．10 天 B．11 天 C．12 天 D．13 天例7，1：1：1型。总共$3\\times8=24$件，即$12/3+6/2+6/1=13$某商铺甲乙两组员工利用包装礼品的边角料制作一批花朵装饰门店。 甲组单独制作需要 10 小时，乙组单独制作需要 15 小时，现两组一起做，期间乙组休息了 1 小时 40 分，完成时甲组比乙组多做 300 朵。问这批花有多少朵？A.600 B.900 C.1350 D.1500练5，同例6。$3x+2x-\\frac{10}{3}=30 \\Rightarrow x=\\frac{20}{3} ","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_8","order":8,"summary":"途最多可以休息几天？A．4 B．3 C．2 D．1例6，按原来的时间完成，即6天，只需要计算B在6天内能干的工作量，让A干剩下的工作量即可。B翻一倍并且休息一天，干了$5\\times2=10$，A翻一倍需要干$(18-10)/4=2$天，可以休息4天。某件刺绣产品，需要效率相当的三名绣工 8 天才能完成；绣品完成 50%时，一人有事提前离开，绣品由剩下的两人继续完成；绣品完成 75%时，又有一人离开，绣品由最后剩下的那个人做完。那么，完成该件绣品一共用了（） 天。A．10 天 B．11 天 C．12 天 D．13 天例7，1：1：1型。总共$3\\times8=24$件，即$12/3+6/2+6/1=13$某商铺甲乙两组员工利用包装礼品的边角料制作一批花朵装饰门店。 甲组单独制作需要 10 小时，乙组单独制作需要 15 小时，现两组一起做，期间乙组休息了 1 小时 40 分，完成时甲组比乙组多做 300 朵。问这批花有多少朵？A.600 B.900 C.1350 D.1500练5，同例6。$3x+2x-\\frac{10}{3}=30 \\Rightarrow x=\\frac{20}{3} ","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"\\Rightarrow$甲完成20，乙完成10，则$20:10=x:x-300$即甲600，乙300，总共900w e t 30 30/10=3 10 30/15=2 15 3 x 2 x-(5/3)h 5. A、B、C 三支施工队在王庄和李庄修路，王庄要修路 900 米。李庄要修路 1250 米。已知 A、B、C 队每天分别能修 24 米、30 米、32 米，A、C 队分别在王庄和李庄修路，B 队先在王庄，施工若干天后转到李庄，两地工程同时开始同时结束。问 B 队在王庄工作了几天？ A.9 B.10 C.11 D.12练7，同时开工同时结束，三队一直干到结束。$(24+30+32)t=900+1250 \\Rightarrow t=25days$ 王庄修了$25\\times24=600\\Rightarrow remain=900-600 \\Rightarrow B_{work} = \\frac{300}{30}=10$ 6. 工厂有 5 条效率不同的生产线。某个生产项目如果任选 3 条生产线一起加工，最快需要 6 天整，最慢需要 12 天整；5 条生产线一起加工，则需要 5 天整。问如","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_9","order":9,"summary":"\\Rightarrow$甲完成20，乙完成10，则$20:10=x:x-300$即甲600，乙300，总共900w e t 30 30/10=3 10 30/15=2 15 3 x 2 x-(5/3)h 5. A、B、C 三支施工队在王庄和李庄修路，王庄要修路 900 米。李庄要修路 1250 米。已知 A、B、C 队每天分别能修 24 米、30 米、32 米，A、C 队分别在王庄和李庄修路，B 队先在王庄，施工若干天后转到李庄，两地工程同时开始同时结束。问 B 队在王庄工作了几天？ A.9 B.10 C.11 D.12练7，同时开工同时结束，三队一直干到结束。$(24+30+32)t=900+1250 \\Rightarrow t=25days$ 王庄修了$25\\times24=600\\Rightarrow remain=900-600 \\Rightarrow B_{work} = \\frac{300}{30}=10$ 6. 工厂有 5 条效率不同的生产线。某个生产项目如果任选 3 条生产线一起加工，最快需要 6 天整，最慢需要 12 天整；5 条生产线一起加工，则需要 5 天整。问如","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"果所有生产线的产能都扩大一倍，任选 2 条生产线一起加工，最多需要多少天完成？A.11 B.13 C.15 D.30练8，效率不同，直接设a\u003eb\u003ec\u003ed\u003ee，题目求最多，选最慢的两条dew e t abc 60 60/6=10 6 cde 60 60/12=5 12 abcde 60 60/5=12 5 de 12-10=2 2de 60 4 60/4=15 某工厂的一个生产小组，当每个工人都在岗位工作，9 小时可以完成一项生产任务。如果交换工人甲和乙的岗位，其他人不变，可提前 1 小时完成任务；如果交换工人丙和丁的岗位，其他人不变，也可以提前 1 小时完成任务。 如果同时交换甲和乙，丙和丁的岗位，其他人不变，可以提前多少时间完成？A.1.4 B.1.8 C.2.2 D.2.6练9，题目没看懂，交换了效率+1，都交换效率+2。$9,8,8 \\Rightarrow w=72 \\Rightarrow 72/(8+2)=7.2$行程问题 行程问题公式：S=v×t，vt反比，Svt正比等距离求平均速度：$\\bar{v} =\\frac{2v_1v_2}{v_1+v_2}$ 流水行船问题 顺流速度","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_10","order":10,"summary":"果所有生产线的产能都扩大一倍，任选 2 条生产线一起加工，最多需要多少天完成？A.11 B.13 C.15 D.30练8，效率不同，直接设a\u003eb\u003ec\u003ed\u003ee，题目求最多，选最慢的两条dew e t abc 60 60/6=10 6 cde 60 60/12=5 12 abcde 60 60/5=12 5 de 12-10=2 2de 60 4 60/4=15 某工厂的一个生产小组，当每个工人都在岗位工作，9 小时可以完成一项生产任务。如果交换工人甲和乙的岗位，其他人不变，可提前 1 小时完成任务；如果交换工人丙和丁的岗位，其他人不变，也可以提前 1 小时完成任务。 如果同时交换甲和乙，丙和丁的岗位，其他人不变，可以提前多少时间完成？A.1.4 B.1.8 C.2.2 D.2.6练9，题目没看懂，交换了效率+1，都交换效率+2。$9,8,8 \\Rightarrow w=72 \\Rightarrow 72/(8+2)=7.2$行程问题 行程问题公式：S=v×t，vt反比，Svt正比等距离求平均速度：$\\bar{v} =\\frac{2v_1v_2}{v_1+v_2}$ 流水行船问题 顺流速度","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"＝静水船速+水速 =\u003e S=(船速+水速) × 时间 逆流速度＝静水船速-水速 =\u003e S=(船速-水速) × 时间 相遇追及问题 相遇距离=(大速度+小速度) × 相遇时间 追及距离=(大速度-小速度) × 追及时间 类似顺水逆水 环形跑道问题 环线型 n 次相遇，总(共同行走的)距离=n × 环线长度 环线型 n 次追及，追及的距离=n × 环线长度。 两端相遇问题 直线型两端出发 n 次相遇，总(共同行走的)距离=(2n-1) × 两地初始距离 解题方法：画图题目：一次长跑比赛在周长为 400 米的环形跑道上进行。比赛中，最后一 名在距离第 3 圈终点 150 米处被第 1 名完成超圈（即比他多跑 1 圈），50 秒后， 他又在距离第 3 圈终点 45 米处被第 2 名完成超圈。假定所有选手均是匀速，那 么第 2 名速度约为：A．2.83m/s B．2.9m/s C．2.82m/s D．2.1m/s练7，题目可知最慢的速度，时间相同下，速度之比=路程之比。$v_{slow}=\\frac{150-45}{50}=2.1m/s \\Rightarrow dist_{slow}=300\\t","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_11","order":11,"summary":"＝静水船速+水速 =\u003e S=(船速+水速) × 时间 逆流速度＝静水船速-水速 =\u003e S=(船速-水速) × 时间 相遇追及问题 相遇距离=(大速度+小速度) × 相遇时间 追及距离=(大速度-小速度) × 追及时间 类似顺水逆水 环形跑道问题 环线型 n 次相遇，总(共同行走的)距离=n × 环线长度 环线型 n 次追及，追及的距离=n × 环线长度。 两端相遇问题 直线型两端出发 n 次相遇，总(共同行走的)距离=(2n-1) × 两地初始距离 解题方法：画图题目：一次长跑比赛在周长为 400 米的环形跑道上进行。比赛中，最后一 名在距离第 3 圈终点 150 米处被第 1 名完成超圈（即比他多跑 1 圈），50 秒后， 他又在距离第 3 圈终点 45 米处被第 2 名完成超圈。假定所有选手均是匀速，那 么第 2 名速度约为：A．2.83m/s B．2.9m/s C．2.82m/s D．2.1m/s练7，题目可知最慢的速度，时间相同下，速度之比=路程之比。$v_{slow}=\\frac{150-45}{50}=2.1m/s \\Rightarrow dist_{slow}=300\\t","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"imes4-45=1155m \\Rightarrow dist_{sec}=1155+400=1555m$ 可知$\\frac{v_{sec}}{v_{slow}}=\\frac{1555}{1155} \\Rightarrow v_{sec}=2.827m/s$甲乙丙分别骑摩托车、乘大巴、打的从 A 地去 B 地，甲的出发时间 分别比乙丙早 15 分钟、20 分钟，到达时间比乙丙都晚 5 分钟。已知甲乙的速度 之比是 2：3，丙的速度是 60 千米/小时，则 AB 两地间的距离是：A．75 千米 B．60 千米 C．48 千米 D．35 千米练8，图要画对，路程相同，速度时间反比。$\\frac{t_a}{t_b}=\\frac{3}{2}=\\frac{x+25}{x+5} \\Rightarrow x=35min \\Rightarrow 35\\times speed_c = 35km$排列组合 ※ 排列组合，概率论的基础分类用加法，分步用乘法 排列有顺序，组合无顺序 $A^m_n = n(n − 1)(n − 2) … (n − m + 1)$ $C_{n}^{m}=\\frac{A_{n}^{","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_12","order":12,"summary":"imes4-45=1155m \\Rightarrow dist_{sec}=1155+400=1555m$ 可知$\\frac{v_{sec}}{v_{slow}}=\\frac{1555}{1155} \\Rightarrow v_{sec}=2.827m/s$甲乙丙分别骑摩托车、乘大巴、打的从 A 地去 B 地，甲的出发时间 分别比乙丙早 15 分钟、20 分钟，到达时间比乙丙都晚 5 分钟。已知甲乙的速度 之比是 2：3，丙的速度是 60 千米/小时，则 AB 两地间的距离是：A．75 千米 B．60 千米 C．48 千米 D．35 千米练8，图要画对，路程相同，速度时间反比。$\\frac{t_a}{t_b}=\\frac{3}{2}=\\frac{x+25}{x+5} \\Rightarrow x=35min \\Rightarrow 35\\times speed_c = 35km$排列组合 ※ 排列组合，概率论的基础分类用加法，分步用乘法 排列有顺序，组合无顺序 $A^m_n = n(n − 1)(n − 2) … (n − m + 1)$ $C_{n}^{m}=\\frac{A_{n}^{","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"m}}{m!}=\\frac{n(n-1)(n-2) \\ldots(n-m+1)}{m \\times(m-1) \\times(m-2) \\ldots \\times 2 \\times 1}$ 捆绑法：相邻问题，将相邻的元素捆绑成一个元素 插空法：不相邻问题，先对其他元素排列，然后将不相邻的元素插入空中 插板法：N 个相同物品分给 M 个人，每人至少分得一个，N 个物品中间有（N-1）个间隔，在间隔中插入（M-1）个板，共有$C^{M-1}_{N-1}$种情况。 错位排列：有 N 封信和 N 个信封，每封信都不装在自己对应的信封里，可能的方案数记作 Dn，D2=1，D3=2，D4=9，D5=44，记住这五个即可。 题目：某单位组织职工参加周末培训，其中英语培训和财务培训均在周六， 公文写作培训和法律培训均在周日。同一天举办的两场培训每人只能报名参加一场，但不在同一天的培训可以都参加。则职工小刘有多少种不同的报名方式？A．4 B．8 C．9 D．16例3，分类讨论，只报一场和两场。只报一场：$C^1_4$，报两场：$C^1_2\\times C_2^1$单位订阅了 30 份学习材料发放给 3 个","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_13","order":13,"summary":"m}}{m!}=\\frac{n(n-1)(n-2) \\ldots(n-m+1)}{m \\times(m-1) \\times(m-2) \\ldots \\times 2 \\times 1}$ 捆绑法：相邻问题，将相邻的元素捆绑成一个元素 插空法：不相邻问题，先对其他元素排列，然后将不相邻的元素插入空中 插板法：N 个相同物品分给 M 个人，每人至少分得一个，N 个物品中间有（N-1）个间隔，在间隔中插入（M-1）个板，共有$C^{M-1}_{N-1}$种情况。 错位排列：有 N 封信和 N 个信封，每封信都不装在自己对应的信封里，可能的方案数记作 Dn，D2=1，D3=2，D4=9，D5=44，记住这五个即可。 题目：某单位组织职工参加周末培训，其中英语培训和财务培训均在周六， 公文写作培训和法律培训均在周日。同一天举办的两场培训每人只能报名参加一场，但不在同一天的培训可以都参加。则职工小刘有多少种不同的报名方式？A．4 B．8 C．9 D．16例3，分类讨论，只报一场和两场。只报一场：$C^1_4$，报两场：$C^1_2\\times C_2^1$单位订阅了 30 份学习材料发放给 3 个","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"部门，每个部门至少发放 9 份材料。问一共有多少种不同的发放方法？（ ）A．12 B．10 C．9 D．7练6，先分至只剩一份：$30-3\\times8=6$，插板法：$C_5^2=10$从 1、2、3、4、5、6、7、8、9 中选取 2 个数，让他们的和是质数，则共有多少种选法？A.19 B.18 C.17 D.16 E.15 F.14 G.13 H.12例12，穷举法，先列出所有质数，再按质数顺序依次选2个数求和拼凑出质数。选F概率问题 概率问题基本概率 某种情况发生的概率＝满足条件的情况数÷总的情况数。 P＝ 满足条件的情况数/总的情况数 分步乘法型 分步概率 = 满足条件的每个步骤概率之积 分类加法型 总体概率 ＝ 满足条件的各种情况概率之和 逆向计算型 某事件的概率 = 1－该事件不发生的概率 题目：某单位工会组织桥牌比赛，共有 8 人报名，随机组成 4 队，每队 2 人。那么，小王和小李恰好被分在同一队的概率是（ ）。A．1/7 B．1/14 C．1/21 D．1/28例4，先确定一个。$P=\\frac{8}{8}\\times\\frac{1}{7}$，小王：总情况数8个位子","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_14","order":14,"summary":"部门，每个部门至少发放 9 份材料。问一共有多少种不同的发放方法？（ ）A．12 B．10 C．9 D．7练6，先分至只剩一份：$30-3\\times8=6$，插板法：$C_5^2=10$从 1、2、3、4、5、6、7、8、9 中选取 2 个数，让他们的和是质数，则共有多少种选法？A.19 B.18 C.17 D.16 E.15 F.14 G.13 H.12例12，穷举法，先列出所有质数，再按质数顺序依次选2个数求和拼凑出质数。选F概率问题 概率问题基本概率 某种情况发生的概率＝满足条件的情况数÷总的情况数。 P＝ 满足条件的情况数/总的情况数 分步乘法型 分步概率 = 满足条件的每个步骤概率之积 分类加法型 总体概率 ＝ 满足条件的各种情况概率之和 逆向计算型 某事件的概率 = 1－该事件不发生的概率 题目：某单位工会组织桥牌比赛，共有 8 人报名，随机组成 4 队，每队 2 人。那么，小王和小李恰好被分在同一队的概率是（ ）。A．1/7 B．1/14 C．1/21 D．1/28例4，先确定一个。$P=\\frac{8}{8}\\times\\frac{1}{7}$，小王：总情况数8个位子","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"，满足情况数8位子都满足，小李：总情况数7，满足情况数1（一队有2个人，且必须分在同一队）某场羽毛球单打比赛采取三局两胜制。假设甲选手在每局都有 80% 的概率赢乙选手，那么这场单打比赛甲有多大的概率战胜乙选手？A. 0.768 B. 0.800 C. 0.896 D. 0.92420例5，分类加法型。战胜的情况必须甲赢两场：1. 前两局就获胜：$0.8\\times0.8$；2. 中间落败：$0.8\\times0.2\\times0.8$；3. 后两局获胜：$0.2\\times0.8\\times0.8$。即$0.64(1+0.2+0.2)=xx6$选C某商场搞抽奖促销，限每人只能参与一次，活动规则是：一个纸箱里装有 5 个大小相同的乒乓球，其中 3 个是白色 2 个是红色，参与者从中任意抽出 2 个球，如果两个都是白色可得抵用券100 元，一白一红可得抵用券 200 元， 两个都是红色可得抵用券 400 元。若小李和小林两人分别参加抽奖，那么两人获得抵用券之和不少于 600 元的概率是多少？A．0.12 B．0.22 C．0.13 D．0.30例6,求概率+分类求和。$P_{100}=\\","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_15","order":15,"summary":"，满足情况数8位子都满足，小李：总情况数7，满足情况数1（一队有2个人，且必须分在同一队）某场羽毛球单打比赛采取三局两胜制。假设甲选手在每局都有 80% 的概率赢乙选手，那么这场单打比赛甲有多大的概率战胜乙选手？A. 0.768 B. 0.800 C. 0.896 D. 0.92420例5，分类加法型。战胜的情况必须甲赢两场：1. 前两局就获胜：$0.8\\times0.8$；2. 中间落败：$0.8\\times0.2\\times0.8$；3. 后两局获胜：$0.2\\times0.8\\times0.8$。即$0.64(1+0.2+0.2)=xx6$选C某商场搞抽奖促销，限每人只能参与一次，活动规则是：一个纸箱里装有 5 个大小相同的乒乓球，其中 3 个是白色 2 个是红色，参与者从中任意抽出 2 个球，如果两个都是白色可得抵用券100 元，一白一红可得抵用券 200 元， 两个都是红色可得抵用券 400 元。若小李和小林两人分别参加抽奖，那么两人获得抵用券之和不少于 600 元的概率是多少？A．0.12 B．0.22 C．0.13 D．0.30例6,求概率+分类求和。$P_{100}=\\","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"frac{C^2_3}{C^2_5}=0.3, P_{400}=\\frac{C^1_3C^1_2}{C^2_5}=0.6, P_{600}=1-0.3-0.6=0.1$。不少于600的情况有三种：1. 200 400：$0.1\\times0.6\\times2$；3. 400 400：$0.1\\times0.1$ 。即$0.12+0.01=0.13$在小李等车期间，有豪华型、舒适型、标准型三种旅游车随机开过。 小李不知道豪华型的标准，只能通过前后两辆车进行对比。为此，小李采取的策略是：不乘坐第一辆，如果发现第二辆比第一辆更豪华就乘坐；如果不是，就乘坐最后一辆。那么，他能乘坐豪华型旅游车的概率是：A．1/2 B．1/3 C．1/4 D．1/5练2，看不懂数据少枚举。设标1舒2豪华3，则123、132、213、231、312、321，其中132、231、213符合，A掷两个骰子，掷出的点数之和为奇数的概率为 P1，掷出的点数之和为偶数的概率为 P2，问 P1 和 P2 的大小关系？A．P1=P2 B．P1\u003eP2 C．P1\u0026lt;P2 D．无法确定练3，和为奇的情况：奇（骰到135）+偶（骰到","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_16","order":16,"summary":"frac{C^2_3}{C^2_5}=0.3, P_{400}=\\frac{C^1_3C^1_2}{C^2_5}=0.6, P_{600}=1-0.3-0.6=0.1$。不少于600的情况有三种：1. 200 400：$0.1\\times0.6\\times2$；3. 400 400：$0.1\\times0.1$ 。即$0.12+0.01=0.13$在小李等车期间，有豪华型、舒适型、标准型三种旅游车随机开过。 小李不知道豪华型的标准，只能通过前后两辆车进行对比。为此，小李采取的策略是：不乘坐第一辆，如果发现第二辆比第一辆更豪华就乘坐；如果不是，就乘坐最后一辆。那么，他能乘坐豪华型旅游车的概率是：A．1/2 B．1/3 C．1/4 D．1/5练2，看不懂数据少枚举。设标1舒2豪华3，则123、132、213、231、312、321，其中132、231、213符合，A掷两个骰子，掷出的点数之和为奇数的概率为 P1，掷出的点数之和为偶数的概率为 P2，问 P1 和 P2 的大小关系？A．P1=P2 B．P1\u003eP2 C．P1\u0026lt;P2 D．无法确定练3，和为奇的情况：奇（骰到135）+偶（骰到","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"246）和偶+奇：$P_{odd}=\\frac{3\\times3+3\\times3}{6\\times6}=\\frac{1}{2}$，非奇即偶，A经济利润 ※ 经济利润利润折扣问题： 总成本=单个成本×进口量；总售价＝单价×销售量； 利润＝售价-成本；总利润＝总售价-总成本 利润率 = 利润/成本 = (售价 − 成本)/成本 = 售价/成本 − 1 毛利 = 利润/营收 列表法：成本 定价 售价 利润*量=总利 （售价=不打折的定价） 分段计费问题 分段计费问题主要涉及水电、资费、提成等通常分段计费问题。 解题关键在于找到分段节点，分区间讨论计算。 画数轴 题目：商场里某商品成本上涨了 20%，售价只上涨了 10%，毛利率（利润/进货价）比以前的下降了 10 个百分点。问原来的毛利率是多少？A.10% B.20% C.30% D.40%例7，比例关系直接赋值，出现成本、售价、利润，优先只赋值成本。$\\frac{x-10}{10}-\\frac{1}{10}=\\frac{1.1x-12}{12} \\Rightarrow x=12 \\Rightarrow \\frac{12-10}{10}=0","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_17","order":17,"summary":"246）和偶+奇：$P_{odd}=\\frac{3\\times3+3\\times3}{6\\times6}=\\frac{1}{2}$，非奇即偶，A经济利润 ※ 经济利润利润折扣问题： 总成本=单个成本×进口量；总售价＝单价×销售量； 利润＝售价-成本；总利润＝总售价-总成本 利润率 = 利润/成本 = (售价 − 成本)/成本 = 售价/成本 − 1 毛利 = 利润/营收 列表法：成本 定价 售价 利润*量=总利 （售价=不打折的定价） 分段计费问题 分段计费问题主要涉及水电、资费、提成等通常分段计费问题。 解题关键在于找到分段节点，分区间讨论计算。 画数轴 题目：商场里某商品成本上涨了 20%，售价只上涨了 10%，毛利率（利润/进货价）比以前的下降了 10 个百分点。问原来的毛利率是多少？A.10% B.20% C.30% D.40%例7，比例关系直接赋值，出现成本、售价、利润，优先只赋值成本。$\\frac{x-10}{10}-\\frac{1}{10}=\\frac{1.1x-12}{12} \\Rightarrow x=12 \\Rightarrow \\frac{12-10}{10}=0","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":".2$成本 售价 利润 毛利润 前 10 x x-10 $\\frac{x-10}{10}$ 后 10*1.2=12 1.1x 1.1x-12 $\\frac{1.1x-12}{12}$ 企业花费 600 万元升级生产线，升级后能耗费用降低了 10%，人工成本降低了 30%，如每天的产量不变，预计在 400 个工作日后收回成本，如果升级前人工成本为能耗费用的 3 倍，问升级后每天的人工成本比能耗费用高多少万元？A．1.2 B．1.5 C．1.8 D．2.4练1，回收成本=天数*节省费用，分为前后。$400(0.9x+0.1x)=600 \\Rightarrow x=1.5 \\Rightarrow 1.2x=1.2\\times1.5=1.8$人工 能耗 前 3x x 后 2.1x 0.9x 省 0.9x 0.1x 某苗木公司准备出售一批苗木，如果每株以 4 元出售，可卖出 20 万 株。若苗木单价每提高 0.4 元，就会少卖 10000 株，问在最佳定价的情况下，该公司最大收入是多少万元？A．60 B．80 C．90 D．100练6，a+b=10 ab≤25，最大问题。总收=$(4+0.4n)","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_18","order":18,"summary":".2$成本 售价 利润 毛利润 前 10 x x-10 $\\frac{x-10}{10}$ 后 10*1.2=12 1.1x 1.1x-12 $\\frac{1.1x-12}{12}$ 企业花费 600 万元升级生产线，升级后能耗费用降低了 10%，人工成本降低了 30%，如每天的产量不变，预计在 400 个工作日后收回成本，如果升级前人工成本为能耗费用的 3 倍，问升级后每天的人工成本比能耗费用高多少万元？A．1.2 B．1.5 C．1.8 D．2.4练1，回收成本=天数*节省费用，分为前后。$400(0.9x+0.1x)=600 \\Rightarrow x=1.5 \\Rightarrow 1.2x=1.2\\times1.5=1.8$人工 能耗 前 3x x 后 2.1x 0.9x 省 0.9x 0.1x 某苗木公司准备出售一批苗木，如果每株以 4 元出售，可卖出 20 万 株。若苗木单价每提高 0.4 元，就会少卖 10000 株，问在最佳定价的情况下，该公司最大收入是多少万元？A．60 B．80 C．90 D．100练6，a+b=10 ab≤25，最大问题。总收=$(4+0.4n)","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"(20-n)=0.4(10+n)(20-n)$，而$a_{10+n}+b_{20-n}=30, ab=15^2 \\Rightarrow 0.4\\times15^2=90$某公司 A 商品利润为定价的 30%，前年销量为 10 万个；B 商品利润为定价的 40%，前年销量为 4 万个。去年公司将 A、B 商品捆绑销售，售价为前年两种商品定价之和的 90%，共卖出 8 万套，总利润比前年增加了 20%。如两种商品去年的成本与前年相同，则前年 A 商品的定价为 B 商品定价的：A．24% B．25% C．30% D．36%练7，定价不打折就是售价，利润=成本-定价，列表法选A。$1.6a+2.4b=1.2(3a+1.6b) \\Rightarrow a=0.24b$成本 定价 利润 量 总利 前 0.7a a 0.3a 10 3a 前 0.6b b 0.4b 4 1.6b 前 0.7a 0.9a 0.2a 8 1.6a 前 0.6b 0.9b 0.3b 8 2.4b 最值问题 最值问题最不利构造 题型特征：至少……才能保证…… 解题方法：最不利情形＋1 数列构造 题型特征： 最多……最少…… ","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_19","order":19,"summary":"(20-n)=0.4(10+n)(20-n)$，而$a_{10+n}+b_{20-n}=30, ab=15^2 \\Rightarrow 0.4\\times15^2=90$某公司 A 商品利润为定价的 30%，前年销量为 10 万个；B 商品利润为定价的 40%，前年销量为 4 万个。去年公司将 A、B 商品捆绑销售，售价为前年两种商品定价之和的 90%，共卖出 8 万套，总利润比前年增加了 20%。如两种商品去年的成本与前年相同，则前年 A 商品的定价为 B 商品定价的：A．24% B．25% C．30% D．36%练7，定价不打折就是售价，利润=成本-定价，列表法选A。$1.6a+2.4b=1.2(3a+1.6b) \\Rightarrow a=0.24b$成本 定价 利润 量 总利 前 0.7a a 0.3a 10 3a 前 0.6b b 0.4b 4 1.6b 前 0.7a 0.9a 0.2a 8 1.6a 前 0.6b 0.9b 0.3b 8 2.4b 最值问题 最值问题最不利构造 题型特征：至少……才能保证…… 解题方法：最不利情形＋1 数列构造 题型特征： 最多……最少…… ","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"最少……最多…… 排名第……最多（少）……… 解题方法： 排序，所有元素进行排序； 定位，求谁设谁 x； 构造，根据题意构造其他元素的值； 求和，所有元素求和，解 x。 如果求得 x 为小数，问最少：向上取整，问最多：向下取整。反向取数 最少的取最大，即比次小的-1，最大的取最小，即比次大的+1，已知的具体量值不改变 多集合反向构造 题型特征：多集合题目中，问题中出现，至少……都……的情况下； 解析策略：采用逆向思考，反向，求和，做差。 各集合的对立面的数量 各集合反向数量相加 sum 总数量-sum 题目：某单位 2011 年招聘了 65 名毕业生，拟分配到该单位的 7 个不同部门。假设行政部门分得的毕业生人数比其他部门都多，问行政部门分得的毕业生人数至少为多少名？A．10 B．11 C．12 D．13例5，其他部门都多，所以设第一名为$x$，其他部门为$6(x-1)$，即$7x-6=65 \\Rightarrow x=10.143$，至少选向上取整选B有编号为 1～13 的卡片，每个编号有 4 张，共 52 张卡片。问至少摸出多少张，就可保证一定有 3 张卡片编号相连？（ ）A．27","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_20","order":20,"summary":"最少……最多…… 排名第……最多（少）……… 解题方法： 排序，所有元素进行排序； 定位，求谁设谁 x； 构造，根据题意构造其他元素的值； 求和，所有元素求和，解 x。 如果求得 x 为小数，问最少：向上取整，问最多：向下取整。反向取数 最少的取最大，即比次小的-1，最大的取最小，即比次大的+1，已知的具体量值不改变 多集合反向构造 题型特征：多集合题目中，问题中出现，至少……都……的情况下； 解析策略：采用逆向思考，反向，求和，做差。 各集合的对立面的数量 各集合反向数量相加 sum 总数量-sum 题目：某单位 2011 年招聘了 65 名毕业生，拟分配到该单位的 7 个不同部门。假设行政部门分得的毕业生人数比其他部门都多，问行政部门分得的毕业生人数至少为多少名？A．10 B．11 C．12 D．13例5，其他部门都多，所以设第一名为$x$，其他部门为$6(x-1)$，即$7x-6=65 \\Rightarrow x=10.143$，至少选向上取整选B有编号为 1～13 的卡片，每个编号有 4 张，共 52 张卡片。问至少摸出多少张，就可保证一定有 3 张卡片编号相连？（ ）A．27","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":" 张 B．29 张 C．33 张 D．37 张练4，magic。12x45x78x1011x13，即摸连续两个编号后下一个没摸到才又连续两个直到13，共9个编号。$9\\times4+1=37$在一次竞标中，评标小组对参加竞标的公司进行评分，满分 120 分。 按得分排名，前 5 名的平均分为 115 分，且得分是互不相同的整数，则第三名得分至少是（ ）A.112 分 B.113 分 C.115 分 D.116 分练5,最大的让他最大，最小的让他最小。一二名：120，119；第三名x；四五名x-1，x-2，即$3x+236=115\\times5 \\Rightarrow x=113$容斥原理 容斥原理两集合标准型公式 |𝐴| + |𝐵| − |𝐴𝐵| = 总数 − 都不满足 三集合标准 |𝐴| + |𝐵| + |𝐶| − |𝐴𝐵| − |𝐵𝐶| − |𝐴𝐶| + |𝐴𝐵𝐶| = 总数 − 都不满足 三集合非标准 |𝐴| + |𝐵| + |𝐶| − 只满足两个条件的 − 2 × 满足三个条件 = 总数 − 都不满足 使用场景：只有当题目中出现“（只）满足两个条件”时，使用非标准公式。 文氏图","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_21","order":21,"summary":" 张 B．29 张 C．33 张 D．37 张练4，magic。12x45x78x1011x13，即摸连续两个编号后下一个没摸到才又连续两个直到13，共9个编号。$9\\times4+1=37$在一次竞标中，评标小组对参加竞标的公司进行评分，满分 120 分。 按得分排名，前 5 名的平均分为 115 分，且得分是互不相同的整数，则第三名得分至少是（ ）A.112 分 B.113 分 C.115 分 D.116 分练5,最大的让他最大，最小的让他最小。一二名：120，119；第三名x；四五名x-1，x-2，即$3x+236=115\\times5 \\Rightarrow x=113$容斥原理 容斥原理两集合标准型公式 |𝐴| + |𝐵| − |𝐴𝐵| = 总数 − 都不满足 三集合标准 |𝐴| + |𝐵| + |𝐶| − |𝐴𝐵| − |𝐵𝐶| − |𝐴𝐶| + |𝐴𝐵𝐶| = 总数 − 都不满足 三集合非标准 |𝐴| + |𝐵| + |𝐶| − 只满足两个条件的 − 2 × 满足三个条件 = 总数 − 都不满足 使用场景：只有当题目中出现“（只）满足两个条件”时，使用非标准公式。 文氏图","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"法：每一个封闭区域内只有一个数字，并且代表该区域的面积。 使用原则：出现“只满足某一个条件”时，优先画图法。 不能直接代入公式的，使用画图法。 题目：有 135 人参加某单位的招聘，31 人有英语证书和普通话证书，37 人有英语证书和计算机证书，16 人有普通话证书和计算机证书，其中一部分人有三种证书，而一部分人则只有一种证书。该单位要求必须至少有两种上述证书的应聘者才有资格参加面试。问至少有多少人不能参加面试？A．50 B．51 C．52 D．53练4，反推。题目反推即能参加的最多。文氏图，设三种都有的为x，能=$31+37+16-2x=84-2x$，因为有一部分人有三种证书，则必须x=1保证才能保存能参加的最多。$135-82=53$几何问题 几何问题$\\mathrm{n}$ 边形的内角和与外角和 内角和 $=(n-2) \\times 180^{\\circ}$ , 外角和恒等于 $360^{\\circ}$常用周长公式 正方形周长 $C_{\\text {正方形 }}=4 a$ ; 长方形周长 $C_{\\text {长方形 }}=2(a+b)$ ; 圆形周长 $C_{\\text {圆 ","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_22","order":22,"summary":"法：每一个封闭区域内只有一个数字，并且代表该区域的面积。 使用原则：出现“只满足某一个条件”时，优先画图法。 不能直接代入公式的，使用画图法。 题目：有 135 人参加某单位的招聘，31 人有英语证书和普通话证书，37 人有英语证书和计算机证书，16 人有普通话证书和计算机证书，其中一部分人有三种证书，而一部分人则只有一种证书。该单位要求必须至少有两种上述证书的应聘者才有资格参加面试。问至少有多少人不能参加面试？A．50 B．51 C．52 D．53练4，反推。题目反推即能参加的最多。文氏图，设三种都有的为x，能=$31+37+16-2x=84-2x$，因为有一部分人有三种证书，则必须x=1保证才能保存能参加的最多。$135-82=53$几何问题 几何问题$\\mathrm{n}$ 边形的内角和与外角和 内角和 $=(n-2) \\times 180^{\\circ}$ , 外角和恒等于 $360^{\\circ}$常用周长公式 正方形周长 $C_{\\text {正方形 }}=4 a$ ; 长方形周长 $C_{\\text {长方形 }}=2(a+b)$ ; 圆形周长 $C_{\\text {圆 ","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"}}=2 \\pi R$ 常用面积公式 正方形面积 $S_{\\text {正方形 }}=a^{2}$ ; 长方形面积 $S_{\\text {长方形 }}=a b$ ; 圆形面积 $S_{\\text {圆 }}=\\pi R^{2}$ 三角形面积 $S_{\\text {三角形 }}=\\frac{1}{2} a h$ ; 同底等高面积相等！ 平行四边形面积 $S_{\\text {平行四边形 }}=a h$ ; 梯形面积 $S_{\\text {梯形 }}=\\frac{1}{2}(a+b) h$ ; 扇形面积 $S_{\\text {扇形 }}=\\frac{n}{360^{°}} \\pi R^{2}$ 常用表面积公式 正方体的表面积 $=6 a^{2}$ ; 长方体的表面积 $=2 \\mathrm{ab}+2 \\mathrm{bc}+2 \\mathrm{ac}$ ; 圆柱的表面积 $=2 \\pi \\mathrm{Rh}+2 \\pi R^{2}$ , 侧面积 $=2 \\pi \\mathrm{Rh}$ ; 球的表面积 $=4 \\pi R^{2}$ 常用体积公式 正方体的体积 $=a^{3}$ ; 长方体","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_23","order":23,"summary":"}}=2 \\pi R$ 常用面积公式 正方形面积 $S_{\\text {正方形 }}=a^{2}$ ; 长方形面积 $S_{\\text {长方形 }}=a b$ ; 圆形面积 $S_{\\text {圆 }}=\\pi R^{2}$ 三角形面积 $S_{\\text {三角形 }}=\\frac{1}{2} a h$ ; 同底等高面积相等！ 平行四边形面积 $S_{\\text {平行四边形 }}=a h$ ; 梯形面积 $S_{\\text {梯形 }}=\\frac{1}{2}(a+b) h$ ; 扇形面积 $S_{\\text {扇形 }}=\\frac{n}{360^{°}} \\pi R^{2}$ 常用表面积公式 正方体的表面积 $=6 a^{2}$ ; 长方体的表面积 $=2 \\mathrm{ab}+2 \\mathrm{bc}+2 \\mathrm{ac}$ ; 圆柱的表面积 $=2 \\pi \\mathrm{Rh}+2 \\pi R^{2}$ , 侧面积 $=2 \\pi \\mathrm{Rh}$ ; 球的表面积 $=4 \\pi R^{2}$ 常用体积公式 正方体的体积 $=a^{3}$ ; 长方体","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"的体积 $=\\mathrm{abc}$ ; 球的体积 $=\\frac{4}{3} \\pi R^{3}$ 圆柱的体积 $=\\pi R^{2} h$ ; 圆雉 (棱雉) 的体积 $=\\frac{1}{3} \\times S_{底} \\times h$ 勾股定理 3：4：5 5：12：13 角度及三角形 直角三角形30°：$1:\\sqrt{3}:2$ 等腰直角三角形：$1:1:\\sqrt{2}$ 等边三角形：$S=\\frac{\\sqrt{3}}{4}a^2$ 相似三角形 面积之比=边长之比的平方 等比缩放 一个几何图形，若边长变为原来的 n 倍，则: 所有对应角度不发生变化 所有对应的面积变为原来 $\\mathrm{n}^{2}$ 倍 所有对应的体积变为原来 $\\mathrm{n}^{3}$ 倍 题目：如图所示，8 块同样大小的长方形钢板拼成了一块大的长方形钢板， 已知大长方形钢板周长为 112 厘米，那么大长方形钢板的面积是( )平方厘米。 A．432 B．588 C．768 D．945例2，注意子图形的关系。2长=3宽某地市区有一个长方形广场，其面积为 1600 平方米。由此可知，这个广","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_24","order":24,"summary":"的体积 $=\\mathrm{abc}$ ; 球的体积 $=\\frac{4}{3} \\pi R^{3}$ 圆柱的体积 $=\\pi R^{2} h$ ; 圆雉 (棱雉) 的体积 $=\\frac{1}{3} \\times S_{底} \\times h$ 勾股定理 3：4：5 5：12：13 角度及三角形 直角三角形30°：$1:\\sqrt{3}:2$ 等腰直角三角形：$1:1:\\sqrt{2}$ 等边三角形：$S=\\frac{\\sqrt{3}}{4}a^2$ 相似三角形 面积之比=边长之比的平方 等比缩放 一个几何图形，若边长变为原来的 n 倍，则: 所有对应角度不发生变化 所有对应的面积变为原来 $\\mathrm{n}^{2}$ 倍 所有对应的体积变为原来 $\\mathrm{n}^{3}$ 倍 题目：如图所示，8 块同样大小的长方形钢板拼成了一块大的长方形钢板， 已知大长方形钢板周长为 112 厘米，那么大长方形钢板的面积是( )平方厘米。 A．432 B．588 C．768 D．945例2，注意子图形的关系。2长=3宽某地市区有一个长方形广场，其面积为 1600 平方米。由此可知，这个广","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"场的周长至少有（ ）。A．160 米 B．200 米 C．240 米 D．320 米例3，长度一定、面积大-\u003e圆，次大正n边形，次次大正方形即$40\\times40=1600$，或$a+b \\ge 2\\sqrt{ab}$,选A太多了，都不会年龄问题 年龄问题溶液问题方法一：代入排除法方法二：方程法核心点：每年每人长一岁，两个人的年龄差不变$\\text { 浓度 }=\\frac{\\text { 溶质 }}{\\text { 溶液 }}=\\frac{\\text { 盐 }}{\\text { 盐水总重量 }}=\\frac{\\text { 糖 }}{\\text { 糖水总重量 }}=\\frac{\\text { 酒精 }}{\\text { 酒水总重量 }}$溶质 = 溶液×浓度题目：2014 年父亲、母亲的年龄之和是年龄之差的 23 倍，年龄之差是儿子年龄的 1/5，5 年后母亲和儿子的年龄都是平方数。问 2014 年父亲的年龄是多 少？（年龄都按整数计算）A．36 岁 B．40 岁 C．44 岁 D．48 岁练1，设儿子为5x，则$5x+5=36$，1、4、9、16、25。儿子=20岁。则$fa","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_25","order":25,"summary":"场的周长至少有（ ）。A．160 米 B．200 米 C．240 米 D．320 米例3，长度一定、面积大-\u003e圆，次大正n边形，次次大正方形即$40\\times40=1600$，或$a+b \\ge 2\\sqrt{ab}$,选A太多了，都不会年龄问题 年龄问题溶液问题方法一：代入排除法方法二：方程法核心点：每年每人长一岁，两个人的年龄差不变$\\text { 浓度 }=\\frac{\\text { 溶质 }}{\\text { 溶液 }}=\\frac{\\text { 盐 }}{\\text { 盐水总重量 }}=\\frac{\\text { 糖 }}{\\text { 糖水总重量 }}=\\frac{\\text { 酒精 }}{\\text { 酒水总重量 }}$溶质 = 溶液×浓度题目：2014 年父亲、母亲的年龄之和是年龄之差的 23 倍，年龄之差是儿子年龄的 1/5，5 年后母亲和儿子的年龄都是平方数。问 2014 年父亲的年龄是多 少？（年龄都按整数计算）A．36 岁 B．40 岁 C．44 岁 D．48 岁练1，设儿子为5x，则$5x+5=36$，1、4、9、16、25。儿子=20岁。则$fa","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"+ma=23\\times4;fa-ma=4 \\Rightarrow fa=48;ma=44$.有甲、乙两种不同浓度的盐水，取 3 克甲盐水和 1 克乙盐水混合可以得到浓度为𝑥%的盐水；用 1 克甲盐水和 3 克乙盐水混合可以得到丙盐水。问用多少克甲盐水和 1 克丙盐水混合可以得到浓度为𝑥%的盐水？A．2 B．4 C．6 D．8练2，按比例调配可得x，则x盐水=3甲+1乙=a甲+丙(1/4甲+3/4乙)中甲乙比例可得x。1g丙含0.25甲0.75g乙，即甲乙比值为$\\frac{3}{1}=\\frac{a+0.25}{0.75} \\Rightarrow a=2$能得到浓度为x的盐水提高篇 牛吃草 牛吃草（例）一片草地（草以均匀的速度生长），240 头牛可以吃 6 天，200 头牛可 以吃 10 天，则这片草原可供 190 头牛吃的天数是（ ）。第一步，假设每头牛每天吃 1 份草。 第二步，假设草场原有 y 份草，每天自然生长 x 份草。 第三步 代入第一个条件“240 头牛可以吃 6 天”，草场每天减少（240-x）份，y÷(240-x)=6； 代入第二个条件“200 头牛可以吃 10 天","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_26","order":26,"summary":"+ma=23\\times4;fa-ma=4 \\Rightarrow fa=48;ma=44$.有甲、乙两种不同浓度的盐水，取 3 克甲盐水和 1 克乙盐水混合可以得到浓度为𝑥%的盐水；用 1 克甲盐水和 3 克乙盐水混合可以得到丙盐水。问用多少克甲盐水和 1 克丙盐水混合可以得到浓度为𝑥%的盐水？A．2 B．4 C．6 D．8练2，按比例调配可得x，则x盐水=3甲+1乙=a甲+丙(1/4甲+3/4乙)中甲乙比例可得x。1g丙含0.25甲0.75g乙，即甲乙比值为$\\frac{3}{1}=\\frac{a+0.25}{0.75} \\Rightarrow a=2$能得到浓度为x的盐水提高篇 牛吃草 牛吃草（例）一片草地（草以均匀的速度生长），240 头牛可以吃 6 天，200 头牛可 以吃 10 天，则这片草原可供 190 头牛吃的天数是（ ）。第一步，假设每头牛每天吃 1 份草。 第二步，假设草场原有 y 份草，每天自然生长 x 份草。 第三步 代入第一个条件“240 头牛可以吃 6 天”，草场每天减少（240-x）份，y÷(240-x)=6； 代入第二个条件“200 头牛可以吃 10 天","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"”，草场每天减少（200-x）份草，y÷(200-x)=10。 第四步，解方程 y=600，x=140，即原草场有 600 份草，每天长 140 份草。 第五步，分析计算，190 头牛每天吃 190 份草，每天长 140 份，于是草场每 天实际减少 50 份草，600÷50=12 天。 题目：某轮船发生漏水事故，漏洞处不断地匀速进水，船员发现险情后立即开启抽水机向外抽水。已知每台抽水机每分钟抽水 20 立方米，若同时使用 2 台抽水机 15 分钟能把水抽完，若同时使用 3 台抽水机 9 分钟能把水抽完。当抽水机开始向外抽水时，该轮船已进水（ ）立方米。A．360 B．450 C．540 D．600例4，设进水量为y，速率为x，则$(40-x)15=y;(60-x)9=y \\Rightarrow x=10;y=450$即B循环周期问题 循环周期核心点：若一串事物以 T 为周期，且 A÷T=N 余 a，那么第 A 项等同于第 a 项。整除是周期最后一项。题目：某政府机构内甲、乙两部门通过门户网站定期向社会发布消息，甲部门每隔 2 天、乙部门每隔 3 天有一个发布日，节假日无休。问甲、乙两部","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_27","order":27,"summary":"”，草场每天减少（200-x）份草，y÷(200-x)=10。 第四步，解方程 y=600，x=140，即原草场有 600 份草，每天长 140 份草。 第五步，分析计算，190 头牛每天吃 190 份草，每天长 140 份，于是草场每 天实际减少 50 份草，600÷50=12 天。 题目：某轮船发生漏水事故，漏洞处不断地匀速进水，船员发现险情后立即开启抽水机向外抽水。已知每台抽水机每分钟抽水 20 立方米，若同时使用 2 台抽水机 15 分钟能把水抽完，若同时使用 3 台抽水机 9 分钟能把水抽完。当抽水机开始向外抽水时，该轮船已进水（ ）立方米。A．360 B．450 C．540 D．600例4，设进水量为y，速率为x，则$(40-x)15=y;(60-x)9=y \\Rightarrow x=10;y=450$即B循环周期问题 循环周期核心点：若一串事物以 T 为周期，且 A÷T=N 余 a，那么第 A 项等同于第 a 项。整除是周期最后一项。题目：某政府机构内甲、乙两部门通过门户网站定期向社会发布消息，甲部门每隔 2 天、乙部门每隔 3 天有一个发布日，节假日无休。问甲、乙两部","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"门在一个自然月内最多有几天同时为发布日？A．5 B．2 C．6 D．3例2，每隔两天=每三天，每四天，则它们的公倍数为12，最多则从1号开始1、13、25。D某新建小区计划在小区主干道两侧种植银杏树和梧桐树绿化环境，一侧每隔 3 棵银杏树种 1 棵梧桐树，另一侧每隔 4 棵梧桐树种 1 棵银杏树，最终两侧各种植了 35 棵树，问最多栽种了多少棵银杏树？A、33 B、34 C、36 D、37例3，最多，则先种银杏树。一侧共$\\frac{35}{4}=8\\cdots3=8\\times3+3=27$，另一侧共$\\frac{35}{5}=7=7\\times1=7$，即B为维护办公环境，某办公室四人在工作日每天轮流打扫卫生，每周一打扫卫生的人给植物浇水。7 月 5 日周五轮到小玲打扫卫生，下一次小玲给植物浇水是哪天？A、7 月 15 日 B、7 月 22 日 C、7 月 29 日 D、8 月 5 日例5，5号是周五，画个日历表，数就完事了。注意是工作日和周一浇水。C星期日期问题 平年与闰年： 四年一闰，百年不闰，四百年再闰。 $(year\\% 4==0 \\\u0026\\\u0026 year\\% 100 !=0) ","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_28","order":28,"summary":"门在一个自然月内最多有几天同时为发布日？A．5 B．2 C．6 D．3例2，每隔两天=每三天，每四天，则它们的公倍数为12，最多则从1号开始1、13、25。D某新建小区计划在小区主干道两侧种植银杏树和梧桐树绿化环境，一侧每隔 3 棵银杏树种 1 棵梧桐树，另一侧每隔 4 棵梧桐树种 1 棵银杏树，最终两侧各种植了 35 棵树，问最多栽种了多少棵银杏树？A、33 B、34 C、36 D、37例3，最多，则先种银杏树。一侧共$\\frac{35}{4}=8\\cdots3=8\\times3+3=27$，另一侧共$\\frac{35}{5}=7=7\\times1=7$，即B为维护办公环境，某办公室四人在工作日每天轮流打扫卫生，每周一打扫卫生的人给植物浇水。7 月 5 日周五轮到小玲打扫卫生，下一次小玲给植物浇水是哪天？A、7 月 15 日 B、7 月 22 日 C、7 月 29 日 D、8 月 5 日例5，5号是周五，画个日历表，数就完事了。注意是工作日和周一浇水。C星期日期问题 平年与闰年： 四年一闰，百年不闰，四百年再闰。 $(year\\% 4==0 \\\u0026\\\u0026 year\\% 100 !=0) ","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"|| year\\% 100 == 0$ 大月与小月： 大月 31 天(1、3、5、7、8、10、12 月)；小月 30 天(4、6、9、11 月) 拳头凸起31天，否则30天 2 月 闰年：29 天 平年：28 天 每过一个平年（365÷7=52 余 1）星期几+1，每过一个闰年（366÷7=52 余 2） 星期几+2 星期日期推断：每连续 7 天一定包含一个完整的星期 题目：小明、小红、小桃三人定期到某棋馆学围棋，小明每隔 3 天去一次， 小红每隔 4 天去一次，小桃每隔 5 天去一次。若 2016 年 2 月 10 日三人恰好在棋馆相遇，则下次三人在棋馆相遇的日期是 ：A．2016 年 4 月 8 日 B．2016 年 4 月 11 日 C．2016 年 4 月 9 日 D．2016 年 4 月 10 日例2，巩固上节例2，一个月一个来的计算根据国务院办公厅部分节假日安排的通知，某年 8 月份有 22 个工作日，那么当年的 8 月 1 日可能是：A．周一或周三 B．周三或周日 C．周一或周四 D．周四或周日例4，算前半部分，把后面变成几个完整的星期，推断前面；如1，2，3...4*","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_29","order":29,"summary":"|| year\\% 100 == 0$ 大月与小月： 大月 31 天(1、3、5、7、8、10、12 月)；小月 30 天(4、6、9、11 月) 拳头凸起31天，否则30天 2 月 闰年：29 天 平年：28 天 每过一个平年（365÷7=52 余 1）星期几+1，每过一个闰年（366÷7=52 余 2） 星期几+2 星期日期推断：每连续 7 天一定包含一个完整的星期 题目：小明、小红、小桃三人定期到某棋馆学围棋，小明每隔 3 天去一次， 小红每隔 4 天去一次，小桃每隔 5 天去一次。若 2016 年 2 月 10 日三人恰好在棋馆相遇，则下次三人在棋馆相遇的日期是 ：A．2016 年 4 月 8 日 B．2016 年 4 月 11 日 C．2016 年 4 月 9 日 D．2016 年 4 月 10 日例2，巩固上节例2，一个月一个来的计算根据国务院办公厅部分节假日安排的通知，某年 8 月份有 22 个工作日，那么当年的 8 月 1 日可能是：A．周一或周三 B．周三或周日 C．周一或周四 D．周四或周日例4，算前半部分，把后面变成几个完整的星期，推断前面；如1，2，3...4*","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"7=28(4个星期工作日20天)。设一号是周四，则23为周五周六，设一号是周日，则23为周一周二。D，如果算8月29日，就将前面合并成完整的星期。比赛问题 比赛问题淘汰赛： 每场比赛淘汰一队，每轮比赛淘汰一半的队伍（如果总数是奇数，例如 11 个队伍一轮淘汰 5 个队伍，一支队伍轮空，保留 6 个队伍）。 单循环赛，每支队伍都要和其他队伍进行一次比赛，N 支队伍的总场次是$C_{N}^{2}=\\frac{N \\times(N-1)}{2}$ 双循环赛，每支队伍都要和其他队伍进行两场比赛（分主场和客场），N 支队伍的总场次是$A^2_N=N \\times (N-1)$ 答案小直接画图 题目：某篮球比赛有 12 支球队报名参加，比赛的第一阶段中，12 支球队平均分成 2 个组进行单循环比赛，每组前 4 名进入第二阶段；第二阶段采用单场淘汰赛，直至决出冠军。问亚军参加的场次占整个赛事总场次的比重为：A．10%以下 B．10%-15% C．15%-20% D．20%以上例3，画图可知总共单循环30场，淘汰赛7场共37场，亚军单循环打5场，淘汰赛3场。选D统筹优化 枚举法、逻辑推断，最优方法题目","date":"2023-11-08T23:00:50+08:00","objectID":"21f522e68021a5577c432f4bbfc3d624_30","order":30,"summary":"7=28(4个星期工作日20天)。设一号是周四，则23为周五周六，设一号是周日，则23为周一周二。D，如果算8月29日，就将前面合并成完整的星期。比赛问题 比赛问题淘汰赛： 每场比赛淘汰一队，每轮比赛淘汰一半的队伍（如果总数是奇数，例如 11 个队伍一轮淘汰 5 个队伍，一支队伍轮空，保留 6 个队伍）。 单循环赛，每支队伍都要和其他队伍进行一次比赛，N 支队伍的总场次是$C_{N}^{2}=\\frac{N \\times(N-1)}{2}$ 双循环赛，每支队伍都要和其他队伍进行两场比赛（分主场和客场），N 支队伍的总场次是$A^2_N=N \\times (N-1)$ 答案小直接画图 题目：某篮球比赛有 12 支球队报名参加，比赛的第一阶段中，12 支球队平均分成 2 个组进行单循环比赛，每组前 4 名进入第二阶段；第二阶段采用单场淘汰赛，直至决出冠军。问亚军参加的场次占整个赛事总场次的比重为：A．10%以下 B．10%-15% C．15%-20% D．20%以上例3，画图可知总共单循环30场，淘汰赛7场共37场，亚军单循环打5场，淘汰赛3场。选D统筹优化 枚举法、逻辑推断，最优方法题目","tags":["CivilServant"],"title":"公务员行测--数量关系","url":"http://localhost:1313/posts/learn/quantitative-relation/"},{"categories":["learn"],"content":"进程间通信 进程间通信的基本概念 管道实现进程间通信 可以看出，为了完成进程间通信，需要创建管道。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是 fork 函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。下面是创建管道的函数。1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u003e int pipe(int filedes[2]); /* 成功时返回 0 ，失败时返回 -1 filedes[0]: 通过管道接收数据时使用的文件描述符，即管道出口 filedes[1]: 通过管道传输数据时使用的文件描述符，即管道入口 */ 单向通信 1 2 3 4 5 6 7 8 9 10 // 调用 pipe 函数创建管道，fds 数组中保存用于 I/O 的文件描述符 pipe(fds); pid = fork(); //子进程将同时拥有创建管道获取的2个文件描述符，复制的并非管道，而是文件描述符 if (pid == 0) { write(fds[1], str, sizeof(str)); } else { read(fds[0], buf, ","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_0","order":0,"summary":"进程间通信 进程间通信的基本概念 管道实现进程间通信 可以看出，为了完成进程间通信，需要创建管道。管道并非属于进程的资源，而是和套接字一样，属于操作系统（也就不是 fork 函数的复制对象）。所以，两个进程通过操作系统提供的内存空间进行通信。下面是创建管道的函数。1 2 3 4 5 6 7 #include \u0026lt;unistd.h\u003e int pipe(int filedes[2]); /* 成功时返回 0 ，失败时返回 -1 filedes[0]: 通过管道接收数据时使用的文件描述符，即管道出口 filedes[1]: 通过管道传输数据时使用的文件描述符，即管道入口 */ 单向通信 1 2 3 4 5 6 7 8 9 10 // 调用 pipe 函数创建管道，fds 数组中保存用于 I/O 的文件描述符 pipe(fds); pid = fork(); //子进程将同时拥有创建管道获取的2个文件描述符，复制的并非管道，而是文件描述符 if (pid == 0) { write(fds[1], str, sizeof(str)); } else { read(fds[0], buf, ","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"BUF_SIZE); puts(buf); } 双向通信 上述单个pipe可能会导致数据接收问题，即子进程把所有数据都读完，需要sleep函数。采用下述方法好一些，但是多加一个pipe1 2 3 4 5 6 7 8 9 10 11 12 13 14 pipe(fds1), pipe(fds2); pid = fork(); if (pid == 0) { write(fds1[1], str1, sizeof(str1)); read(fds2[0], buf, BUF_SIZE); printf(\"Child proc output: %s \\n\", buf); } else { read(fds1[0], buf, BUF_SIZE); printf(\"Parent proc output: %s \\n\", buf); write(fds2[1], str2, sizeof(str2)); } 总结 进程间通信意味着两个不同的进程间可以交换数据。从内存上来说，就是两个进程可以访问同一个内存区域，然后通过这个内存区域数据的变化来进行通信。I/O 复用 基于 I/O 复用的服务器端 多","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_1","order":1,"summary":"BUF_SIZE); puts(buf); } 双向通信 上述单个pipe可能会导致数据接收问题，即子进程把所有数据都读完，需要sleep函数。采用下述方法好一些，但是多加一个pipe1 2 3 4 5 6 7 8 9 10 11 12 13 14 pipe(fds1), pipe(fds2); pid = fork(); if (pid == 0) { write(fds1[1], str1, sizeof(str1)); read(fds2[0], buf, BUF_SIZE); printf(\"Child proc output: %s \\n\", buf); } else { read(fds1[0], buf, BUF_SIZE); printf(\"Parent proc output: %s \\n\", buf); write(fds2[1], str2, sizeof(str2)); } 总结 进程间通信意味着两个不同的进程间可以交换数据。从内存上来说，就是两个进程可以访问同一个内存区域，然后通过这个内存区域数据的变化来进行通信。I/O 复用 基于 I/O 复用的服务器端 多","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"进程服务端的缺点：为了构建并发服务器，只要有客户端连接请求就会创建新进程。这的确是实际操作中采用的一种方案，但并非十全十美，因为创建进程要付出很大的代价。这需要大量的运算和内存空间，由于每个进程都具有独立的内存空间，所以相互间的数据交换也要采用相对复杂的方法（IPC 属于相对复杂的通信方法）。I/O 复用技术可以解决这个问题。无论连接多少客户端，提供服务的进程只有一个。理解 select 函数并实现服务端 select 函数是最具代表性的实现复用服务器的方法。在 Windows 平台下也有同名函数，所以具有很好的移植性。select 函数的调用过程如下图所示：设置文件描述符 利用 select 函数可以同时监视多个文件描述符。当然，监视文件描述符可以视为监视套接字。此时首先需要将要监视的文件描述符集中在一起。集中时也要按照监视项（接收、传输、异常）进行区分，即按照上述 3 种监视项分成 3 类。利用 fd_set 数组变量执行此操作，如图所示，该数组是存有0和1的位数组。图中最左端表示文件描述符 0。如果该位设置为 1，则表示该文件描述符是监视对象。图中文件描述符 1 和 3是监视对象","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_2","order":2,"summary":"进程服务端的缺点：为了构建并发服务器，只要有客户端连接请求就会创建新进程。这的确是实际操作中采用的一种方案，但并非十全十美，因为创建进程要付出很大的代价。这需要大量的运算和内存空间，由于每个进程都具有独立的内存空间，所以相互间的数据交换也要采用相对复杂的方法（IPC 属于相对复杂的通信方法）。I/O 复用技术可以解决这个问题。无论连接多少客户端，提供服务的进程只有一个。理解 select 函数并实现服务端 select 函数是最具代表性的实现复用服务器的方法。在 Windows 平台下也有同名函数，所以具有很好的移植性。select 函数的调用过程如下图所示：设置文件描述符 利用 select 函数可以同时监视多个文件描述符。当然，监视文件描述符可以视为监视套接字。此时首先需要将要监视的文件描述符集中在一起。集中时也要按照监视项（接收、传输、异常）进行区分，即按照上述 3 种监视项分成 3 类。利用 fd_set 数组变量执行此操作，如图所示，该数组是存有0和1的位数组。图中最左端表示文件描述符 0。如果该位设置为 1，则表示该文件描述符是监视对象。图中文件描述符 1 和 3是监视对象","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"。在 fd_set 变量中注册或更改值的操作都由下列宏完成。FD_ZERO(fd_set *fdset)：将 fd_set 变量所指的位全部初始化成0 FD_SET(int fd,fd_set *fdset)：在参数 fdset 指向的变量中注册文件描述符 fd 的信息 FD_CLR(int fd,fd_set *fdset)：从参数 fdset 指向的变量中清除文件描述符 fd 的信息 FD_ISSET(int fd,fd_set *fdset)：若参数 fdset 指向的变量中包含文件描述符 fd 的信息，则返回「真」 设置检查（监视）范围及超时 下面是 select 函数的定义：1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;sys/select.h\u003e #include \u0026lt;sys/time.h\u003e int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); /* 成功时返回大于 ","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_3","order":3,"summary":"。在 fd_set 变量中注册或更改值的操作都由下列宏完成。FD_ZERO(fd_set *fdset)：将 fd_set 变量所指的位全部初始化成0 FD_SET(int fd,fd_set *fdset)：在参数 fdset 指向的变量中注册文件描述符 fd 的信息 FD_CLR(int fd,fd_set *fdset)：从参数 fdset 指向的变量中清除文件描述符 fd 的信息 FD_ISSET(int fd,fd_set *fdset)：若参数 fdset 指向的变量中包含文件描述符 fd 的信息，则返回「真」 设置检查（监视）范围及超时 下面是 select 函数的定义：1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;sys/select.h\u003e #include \u0026lt;sys/time.h\u003e int select(int maxfd, fd_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout); /* 成功时返回大于 ","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"0 的值，失败时返回 -1 maxfd: 监视对象文件描述符数量 readset: 将所有关注「是否存在待读取数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。 writeset: 将所有关注「是否可传输无阻塞数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。 exceptset: 将所有关注「是否发生异常」的文件描述符注册到 fd_set 型变量，并传递其地址值。 timeout: 调用 select 函数后，为防止陷入无限阻塞的状态，传递超时(time-out)信息 返回值: 发生错误时返回 -1,超时时返回0,。因发生关注的时间返回时，返回大于0的值，该值是发生事件的文件描述符数。 */ 如上所述，select 函数用来验证 3 种监视的变化情况，根据监视项声明 3 个 fd_set 型变量，分别向其注册文件描述符信息，并把变量的地址值传递到上述函数的第二到第四个参数。但在此之前（调用 select 函数之前）需要决定下面两件事：文件描述符的监视（检查）范围是？ 如何设定 select 函数的超时时间？ 第一，文件描述符的监视范围和 select 的第","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_4","order":4,"summary":"0 的值，失败时返回 -1 maxfd: 监视对象文件描述符数量 readset: 将所有关注「是否存在待读取数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。 writeset: 将所有关注「是否可传输无阻塞数据」的文件描述符注册到 fd_set 型变量，并传递其地址值。 exceptset: 将所有关注「是否发生异常」的文件描述符注册到 fd_set 型变量，并传递其地址值。 timeout: 调用 select 函数后，为防止陷入无限阻塞的状态，传递超时(time-out)信息 返回值: 发生错误时返回 -1,超时时返回0,。因发生关注的时间返回时，返回大于0的值，该值是发生事件的文件描述符数。 */ 如上所述，select 函数用来验证 3 种监视的变化情况，根据监视项声明 3 个 fd_set 型变量，分别向其注册文件描述符信息，并把变量的地址值传递到上述函数的第二到第四个参数。但在此之前（调用 select 函数之前）需要决定下面两件事：文件描述符的监视（检查）范围是？ 如何设定 select 函数的超时时间？ 第一，文件描述符的监视范围和 select 的第","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"一个参数有关。实际上，select 函数要求通过第一个参数传递监视对象文件描述符的数量。因此，需要得到注册在 fd_set 变量中的文件描述符数。但每次新建文件描述符时，其值就会增加 1 ，故只需**将最大的文件描述符值加 1 **再传递给 select 函数即可。加 1 是因为文件描述符的值是从 0 开始的。第二，select 函数的超时时间与 select 函数的最后一个参数有关，其中 timeval 结构体定义如下：1 2 3 4 5 struct timeval { long tv_sec; long tv_usec; }; 本来 select 函数只有在监视文件描述符发生变化时才返回。如果未发生变化，就会进入阻塞状态。指定超时时间就是为了防止这种情况的发生。通过上述结构体变量，将秒数填入 tv_sec 的成员，将微秒数填入 tv_usec 的成员，然后将结构体的地址值传递到 select 函数的最后一个参数。此时，即使文件描述符未发生变化，只要过了指定时间，也可以从函数中返回。不过这种情况下， select 函数返回 0 。因此，可以通过返回值了解原因。如果不想设置超时，则传","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_5","order":5,"summary":"一个参数有关。实际上，select 函数要求通过第一个参数传递监视对象文件描述符的数量。因此，需要得到注册在 fd_set 变量中的文件描述符数。但每次新建文件描述符时，其值就会增加 1 ，故只需**将最大的文件描述符值加 1 **再传递给 select 函数即可。加 1 是因为文件描述符的值是从 0 开始的。第二，select 函数的超时时间与 select 函数的最后一个参数有关，其中 timeval 结构体定义如下：1 2 3 4 5 struct timeval { long tv_sec; long tv_usec; }; 本来 select 函数只有在监视文件描述符发生变化时才返回。如果未发生变化，就会进入阻塞状态。指定超时时间就是为了防止这种情况的发生。通过上述结构体变量，将秒数填入 tv_sec 的成员，将微秒数填入 tv_usec 的成员，然后将结构体的地址值传递到 select 函数的最后一个参数。此时，即使文件描述符未发生变化，只要过了指定时间，也可以从函数中返回。不过这种情况下， select 函数返回 0 。因此，可以通过返回值了解原因。如果不想设置超时，则传","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"递 NULL 参数。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 FD_ZERO(\u0026reads); FD_SET(serv_sock, \u0026reads); fd_max = serv_sock; while (1){ cpy_reads = reads; timeout.tv_sec = 3; timeout.tv_usec = 0; if ((fd_num = select(fd_max + 1, \u0026cpy_reads, 0, 0, \u0026timeout)) == -1) //开始监视,每次重新监听 break; if (fd_num == 0) continue; for (int i = 0; i \u0026lt; fd_max + 1; ++i) { if (FD_ISSET(i, \u0026cpy_reads)) { if (i == serv_sock) { // 等于服务器描述符 adr_sz = sizeof(clnt_adr); clnt_soc","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_6","order":6,"summary":"递 NULL 参数。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 FD_ZERO(\u0026reads); FD_SET(serv_sock, \u0026reads); fd_max = serv_sock; while (1){ cpy_reads = reads; timeout.tv_sec = 3; timeout.tv_usec = 0; if ((fd_num = select(fd_max + 1, \u0026cpy_reads, 0, 0, \u0026timeout)) == -1) //开始监视,每次重新监听 break; if (fd_num == 0) continue; for (int i = 0; i \u0026lt; fd_max + 1; ++i) { if (FD_ISSET(i, \u0026cpy_reads)) { if (i == serv_sock) { // 等于服务器描述符 adr_sz = sizeof(clnt_adr); clnt_soc","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"k = accept(serv_sock, (struct sockaddr*)\u0026clnt_adr, \u0026adr_sz); FD_SET(clnt_sock, \u0026reads); // 加入客户端描述符 if (fd_max \u0026lt; clnt_sock) fd_max = clnt_sock; printf(\"connect client: %d\\n\", clnt_sock); } else { // 等于客户端描述符 str_len = read(i, buf, BUF_SIZE); if (str_len == 0) { FD_CLR(i, \u0026reads); close(i); printf(\"close client %d\\n\", i); }else { write(i, buf, str_len); } } } } } 多种 I/O 函数 send \u0026 recv 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;sys/socket.h\u003e ssize_t send(int sockfd, const void *b","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_7","order":7,"summary":"k = accept(serv_sock, (struct sockaddr*)\u0026clnt_adr, \u0026adr_sz); FD_SET(clnt_sock, \u0026reads); // 加入客户端描述符 if (fd_max \u0026lt; clnt_sock) fd_max = clnt_sock; printf(\"connect client: %d\\n\", clnt_sock); } else { // 等于客户端描述符 str_len = read(i, buf, BUF_SIZE); if (str_len == 0) { FD_CLR(i, \u0026reads); close(i); printf(\"close client %d\\n\", i); }else { write(i, buf, str_len); } } } } } 多种 I/O 函数 send \u0026 recv 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;sys/socket.h\u003e ssize_t send(int sockfd, const void *b","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"uf, size_t nbytes, int flags); /* 成功时返回发送的字节数，失败时返回 -1 sockfd: 表示与数据传输对象的连接的套接字和文件描述符 buf: 保存待传输数据的缓冲地址值 nbytes: 待传输字节数 flags: 传输数据时指定的可选项信息 */ ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); /* 成功时返回接收的字节数（收到 EOF 返回 0），失败时返回 -1 sockfd: 表示数据接受对象的连接的套接字文件描述符 buf: 保存接受数据的缓冲地址值 nbytes: 可接收的最大字节数 flags: 接收数据时指定的可选项参数 */ send 和 recv 函数的最后一个参数是收发数据的可选项，该选项可以用位或（bit OR）运算符同时传递多个信息 (MSG_OOB | MSG_PEEK )send \u0026 recv 函数的可选项意义：可选项（Option） 含义 send recv MSG_OOB 用于传输带外数据（Out-of-band data） O O MS","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_8","order":8,"summary":"uf, size_t nbytes, int flags); /* 成功时返回发送的字节数，失败时返回 -1 sockfd: 表示与数据传输对象的连接的套接字和文件描述符 buf: 保存待传输数据的缓冲地址值 nbytes: 待传输字节数 flags: 传输数据时指定的可选项信息 */ ssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); /* 成功时返回接收的字节数（收到 EOF 返回 0），失败时返回 -1 sockfd: 表示数据接受对象的连接的套接字文件描述符 buf: 保存接受数据的缓冲地址值 nbytes: 可接收的最大字节数 flags: 接收数据时指定的可选项参数 */ send 和 recv 函数的最后一个参数是收发数据的可选项，该选项可以用位或（bit OR）运算符同时传递多个信息 (MSG_OOB | MSG_PEEK )send \u0026 recv 函数的可选项意义：可选项（Option） 含义 send recv MSG_OOB 用于传输带外数据（Out-of-band data） O O MS","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"G_PEEK 验证输入缓冲中是否存在接受的数据，不会清空缓冲区数据 X O MSG_DONTROUTE 数据传输过程中不参照本地路由（Routing）表，在本地（Local）网络中寻找目的地 O X MSG_DONTWAIT 调用 I/O 函数时不阻塞，用于使用非阻塞（Non-blocking）I/O O O MSG_WAITALL 防止函数返回，直到接收到全部请求的字节数 X O MSG_OOB：发送紧急消息 代码参考：https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch13/oob_recv.chttps://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch13/oob_send.c代码中关于:fcntl(recv_sock, F_SETOWN, getpid());的意思是：文件描述符 recv_sock 指向的套接字引发的 SIGURG 信号处理进程变为 getpid 函数返回值用作 ID 进程.上述描述中的「处理 SIGURG 信号」指的是「调用 S","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_9","order":9,"summary":"G_PEEK 验证输入缓冲中是否存在接受的数据，不会清空缓冲区数据 X O MSG_DONTROUTE 数据传输过程中不参照本地路由（Routing）表，在本地（Local）网络中寻找目的地 O X MSG_DONTWAIT 调用 I/O 函数时不阻塞，用于使用非阻塞（Non-blocking）I/O O O MSG_WAITALL 防止函数返回，直到接收到全部请求的字节数 X O MSG_OOB：发送紧急消息 代码参考：https://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch13/oob_recv.chttps://github.com/riba2534/TCP-IP-NetworkNote/blob/master/ch13/oob_send.c代码中关于:fcntl(recv_sock, F_SETOWN, getpid());的意思是：文件描述符 recv_sock 指向的套接字引发的 SIGURG 信号处理进程变为 getpid 函数返回值用作 ID 进程.上述描述中的「处理 SIGURG 信号」指的是「调用 S","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"IGURG 信号处理函数」。但是之前讲过，多个进程可以拥有 1 个套接字的文件描述符。例如，通过调用 fork 函数创建子进程并同时复制文件描述符。此时如果发生 SIGURG 信号，应该调用哪个进程的信号处理函数呢？可以肯定的是，不会调用所有进程的信号处理函数。因此，处理 SIGURG 信号时必须指定处理信号所用的进程，而 getpid 返回的是调用此函数的进程 ID 。上述调用语句指当前为处理 SIGURG 信号的主体。输出结果，可能出乎意料：通过 MSG_OOB 可选项传递数据时只返回 1 个字节，而且也不快的确，通过 MSG_OOB 并不会加快传输速度，而通过信号处理函数 urg_handler 也只能读取一个字节。剩余数据只能通过未设置 MSG_OOB 可选项的普通输入函数读取。因为 TCP 不存在真正意义上的「外带数据」。实际上，MSG_OOB 中的 OOB 指的是 Out-of-band ，而「外带数据」的含义是：通过完全不同的通信路径传输的数据即真正意义上的 Out-of-band 需要通过单独的通信路径高速传输数据，但是 TCP 不另外提供，只利用 TCP 的紧急模式（","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_10","order":10,"summary":"IGURG 信号处理函数」。但是之前讲过，多个进程可以拥有 1 个套接字的文件描述符。例如，通过调用 fork 函数创建子进程并同时复制文件描述符。此时如果发生 SIGURG 信号，应该调用哪个进程的信号处理函数呢？可以肯定的是，不会调用所有进程的信号处理函数。因此，处理 SIGURG 信号时必须指定处理信号所用的进程，而 getpid 返回的是调用此函数的进程 ID 。上述调用语句指当前为处理 SIGURG 信号的主体。输出结果，可能出乎意料：通过 MSG_OOB 可选项传递数据时只返回 1 个字节，而且也不快的确，通过 MSG_OOB 并不会加快传输速度，而通过信号处理函数 urg_handler 也只能读取一个字节。剩余数据只能通过未设置 MSG_OOB 可选项的普通输入函数读取。因为 TCP 不存在真正意义上的「外带数据」。实际上，MSG_OOB 中的 OOB 指的是 Out-of-band ，而「外带数据」的含义是：通过完全不同的通信路径传输的数据即真正意义上的 Out-of-band 需要通过单独的通信路径高速传输数据，但是 TCP 不另外提供，只利用 TCP 的紧急模式（","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"Urgent mode）进行传输。紧急模式工作原理指定 MSG_OOB 选项的数据包本身就是紧急数据包，并通过紧急指针表示紧急消息所在的位置。紧急消息的意义在于督促消息处理，而非紧急传输形式受限的信息。检查输入缓冲 同时设置 MSG_PEEK 选项和 MSG_DONTWAIT 选项，以验证输入缓冲是否存在接收的数据。设置 MSG_PEEK 选项并调用 recv 函数时，即使读取了输入缓冲的数据也不会删除。因此，该选项通常与 MSG_DONTWAIT （会删除数据）合作，用于以非阻塞方式验证待读数据存在与否。readv \u0026 writev 函数 readv \u0026 writev 函数的功能可概括如下：对数据进行整合传输及发送的函数也就是说，通过 writev 函数可以将分散保存在多个缓冲中的数据一并发送，通过 readv 函数可以由多个缓冲分别接收。因此，使用这 2 个函数可以减少 I/O 函数的调用次数。writev 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;sys/uio.h\u003e ssize_t writev(int filedes, con","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_11","order":11,"summary":"Urgent mode）进行传输。紧急模式工作原理指定 MSG_OOB 选项的数据包本身就是紧急数据包，并通过紧急指针表示紧急消息所在的位置。紧急消息的意义在于督促消息处理，而非紧急传输形式受限的信息。检查输入缓冲 同时设置 MSG_PEEK 选项和 MSG_DONTWAIT 选项，以验证输入缓冲是否存在接收的数据。设置 MSG_PEEK 选项并调用 recv 函数时，即使读取了输入缓冲的数据也不会删除。因此，该选项通常与 MSG_DONTWAIT （会删除数据）合作，用于以非阻塞方式验证待读数据存在与否。readv \u0026 writev 函数 readv \u0026 writev 函数的功能可概括如下：对数据进行整合传输及发送的函数也就是说，通过 writev 函数可以将分散保存在多个缓冲中的数据一并发送，通过 readv 函数可以由多个缓冲分别接收。因此，使用这 2 个函数可以减少 I/O 函数的调用次数。writev 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;sys/uio.h\u003e ssize_t writev(int filedes, con","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"st struct iovec *iov, int iovcnt); /* 成功时返回发送的字节数，失败时返回 -1 filedes: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 read 一样向向其传递文件或标准输出描述符. iov: iovec 结构体数组的地址值，结构体 iovec 中包含待发送数据的位置和大小信息 iovcnt: 向第二个参数传递数组长度 */ struct iovec { void *iov_base; //缓冲地址 size_t iov_len; //缓冲大小 }; writev 的第一个参数，是文件描述符，因此‘1’代表向控制台输出数据，ptr 是存有待发送数据信息的 iovec 数组指针。第三个参数为 2，因此，从 ptr 指向的地址开始，共浏览 2 个 iovec 结构体变量，发送这些指针指向的缓冲数据。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u003e #include \u0026lt;sys/uio.h\u003e int main(int arg","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_12","order":12,"summary":"st struct iovec *iov, int iovcnt); /* 成功时返回发送的字节数，失败时返回 -1 filedes: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 read 一样向向其传递文件或标准输出描述符. iov: iovec 结构体数组的地址值，结构体 iovec 中包含待发送数据的位置和大小信息 iovcnt: 向第二个参数传递数组长度 */ struct iovec { void *iov_base; //缓冲地址 size_t iov_len; //缓冲大小 }; writev 的第一个参数，是文件描述符，因此‘1’代表向控制台输出数据，ptr 是存有待发送数据信息的 iovec 数组指针。第三个参数为 2，因此，从 ptr 指向的地址开始，共浏览 2 个 iovec 结构体变量，发送这些指针指向的缓冲数据。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u003e #include \u0026lt;sys/uio.h\u003e int main(int arg","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"c, char *argv[]) { struct iovec vec[2]; char buf1[] = \"ABCDEFG\"; char buf2[] = \"1234567\"; int str_len; vec[0].iov_base = buf1; vec[0].iov_len = 3; vec[1].iov_base = buf2; vec[1].iov_len = 4; str_len = writev(1, vec, 2); puts(\"\"); printf(\"Write bytes: %d \\n\", str_len); return 0; } readv 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;sys/uio.h\u003e ssize_t readv(int filedes, const struct iovc *iov, int iovcnt); /* 成功时返回接收的字节数，失败时返回 -1 filed","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_13","order":13,"summary":"c, char *argv[]) { struct iovec vec[2]; char buf1[] = \"ABCDEFG\"; char buf2[] = \"1234567\"; int str_len; vec[0].iov_base = buf1; vec[0].iov_len = 3; vec[1].iov_base = buf2; vec[1].iov_len = 4; str_len = writev(1, vec, 2); puts(\"\"); printf(\"Write bytes: %d \\n\", str_len); return 0; } readv 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;sys/uio.h\u003e ssize_t readv(int filedes, const struct iovc *iov, int iovcnt); /* 成功时返回接收的字节数，失败时返回 -1 filed","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"es: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 write 一样向向其传递文件或标准输出描述符. iov: iovec 结构体数组的地址值，结构体 iovec 中包含待数据保存的位置和大小信息 iovcnt: 第二个参数中数组的长度 */ #include \u0026lt;stdio.h\u003e #include \u0026lt;sys/uio.h\u003e #define BUF_SIZE 100 int main(int argc, char *argv[]) { struct iovec vec[2]; char buf1[BUF_SIZE] = { 0, }; char buf2[BUF_SIZE] = { 0, }; int str_len; vec[0].iov_base = buf1; vec[0].iov_len = 5; // 先收取5个 vec[1].iov_base = buf2; vec[1].iov_len = BUF_SIZE; // 再接收剩下100个 // 0 控制台输入 str_len = readv(0, vec, 2); printf(\"Re","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_14","order":14,"summary":"es: 表示数据传输对象的套接字文件描述符。但该函数并不仅限于套接字，因此，可以像 write 一样向向其传递文件或标准输出描述符. iov: iovec 结构体数组的地址值，结构体 iovec 中包含待数据保存的位置和大小信息 iovcnt: 第二个参数中数组的长度 */ #include \u0026lt;stdio.h\u003e #include \u0026lt;sys/uio.h\u003e #define BUF_SIZE 100 int main(int argc, char *argv[]) { struct iovec vec[2]; char buf1[BUF_SIZE] = { 0, }; char buf2[BUF_SIZE] = { 0, }; int str_len; vec[0].iov_base = buf1; vec[0].iov_len = 5; // 先收取5个 vec[1].iov_base = buf2; vec[1].iov_len = BUF_SIZE; // 再接收剩下100个 // 0 控制台输入 str_len = readv(0, vec, 2); printf(\"Re","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"ad bytes: %d \\n\", str_len); printf(\"First message: %s \\n\", buf1); printf(\"Second message: %s \\n\", buf2); return 0; } 合理使用 readv \u0026 writev 函数 实际上，能使用该函数的所有情况都适用。例如，需要传输的数据分别位于不同缓冲（数组）时，需要多次调用 write 函数。此时可通过 1 次 writev 函数调用替代操作，当然会提高效率。同样，需要将输入缓冲中的数据读入不同位置时，可以不必多次调用 read 函数，而是利用 1 次 readv 函数就能大大提高效率。其意义在于减少数据包个数。假设为了提高效率在服务器端明确禁用了 Nagle 算法。其实 writev 函数在不采用 Nagle 算法时更有价值，如图：多播与广播 多播 多播（Multicast）方式的数据传输是基于 UDP 完成的。因此 ，与 UDP 服务器端/客户端的实现方式非常接近。区别在于，UDP 数据传输以单一目标进行，而多播数据同时传递到加入（注册）特定组的大量主机。换言之，采用多播方式时，","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_15","order":15,"summary":"ad bytes: %d \\n\", str_len); printf(\"First message: %s \\n\", buf1); printf(\"Second message: %s \\n\", buf2); return 0; } 合理使用 readv \u0026 writev 函数 实际上，能使用该函数的所有情况都适用。例如，需要传输的数据分别位于不同缓冲（数组）时，需要多次调用 write 函数。此时可通过 1 次 writev 函数调用替代操作，当然会提高效率。同样，需要将输入缓冲中的数据读入不同位置时，可以不必多次调用 read 函数，而是利用 1 次 readv 函数就能大大提高效率。其意义在于减少数据包个数。假设为了提高效率在服务器端明确禁用了 Nagle 算法。其实 writev 函数在不采用 Nagle 算法时更有价值，如图：多播与广播 多播 多播（Multicast）方式的数据传输是基于 UDP 完成的。因此 ，与 UDP 服务器端/客户端的实现方式非常接近。区别在于，UDP 数据传输以单一目标进行，而多播数据同时传递到加入（注册）特定组的大量主机。换言之，采用多播方式时，","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"可以同时向多个主机传递数据。多播的数据传输方式以及流量方面的优点 多播的数据传输特点可整理如下：多播服务器端针对特定多播组，只发送 1 次数据。 即使只发送 1 次数据，但该组内的所有客户端都会接收数据 多播组数可以在 IP 地址范围内任意增加 多播组是 D 类IP地址（224.0.0.0~239.255.255.255），「加入多播组」可以理解为通过程序完成如下声明：在 D 类IP地址中，我希望接收发往目标 239.234.218.234 的多播数据多播是基于 UDP 完成的，也就是说，多播数据包的格式与 UDP 数据包相同。只是与一般的 UDP 数据包不同。向网络传递 1 个多播数据包时，路由器将复制该数据包并传递到多个主机。像这样，多播需要借助路由器完成。如图所示：若通过 TCP 或 UDP 向 1000 个主机发送文件，则共需要传递 1000 次。但是此时如果用多播网络传输文件，则只需要发送一次。这时由 1000 台主机构成的网络中的路由器负责复制文件并传递到主机。就因为这种特性，多播主要用于「多媒体数据实时传输」。另外，理论上可以完成多播通信，但是不少路由器并不支持多播，或即","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_16","order":16,"summary":"可以同时向多个主机传递数据。多播的数据传输方式以及流量方面的优点 多播的数据传输特点可整理如下：多播服务器端针对特定多播组，只发送 1 次数据。 即使只发送 1 次数据，但该组内的所有客户端都会接收数据 多播组数可以在 IP 地址范围内任意增加 多播组是 D 类IP地址（224.0.0.0~239.255.255.255），「加入多播组」可以理解为通过程序完成如下声明：在 D 类IP地址中，我希望接收发往目标 239.234.218.234 的多播数据多播是基于 UDP 完成的，也就是说，多播数据包的格式与 UDP 数据包相同。只是与一般的 UDP 数据包不同。向网络传递 1 个多播数据包时，路由器将复制该数据包并传递到多个主机。像这样，多播需要借助路由器完成。如图所示：若通过 TCP 或 UDP 向 1000 个主机发送文件，则共需要传递 1000 次。但是此时如果用多播网络传输文件，则只需要发送一次。这时由 1000 台主机构成的网络中的路由器负责复制文件并传递到主机。就因为这种特性，多播主要用于「多媒体数据实时传输」。另外，理论上可以完成多播通信，但是不少路由器并不支持多播，或即","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"便支持也因网络拥堵问题故意阻断多播。因此，为了在不支持多播的路由器中完成多播通信，也会使用隧道（Tunneling）技术。路由（Routing）和 TTL（Time to Live,生存时间），以及加入组的办法 为了传递多播数据包，必须设置 TTL 。TTL 是 Time to Live的简写，是决定「数据包传递距离」的主要因素。TTL 用整数表示，并且每经过一个路由器就减一。TTL 变为 0 时，该数据包就无法再被传递，只能销毁。因此，TTL 的值设置过大将影响网络流量。当然，设置过小，也无法传递到目标。TTL 是可以通过第九章的套接字可选项完成的。与设置 TTL 相关的协议层为 IPPROTO_IP ，选项名为 IP_MULTICAST_TTL。用如下代码把 TTL 设置为 64:1 2 3 4 5 6 int send_sock; int time_live = 64; ... send_sock=socket(PF_INET,SOCK_DGRAM,0); setsockopt(send_sock,IPPROTO_IP,IP_MULTICAST_TTL,(void*)\u0026time_","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_17","order":17,"summary":"便支持也因网络拥堵问题故意阻断多播。因此，为了在不支持多播的路由器中完成多播通信，也会使用隧道（Tunneling）技术。路由（Routing）和 TTL（Time to Live,生存时间），以及加入组的办法 为了传递多播数据包，必须设置 TTL 。TTL 是 Time to Live的简写，是决定「数据包传递距离」的主要因素。TTL 用整数表示，并且每经过一个路由器就减一。TTL 变为 0 时，该数据包就无法再被传递，只能销毁。因此，TTL 的值设置过大将影响网络流量。当然，设置过小，也无法传递到目标。TTL 是可以通过第九章的套接字可选项完成的。与设置 TTL 相关的协议层为 IPPROTO_IP ，选项名为 IP_MULTICAST_TTL。用如下代码把 TTL 设置为 64:1 2 3 4 5 6 int send_sock; int time_live = 64; ... send_sock=socket(PF_INET,SOCK_DGRAM,0); setsockopt(send_sock,IPPROTO_IP,IP_MULTICAST_TTL,(void*)\u0026time_","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"live,sizeof(time_live); ... 加入多播组也通过设置套接字可选项来完成。加入多播组相关的协议层也为 IPPROTO_IP，选项名为 IP_ADD_MEMBERSHIP 。可通过如下代码加入多播组：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int recv_sock; struct ip_mreq join_adr; ... recv_sock=socket(PF_INET,SOCK_DGRAM,0); ... join_adr.imr_multiaddr.s_addr=\"多播组地址信息\"; join_adr.imr_interface.s_addr=\"加入多播组的主机地址信息\"; setsockopt(recv_sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,(void*)\u0026join_adr,sizeof(join_adr); ... \"\"\" struct ip_mreq { struct in_addr imr_multiaddr; // 多播组的IP地址 struct in_addr imr_inter","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_18","order":18,"summary":"live,sizeof(time_live); ... 加入多播组也通过设置套接字可选项来完成。加入多播组相关的协议层也为 IPPROTO_IP，选项名为 IP_ADD_MEMBERSHIP 。可通过如下代码加入多播组：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int recv_sock; struct ip_mreq join_adr; ... recv_sock=socket(PF_INET,SOCK_DGRAM,0); ... join_adr.imr_multiaddr.s_addr=\"多播组地址信息\"; join_adr.imr_interface.s_addr=\"加入多播组的主机地址信息\"; setsockopt(recv_sock,IPPROTO_IP,IP_ADD_MEMBERSHIP,(void*)\u0026join_adr,sizeof(join_adr); ... \"\"\" struct ip_mreq { struct in_addr imr_multiaddr; // 多播组的IP地址 struct in_addr imr_inter","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"face; // 待加入的IP地址 }; \"\"\" 实现多播 Sender 和 Receiver news_sender.c news_receiver.c 代码中recviver不会停止，阻塞等待sender消息 延迟运行 receiver 将无法接受之前发送的信息。 广播 多播即使在跨越不同网络的情况下，只要加入多播组就能接受数据。相反，广播只能向同一网络中的主机传输数据。多播传输数据的范围有区别。广播的理解和实现方式 广播是向同一网络中的所有主机传输数据的方法。与多播相同，广播也是通过 UDP 来完成的。根据传输数据时使用的IP地址形式，广播分为以下两种：直接广播（Directed Broadcast） 本地广播（Local Broadcast） 二者在实现上的差别主要在于IP地址。直接广播的IP地址中除了网络地址外，其余主机地址全部设置成 1。例如，希望向网络地址 192.12.34 中的所有主机传输数据时，可以向 192.12.34.255 传输。换言之，可以采取直接广播的方式向特定区域内所有主机传输数据。反之，本地广播中使用的IP地址限定为 255.255.255.255 。","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_19","order":19,"summary":"face; // 待加入的IP地址 }; \"\"\" 实现多播 Sender 和 Receiver news_sender.c news_receiver.c 代码中recviver不会停止，阻塞等待sender消息 延迟运行 receiver 将无法接受之前发送的信息。 广播 多播即使在跨越不同网络的情况下，只要加入多播组就能接受数据。相反，广播只能向同一网络中的主机传输数据。多播传输数据的范围有区别。广播的理解和实现方式 广播是向同一网络中的所有主机传输数据的方法。与多播相同，广播也是通过 UDP 来完成的。根据传输数据时使用的IP地址形式，广播分为以下两种：直接广播（Directed Broadcast） 本地广播（Local Broadcast） 二者在实现上的差别主要在于IP地址。直接广播的IP地址中除了网络地址外，其余主机地址全部设置成 1。例如，希望向网络地址 192.12.34 中的所有主机传输数据时，可以向 192.12.34.255 传输。换言之，可以采取直接广播的方式向特定区域内所有主机传输数据。反之，本地广播中使用的IP地址限定为 255.255.255.255 。","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"例如，192.32.24 网络中的主机向 255.255.255.255 传输数据时，数据将传输到 192.32.24 网络中所有主机。数据通信中使用的IP地址是与 UDP 示例的唯一区别。默认生成的套接字会阻止广播，因此，只需通过如下代码更改默认设置。1 2 3 4 int send_sock; int bcast; send_sock=socket(PF_INET,SOCK_DGRAM,0); setsockopt(send_sock,SOL_SOCKET,SO_BROADCAST,(void*)\u0026bcast,sizeof(bcast)); 下面是广播数据的 Sender 和 Receiver的代码：news_sender_brd.c news_receiver_brd.c 套接字和标准I/O 标准 I/O 的优缺点 优点 标准 I/O 函数具有良好的移植性 标准 I/O 函数可以利用缓冲提高性能 缺点 不容易进行双向通信 有时可能频繁调用 fflush 函数 需要以 FILE 结构体指针的形式返回文件描述符。 创建套接字时，操作系统会准备 I/O 缓冲。此缓冲在执行 TCP 协议","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_20","order":20,"summary":"例如，192.32.24 网络中的主机向 255.255.255.255 传输数据时，数据将传输到 192.32.24 网络中所有主机。数据通信中使用的IP地址是与 UDP 示例的唯一区别。默认生成的套接字会阻止广播，因此，只需通过如下代码更改默认设置。1 2 3 4 int send_sock; int bcast; send_sock=socket(PF_INET,SOCK_DGRAM,0); setsockopt(send_sock,SOL_SOCKET,SO_BROADCAST,(void*)\u0026bcast,sizeof(bcast)); 下面是广播数据的 Sender 和 Receiver的代码：news_sender_brd.c news_receiver_brd.c 套接字和标准I/O 标准 I/O 的优缺点 优点 标准 I/O 函数具有良好的移植性 标准 I/O 函数可以利用缓冲提高性能 缺点 不容易进行双向通信 有时可能频繁调用 fflush 函数 需要以 FILE 结构体指针的形式返回文件描述符。 创建套接字时，操作系统会准备 I/O 缓冲。此缓冲在执行 TCP 协议","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"时发挥着非常重要的作用。此时若使用标准 I/O 函数，将得到额外的缓冲支持。如下图：假设使用 fputs 函数进行传输字符串 「Hello」时，首先将数据传递到标准 I/O 缓冲，然后将数据移动到套接字输出缓冲，最后fflush将字符串发送到对方主机。使用标准 I/O 函数 利用 fdopen 函数转换为 FILE 结构体指针 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u003e FILE *fdopen(int fildes, const char *mode); /* 将文件描述符转换为标准IO 成功时返回转换的 FILE 结构体指针，失败时返回 NULL fildes ： 需要转换的文件描述符 mode ： 将要创建的 FILE 结构体指针的模式信息 */ 利用 fileno 函数转换为文件描述符 1 2 3 4 5 #include \u0026lt;stdio.h\u003e int fileno(FILE *stream); /* 成功时返回文件描述符，失败时返回 -1 */ 基于套接字的标准 I/O 函数使用 把第四章的回声客户端和回声服务端的内容改为基于标准 I/O ","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_21","order":21,"summary":"时发挥着非常重要的作用。此时若使用标准 I/O 函数，将得到额外的缓冲支持。如下图：假设使用 fputs 函数进行传输字符串 「Hello」时，首先将数据传递到标准 I/O 缓冲，然后将数据移动到套接字输出缓冲，最后fflush将字符串发送到对方主机。使用标准 I/O 函数 利用 fdopen 函数转换为 FILE 结构体指针 1 2 3 4 5 6 7 8 #include \u0026lt;stdio.h\u003e FILE *fdopen(int fildes, const char *mode); /* 将文件描述符转换为标准IO 成功时返回转换的 FILE 结构体指针，失败时返回 NULL fildes ： 需要转换的文件描述符 mode ： 将要创建的 FILE 结构体指针的模式信息 */ 利用 fileno 函数转换为文件描述符 1 2 3 4 5 #include \u0026lt;stdio.h\u003e int fileno(FILE *stream); /* 成功时返回文件描述符，失败时返回 -1 */ 基于套接字的标准 I/O 函数使用 把第四章的回声客户端和回声服务端的内容改为基于标准 I/O ","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"函数的数据交换形式。代码如下：echo_client.c echo_stdserv.c I/O 流分离的其他内容 之前两种分离方法：第一种是「TCP I/O 过程」分离。通过调用 fork 函数复制出一个文件描述符，以区分输入和输出中使用的文件描述符。虽然文件描述符本身不会根据输入和输出进行区分，但我们分开了 2 个文件描述符的用途，因此，这也属于「流」的分离。 第二种分离是通过 2 次调用fdopen 函数，创建读模式 FILE 指针（FILE 结构体指针）和写模式 FILE 指针。换言之，我们分离了输入工具和输出工具，因此也可视为「流」的分离。下面是分离的理由。 分离「流」的好处 首先是fork的分离目的：通过分开输入过程（代码）和输出过程降低实现难度 与输入无关的输出操作可以提高速度 下面是fdopen分离的目的：为了将 FILE 指针按读模式和写模式加以区分 可以通过区分读写模式降低实现难度 通过区分 I/O 缓冲提高缓冲性能 「流」分离带来的 EOF 问题 close()一个fdopen会关闭整个套接字只需要创建 FILE 指针前先复制文件描述符即可。复制后另外创建一个文件描","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_22","order":22,"summary":"函数的数据交换形式。代码如下：echo_client.c echo_stdserv.c I/O 流分离的其他内容 之前两种分离方法：第一种是「TCP I/O 过程」分离。通过调用 fork 函数复制出一个文件描述符，以区分输入和输出中使用的文件描述符。虽然文件描述符本身不会根据输入和输出进行区分，但我们分开了 2 个文件描述符的用途，因此，这也属于「流」的分离。 第二种分离是通过 2 次调用fdopen 函数，创建读模式 FILE 指针（FILE 结构体指针）和写模式 FILE 指针。换言之，我们分离了输入工具和输出工具，因此也可视为「流」的分离。下面是分离的理由。 分离「流」的好处 首先是fork的分离目的：通过分开输入过程（代码）和输出过程降低实现难度 与输入无关的输出操作可以提高速度 下面是fdopen分离的目的：为了将 FILE 指针按读模式和写模式加以区分 可以通过区分读写模式降低实现难度 通过区分 I/O 缓冲提高缓冲性能 「流」分离带来的 EOF 问题 close()一个fdopen会关闭整个套接字只需要创建 FILE 指针前先复制文件描述符即可。复制后另外创建一个文件描","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"述符，然后利用各自的文件描述符生成读模式的 FILE 指针和写模式的 FILE 指针。这就为半关闭创造好了环境，因为套接字和文件描述符具有如下关系：销毁所有文件描述符候才能销毁套接字也就是说，针对写模式 FILE 指针调用 fclose 函数时，只能销毁与该 FILE 指针相关的文件描述符，无法销毁套接字。那么调用 fclose 函数候还剩下 1 个文件描述符，因此没有销毁套接字。那此时的状态是否为半关闭状态？不是！只是准备好了进入半关闭状态，而不是已经进入了半关闭状态。仔细观察，还剩下一个文件描述符。而该文件描述符可以同时进行 I/O 。因此，不但没有发送 EOF ，而且仍然可以利用文件描述符进行输出。流的分离 复制文件描述符，使用dup/dup2函数 与调用 fork 函数不同，调用 fork 函数将复制整个进程，此处讨论的是同一进程内完成对完成描述符的复制。如图：1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;unistd.h\u003e int dup(int fildes); int dup2(int fildes, int fildes2); /* 成","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_23","order":23,"summary":"述符，然后利用各自的文件描述符生成读模式的 FILE 指针和写模式的 FILE 指针。这就为半关闭创造好了环境，因为套接字和文件描述符具有如下关系：销毁所有文件描述符候才能销毁套接字也就是说，针对写模式 FILE 指针调用 fclose 函数时，只能销毁与该 FILE 指针相关的文件描述符，无法销毁套接字。那么调用 fclose 函数候还剩下 1 个文件描述符，因此没有销毁套接字。那此时的状态是否为半关闭状态？不是！只是准备好了进入半关闭状态，而不是已经进入了半关闭状态。仔细观察，还剩下一个文件描述符。而该文件描述符可以同时进行 I/O 。因此，不但没有发送 EOF ，而且仍然可以利用文件描述符进行输出。流的分离 复制文件描述符，使用dup/dup2函数 与调用 fork 函数不同，调用 fork 函数将复制整个进程，此处讨论的是同一进程内完成对完成描述符的复制。如图：1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;unistd.h\u003e int dup(int fildes); int dup2(int fildes, int fildes2); /* 成","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"功时返回复制的文件描述符，失败时返回 -1 fildes : 需要复制的文件描述符 fildes2 : 明确指定的文件描述符的整数值。 dup2 函数明确指定复制的文件描述符的整数值。 向其传递大于 0 且小于进程能生成的最大文件描述符值时， 该值将成为复制出的文件描述符值。 0 stdin；1 stdout；2 error */ 使用shutdown，半关闭描述符 shutdown(fileno(writefp), SHUT_WR); close(writefp) It's important to note that shutdown() doesn't actually close the file descriptor—it just changes its usability. To free a socket descriptor, you need to use close(). 优于 select 的 epoll epoll 理解及应用 select 复用方法由来已久，因此，利用该技术后，无论如何优化程序性能也无法同时介入上百个客户端。基于 select 的 I/O 复","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_24","order":24,"summary":"功时返回复制的文件描述符，失败时返回 -1 fildes : 需要复制的文件描述符 fildes2 : 明确指定的文件描述符的整数值。 dup2 函数明确指定复制的文件描述符的整数值。 向其传递大于 0 且小于进程能生成的最大文件描述符值时， 该值将成为复制出的文件描述符值。 0 stdin；1 stdout；2 error */ 使用shutdown，半关闭描述符 shutdown(fileno(writefp), SHUT_WR); close(writefp) It's important to note that shutdown() doesn't actually close the file descriptor—it just changes its usability. To free a socket descriptor, you need to use close(). 优于 select 的 epoll epoll 理解及应用 select 复用方法由来已久，因此，利用该技术后，无论如何优化程序性能也无法同时介入上百个客户端。基于 select 的 I/O 复","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"用技术速度慢的原因 第 12 章实现了基于 select 的 I/O 复用技术服务端，其中有不合理的设计如下：调用 select 函数后常见的针对所有文件描述符的循环语句 每次调用 select 函数时都需要向该函数传递监视对象信息 上述两点可以从 echo_selectserv.c 得到确认，调用 select 函数后，并不是把发生变化的文件描述符单独集中在一起，而是通过作为监视对象的 fd_set 变量的变化，找出发生变化的文件描述符（54,56行），因此无法避免针对所有监视对象的循环语句。而且，作为监视对象的 fd_set 会发生变化，所以调用 select 函数前应该复制并保存原有信息，并在每次调用 select 函数时传递新的监视对象信息。select 性能上最大的弱点是：每次传递监视对象信息，准确的说，select 是监视套接字变化的函数。而套接字是操作系统管理的，所以 select 函数要借助操作系统才能完成功能。select 函数的这一缺点可以通过如下方式弥补：仅向操作系统传递一次监视对象，监视范围或内容发生变化时只通知发生变化的事项这样就无需每次调用 select 函","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_25","order":25,"summary":"用技术速度慢的原因 第 12 章实现了基于 select 的 I/O 复用技术服务端，其中有不合理的设计如下：调用 select 函数后常见的针对所有文件描述符的循环语句 每次调用 select 函数时都需要向该函数传递监视对象信息 上述两点可以从 echo_selectserv.c 得到确认，调用 select 函数后，并不是把发生变化的文件描述符单独集中在一起，而是通过作为监视对象的 fd_set 变量的变化，找出发生变化的文件描述符（54,56行），因此无法避免针对所有监视对象的循环语句。而且，作为监视对象的 fd_set 会发生变化，所以调用 select 函数前应该复制并保存原有信息，并在每次调用 select 函数时传递新的监视对象信息。select 性能上最大的弱点是：每次传递监视对象信息，准确的说，select 是监视套接字变化的函数。而套接字是操作系统管理的，所以 select 函数要借助操作系统才能完成功能。select 函数的这一缺点可以通过如下方式弥补：仅向操作系统传递一次监视对象，监视范围或内容发生变化时只通知发生变化的事项这样就无需每次调用 select 函","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"数时都向操作系统传递监视对象信息，但是前提操作系统支持这种处理方式。Linux 的支持方式是 epoll ，Windows 的支持方式是 IOCP。select 优点 select 的兼容性比较高，这样就可以支持很多的操作系统，不受平台的限制，满足以下两个条件使可以使用 select 函数：服务器接入者少 程序应该具有兼容性 实现 epoll 时必要的函数和结构体 能够克服 select 函数缺点的 epoll 函数具有以下优点，这些优点正好与之前的 select 函数缺点相反。无需编写以监视状态变化为目的的针对所有文件描述符的循环语句 调用对应于 select 函数的 epoll_wait 函数时无需每次传递监视对象信息。 下面是 epoll 函数的功能：epoll_create：创建保存 epoll 文件描述符的空间 epoll_ctl：向空间注册并注销文件描述符 epoll_wait：与 select 函数类似，等待文件描述符发生变化 select 函数中为了保存监视对象的文件描述符，直接声明了 fd_set 变量，但epoll方式让操作系统负责保存监视对象文件描述符，因此需要向","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_26","order":26,"summary":"数时都向操作系统传递监视对象信息，但是前提操作系统支持这种处理方式。Linux 的支持方式是 epoll ，Windows 的支持方式是 IOCP。select 优点 select 的兼容性比较高，这样就可以支持很多的操作系统，不受平台的限制，满足以下两个条件使可以使用 select 函数：服务器接入者少 程序应该具有兼容性 实现 epoll 时必要的函数和结构体 能够克服 select 函数缺点的 epoll 函数具有以下优点，这些优点正好与之前的 select 函数缺点相反。无需编写以监视状态变化为目的的针对所有文件描述符的循环语句 调用对应于 select 函数的 epoll_wait 函数时无需每次传递监视对象信息。 下面是 epoll 函数的功能：epoll_create：创建保存 epoll 文件描述符的空间 epoll_ctl：向空间注册并注销文件描述符 epoll_wait：与 select 函数类似，等待文件描述符发生变化 select 函数中为了保存监视对象的文件描述符，直接声明了 fd_set 变量，但epoll方式让操作系统负责保存监视对象文件描述符，因此需要向","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"操作系统请求创建保存文件描述符的空间，此时用的函数就是 epoll_create 。此外，为了添加和删除监视对象文件描述符，select 方式中需要 FD_SET、FD_CLR 函数。但在 epoll 方式中，通过 epoll_ctl 函数请求操作系统完成。最后，select 方式下调用 select 函数等待文件描述符的变化，而 epoll_wait 调用 epoll_wait 函数。还有，select 方式中通过 fd_set 变量查看监视对象的状态变化，而 epoll 方式通过如下结构体 epoll_event 将发生变化的文件描述符单独集中在一起。1 2 3 4 5 6 7 8 9 10 11 struct epoll_event { __uint32_t events; epoll_data_t data; }; typedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; 声明足够大的 epoll_event 结构体数组后，传递给 epoll_wai","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_27","order":27,"summary":"操作系统请求创建保存文件描述符的空间，此时用的函数就是 epoll_create 。此外，为了添加和删除监视对象文件描述符，select 方式中需要 FD_SET、FD_CLR 函数。但在 epoll 方式中，通过 epoll_ctl 函数请求操作系统完成。最后，select 方式下调用 select 函数等待文件描述符的变化，而 epoll_wait 调用 epoll_wait 函数。还有，select 方式中通过 fd_set 变量查看监视对象的状态变化，而 epoll 方式通过如下结构体 epoll_event 将发生变化的文件描述符单独集中在一起。1 2 3 4 5 6 7 8 9 10 11 struct epoll_event { __uint32_t events; epoll_data_t data; }; typedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; 声明足够大的 epoll_event 结构体数组后，传递给 epoll_wai","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"t 函数时，发生变化的文件描述符信息将被填入数组。因此，无需像 select 函数那样针对所有文件描述符进行循环。epoll_create epoll 是从 Linux 的 2.5.44 版内核开始引入的。通过以下命令可以查看 Linux 内核版本（老式机子需要检查）：cat /proc/sys/kernel/osreleaseepoll_create 原型1 2 3 4 5 6 #include \u0026lt;sys/epoll.h\u003e int epoll_create(int size); /* 成功时返回 epoll 的文件描述符，失败时返回 -1 size：epoll 实例的大小 */ 调用 epoll_create 函数时创建的文件描述符保存空间称为「epoll 例程」，但有些情况下名称不同，需要稍加注意。通过参数 size 传递的值决定 epoll 例程的大小，但该值只是向操作系统提出的建议。换言之，size 并不用来决定 epoll 的大小，而仅供操作系统参考（Linux3.6.8后完全忽略size建议）。epoll_create 函数创建的资源与套接字相同，也由操作系统管理。因","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_28","order":28,"summary":"t 函数时，发生变化的文件描述符信息将被填入数组。因此，无需像 select 函数那样针对所有文件描述符进行循环。epoll_create epoll 是从 Linux 的 2.5.44 版内核开始引入的。通过以下命令可以查看 Linux 内核版本（老式机子需要检查）：cat /proc/sys/kernel/osreleaseepoll_create 原型1 2 3 4 5 6 #include \u0026lt;sys/epoll.h\u003e int epoll_create(int size); /* 成功时返回 epoll 的文件描述符，失败时返回 -1 size：epoll 实例的大小 */ 调用 epoll_create 函数时创建的文件描述符保存空间称为「epoll 例程」，但有些情况下名称不同，需要稍加注意。通过参数 size 传递的值决定 epoll 例程的大小，但该值只是向操作系统提出的建议。换言之，size 并不用来决定 epoll 的大小，而仅供操作系统参考（Linux3.6.8后完全忽略size建议）。epoll_create 函数创建的资源与套接字相同，也由操作系统管理。因","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"此，该函数和创建套接字的情况相同，也会返回文件描述符，也就是说返回的文件描述符主要用于区分 epoll 例程。需要终止时，与其他文件描述符相同，也要调用 close 函数。epoll_ctl 生成例程后，应在其内部注册监视对象文件描述符，此时使用 epoll_ctl 函数。1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;sys/epoll.h\u003e int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); /* 成功时返回 0 ，失败时返回 -1 epfd：用于注册监视对象的 epoll 例程的文件描述符 op：用于指定监视对象的添加、删除或更改等操作 fd：需要注册的监视对象文件描述符 event：监视对象的事件类型 op: EPOLL_CTL_ADD：将文件描述符注册到 epoll 例程 EPOLL_CTL_DEL：从 epoll 例程中删除文件描述符 EPOLL_CTL_MOD：更改注册的文件描述符的关注事件发生情况 */ 与其他 epoll 函数相比，该函数看起","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_29","order":29,"summary":"此，该函数和创建套接字的情况相同，也会返回文件描述符，也就是说返回的文件描述符主要用于区分 epoll 例程。需要终止时，与其他文件描述符相同，也要调用 close 函数。epoll_ctl 生成例程后，应在其内部注册监视对象文件描述符，此时使用 epoll_ctl 函数。1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;sys/epoll.h\u003e int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); /* 成功时返回 0 ，失败时返回 -1 epfd：用于注册监视对象的 epoll 例程的文件描述符 op：用于指定监视对象的添加、删除或更改等操作 fd：需要注册的监视对象文件描述符 event：监视对象的事件类型 op: EPOLL_CTL_ADD：将文件描述符注册到 epoll 例程 EPOLL_CTL_DEL：从 epoll 例程中删除文件描述符 EPOLL_CTL_MOD：更改注册的文件描述符的关注事件发生情况 */ 与其他 epoll 函数相比，该函数看起","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"来有些复杂，但通过调用语句就很容易理解，假设按照如下形式调用 epoll_ctl 函数：epoll_ctl(A,EPOLL_CTL_ADD,B,C); epoll 例程 A 中注册文件描述符 B ，主要目的是为了监视参数 C 中的事件epoll_ctl(A,EPOLL_CTL_DEL,B,NULL); 从 epoll 例程 A 中删除文件描述符 Bepoll_event 结构体用于和保存事件的文件描述符结合。但也可以在 epoll_ctl中注册文件描述符时，用于注册关注的事件。该函数中 epoll_event 结构体的定义并不显眼，因此通过调用语句说明该结构体在 epoll_ctl 函数中的应用。1 2 3 4 5 6 struct epoll_event event; ... event.events=EPOLLIN;//发生需要读取数据的情况时 event.data.fd=sockfd; epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,\u0026event); ... 上述代码将 sockfd 注册到 epoll 例程 epfd 中，并在需要读取数据的情况下产生相应","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_30","order":30,"summary":"来有些复杂，但通过调用语句就很容易理解，假设按照如下形式调用 epoll_ctl 函数：epoll_ctl(A,EPOLL_CTL_ADD,B,C); epoll 例程 A 中注册文件描述符 B ，主要目的是为了监视参数 C 中的事件epoll_ctl(A,EPOLL_CTL_DEL,B,NULL); 从 epoll 例程 A 中删除文件描述符 Bepoll_event 结构体用于和保存事件的文件描述符结合。但也可以在 epoll_ctl中注册文件描述符时，用于注册关注的事件。该函数中 epoll_event 结构体的定义并不显眼，因此通过调用语句说明该结构体在 epoll_ctl 函数中的应用。1 2 3 4 5 6 struct epoll_event event; ... event.events=EPOLLIN;//发生需要读取数据的情况时 event.data.fd=sockfd; epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,\u0026event); ... 上述代码将 sockfd 注册到 epoll 例程 epfd 中，并在需要读取数据的情况下产生相应","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"事件。接下来给出 epoll_event 的成员 events 中可以保存的常量及所指的事件类型。EPOLLIN：需要读取数据的情况 EPOLLOUT：输出缓冲为空，可以立即发送数据的情况 EPOLLPRI：收到 OOB 数据的情况 EPOLLRDHUP：断开连接或半关闭的情况，这在边缘触发方式下非常有用 EPOLLERR：发生错误的情况 EPOLLET：以边缘触发的方式得到事件通知 EPOLLONESHOT：发生一次事件后，相应文件描述符不再收到事件通知。因此需要向 epoll_ctl 函数的第二个参数传递 EPOLL_CTL_MOD ，再次设置事件。 可通过位或运算 | 同时传递多个上述参数。epoll_wait 1 2 3 4 5 6 7 8 9 #include \u0026lt;sys/epoll.h\u003e int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); /* 成功时返回发生事件的文件描述符个数，失败时返回 -1 epfd : 表示事件发生监视范围的 epoll 例程的文件描","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_31","order":31,"summary":"事件。接下来给出 epoll_event 的成员 events 中可以保存的常量及所指的事件类型。EPOLLIN：需要读取数据的情况 EPOLLOUT：输出缓冲为空，可以立即发送数据的情况 EPOLLPRI：收到 OOB 数据的情况 EPOLLRDHUP：断开连接或半关闭的情况，这在边缘触发方式下非常有用 EPOLLERR：发生错误的情况 EPOLLET：以边缘触发的方式得到事件通知 EPOLLONESHOT：发生一次事件后，相应文件描述符不再收到事件通知。因此需要向 epoll_ctl 函数的第二个参数传递 EPOLL_CTL_MOD ，再次设置事件。 可通过位或运算 | 同时传递多个上述参数。epoll_wait 1 2 3 4 5 6 7 8 9 #include \u0026lt;sys/epoll.h\u003e int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); /* 成功时返回发生事件的文件描述符个数，失败时返回 -1 epfd : 表示事件发生监视范围的 epoll 例程的文件描","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"述符 events : 保存发生事件的文件描述符集合的结构体地址值 maxevents : 第二个参数中可以保存的最大事件数 timeout : 以 1/1000 秒为单位的等待时间，传递 -1 时，一直等待直到发生事件 */ 该函数调用方式如下。需要注意的是，第二个参数所指缓冲需要动态分配。1 2 3 4 5 6 7 int event_cnt; struct epoll_event *ep_events; ... ep_events=malloc(sizeof(struct epoll_event)*EPOLL_SIZE);//EPOLL_SIZE是宏常量 ... event_cnt=epoll_wait(epfd,ep_events,EPOLL_SIZE,-1); ... 调用函数后，返回发生事件的文件描述符个数，同时在第二个参数指向的缓冲中保存发生事件的文件描述符集合。因此，无需像 select 一样插入针对所有文件描述符的循环。基于 epoll 的回声服务器端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 2","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_32","order":32,"summary":"述符 events : 保存发生事件的文件描述符集合的结构体地址值 maxevents : 第二个参数中可以保存的最大事件数 timeout : 以 1/1000 秒为单位的等待时间，传递 -1 时，一直等待直到发生事件 */ 该函数调用方式如下。需要注意的是，第二个参数所指缓冲需要动态分配。1 2 3 4 5 6 7 int event_cnt; struct epoll_event *ep_events; ... ep_events=malloc(sizeof(struct epoll_event)*EPOLL_SIZE);//EPOLL_SIZE是宏常量 ... event_cnt=epoll_wait(epfd,ep_events,EPOLL_SIZE,-1); ... 调用函数后，返回发生事件的文件描述符个数，同时在第二个参数指向的缓冲中保存发生事件的文件描述符集合。因此，无需像 select 一样插入针对所有文件描述符的循环。基于 epoll 的回声服务器端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 2","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"3 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #define EPOLL_SIZE 100 struct epoll_event *ep_events; // 用指针可以存储多个event struct epoll_event event; // 单个event用于指明事件信息 int epfd = epoll_create(EPOLL_SIZE); //可以忽略这个参数，填入的参数为操作系统参考 ep_events = malloc(sizeof(struct epoll_event) * EPOLL_SIZE); event.events = EPOLLIN; //需要读取数据的情况 event.data.fd = serv_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, \u0026event); //例程epfd 中添加文件描述符 serv_sock，目的是监听 enevt 中的事件 while (1) { event_cnt ","date":"2023-08-13T22:41:59+08:00","objectID":"2370cb2dca95ec88b5bdf733363ffcab_33","order":33,"summary":"3 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #define EPOLL_SIZE 100 struct epoll_event *ep_events; // 用指针可以存储多个event struct epoll_event event; // 单个event用于指明事件信息 int epfd = epoll_create(EPOLL_SIZE); //可以忽略这个参数，填入的参数为操作系统参考 ep_events = malloc(sizeof(struct epoll_event) * EPOLL_SIZE); event.events = EPOLLIN; //需要读取数据的情况 event.data.fd = serv_sock; epoll_ctl(epfd, EPOLL_CTL_ADD, serv_sock, \u0026event); //例程epfd 中添加文件描述符 serv_sock，目的是监听 enevt 中的事件 while (1) { event_cnt ","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程2","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming2/"},{"categories":["learn"],"content":"理解网络编程和套接字 server：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;sys/socket.h\u003e int main(){ int sockfd; int clnt_sock; struct sockaddr_in serv_addr; struct sockaddr_in clnt_addr; // 创建套接字 sockfd = socket(PF_INET, SOCK_STREAM, 0); if (sockfd == -1) exit(0); // 端口复用，防止address in use int one = 1; setsoc","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_0","order":0,"summary":"理解网络编程和套接字 server：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;sys/socket.h\u003e int main(){ int sockfd; int clnt_sock; struct sockaddr_in serv_addr; struct sockaddr_in clnt_addr; // 创建套接字 sockfd = socket(PF_INET, SOCK_STREAM, 0); if (sockfd == -1) exit(0); // 端口复用，防止address in use int one = 1; setsoc","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"kopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026one, sizeof(one)); // bind地址 memset(\u0026serv_addr, 0, sizeof(sockaddr_in)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); serv_addr.sin_port = htons(8888); if (bind(sockfd, ( struct sockaddr*)\u0026serv_addr, sizeof(serv_addr))\u0026lt; 0) exit(0); // 开始监听客户端连入 if (listen(sockfd, 1) \u0026lt; 0) exit(0); // 可以与客户端通信 socklen_t clnt_addr_size; clnt_addr_size = sizeof(clnt_addr); // 不能使用(socklen_t*)clnt_addr_size使用(socklen_t*)\u0026clnt_addr_size cl","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_1","order":1,"summary":"kopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026one, sizeof(one)); // bind地址 memset(\u0026serv_addr, 0, sizeof(sockaddr_in)); serv_addr.sin_family = AF_INET; serv_addr.sin_addr.s_addr = htonl(INADDR_ANY); serv_addr.sin_port = htons(8888); if (bind(sockfd, ( struct sockaddr*)\u0026serv_addr, sizeof(serv_addr))\u0026lt; 0) exit(0); // 开始监听客户端连入 if (listen(sockfd, 1) \u0026lt; 0) exit(0); // 可以与客户端通信 socklen_t clnt_addr_size; clnt_addr_size = sizeof(clnt_addr); // 不能使用(socklen_t*)clnt_addr_size使用(socklen_t*)\u0026clnt_addr_size cl","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"nt_sock = accept(sockfd, (struct sockaddr*)\u0026clnt_addr, \u0026clnt_addr_size); if (clnt_sock \u0026lt; 0) exit(0); // 发送数据 char message[] = \"Hello!\"; write(clnt_sock, message, sizeof(message)); close(clnt_sock); close(sockfd); return 0; } client：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;sys/socket.h\u003e int main(int argc, char* argv[]){ int sock; struc","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_2","order":2,"summary":"nt_sock = accept(sockfd, (struct sockaddr*)\u0026clnt_addr, \u0026clnt_addr_size); if (clnt_sock \u0026lt; 0) exit(0); // 发送数据 char message[] = \"Hello!\"; write(clnt_sock, message, sizeof(message)); close(clnt_sock); close(sockfd); return 0; } client：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;sys/socket.h\u003e int main(int argc, char* argv[]){ int sock; struc","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"t sockaddr_in serv_addr; char message[30]; int str_len; // 创建套接字 sock = socket(PF_INET, SOCK_STREAM, 0); // connect连接 memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(8888); serv_addr.sin_addr.s_addr = inet_addr(argv[1]); connect(sock, ( sockaddr*)\u0026serv_addr, sizeof(serv_addr)); // 读取server数据 str_len = read(sock, message, sizeof(message) - 1); printf(\"Message : %s\\n\", message); close(sock); return 0; } 地址族与数据序列 只需通过IP地址的第一个字节即可判断网络地址占用的总字节数，因为我","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_3","order":3,"summary":"t sockaddr_in serv_addr; char message[30]; int str_len; // 创建套接字 sock = socket(PF_INET, SOCK_STREAM, 0); // connect连接 memset(\u0026serv_addr, 0, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(8888); serv_addr.sin_addr.s_addr = inet_addr(argv[1]); connect(sock, ( sockaddr*)\u0026serv_addr, sizeof(serv_addr)); // 读取server数据 str_len = read(sock, message, sizeof(message) - 1); printf(\"Message : %s\\n\", message); close(sock); return 0; } 地址族与数据序列 只需通过IP地址的第一个字节即可判断网络地址占用的总字节数，因为我","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"们根据IP地址的边界区分网络地址，如下所示：A 类地址的首字节范围为：0~127 B 类地址的首字节范围为：128~191 C 类地址的首字节范围为：192~223 还有如下这种表示方式：A 类地址的首位以 0 开始 B 类地址的前2位以 10 开始 C 类地址的前3位以 110 开始 端口号由 16 位构成，可分配的端口号范围除 0-1023，这些是知名端口，一般分配给特定的应用程序，所以应当分配给此范围之外的值。HTTP 的端口号是 80 ，FTP 的端口号是20和21 虽然端口号不能重复，但是 TCP 套接字和 UDP 套接字不会共用端接口号，所以允许重复。 1 2 3 4 5 6 7 8 9 10 11 12 13 /* Structure describing an Internet socket address. */ struct sockaddr_in { __SOCKADDR_COMMON (sin_); in_port_t sin_port;\t/* Port number. uint16_t 16bits*/ struct in_addr sin_addr;\t/* ","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_4","order":4,"summary":"们根据IP地址的边界区分网络地址，如下所示：A 类地址的首字节范围为：0~127 B 类地址的首字节范围为：128~191 C 类地址的首字节范围为：192~223 还有如下这种表示方式：A 类地址的首位以 0 开始 B 类地址的前2位以 10 开始 C 类地址的前3位以 110 开始 端口号由 16 位构成，可分配的端口号范围除 0-1023，这些是知名端口，一般分配给特定的应用程序，所以应当分配给此范围之外的值。HTTP 的端口号是 80 ，FTP 的端口号是20和21 虽然端口号不能重复，但是 TCP 套接字和 UDP 套接字不会共用端接口号，所以允许重复。 1 2 3 4 5 6 7 8 9 10 11 12 13 /* Structure describing an Internet socket address. */ struct sockaddr_in { __SOCKADDR_COMMON (sin_); in_port_t sin_port;\t/* Port number. uint16_t 16bits*/ struct in_addr sin_addr;\t/* ","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"Internet address. uint32_t*/ /* Pad to size of `struct sockaddr'. 8 = 16-2-2-4， 用于强制转换成sockaddr*/ unsigned char sin_zero[sizeof (struct sockaddr) - // 16byte __SOCKADDR_COMMON_SIZE - // 2byte sizeof (in_port_t) - // 2 sizeof (struct in_addr)]; // 4 }; sa_family_t 地址族（address family） sys/socket.h socklen_t 长度（length of struct） sys/socket.h in_addr_t IP地址，声明为 uint_32_t netinet/in.h in_port_t 端口号，声明为 uint_16_t netinet/in.h int 8_t 这种类型都是在该头文件 signed 8-bit int sys/types.h 大端序（Big Endian）：高位字节存放到低位地址","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_5","order":5,"summary":"Internet address. uint32_t*/ /* Pad to size of `struct sockaddr'. 8 = 16-2-2-4， 用于强制转换成sockaddr*/ unsigned char sin_zero[sizeof (struct sockaddr) - // 16byte __SOCKADDR_COMMON_SIZE - // 2byte sizeof (in_port_t) - // 2 sizeof (struct in_addr)]; // 4 }; sa_family_t 地址族（address family） sys/socket.h socklen_t 长度（length of struct） sys/socket.h in_addr_t IP地址，声明为 uint_32_t netinet/in.h in_port_t 端口号，声明为 uint_16_t netinet/in.h int 8_t 这种类型都是在该头文件 signed 8-bit int sys/types.h 大端序（Big Endian）：高位字节存放到低位地址","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"，网络字节序小端序（Little Endian）：高位字节存放到高位地址h to n s 的 h 代表主机（host）字节序。通常小端序htons 的 n 代表网络（network）字节序。s 代表两个字节的 short =uint16=2字节，因此以 s 为后缀的函数用于端口转换l 代表四个字节的 long 类型，所以以 l 为后缀的函数用于 IP 地址转换（long在64位系统下仍是4字节，因为是uint32）1 2 3 4 5 6 7 8 9 10 in_addr_t inet_addr(const char *string); // 点/数字符串形式的IP地址转换成整数型的IP地址 //成功时返回 32 位大端序整数型值，失败时返回 INADDR_NONE，以便存入是sockaddr_in中 int inet_aton(const char *string, struct in_addr *addr); // more use /* 成功时返回 1 ，失败时返回 0 string: 含有需要转换的IP地址信息的字符串地址值 addr: 保存转换结果的 in_addr 结构体变量","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_6","order":6,"summary":"，网络字节序小端序（Little Endian）：高位字节存放到高位地址h to n s 的 h 代表主机（host）字节序。通常小端序htons 的 n 代表网络（network）字节序。s 代表两个字节的 short =uint16=2字节，因此以 s 为后缀的函数用于端口转换l 代表四个字节的 long 类型，所以以 l 为后缀的函数用于 IP 地址转换（long在64位系统下仍是4字节，因为是uint32）1 2 3 4 5 6 7 8 9 10 in_addr_t inet_addr(const char *string); // 点/数字符串形式的IP地址转换成整数型的IP地址 //成功时返回 32 位大端序整数型值，失败时返回 INADDR_NONE，以便存入是sockaddr_in中 int inet_aton(const char *string, struct in_addr *addr); // more use /* 成功时返回 1 ，失败时返回 0 string: 含有需要转换的IP地址信息的字符串地址值 addr: 保存转换结果的 in_addr 结构体变量","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"的地址值 */ char *inet_ntoa(struct in_addr adr); // 网络字节序整数型IP地址转换成字符串形式 //成功时返回保存转换结果的字符串地址值，失败时返回 NULL 空指针 问题 端口不一致会导致乱码 htonl(8888) != htons(8888)，htons Linux 文件 1.4—文件描述符0 1 2（文件操作简述） 因此文件open之后的文件描述符从3开始 底层文件I/O和ANSI标准I/O的区别 通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。基于TCP的客户端/服务端 TCP/IP 协议栈 TCP/IP 协议栈共分为 4 层，可以理解为数据收发分成了 4 个层次化过程，通过层次化的方式来解决问题链路层 链路层是物理链接领域标准化的结果，也是最基本的领域，专门定义LAN、WAN、MAN等网络标准。若两台主机通过网络进行数据交换，则需要物理连接","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_7","order":7,"summary":"的地址值 */ char *inet_ntoa(struct in_addr adr); // 网络字节序整数型IP地址转换成字符串形式 //成功时返回保存转换结果的字符串地址值，失败时返回 NULL 空指针 问题 端口不一致会导致乱码 htonl(8888) != htons(8888)，htons Linux 文件 1.4—文件描述符0 1 2（文件操作简述） 因此文件open之后的文件描述符从3开始 底层文件I/O和ANSI标准I/O的区别 通过文件I/O读写文件时，每次操作都会执行相关系统调用。这样处理的好处是直接读写实际文件，坏处是频繁的系统调用会增加系统开销，标准I/O可以看成是在文件I/O的基础上封装了缓冲机制。先读写缓冲区，必要时再访问实际文件，从而减少了系统调用的次数。基于TCP的客户端/服务端 TCP/IP 协议栈 TCP/IP 协议栈共分为 4 层，可以理解为数据收发分成了 4 个层次化过程，通过层次化的方式来解决问题链路层 链路层是物理链接领域标准化的结果，也是最基本的领域，专门定义LAN、WAN、MAN等网络标准。若两台主机通过网络进行数据交换，则需要物理连接","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"，链路层就负责这些标准。IP 层 准备好物理连接后就要传输数据。为了在复杂网络中传输数据，首先要考虑路径的选择。向目标传输数据需要经过哪条路径？解决此问题的就是IP层，该层使用的协议就是IP。IP 是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输过程中发生错误，则选择其他路径，但是如果发生数据丢失或错误，则无法解决。换言之，IP协议无法应对数据错误。TCP/UDP 层 IP 层解决数据传输中的路径选择问题，只需照此路径传输数据即可。TCP 和 UDP 层以 IP 层提供的路径信息为基础完成实际的数据传输，故该层又称为传输层 。 TCP 可以保证数据的可靠传输，但是它发送数据时以 IP 层为基础（这也是协议栈层次化的原因）。IP 层只关注一个数据包（数据传输基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由 IP 层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，是不可靠的，需要利用TCP来解决数据丢失，顺序不一致等问题。应用层 上述内容是套接字通信过程中自动处理的。选择数据传输路径、数据确认过程都被隐藏到套接字内部","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_8","order":8,"summary":"，链路层就负责这些标准。IP 层 准备好物理连接后就要传输数据。为了在复杂网络中传输数据，首先要考虑路径的选择。向目标传输数据需要经过哪条路径？解决此问题的就是IP层，该层使用的协议就是IP。IP 是面向消息的、不可靠的协议。每次传输数据时会帮我们选择路径，但并不一致。如果传输过程中发生错误，则选择其他路径，但是如果发生数据丢失或错误，则无法解决。换言之，IP协议无法应对数据错误。TCP/UDP 层 IP 层解决数据传输中的路径选择问题，只需照此路径传输数据即可。TCP 和 UDP 层以 IP 层提供的路径信息为基础完成实际的数据传输，故该层又称为传输层 。 TCP 可以保证数据的可靠传输，但是它发送数据时以 IP 层为基础（这也是协议栈层次化的原因）。IP 层只关注一个数据包（数据传输基本单位）的传输过程。因此，即使传输多个数据包，每个数据包也是由 IP 层实际传输的，也就是说传输顺序及传输本身是不可靠的。若只利用IP层传输数据，是不可靠的，需要利用TCP来解决数据丢失，顺序不一致等问题。应用层 上述内容是套接字通信过程中自动处理的。选择数据传输路径、数据确认过程都被隐藏到套接字内部","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"。向程序员提供的工具就是套接字，只需要利用套接字编出程序即可。编写软件的过程中，需要根据程序的特点来决定服务器和客户端之间的数据传输规则，这便是应用层协议。TCP流程 服务端 #include \u0026lt;sys/socket.h\u003esocket(AF_INET, SOCKEt_STREAM, 0) 创建套接字bind(sockfd, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) 分配套接字地址listen(sockfd, 请求数backlog) 等待连接请求状态，此时客户端才能发送connet请求accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) 允许连接，产生用于数据IO的套接字，需要close()read() / write() 数据交换close() 断开连接服务端实现过程中首先要创建套接字，此时的套接字并非是真正的服务端套接字为了完成套接字地址的分配，初始化结构体变量并调用 bind 函数。调用 listen 函数进入等待连接请求状态。连接请求状态队列的长度设置","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_9","order":9,"summary":"。向程序员提供的工具就是套接字，只需要利用套接字编出程序即可。编写软件的过程中，需要根据程序的特点来决定服务器和客户端之间的数据传输规则，这便是应用层协议。TCP流程 服务端 #include \u0026lt;sys/socket.h\u003esocket(AF_INET, SOCKEt_STREAM, 0) 创建套接字bind(sockfd, (struct sockaddr *)\u0026serv_adr, sizeof(serv_adr)) 分配套接字地址listen(sockfd, 请求数backlog) 等待连接请求状态，此时客户端才能发送connet请求accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) 允许连接，产生用于数据IO的套接字，需要close()read() / write() 数据交换close() 断开连接服务端实现过程中首先要创建套接字，此时的套接字并非是真正的服务端套接字为了完成套接字地址的分配，初始化结构体变量并调用 bind 函数。调用 listen 函数进入等待连接请求状态。连接请求状态队列的长度设置","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"为5.此时的套接字才是服务端套接字。调用 accept 函数从队头取 1 个连接请求与客户端建立连接，并返回创建的套接字文件描述符。另外，调用 accept 函数时若等待队列为空，则 accept 函数不会返回，直到队列中出现新的客户端连接。调用 write 函数向客户端传送数据，调用 close 关闭连接客户端 创建准备连接服务器的套接字，此时创建的是 TCP 套接字 结构体变量 serv_addr 中初始化IP和端口信息。初始化值为目标服务器端套接字的IP和端口信息。 调用 connect 函数向服务端发起连接请求，自动分配客户端IP地址和端口 完成连接后，接收服务端传输的数据 接收数据后调用 close 函数关闭套接字，结束与服务器端的连接。(对套接字调用close函数，对应于向建立连接的对应套接字发送EOF。即，如果客户端的套接字调用了close函数，服务端read时候会返回0。) 客户端只能等到服务端调用 listen 函数后才能调用 connect 函数 服务器端可能会在客户端调用 connect 之前调用 accept 函数，这时服务器端进入阻塞（blocking）状态，","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_10","order":10,"summary":"为5.此时的套接字才是服务端套接字。调用 accept 函数从队头取 1 个连接请求与客户端建立连接，并返回创建的套接字文件描述符。另外，调用 accept 函数时若等待队列为空，则 accept 函数不会返回，直到队列中出现新的客户端连接。调用 write 函数向客户端传送数据，调用 close 关闭连接客户端 创建准备连接服务器的套接字，此时创建的是 TCP 套接字 结构体变量 serv_addr 中初始化IP和端口信息。初始化值为目标服务器端套接字的IP和端口信息。 调用 connect 函数向服务端发起连接请求，自动分配客户端IP地址和端口 完成连接后，接收服务端传输的数据 接收数据后调用 close 函数关闭套接字，结束与服务器端的连接。(对套接字调用close函数，对应于向建立连接的对应套接字发送EOF。即，如果客户端的套接字调用了close函数，服务端read时候会返回0。) 客户端只能等到服务端调用 listen 函数后才能调用 connect 函数 服务器端可能会在客户端调用 connect 之前调用 accept 函数，这时服务器端进入阻塞（blocking）状态，","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"直到客户端调用 connect 函数后接收到连接请求。 echo server/client 使用for循环处理多个连接，会出现服务端发送多个数据给一个客户端，并且可能数据太多，需要分开发送，但客户端只调用一次read。上述原因为TCP 不存在数据边界。问题 分层的好处：①隔层之间是独立的②灵活性好③结构上可以分隔开④易于实现和维护⑤能促进标准化工作。基于 TCP 的服务端/客户端（2） echo client的完美实现 已知接收数据的大小 echo client如果可以知道接收数据的大小，则可以利用for循环来接收，但是一般情况下不确定。1 2 3 4 5 6 7 8 9 str_len = write(sock, message, strlen(message)); recv_len = 0; while (recv_len \u0026lt; str_len) { recv_cnt = read(sock, \u0026message[recv_len], BUF_SIZE - 1); if (recv_cnt == -1) error_handling(\"read() error\"); recv_","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_11","order":11,"summary":"直到客户端调用 connect 函数后接收到连接请求。 echo server/client 使用for循环处理多个连接，会出现服务端发送多个数据给一个客户端，并且可能数据太多，需要分开发送，但客户端只调用一次read。上述原因为TCP 不存在数据边界。问题 分层的好处：①隔层之间是独立的②灵活性好③结构上可以分隔开④易于实现和维护⑤能促进标准化工作。基于 TCP 的服务端/客户端（2） echo client的完美实现 已知接收数据的大小 echo client如果可以知道接收数据的大小，则可以利用for循环来接收，但是一般情况下不确定。1 2 3 4 5 6 7 8 9 str_len = write(sock, message, strlen(message)); recv_len = 0; while (recv_len \u0026lt; str_len) { recv_cnt = read(sock, \u0026message[recv_len], BUF_SIZE - 1); if (recv_cnt == -1) error_handling(\"read() error\"); recv_","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"len += recv_cnt; } 问题不在于回声客户端：定义应用层协议 在收发过程中定好规则（协议）以表示数据边界，或者提前告知需要发送的数据的大小。服务端/客户端实现过程中逐步定义的规则集合就是应用层协议。TCP 原理 TCP 套接字中的 I/O 缓冲 实际上，write 函数调用后并非立即传输数据， read 函数调用后也并非马上接收数据。I/O 缓冲特性可以整理如下：I/O 缓冲在每个 TCP 套接字中单独存在 I/O 缓冲在创建套接字时自动生成 即使关闭套接字也会继续传递输出缓冲中遗留的数据 关闭套接字将丢失输入缓冲中的数据 TCP 内部工作原理 TCP 套接字从创建到消失所经过的过程分为如下三步：与对方套接字建立连接 与对方套接字进行数据交换 断开与对方套接字的连接 1 与对方套接字的连接 Three-way handshaking 第一次客户端发送SYN，表示发送SEQ为1000的数据包 第二次服务端发送SYN+ACK，表示接收后发送ACK（1000+1）的数据包，并发送SEQ为2000的数据包 第三次客户端发送SYN+ACK，表示接收到服务端的数据包，并发送下一个数据","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_12","order":12,"summary":"len += recv_cnt; } 问题不在于回声客户端：定义应用层协议 在收发过程中定好规则（协议）以表示数据边界，或者提前告知需要发送的数据的大小。服务端/客户端实现过程中逐步定义的规则集合就是应用层协议。TCP 原理 TCP 套接字中的 I/O 缓冲 实际上，write 函数调用后并非立即传输数据， read 函数调用后也并非马上接收数据。I/O 缓冲特性可以整理如下：I/O 缓冲在每个 TCP 套接字中单独存在 I/O 缓冲在创建套接字时自动生成 即使关闭套接字也会继续传递输出缓冲中遗留的数据 关闭套接字将丢失输入缓冲中的数据 TCP 内部工作原理 TCP 套接字从创建到消失所经过的过程分为如下三步：与对方套接字建立连接 与对方套接字进行数据交换 断开与对方套接字的连接 1 与对方套接字的连接 Three-way handshaking 第一次客户端发送SYN，表示发送SEQ为1000的数据包 第二次服务端发送SYN+ACK，表示接收后发送ACK（1000+1）的数据包，并发送SEQ为2000的数据包 第三次客户端发送SYN+ACK，表示接收到服务端的数据包，并发送下一个数据","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"包 2与对方主机的数据交换 首先主机A发送100字节的数据包，SEQ为1200，主机B确认收到发送ACK（SEQ+传递字节数+1）=1301给主机B，防止丢失数据 第二次发送时主机A失败，主机B未发送ACK，主机A启动计时器等待ACK应答，超时则重传数据。 3与对方主机的数据交换 图中数据包内的 FIN 表示断开连接。也就是说，双方各发送 1 次 FIN 消息后断开连接。图中，主机 A 传递了两次 ACK 5001，也许这里会有困惑。其实，第二次 FIN 数据包中的 ACK 5001 只是因为发送了 ACK 消息后未接收到的数据重传的。基于UDP的服务端/客户端 UDP原理 寄信前应先在信封上填好寄信人ip和收信人的地址port，之后贴上邮票放进邮筒write即可。当然，信件的特点使我们无法确认信件是否被收到。邮寄过程中也可能发生信件丢失的情况。也就是说，信件是一种不可靠的传输方式，UDP 也是一种不可靠的数据传输方式。UDP工作原理 IP 的作用就是让离开主机 B 的 UDP 数据包准确传递到主机 A 。但是把 UDP 数据包最终交给主机 A 的某一 UDP 套接字的过程是由 UDP","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_13","order":13,"summary":"包 2与对方主机的数据交换 首先主机A发送100字节的数据包，SEQ为1200，主机B确认收到发送ACK（SEQ+传递字节数+1）=1301给主机B，防止丢失数据 第二次发送时主机A失败，主机B未发送ACK，主机A启动计时器等待ACK应答，超时则重传数据。 3与对方主机的数据交换 图中数据包内的 FIN 表示断开连接。也就是说，双方各发送 1 次 FIN 消息后断开连接。图中，主机 A 传递了两次 ACK 5001，也许这里会有困惑。其实，第二次 FIN 数据包中的 ACK 5001 只是因为发送了 ACK 消息后未接收到的数据重传的。基于UDP的服务端/客户端 UDP原理 寄信前应先在信封上填好寄信人ip和收信人的地址port，之后贴上邮票放进邮筒write即可。当然，信件的特点使我们无法确认信件是否被收到。邮寄过程中也可能发生信件丢失的情况。也就是说，信件是一种不可靠的传输方式，UDP 也是一种不可靠的数据传输方式。UDP工作原理 IP 的作用就是让离开主机 B 的 UDP 数据包准确传递到主机 A 。但是把 UDP 数据包最终交给主机 A 的某一 UDP 套接字的过程是由 UDP","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":" 完成的。UDP 的最重要的作用就是根据端口号将传到主机的数据包交付给最终的 UDP 套接字。TCP 比 UDP 慢的原因主要有以下两点：收发数据前后进行的连接设置及清除过程。 收发过程中为保证可靠性而添加的流控制。 如果收发的数据量小但是需要频繁连接时，UDP 比 TCP 更高效。TCP需要listen、accept，而UDP只需要只有创建套接字和数据交换过程。 TCP只能一一对应服务端客户端，UDP可以一对多传输 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;sys/socket.h\u003e ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen); /* 成功时返回发送的字节数，失败时返回 -1 sock: 用于传输数据的 UDP 套接字 buff: 保存待传输数据的缓冲地址值 nbytes: 待传输的数据长度，以字节为单位 ","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_14","order":14,"summary":" 完成的。UDP 的最重要的作用就是根据端口号将传到主机的数据包交付给最终的 UDP 套接字。TCP 比 UDP 慢的原因主要有以下两点：收发数据前后进行的连接设置及清除过程。 收发过程中为保证可靠性而添加的流控制。 如果收发的数据量小但是需要频繁连接时，UDP 比 TCP 更高效。TCP需要listen、accept，而UDP只需要只有创建套接字和数据交换过程。 TCP只能一一对应服务端客户端，UDP可以一对多传输 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;sys/socket.h\u003e ssize_t sendto(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen); /* 成功时返回发送的字节数，失败时返回 -1 sock: 用于传输数据的 UDP 套接字 buff: 保存待传输数据的缓冲地址值 nbytes: 待传输的数据长度，以字节为单位 ","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"flags: 可选项参数，若没有则传递 0 to: 存有目标地址的 sockaddr 结构体变量的地址值 addrlen: 传递给参数 to 的地址值结构体变量长度 调用 sendto 函数时自动给client分配IP和端口号 */ ssize_t recvfrom(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); /* 成功时返回接收的字节数，失败时返回 -1 sock: 用于传输数据的 UDP 套接字 buff: 保存待传输数据的缓冲地址值 nbytes: 待传输的数据长度，以字节为单位 flags: 可选项参数，若没有则传递 0 from: 存有**发送端**地址信息的 sockaddr 结构体变量的地址值 addrlen: 保存参数 from 的结构体变量长度的变量地址值。 */ UDP 的数据传输特性和调用 connect 函数 输入函数的调用次数和输出函数的调用次数应该完全一致 每次调用 sendto 函数时每次都变更目标地址，因此可以重复利","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_15","order":15,"summary":"flags: 可选项参数，若没有则传递 0 to: 存有目标地址的 sockaddr 结构体变量的地址值 addrlen: 传递给参数 to 的地址值结构体变量长度 调用 sendto 函数时自动给client分配IP和端口号 */ ssize_t recvfrom(int sock, void *buff, size_t nbytes, int flags, struct sockaddr *from, socklen_t *addrlen); /* 成功时返回接收的字节数，失败时返回 -1 sock: 用于传输数据的 UDP 套接字 buff: 保存待传输数据的缓冲地址值 nbytes: 待传输的数据长度，以字节为单位 flags: 可选项参数，若没有则传递 0 from: 存有**发送端**地址信息的 sockaddr 结构体变量的地址值 addrlen: 保存参数 from 的结构体变量长度的变量地址值。 */ UDP 的数据传输特性和调用 connect 函数 输入函数的调用次数和输出函数的调用次数应该完全一致 每次调用 sendto 函数时每次都变更目标地址，因此可以重复利","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"用同一 UDP 套接字向不同目标传递数据。这种未注册目标地址信息的套接字称为未连接套接字，反之，注册了目标地址的套接字称为连接 connected 套接字。 sendto流程 第 1 阶段：向 UDP 套接字注册目标 IP 和端口号 第 2 阶段：传输数据 第 3 阶段：删除 UDP 套接字中注册的目标地址信息。 python -c \"import socket;print([(s.connect(('8.8.8.8', 53)), s.getsockname()[0], s.close()) for s in [socket.socket(socket.AF_INET, socket.SOCK_DGRAM)]][0][1])\"终端输入上述命令获取本地ip优雅的断开套接字的连接 基于 TCP 的半关闭 TCP 的断开过程可能发生预想不到的情况，需要掌握半关闭（half-close）。Linux 和 Windows 的 closesocket 函数意味着完全断开连接。完全断开不仅指无法传输数据，而且也不能接收数据。一旦两台主机之间建立了套接字连接，每个主机就会拥有单独的输入流和输出流。针","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_16","order":16,"summary":"用同一 UDP 套接字向不同目标传递数据。这种未注册目标地址信息的套接字称为未连接套接字，反之，注册了目标地址的套接字称为连接 connected 套接字。 sendto流程 第 1 阶段：向 UDP 套接字注册目标 IP 和端口号 第 2 阶段：传输数据 第 3 阶段：删除 UDP 套接字中注册的目标地址信息。 python -c \"import socket;print([(s.connect(('8.8.8.8', 53)), s.getsockname()[0], s.close()) for s in [socket.socket(socket.AF_INET, socket.SOCK_DGRAM)]][0][1])\"终端输入上述命令获取本地ip优雅的断开套接字的连接 基于 TCP 的半关闭 TCP 的断开过程可能发生预想不到的情况，需要掌握半关闭（half-close）。Linux 和 Windows 的 closesocket 函数意味着完全断开连接。完全断开不仅指无法传输数据，而且也不能接收数据。一旦两台主机之间建立了套接字连接，每个主机就会拥有单独的输入流和输出流。针","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"对优雅断开的 shutdown 函数 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;sys/socket.h\u003e int shutdown(int sock, int howto); /* 成功时返回 0 ，失败时返回 -1 sock: 需要断开套接字文件描述符 howto: 传递断开方式信息 SHUT_RD : 断开输入流 0 SHUT_WR : 断开输出流 1 SHUT_RDWR : 同时断开 I/O 流 2 */ Linux-socket的close和shutdown区别及应用场景（也有后续章节的多进程传输中使用shutdown的原因，会不管计数，直接关闭输入输出流）为何要半关闭 为了关闭服务器后，仍可以接收客户端的数据。调用 shutdown 函数，只关闭服务器的输出流。这样既可以发送 EOF ，同时又保留了输入流。一个优雅的流程 当服务端发送完数据后，shutdown关闭发送流，当接收到客户端的回复信息，则close套接字，同时客户端发送完消息后关闭套接字。域名及网络地址 域名系统 DNS 是对IP地址和域名进行相互转换的系统，其核心是 DNS 服务器域名","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_17","order":17,"summary":"对优雅断开的 shutdown 函数 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;sys/socket.h\u003e int shutdown(int sock, int howto); /* 成功时返回 0 ，失败时返回 -1 sock: 需要断开套接字文件描述符 howto: 传递断开方式信息 SHUT_RD : 断开输入流 0 SHUT_WR : 断开输出流 1 SHUT_RDWR : 同时断开 I/O 流 2 */ Linux-socket的close和shutdown区别及应用场景（也有后续章节的多进程传输中使用shutdown的原因，会不管计数，直接关闭输入输出流）为何要半关闭 为了关闭服务器后，仍可以接收客户端的数据。调用 shutdown 函数，只关闭服务器的输出流。这样既可以发送 EOF ，同时又保留了输入流。一个优雅的流程 当服务端发送完数据后，shutdown关闭发送流，当接收到客户端的回复信息，则close套接字，同时客户端发送完消息后关闭套接字。域名及网络地址 域名系统 DNS 是对IP地址和域名进行相互转换的系统，其核心是 DNS 服务器域名","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"是IP地址的别名，可以通过DNS服务器查询到对应IP地址当在电脑浏览器上输入一个域名，会通过一系列的DNS服务器的映射找到最终的目标服务器。IP地址和域名之间的转换 通过域名获得ip 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;netdb.h\u003e struct hostent *gethostbyname(const char *hostname); /* 成功时返回 hostent 结构体地址，失败时返回 NULL 指针 */ struct hostent { char *h_name; /* Official name of host. 官方域名*/ char **h_aliases; /* Alias list. 域名别称*/ int h_addrtype; /* Host address type. IP地址*/ int h_length; /* Length of address. IP地址长度*/ char **h_addr_list; /* List of addresses from name server. 域名对应IP地","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_18","order":18,"summary":"是IP地址的别名，可以通过DNS服务器查询到对应IP地址当在电脑浏览器上输入一个域名，会通过一系列的DNS服务器的映射找到最终的目标服务器。IP地址和域名之间的转换 通过域名获得ip 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;netdb.h\u003e struct hostent *gethostbyname(const char *hostname); /* 成功时返回 hostent 结构体地址，失败时返回 NULL 指针 */ struct hostent { char *h_name; /* Official name of host. 官方域名*/ char **h_aliases; /* Alias list. 域名别称*/ int h_addrtype; /* Host address type. IP地址*/ int h_length; /* Length of address. IP地址长度*/ char **h_addr_list; /* List of addresses from name server. 域名对应IP地","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"址 */ }; linux下可以使用dig @8.8.8.8 +trace baidu.com命令追踪DNS查询路径1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;netdb.h\u003e void error_handling(char *message); int main(int argc, char *argv[]) { int i; struct hostent *host; if (argc != 2) { printf(\"Usage : %s \u0026lt;addr\u003e\\n\", argv[0]); exit(1); } // 把参数传递给函数，返回结构体 host = gethostbyname(argv[","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_19","order":19,"summary":"址 */ }; linux下可以使用dig @8.8.8.8 +trace baidu.com命令追踪DNS查询路径1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;netdb.h\u003e void error_handling(char *message); int main(int argc, char *argv[]) { int i; struct hostent *host; if (argc != 2) { printf(\"Usage : %s \u0026lt;addr\u003e\\n\", argv[0]); exit(1); } // 把参数传递给函数，返回结构体 host = gethostbyname(argv[","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"1]); // IP to host // struct sockaddr_in addr; // memset(\u0026addr, 0, sizeof(addr)); // addr.sin_addr.s_addr = inet_addr(argv[1]); // host = gethostbyaddr((char *)\u0026addr.sin_addr, 4, AF_INET); if (!host) printf(\"gethost... error\"); // 输出官方域名 printf(\"Official name: %s \\n\", host-\u003eh_name); // Aliases 貌似是解析的 cname 域名？ for (i = 0; host-\u003eh_aliases[i]; i++) printf(\"Aliases %d: %s \\n\", i + 1, host-\u003eh_aliases[i]); //看看是不是ipv4 printf(\"Address type: %s \\n\", (host-\u003eh_addrtype == AF_INET) ? \"AF_INET\" : \"AF_INET6","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_20","order":20,"summary":"1]); // IP to host // struct sockaddr_in addr; // memset(\u0026addr, 0, sizeof(addr)); // addr.sin_addr.s_addr = inet_addr(argv[1]); // host = gethostbyaddr((char *)\u0026addr.sin_addr, 4, AF_INET); if (!host) printf(\"gethost... error\"); // 输出官方域名 printf(\"Official name: %s \\n\", host-\u003eh_name); // Aliases 貌似是解析的 cname 域名？ for (i = 0; host-\u003eh_aliases[i]; i++) printf(\"Aliases %d: %s \\n\", i + 1, host-\u003eh_aliases[i]); //看看是不是ipv4 printf(\"Address type: %s \\n\", (host-\u003eh_addrtype == AF_INET) ? \"AF_INET\" : \"AF_INET6","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"\"); // 输出ip地址信息 for (i = 0; host-\u003eh_addr_list[i]; i++) // 对in_addr*指针取值用* printf(\"IP addr %d: %s \\n\", i + 1, inet_ntoa(*(struct in_addr *)host-\u003eh_addr_list[i])); return 0; } 利用IP地址获取域名 1 2 3 4 5 6 7 8 #include \u0026lt;netdb.h\u003e struct hostent *gethostbyaddr(const char *addr, socklen_t len, int family); /* 成功时返回 hostent 结构体变量地址值，失败时返回 NULL 指针 addr: 含有IP地址信息的 in_addr 结构体指针。为了同时传递 IPV4 地址之外的全部信息，该变量的类型声明为 char 指针 len: 向第一个参数传递的地址信息的字节数，IPV4时为 4 ，IPV6 时为16. family: 传递地址族信息，ipv4 是 AF_INET ，IPV6是 AF_INET6 ","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_21","order":21,"summary":"\"); // 输出ip地址信息 for (i = 0; host-\u003eh_addr_list[i]; i++) // 对in_addr*指针取值用* printf(\"IP addr %d: %s \\n\", i + 1, inet_ntoa(*(struct in_addr *)host-\u003eh_addr_list[i])); return 0; } 利用IP地址获取域名 1 2 3 4 5 6 7 8 #include \u0026lt;netdb.h\u003e struct hostent *gethostbyaddr(const char *addr, socklen_t len, int family); /* 成功时返回 hostent 结构体变量地址值，失败时返回 NULL 指针 addr: 含有IP地址信息的 in_addr 结构体指针。为了同时传递 IPV4 地址之外的全部信息，该变量的类型声明为 char 指针 len: 向第一个参数传递的地址信息的字节数，IPV4时为 4 ，IPV6 时为16. family: 传递地址族信息，ipv4 是 AF_INET ，IPV6是 AF_INET6 ","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"*/ 在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？套接字的多种可选项 套接字可选项和 I/O 缓冲大小 我们之前写得程序都是创建好套接字之后直接使用的，此时通过默认的套接字特性进行数据通信，这里列出了一些套接字可选项。协议层 选项名 getsockopt setsockopt SOL_SOCKET SO_SNDBUF O O SOL_SOCKET SO_RCVBUF O O SOL_SOCKET SO_REUSEADDR O O SOL_SOCKET SO_KEEPALIVE O O SOL_SOCKET SO_BROADCAST O O SOL_SOCKET SO_DONTROUTE O O SOL_SOCKET SO_OOBINLINE O O SOL_SOCKET SO_ERROR O X SOL_SOCKET SO_TYPE O X IPPROTO_IP IP_TOS O O IPPROTO_IP IP_TTL O O IPPROTO_IP IP_MULTICAST_TTL O O IPPROTO_IP IP_MULTICAST_LOOP O O IPPROTO","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_22","order":22,"summary":"*/ 在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？套接字的多种可选项 套接字可选项和 I/O 缓冲大小 我们之前写得程序都是创建好套接字之后直接使用的，此时通过默认的套接字特性进行数据通信，这里列出了一些套接字可选项。协议层 选项名 getsockopt setsockopt SOL_SOCKET SO_SNDBUF O O SOL_SOCKET SO_RCVBUF O O SOL_SOCKET SO_REUSEADDR O O SOL_SOCKET SO_KEEPALIVE O O SOL_SOCKET SO_BROADCAST O O SOL_SOCKET SO_DONTROUTE O O SOL_SOCKET SO_OOBINLINE O O SOL_SOCKET SO_ERROR O X SOL_SOCKET SO_TYPE O X IPPROTO_IP IP_TOS O O IPPROTO_IP IP_TTL O O IPPROTO_IP IP_MULTICAST_TTL O O IPPROTO_IP IP_MULTICAST_LOOP O O IPPROTO","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"_IP IP_MULTICAST_IF O O IPPROTO_TCP TCP_KEEPALIVE O O IPPROTO_TCP TCP_NODELAY O O IPPROTO_TCP TCP_MAXSEG O O 从表中可以看出，套接字可选项是分层的。IPPROTO_IP 可选项是IP协议相关事项 IPPROTO_TCP 层可选项是 TCP 协议的相关事项 SOL_SOCKET 层是套接字的通用可选项。 用于验证套接类型的 SO_TYPE 是只读可选项，因为套接字类型只能在创建(调用socket()方法时)时决定，以后不能再更改。 getsockopt \u0026 setsockopt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;sys/socket.h\u003e // 读取套接字可选项 int getsockopt(int sock, int le","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_23","order":23,"summary":"_IP IP_MULTICAST_IF O O IPPROTO_TCP TCP_KEEPALIVE O O IPPROTO_TCP TCP_NODELAY O O IPPROTO_TCP TCP_MAXSEG O O 从表中可以看出，套接字可选项是分层的。IPPROTO_IP 可选项是IP协议相关事项 IPPROTO_TCP 层可选项是 TCP 协议的相关事项 SOL_SOCKET 层是套接字的通用可选项。 用于验证套接类型的 SO_TYPE 是只读可选项，因为套接字类型只能在创建(调用socket()方法时)时决定，以后不能再更改。 getsockopt \u0026 setsockopt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;sys/socket.h\u003e // 读取套接字可选项 int getsockopt(int sock, int le","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"vel, int optname, void *optval, socklen_t *optlen); /* 成功时返回 0 ，失败时返回 -1 sock: 用于查看选项套接字文件描述符 level: 要查看的可选项协议层 optname: 要查看的可选项名 optval: 保存查看结果的缓冲地址值 optlen: 向第四个参数传递的缓冲大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数。 */ #include \u0026lt;sys/socket.h\u003e // 更改可选项 int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen); /* 成功时返回 0 ，失败时返回 -1 sock: 用于更改选项套接字文件描述符 level: 要更改的可选项协议层 optname: 要更改的可选项名 optval: 保存更改结果的缓冲地址值 optlen: 向第四个参数传递的缓冲大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数。 */ #include \u0026","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_24","order":24,"summary":"vel, int optname, void *optval, socklen_t *optlen); /* 成功时返回 0 ，失败时返回 -1 sock: 用于查看选项套接字文件描述符 level: 要查看的可选项协议层 optname: 要查看的可选项名 optval: 保存查看结果的缓冲地址值 optlen: 向第四个参数传递的缓冲大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数。 */ #include \u0026lt;sys/socket.h\u003e // 更改可选项 int setsockopt(int sock, int level, int optname, const void *optval, socklen_t optlen); /* 成功时返回 0 ，失败时返回 -1 sock: 用于更改选项套接字文件描述符 level: 要更改的可选项协议层 optname: 要更改的可选项名 optval: 保存更改结果的缓冲地址值 optlen: 向第四个参数传递的缓冲大小。调用函数后，该变量中保存通过第四个参数返回的可选项信息的字节数。 */ #include \u0026","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;sys/socket.h\u003e int main(int argc, char *argv[]) { int tcp_sock, udp_sock; int sock_type; socklen_t optlen; int state; optlen = sizeof(sock_type); tcp_sock = socket(PF_INET, SOCK_STREAM, 0); udp_sock = socket(PF_INET, SOCK_DGRAM, 0); printf(\"SOCK_STREAM: %d\\n\", SOCK_STREAM); printf(\"SOCK_DGRAM: %d\\n\", SOCK_DGRAM); state = getsockopt(tcp_sock, SOL_SOCKET, SO_TYPE, (void *)\u0026sock_type, \u0026optlen); printf(\"Socket type one: %d \\n\", so","date":"2023-08-13T22:41:54+08:00","objectID":"1af475fc238aa198cd2c61eb6754c8b7_25","order":25,"summary":"lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;sys/socket.h\u003e int main(int argc, char *argv[]) { int tcp_sock, udp_sock; int sock_type; socklen_t optlen; int state; optlen = sizeof(sock_type); tcp_sock = socket(PF_INET, SOCK_STREAM, 0); udp_sock = socket(PF_INET, SOCK_DGRAM, 0); printf(\"SOCK_STREAM: %d\\n\", SOCK_STREAM); printf(\"SOCK_DGRAM: %d\\n\", SOCK_DGRAM); state = getsockopt(tcp_sock, SOL_SOCKET, SO_TYPE, (void *)\u0026sock_type, \u0026optlen); printf(\"Socket type one: %d \\n\", so","tags":["TCP","C++","Network"],"title":"TCP_IP网络编程","url":"http://localhost:1313/posts/learn/tcp_ip_network_programming/"},{"categories":["learn"],"content":"数据库概述 资料+视频MySQL常用命令 退出 exit 查看数据库 show databases; 使用某数据库 use xxx; 创建数据库 create databse xxx; 查看数据库中的表 show tables; 导入表 source path/xxx.sql 查看当前使用的数据库 select database() 批量执行sql脚本 source xxx.sql(或者windows直接sql文件拖进来) 建议都小写，不同操作系统处理方式不一致 以;结尾才会执行 表的理解 数据库中最基本的单位是表 数据库中以表格的形式表示数据 任何一张表都有行和列： 行：数据/记录 列：字段（包含字段名、数据类型、约束等属性） 数据库中的有一条命名规范：所有的标识符都是全部小写，单词和单词之间使用下划线进行衔接。 SQL语句的分类 DQL：数据查询语言（有select关键字） DML：数据操作语言（增删改表中的数据（insert into、delete、update）） DDL：数据定义语言（增删改表（create、drop、alter）） TCL：事务控制语言（事务提交commit","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_0","order":0,"summary":"数据库概述 资料+视频MySQL常用命令 退出 exit 查看数据库 show databases; 使用某数据库 use xxx; 创建数据库 create databse xxx; 查看数据库中的表 show tables; 导入表 source path/xxx.sql 查看当前使用的数据库 select database() 批量执行sql脚本 source xxx.sql(或者windows直接sql文件拖进来) 建议都小写，不同操作系统处理方式不一致 以;结尾才会执行 表的理解 数据库中最基本的单位是表 数据库中以表格的形式表示数据 任何一张表都有行和列： 行：数据/记录 列：字段（包含字段名、数据类型、约束等属性） 数据库中的有一条命名规范：所有的标识符都是全部小写，单词和单词之间使用下划线进行衔接。 SQL语句的分类 DQL：数据查询语言（有select关键字） DML：数据操作语言（增删改表中的数据（insert into、delete、update）） DDL：数据定义语言（增删改表（create、drop、alter）） TCL：事务控制语言（事务提交commit","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"、事务回滚rollback） DCL：数据控制语言（授权grant、撤权revoke） 查看表信息 select * from table_name 查看表内数据 desc table_name 查看表结构 SQL查询 简单查询 查询一个字段：select 字段名 from 表名; select/from是关键字 字段名和表名是标识符 字段名处也可以为字面量/字面值，此时输出 值为一样的所有行 select 1000 as num from EMP; 查询多个字段：select 字段名1,字段名2 from 表名 查询全部字段：select 全部字段 from 表名 or select * from 表名 效率比较低，可读性差 不建议写到程序里 起别名：select 字段名 as 别名 from 表名 只是将查询结果的列表显示为别名，不会修改表字段名 例：-- mysql注释 select deptno, dname deptname from dept; -- 去除as select deptno, dname 'dept name' from dept -- 别名加空格/中文用单引","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_1","order":1,"summary":"、事务回滚rollback） DCL：数据控制语言（授权grant、撤权revoke） 查看表信息 select * from table_name 查看表内数据 desc table_name 查看表结构 SQL查询 简单查询 查询一个字段：select 字段名 from 表名; select/from是关键字 字段名和表名是标识符 字段名处也可以为字面量/字面值，此时输出 值为一样的所有行 select 1000 as num from EMP; 查询多个字段：select 字段名1,字段名2 from 表名 查询全部字段：select 全部字段 from 表名 or select * from 表名 效率比较低，可读性差 不建议写到程序里 起别名：select 字段名 as 别名 from 表名 只是将查询结果的列表显示为别名，不会修改表字段名 例：-- mysql注释 select deptno, dname deptname from dept; -- 去除as select deptno, dname 'dept name' from dept -- 别名加空格/中文用单引","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"号; 注意数据库中使用单引号，双引号不标准 select ename, sal*10 as '年薪' from EMP -- 使用数学表达式 ; 条件查询 语法格式：select 字段1, 字段2from 表名where 条件;比较符号：= 、\u0026lt;\u003e或!= 、\u0026lt; 、\u0026lt;= 、\u003e 、\u003e=、between…and … （闭区间，左小右大） select empno, enmae, sal from EMP where sal \u0026lt; 1000; 判断符号：is null 为空（ is not null 不为空）and 、or in 包含，相当于多个 or （ not in 不在这个范围中）not 可以取非，主要用在 is 或 in 中 select empno,ename,sal,comm from emp where comm is null; select * from emp where (job='MANAGER' or job = 'SALESMAN') and sal \u003e 3000; and 优先级高 select empno,ename,job from em","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_2","order":2,"summary":"号; 注意数据库中使用单引号，双引号不标准 select ename, sal*10 as '年薪' from EMP -- 使用数学表达式 ; 条件查询 语法格式：select 字段1, 字段2from 表名where 条件;比较符号：= 、\u0026lt;\u003e或!= 、\u0026lt; 、\u0026lt;= 、\u003e 、\u003e=、between…and … （闭区间，左小右大） select empno, enmae, sal from EMP where sal \u0026lt; 1000; 判断符号：is null 为空（ is not null 不为空）and 、or in 包含，相当于多个 or （ not in 不在这个范围中）not 可以取非，主要用在 is 或 in 中 select empno,ename,sal,comm from emp where comm is null; select * from emp where (job='MANAGER' or job = 'SALESMAN') and sal \u003e 3000; and 优先级高 select empno,ename,job from em","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"p where job in ('MANAGER', 'SALESMAN'); 模糊查询：like 称为模糊查询，支持%或下划线匹配 特殊符号：% 匹配任意个字符、_ 只匹配一个字符 select ename from emp where ename like '%T' -- 最后一个是T select ename from emp where ename like '__R%' -- 第三个字母是R select name from t_student where name like '%_%' -- \\转义字符 排序 语法格式：select * from tablename order by sal -- 默认升序;order by sal desc -- 降序 或者-sal;order by sal asc -- 升序 或者+sal;语句顺序为 from -\u003e where -\u003e order by多字段排序：select ename,sal from emporder by sal asc, ename asc; // sal在前，起主导，只有sal相等的时候，才会考虑启用enam","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_3","order":3,"summary":"p where job in ('MANAGER', 'SALESMAN'); 模糊查询：like 称为模糊查询，支持%或下划线匹配 特殊符号：% 匹配任意个字符、_ 只匹配一个字符 select ename from emp where ename like '%T' -- 最后一个是T select ename from emp where ename like '__R%' -- 第三个字母是R select name from t_student where name like '%_%' -- \\转义字符 排序 语法格式：select * from tablename order by sal -- 默认升序;order by sal desc -- 降序 或者-sal;order by sal asc -- 升序 或者+sal;语句顺序为 from -\u003e where -\u003e order by多字段排序：select ename,sal from emporder by sal asc, ename asc; // sal在前，起主导，只有sal相等的时候，才会考虑启用enam","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"e排序。 数据处理函数 又称为单行处理函数。特点：一个输入对应一个输出。常见函数：Lower 转换小写、upper 转换大写 select lower(ename) as ename from EMP; substr 取子串 (substr(被截取的字符串,起始下标,截取的长度)) select ename from EMP where substr(ename, 1, 1) = 'A' -- 下标从1开始 select concat(lower(substr(ename,1,1)), substr(ename, 2)) as result from EMP -- 首字母小写 length 取长度 select length(ename) enamelength from EMP; trim 去空格 select * from EMP where ename = trim(' KING'); str_to_date 将字符串转换成日期 str_to_date('字符串日期', '日期格式') %Y\t年 %m 月 %d 日 %h 时 %i 分 %s 秒 %Y-%m-%d 不需要写日期格式","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_4","order":4,"summary":"e排序。 数据处理函数 又称为单行处理函数。特点：一个输入对应一个输出。常见函数：Lower 转换小写、upper 转换大写 select lower(ename) as ename from EMP; substr 取子串 (substr(被截取的字符串,起始下标,截取的长度)) select ename from EMP where substr(ename, 1, 1) = 'A' -- 下标从1开始 select concat(lower(substr(ename,1,1)), substr(ename, 2)) as result from EMP -- 首字母小写 length 取长度 select length(ename) enamelength from EMP; trim 去空格 select * from EMP where ename = trim(' KING'); str_to_date 将字符串转换成日期 str_to_date('字符串日期', '日期格式') %Y\t年 %m 月 %d 日 %h 时 %i 分 %s 秒 %Y-%m-%d 不需要写日期格式","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":" 通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据 insert into t_user(id,name,birth) values(1, 'zhangsan', str_to_date('01-10-1990','%d-%m-%Y')); 默认格式 %Y-%m-%d date_format 格式化日期 date_format(birth, '%m/%d/%Y') 通常使用在查询日期方面。设置展示的日期格式。 select id,name,date_format(birth,'%Y/%m/%d') as birth from t_user; 默认的日期格式：'%Y-%m-%d' format 设置千分位 select ename, format(sal, '$999,9999') as sal from EMP; // 不写999没事 round 四舍五入 select round(1236.5567, -1) as res from EMP; // 个位数四舍五入 rand() 生成随机数 select round(rand()*100,0) from emp; ","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_5","order":5,"summary":" 通常使用在插入insert方面，因为插入的时候需要一个日期类型的数据 insert into t_user(id,name,birth) values(1, 'zhangsan', str_to_date('01-10-1990','%d-%m-%Y')); 默认格式 %Y-%m-%d date_format 格式化日期 date_format(birth, '%m/%d/%Y') 通常使用在查询日期方面。设置展示的日期格式。 select id,name,date_format(birth,'%Y/%m/%d') as birth from t_user; 默认的日期格式：'%Y-%m-%d' format 设置千分位 select ename, format(sal, '$999,9999') as sal from EMP; // 不写999没事 round 四舍五入 select round(1236.5567, -1) as res from EMP; // 个位数四舍五入 rand() 生成随机数 select round(rand()*100,0) from emp; ","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"// 100以内的随机数 Ifnull 可以将 null 转换成一个具体值 ifnull是空处理函数。专门处理NULL的。在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。 select ename, (sal + ifnull(comm, 0)) * 12 as yearsal from emp; case ... when ... then ... when ... then ... else ... end select ename, job, sal as oldsal,(case job when 'MANAGER' then sal * 1.1 when 'SALESMAN' then sal * 1.5 else sal end) as newsal from emp; 分组函数 又名多行处理函数，特点：输入多行，输出一行。分组函数在使用的时候先分组，再使用，默认一张表为一组。count 计数 select count(ename) from EMP; sum 求和 avg 平均值 max 最大值 min 最小值 注意事项：分组函数自动忽略NULL，不","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_6","order":6,"summary":"// 100以内的随机数 Ifnull 可以将 null 转换成一个具体值 ifnull是空处理函数。专门处理NULL的。在所有数据库当中，只要有NULL参与的数学运算，最终结果就是NULL。 select ename, (sal + ifnull(comm, 0)) * 12 as yearsal from emp; case ... when ... then ... when ... then ... else ... end select ename, job, sal as oldsal,(case job when 'MANAGER' then sal * 1.1 when 'SALESMAN' then sal * 1.5 else sal end) as newsal from emp; 分组函数 又名多行处理函数，特点：输入多行，输出一行。分组函数在使用的时候先分组，再使用，默认一张表为一组。count 计数 select count(ename) from EMP; sum 求和 avg 平均值 max 最大值 min 最小值 注意事项：分组函数自动忽略NULL，不","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"需要提前处理NULL 分组函数中count(*)和count(具体字段)的区别 具体字段：统计该字段下所有不为NULL的元素的总数 *：统计表中所有行。一行不可能全为NULL 分组函数不能直接用在where子句中 select ename,sal from emp where sal \u003e min(sal); // error 所有分组函数可以组合起来使用，不能嵌套使用 分组查询 select ... from ... group by ...执行顺序 from -\u003e where -\u003e group by -\u003e having -\u003e select -\u003e order by 为什么分组函数不能直接使用在where后面？select ename,sal from emp where sal \u003e min(sal); //报错。因为分组函数在使用的时候必须先分组之后才能使用。where执行的时候，还没有分组。所以where后面不能出现分组函数。select sum(sal) from emp; 这个没有分组，为啥sum()函数可以用呢？因为select在group by之后执行。不分组默认一张表一组例","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_7","order":7,"summary":"需要提前处理NULL 分组函数中count(*)和count(具体字段)的区别 具体字段：统计该字段下所有不为NULL的元素的总数 *：统计表中所有行。一行不可能全为NULL 分组函数不能直接用在where子句中 select ename,sal from emp where sal \u003e min(sal); // error 所有分组函数可以组合起来使用，不能嵌套使用 分组查询 select ... from ... group by ...执行顺序 from -\u003e where -\u003e group by -\u003e having -\u003e select -\u003e order by 为什么分组函数不能直接使用在where后面？select ename,sal from emp where sal \u003e min(sal); //报错。因为分组函数在使用的时候必须先分组之后才能使用。where执行的时候，还没有分组。所以where后面不能出现分组函数。select sum(sal) from emp; 这个没有分组，为啥sum()函数可以用呢？因为select在group by之后执行。不分组默认一张表一组例","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"：select job,sum(sal) from emp group by job; 先从emp表中查询数据。根据job字段进行分组。然后对每一组的数据进行sum(sal) 在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其它的一律不能跟，sql旧版本不会报错。 select deptno, job, max(sal) from emp group by deptno, job; 联合分组查询，每个部门，不同工作岗位的最高薪资 使用having 进一步过滤 （不能单独使用，只能配套group by）where和having，优先选择where，where实在完成不了，再选择having。例：select job, avg(sal) avgsal from EMP where job \u0026lt;\u003e 'MANAGER' group by job having avg(sal) \u003e 1500 order by avgsal desc; 最好使用desc而不是-avgsal 会报错 连接查询 去除重复记录 distinct //","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_8","order":8,"summary":"：select job,sum(sal) from emp group by job; 先从emp表中查询数据。根据job字段进行分组。然后对每一组的数据进行sum(sal) 在一条select语句当中，如果有group by语句的话，select后面只能跟：参加分组的字段，以及分组函数。其它的一律不能跟，sql旧版本不会报错。 select deptno, job, max(sal) from emp group by deptno, job; 联合分组查询，每个部门，不同工作岗位的最高薪资 使用having 进一步过滤 （不能单独使用，只能配套group by）where和having，优先选择where，where实在完成不了，再选择having。例：select job, avg(sal) avgsal from EMP where job \u0026lt;\u003e 'MANAGER' group by job having avg(sal) \u003e 1500 order by avgsal desc; 最好使用desc而不是-avgsal 会报错 连接查询 去除重复记录 distinct //","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":" distinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。 select distinct job,deptno from emp; select count(distinct job) from emp; // 得到工作种类数 概念：多张表联合查询。连接查询的分类：语法的年代 sql92 sql99 （本文使用） 连接的方式 内连接 等值连接 非等值连接 自连接 外连接 左外连接（左连接） 右外连接（右连接） 笛卡尔积 当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表行数的乘积，这种现象被称为：笛卡尔积现象。加入条件限制：select ename, dname from EMP, DEPT where EMP.ename = DEPT.dname匹配次数没减少，显示条数减少，添加筛选优化（表起别名）：select e.ename, d.dname from EMP e, DEPT d where e.deptno = d.deptno; //92语法注意：通过笛卡尔积现象得出，表的连接次数越多效率越低，尽量避免表的连接次数。内连接 s","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_9","order":9,"summary":" distinct出现在job,deptno两个字段之前，表示两个字段联合起来去重。 select distinct job,deptno from emp; select count(distinct job) from emp; // 得到工作种类数 概念：多张表联合查询。连接查询的分类：语法的年代 sql92 sql99 （本文使用） 连接的方式 内连接 等值连接 非等值连接 自连接 外连接 左外连接（左连接） 右外连接（右连接） 笛卡尔积 当两张表进行连接查询，没有任何条件限制的时候，最终查询结果条数，是两张表行数的乘积，这种现象被称为：笛卡尔积现象。加入条件限制：select ename, dname from EMP, DEPT where EMP.ename = DEPT.dname匹配次数没减少，显示条数减少，添加筛选优化（表起别名）：select e.ename, d.dname from EMP e, DEPT d where e.deptno = d.deptno; //92语法注意：通过笛卡尔积现象得出，表的连接次数越多效率越低，尽量避免表的连接次数。内连接 s","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"ql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。sql99的优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where。sql99的语法：select ... from a join b on a和b的连接条件 where 筛选条件 （默认内连接 inner join）内连接特点：A和B连接，AB两张表没有主次关系。平等的。等值连接 条件是等量关系，所以被称为等值连接。 select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno; 非等值连接 条件不是一个等量关系，称为非等值连接。 select e.ename, e.sal, s.grade from emp e inner join salgrade s on e.sal between s.losal and s.hisal; 自连接 一张表看做两张表。 select a.ename, b.ename from EMP a join EMP b on a.mgr = b.em","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_10","order":10,"summary":"ql92的缺点：结构不清晰，表的连接条件，和后期进一步筛选的条件，都放到了where后面。sql99的优点：表连接的条件是独立的，连接之后，如果还需要进一步筛选，再往后继续添加where。sql99的语法：select ... from a join b on a和b的连接条件 where 筛选条件 （默认内连接 inner join）内连接特点：A和B连接，AB两张表没有主次关系。平等的。等值连接 条件是等量关系，所以被称为等值连接。 select e.ename,d.dname from emp e inner join dept d on e.deptno = d.deptno; 非等值连接 条件不是一个等量关系，称为非等值连接。 select e.ename, e.sal, s.grade from emp e inner join salgrade s on e.sal between s.losal and s.hisal; 自连接 一张表看做两张表。 select a.ename, b.ename from EMP a join EMP b on a.mgr = b.em","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"pno; 注意 null不显示 外连接 右连接 select e.ename,d.dname from emp e right outer join dept d on e.deptno = d.deptno; right表示将join关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表。在外连接当中，两张表连接，产生了主次关系。 左连接 select a.ename as '员工名', b.ename as '领导名' from emp a left join emp b on a.mgr = b.empno; 内连接不显示null 外连接的查询结果条数一定是 \u003e= 内连接的查询结果条数 多表连接 语法：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 select ... from a join b on a和b的连接条件 join c on a和c的连接条件 right join d on a和d的连接条件 每个员工的部门名称以","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_11","order":11,"summary":"pno; 注意 null不显示 外连接 右连接 select e.ename,d.dname from emp e right outer join dept d on e.deptno = d.deptno; right表示将join关键字右边的这张表看成主表，主要是为了将这张表的数据全部查询出来，捎带着关联查询左边的表。在外连接当中，两张表连接，产生了主次关系。 左连接 select a.ename as '员工名', b.ename as '领导名' from emp a left join emp b on a.mgr = b.empno; 内连接不显示null 外连接的查询结果条数一定是 \u003e= 内连接的查询结果条数 多表连接 语法：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 select ... from a join b on a和b的连接条件 join c on a和c的连接条件 right join d on a和d的连接条件 每个员工的部门名称以","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"及工资等级，还有上级领导，员工信息 select e.ename,e.sal,d.dname,s.grade,l.ename from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal left join emp l on e.mgr = l.empno; 子查询 定义：select语句中嵌套select语句，被嵌套的语句称为子查询子查询可以出现在select ...(select) from ... (select) where ... (select)where中的子查询 select ename,sal from emp where sal \u003e (select min(sal) from emp); from中的子查询 可以将子查询的结果作为临时表 select t.*, s.grade from(select job,avg(sal) as avgsal from emp group by job) t join salgrade s on ","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_12","order":12,"summary":"及工资等级，还有上级领导，员工信息 select e.ename,e.sal,d.dname,s.grade,l.ename from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal left join emp l on e.mgr = l.empno; 子查询 定义：select语句中嵌套select语句，被嵌套的语句称为子查询子查询可以出现在select ...(select) from ... (select) where ... (select)where中的子查询 select ename,sal from emp where sal \u003e (select min(sal) from emp); from中的子查询 可以将子查询的结果作为临时表 select t.*, s.grade from(select job,avg(sal) as avgsal from emp group by job) t join salgrade s on ","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"t.avgsal between s.losal and s.hisal; 子查询中avg要起别名 select中的子查询 （了解即可） select子查询必须返回一条结果 select e.ename,e.deptno,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e; union union的效率要高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。。但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接。a 连接 b 连接 ca 10条记录b 10条记录c 10条记录匹配次数是：1000a 连接 b一个结果：10 * 10 --\u003e 100次a 连接 c一个结果：10 * 10 --\u003e 100次使用union的话是：100次 + 100次 = 200次。（union把乘法变成了加法运算）1 2 3 4 select ename,job from EMP where job = 'MANAGER' union select enam","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_13","order":13,"summary":"t.avgsal between s.losal and s.hisal; 子查询中avg要起别名 select中的子查询 （了解即可） select子查询必须返回一条结果 select e.ename,e.deptno,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e; union union的效率要高一些。对于表连接来说，每连接一次新表，则匹配的次数满足笛卡尔积，成倍的翻。。但是union可以减少匹配的次数。在减少匹配次数的情况下，还可以完成两个结果集的拼接。a 连接 b 连接 ca 10条记录b 10条记录c 10条记录匹配次数是：1000a 连接 b一个结果：10 * 10 --\u003e 100次a 连接 c一个结果：10 * 10 --\u003e 100次使用union的话是：100次 + 100次 = 200次。（union把乘法变成了加法运算）1 2 3 4 select ename,job from EMP where job = 'MANAGER' union select enam","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"e from EMP where job = 'SALESMAN'; -- 需要加上job -- 否则oracle,mysql8报错，要求：结果集合并时列和列的数据类型也要一致。 limit (!important) limit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。完整用法：limit startIndex, length只能加数字The LIMIT clause can be used to constrain the number of rows returned by the SELECT statement. LIMIT takes one or two numeric arguments, which must both be nonnegative integer constants, with these exceptions:Within prepared statements, LIMIT parameters can be specified using ? placeholder markers. Within stored programs,","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_14","order":14,"summary":"e from EMP where job = 'SALESMAN'; -- 需要加上job -- 否则oracle,mysql8报错，要求：结果集合并时列和列的数据类型也要一致。 limit (!important) limit作用：将查询结果集的一部分取出来。通常使用在分页查询当中。完整用法：limit startIndex, length只能加数字The LIMIT clause can be used to constrain the number of rows returned by the SELECT statement. LIMIT takes one or two numeric arguments, which must both be nonnegative integer constants, with these exceptions:Within prepared statements, LIMIT parameters can be specified using ? placeholder markers. Within stored programs,","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":" LIMIT parameters can be specified using integer-valued routine parameters or local variables. startIndex是起始下标从0开始，length是长度。缺省用法：limit 5; 这是取前5.执行顺序在order by 之后 select ename, sal from EMP order by sal limit 2, 3; 分页 每页显示pageSize条记录第pageNo页：limit (pageNo - 1) * pageSize , pageSizeDQL总结 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 select ... from ... where ... group by ... having ... order by ... limit ... 执行顺序： 1.from 2.where 3.group by 4.having 5.select 6.order by 7.limit.. SQL增删","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_15","order":15,"summary":" LIMIT parameters can be specified using integer-valued routine parameters or local variables. startIndex是起始下标从0开始，length是长度。缺省用法：limit 5; 这是取前5.执行顺序在order by 之后 select ename, sal from EMP order by sal limit 2, 3; 分页 每页显示pageSize条记录第pageNo页：limit (pageNo - 1) * pageSize , pageSizeDQL总结 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 select ... from ... where ... group by ... having ... order by ... limit ... 执行顺序： 1.from 2.where 3.group by 4.having 5.select 6.order by 7.limit.. SQL增删","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"改 mysql中的数据类型 varchar(最长255)\t可变长度的字符串 比较智能，节省空间。会根据实际的数据长度动态分配空间。 优点：节省空间。缺点：需要动态分配空间，速度慢。 char(最长255)\t定长字符串 不管实际的数据长度是多少。分配固定长度的空间去存储数据。使用不恰当的时候，可能会导致空间的浪费。 优点：不需要动态分配空间，速度快。缺点：使用不当可能会导致空间的浪费。 varchar和char我们应该怎么选择？ 性别字段你选什么？因为性别是固定长度的字符串，所以选择char。姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。 int\t整数型。(最长11)。 bigint\t长整型。 float\t单精度浮点型数据 double\t双精度浮点型数据 date\t短日期类型 默认格式：%Y-%m-%d datetime\t长日期类型 默认格式：%Y-%m-%d %h:%i:%s 获取当前时间 now()函数 clob\t字符大对象\tCharacter Large OBject 最多可以存储4G的字符串。超过255个字符的都要采用CLOB字符大对象来存储。 blob\t二进","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_16","order":16,"summary":"改 mysql中的数据类型 varchar(最长255)\t可变长度的字符串 比较智能，节省空间。会根据实际的数据长度动态分配空间。 优点：节省空间。缺点：需要动态分配空间，速度慢。 char(最长255)\t定长字符串 不管实际的数据长度是多少。分配固定长度的空间去存储数据。使用不恰当的时候，可能会导致空间的浪费。 优点：不需要动态分配空间，速度快。缺点：使用不当可能会导致空间的浪费。 varchar和char我们应该怎么选择？ 性别字段你选什么？因为性别是固定长度的字符串，所以选择char。姓名字段你选什么？每一个人的名字长度不同，所以选择varchar。 int\t整数型。(最长11)。 bigint\t长整型。 float\t单精度浮点型数据 double\t双精度浮点型数据 date\t短日期类型 默认格式：%Y-%m-%d datetime\t长日期类型 默认格式：%Y-%m-%d %h:%i:%s 获取当前时间 now()函数 clob\t字符大对象\tCharacter Large OBject 最多可以存储4G的字符串。超过255个字符的都要采用CLOB字符大对象来存储。 blob\t二进","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"制大对象\tBinary Large Object 专门用来存储图片、声音、视频等流媒体数据。 往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，需要使用IO流。 增删改表（DDL） create table 表名(字段名1 数据类型, 字段名2 数据类型, ...); 表名：建议以t_ 或者 tbl_开始，可读性强。见名知意。 字段名：见名知意。 表名和字段名都属于标识符。 快速建表：create table emp as select * from EMP; //了解 将查询结果当做一个表新建，完成快速复制 1 2 3 4 5 6 7 create table t_student( no int, name varchar(32), sex char(1) default 'm', age int(3), email varchar(255) ); drop table 表名; // 不存在则删除报错 drop table if exists 表名; // 不报错 truncate table 表名 比delete 快，但是不支持回滚，是物理删除，需要仔细确认。 删除表","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_17","order":17,"summary":"制大对象\tBinary Large Object 专门用来存储图片、声音、视频等流媒体数据。 往BLOB类型的字段上插入数据的时候，例如插入一个图片、视频等，需要使用IO流。 增删改表（DDL） create table 表名(字段名1 数据类型, 字段名2 数据类型, ...); 表名：建议以t_ 或者 tbl_开始，可读性强。见名知意。 字段名：见名知意。 表名和字段名都属于标识符。 快速建表：create table emp as select * from EMP; //了解 将查询结果当做一个表新建，完成快速复制 1 2 3 4 5 6 7 create table t_student( no int, name varchar(32), sex char(1) default 'm', age int(3), email varchar(255) ); drop table 表名; // 不存在则删除报错 drop table if exists 表名; // 不报错 truncate table 表名 比delete 快，但是不支持回滚，是物理删除，需要仔细确认。 删除表","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"数据，不是删除表 增删改数据（DML） insert into 表名(字段名1,字段名2,字段名3...) values(值1,值2,值3), (值1, 值2, 值3), (...); 注意：字段名和值要一一对应。数量要对应。数据类型要对应。 insert语句执行成功了，必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。 insert into t_student values(2, 'lisi', 'f', 20, 'lisi@123.com'); // 不写字段名，需要跟表字段名一一对应 快速复制：insert into emp_bak select * from emp; //了解 update 表名 set 字段名1=值1, 字段名2=值2,...** where 条件**; 不加条件限制会更新所有数据 delete from 表名** where 条件**; 不加条件限制会删除所有数据 删除数据的原理：表中的数据被删除了，但是保存在硬盘内的数据不会被释放；因此效率较低，但是可以回滚，恢复数据 增删改表结构 开发中很少进行表结构的修改。 alter关键字 约束 保证","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_18","order":18,"summary":"数据，不是删除表 增删改数据（DML） insert into 表名(字段名1,字段名2,字段名3...) values(值1,值2,值3), (值1, 值2, 值3), (...); 注意：字段名和值要一一对应。数量要对应。数据类型要对应。 insert语句执行成功了，必然会多一条记录。没有给其它字段指定值的话，默认值是NULL。 insert into t_student values(2, 'lisi', 'f', 20, 'lisi@123.com'); // 不写字段名，需要跟表字段名一一对应 快速复制：insert into emp_bak select * from emp; //了解 update 表名 set 字段名1=值1, 字段名2=值2,...** where 条件**; 不加条件限制会更新所有数据 delete from 表名** where 条件**; 不加条件限制会删除所有数据 删除数据的原理：表中的数据被删除了，但是保存在硬盘内的数据不会被释放；因此效率较低，但是可以回滚，恢复数据 增删改表结构 开发中很少进行表结构的修改。 alter关键字 约束 保证","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"数据有效性、完整性约束包括：create table中指定非空约束 not null 列级约束：id int not null 唯一性约束 unique null可以重复 列级约束：name varchar(23) unique 表级约束（多字段联合约束）：unique(name, email) 主键约束 primary key 主键约束、主键字段、主键值 一个字段同时非空又不能重复自动为主键，oracle不行，主键约束特征是not null + unique 每个表都应有主键，是每一行记录的唯一标识 可以单一主键或复合主键（不建议使用复合） int id primary key, primary key(id, name), 又分为自然主键和业务主键，通常自然主键 主键约束只能有一个 建议使用int、bigint、char，等定长类型 自动维护主键值：id int primary key auto_increment, 外键约束 foreign key 减少表冗余，防止出现无效数据 外界约束、外键字段、外键值 格式： foreign key(子表字段) references (父表唯","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_19","order":19,"summary":"数据有效性、完整性约束包括：create table中指定非空约束 not null 列级约束：id int not null 唯一性约束 unique null可以重复 列级约束：name varchar(23) unique 表级约束（多字段联合约束）：unique(name, email) 主键约束 primary key 主键约束、主键字段、主键值 一个字段同时非空又不能重复自动为主键，oracle不行，主键约束特征是not null + unique 每个表都应有主键，是每一行记录的唯一标识 可以单一主键或复合主键（不建议使用复合） int id primary key, primary key(id, name), 又分为自然主键和业务主键，通常自然主键 主键约束只能有一个 建议使用int、bigint、char，等定长类型 自动维护主键值：id int primary key auto_increment, 外键约束 foreign key 减少表冗余，防止出现无效数据 外界约束、外键字段、外键值 格式： foreign key(子表字段) references (父表唯","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"一性约束字段，可以为NULL) 检查约束 check （mysql 不支持，oracle支持） 存储引擎 存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）存储引擎是一个表存储/组织数据的方式。不同的存储引擎，表存储数据的方式不同。给表指定存储引擎显示存储引擎：show create table 表名 mysql默认引擎是InnoDB，字符集utf8 格式：create table 表名() engine=InnoDB default charset=gbk; 查看mysql支持存储引擎：show engines \\GMyISAM存储引擎 它管理的表具有以下特征： 使用三个文件表示每个表： 格式文件 — 存储表结构的定义（mytable.frm / framework） 数据文件 — 存储表行的内容（mytable.MYD/ mydata） 索引文件 — 存储表上索引（mytable.MYI / myindex）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。 可被转换为压缩（只读）表来节省空间 对于一张表来说，只要是主键，或者加","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_20","order":20,"summary":"一性约束字段，可以为NULL) 检查约束 check （mysql 不支持，oracle支持） 存储引擎 存储引擎是MySQL中特有的一个术语，其它数据库中没有。（Oracle中有，但是不叫这个名字）存储引擎是一个表存储/组织数据的方式。不同的存储引擎，表存储数据的方式不同。给表指定存储引擎显示存储引擎：show create table 表名 mysql默认引擎是InnoDB，字符集utf8 格式：create table 表名() engine=InnoDB default charset=gbk; 查看mysql支持存储引擎：show engines \\GMyISAM存储引擎 它管理的表具有以下特征： 使用三个文件表示每个表： 格式文件 — 存储表结构的定义（mytable.frm / framework） 数据文件 — 存储表行的内容（mytable.MYD/ mydata） 索引文件 — 存储表上索引（mytable.MYI / myindex）：索引是一本书的目录，缩小扫描范围，提高查询效率的一种机制。 可被转换为压缩（只读）表来节省空间 对于一张表来说，只要是主键，或者加","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["learn"],"content":"有unique约束的字段上会自动创建索引。 MyISAM存储引擎特点： 可被转换为压缩（只读）表来节省空间 这是这种存储引擎的优势！ MyISAM不支持事务机制，安全性低。 InnoDB存储引擎 这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。 InnoDB支持事务，支持数据库崩溃后自动恢复机制。 InnoDB存储引擎最主要的特点是：非常安全。 它管理的表具有下列主要特征： 每个 InnoDB 表在数据库目录中以.frm 格式文件表示 InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间：存储数据+索引。） 提供一组用来记录事务性活动的日志文件 用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理 提供全 ACID 兼容 在 MySQL 服务器崩溃后提供自动恢复 多版本（MVCC）和行级锁定 支持外键及引用的完整性，包括级联删除和更新 InnoDB最大的特点就是支持事务： 保证数据的安全。效率不是很高，不能压缩，不能转换为只读，不能很好的节省存储空间。 MEMORY存储引擎 用 MEMORY 存储引擎的","date":"2023-08-10T23:13:48+08:00","objectID":"8a23d13a7e3a8d9f9a094aaaed4fd21a_21","order":21,"summary":"有unique约束的字段上会自动创建索引。 MyISAM存储引擎特点： 可被转换为压缩（只读）表来节省空间 这是这种存储引擎的优势！ MyISAM不支持事务机制，安全性低。 InnoDB存储引擎 这是mysql默认的存储引擎，同时也是一个重量级的存储引擎。 InnoDB支持事务，支持数据库崩溃后自动恢复机制。 InnoDB存储引擎最主要的特点是：非常安全。 它管理的表具有下列主要特征： 每个 InnoDB 表在数据库目录中以.frm 格式文件表示 InnoDB 表空间 tablespace 被用于存储表的内容（表空间是一个逻辑名称。表空间：存储数据+索引。） 提供一组用来记录事务性活动的日志文件 用 COMMIT(提交)、SAVEPOINT 及ROLLBACK(回滚)支持事务处理 提供全 ACID 兼容 在 MySQL 服务器崩溃后提供自动恢复 多版本（MVCC）和行级锁定 支持外键及引用的完整性，包括级联删除和更新 InnoDB最大的特点就是支持事务： 保证数据的安全。效率不是很高，不能压缩，不能转换为只读，不能很好的节省存储空间。 MEMORY存储引擎 用 MEMORY 存储引擎的","tags":["MySQL"],"title":"MySQL学习","url":"http://localhost:1313/posts/learn/mysql-tutorial/"},{"categories":["life"],"content":"序 限于文字功底不是那么深厚，故摘录一些喜欢的文字。禅与摩托车维修艺术 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/30208077/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/避开陷阱的第一个技巧就是拿出你的笔记本，写下拆卸的每一个步骤，关注特殊细节，它们在安装时很可能出问题。这本笔记本上面一定会沾染许多油污，但是几次下来之后，写在上面的一两个字虽然往往看似不甚重要，却使你避免了很多错误，节省了不少时间。写的时候，要特别注意各个零件在左在右，以及上下朝向，电线的颜色和布线方式。而且，如果有某个零件磨损，正好记下来，以便以后一起采购。第二个技巧就是在车库地上铺一张报纸，把所有的零件由左到右、由上到下排列整齐，和我们读书的顺序一样。这样一来，安装的时候，你就可以按照相反的次序进行，许多小螺钉、垫圈还有扣针才不会被遗漏。即使有这样周全的准备，可能仍然会出意外，这时你就要特别注意自己的士气。一定要静下心来。如果你想加紧脚步，弥补损失的时间，可能反","date":"2023-07-31T22:57:22+08:00","objectID":"775b57e2e95e90fd6915e39909fb4748_0","order":0,"summary":"序 限于文字功底不是那么深厚，故摘录一些喜欢的文字。禅与摩托车维修艺术 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/30208077/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/避开陷阱的第一个技巧就是拿出你的笔记本，写下拆卸的每一个步骤，关注特殊细节，它们在安装时很可能出问题。这本笔记本上面一定会沾染许多油污，但是几次下来之后，写在上面的一两个字虽然往往看似不甚重要，却使你避免了很多错误，节省了不少时间。写的时候，要特别注意各个零件在左在右，以及上下朝向，电线的颜色和布线方式。而且，如果有某个零件磨损，正好记下来，以便以后一起采购。第二个技巧就是在车库地上铺一张报纸，把所有的零件由左到右、由上到下排列整齐，和我们读书的顺序一样。这样一来，安装的时候，你就可以按照相反的次序进行，许多小螺钉、垫圈还有扣针才不会被遗漏。即使有这样周全的准备，可能仍然会出意外，这时你就要特别注意自己的士气。一定要静下心来。如果你想加紧脚步，弥补损失的时间，可能反","tags":["Life","Books"],"title":"文字摘录","url":"http://localhost:1313/posts/life/book-list/"},{"categories":["life"],"content":"而会错误百出。当你意识到你必须全部拆开，从头再来一遍的时候，一定要停下来，好好休息一番。 ---- 第三部 26 明朝那些事儿 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/7163250/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/千锤百炼出深山，烈火焚烧若等闲。粉身碎骨浑不怕，要留清白在人间！ --- 于谦82年生的金智英 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/34434309/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/有时持家会被看作“整天在家里闲着没事做”，充满贬义和歧视；有时则被看作养活一家老小的事”，把你捧得高高在上，却又不会用金钱来换算这件事情，因为一旦有了定价，势必得有人支付。 我们经常会听过来人说：“母爱是本能，等你面对时自然就会了。”可是当妈妈真的不是这么一回事，那是一","date":"2023-07-31T22:57:22+08:00","objectID":"775b57e2e95e90fd6915e39909fb4748_1","order":1,"summary":"而会错误百出。当你意识到你必须全部拆开，从头再来一遍的时候，一定要停下来，好好休息一番。 ---- 第三部 26 明朝那些事儿 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/7163250/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/千锤百炼出深山，烈火焚烧若等闲。粉身碎骨浑不怕，要留清白在人间！ --- 于谦82年生的金智英 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/34434309/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/有时持家会被看作“整天在家里闲着没事做”，充满贬义和歧视；有时则被看作养活一家老小的事”，把你捧得高高在上，却又不会用金钱来换算这件事情，因为一旦有了定价，势必得有人支付。 我们经常会听过来人说：“母爱是本能，等你面对时自然就会了。”可是当妈妈真的不是这么一回事，那是一","tags":["Life","Books"],"title":"文字摘录","url":"http://localhost:1313/posts/life/book-list/"},{"categories":["life"],"content":"连串难以言喻的恐惧、疲劳、惊吓、不知所措、混乱、挫折，甚至会出现一股背叛感，觉得“怎么都没有人事先告诉我会这么辛苦，要是有人告诉我，我就会提早做好身体与心理准备，说不定会处理得更得心应手，不会那么辛苦。难道是因为怕说出实情以后，在这出生率已经够低的年代会害得更多人不敢生小孩吗？还是到处对人说带小孩有多累是不礼貌的行为”？当然，我们从不认为身为女儿、女学生、女朋友、女员工、妻子、媳妇的人生就不辛苦，但是母亲的角色毋庸置疑是辛苦的，而这份辛苦，也并非单纯只来自抚养另外一个小生命。 The old man and the sea https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/26994251/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/But, he thought, I keep them with precision. Only I have no luck any more.But who knows? Maybe today. Every ","date":"2023-07-31T22:57:22+08:00","objectID":"775b57e2e95e90fd6915e39909fb4748_2","order":2,"summary":"连串难以言喻的恐惧、疲劳、惊吓、不知所措、混乱、挫折，甚至会出现一股背叛感，觉得“怎么都没有人事先告诉我会这么辛苦，要是有人告诉我，我就会提早做好身体与心理准备，说不定会处理得更得心应手，不会那么辛苦。难道是因为怕说出实情以后，在这出生率已经够低的年代会害得更多人不敢生小孩吗？还是到处对人说带小孩有多累是不礼貌的行为”？当然，我们从不认为身为女儿、女学生、女朋友、女员工、妻子、媳妇的人生就不辛苦，但是母亲的角色毋庸置疑是辛苦的，而这份辛苦，也并非单纯只来自抚养另外一个小生命。 The old man and the sea https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/26994251/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/But, he thought, I keep them with precision. Only I have no luck any more.But who knows? Maybe today. Every ","tags":["Life","Books"],"title":"文字摘录","url":"http://localhost:1313/posts/life/book-list/"},{"categories":["life"],"content":"day is a new day. It is better to be lucky. But I would rather be exact. Then when luck comes you are ready. 大学 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/2037610/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/所谓诚其意者：毋自欺也。如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也！ 南京大屠杀 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/26545308/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/在一个眩晕的瞬间，我陡然明白生命和人类的经历本身都是如此脆弱。我们从小就知道死亡是什么。任何人都会被卡车或者巴士撞到，生命随之在刹那间消失。如果没有某种宗教荥阳，我们会认为这样的死亡","date":"2023-07-31T22:57:22+08:00","objectID":"775b57e2e95e90fd6915e39909fb4748_3","order":3,"summary":"day is a new day. It is better to be lucky. But I would rather be exact. Then when luck comes you are ready. 大学 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/2037610/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/所谓诚其意者：毋自欺也。如恶恶臭，如好好色，此之谓自谦，故君子必慎其独也！ 南京大屠杀 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/26545308/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/在一个眩晕的瞬间，我陡然明白生命和人类的经历本身都是如此脆弱。我们从小就知道死亡是什么。任何人都会被卡车或者巴士撞到，生命随之在刹那间消失。如果没有某种宗教荥阳，我们会认为这样的死亡","tags":["Life","Books"],"title":"文字摘录","url":"http://localhost:1313/posts/life/book-list/"},{"categories":["life"],"content":"是毫无意义也不公正的对生命的剥夺。但我们也知道，大多数人都尊重生命和死亡的过程。如果你被一辆巴士装撞了，也许有人会乘你受伤的时候偷走你的钱包，但更多的人会来帮你，抢救你宝贵的生命。有人会拨急救电话，有人会奔跑到街上叫当班的警察，还有人会脱下大衣，叠起来垫在你的脑后。这样，即使这是你生命的最后时刻，你也能从这些很小却很温暖的事情中感受到他人的关心。挂在普库提诺墙上的照片却展示了千千万万的生命会因他人的狂妄念头而遭到毁灭，而这种死亡在第二天就变得毫无意义。更重要的是，那些带来死亡的人竟还羞辱受难者，逼使他们在最大限度的痛苦和耻辱中死去。这样对死亡的残忍的不敬，这样人类社会过程的倒退，将只会缩成历史的一个脚注。除非有人迫使这个世界去记住它，否则它就像计算机程序中的一个无害的小错，也许会，又也许不会引起任何问题。想到这里，我感到一阵心悸。 回顾千年历史，使人清楚的是，没有一个种族或一种文化在战争的残酷性方便占有垄断权。文明的外衣看起来是太薄了——以致人们能够很容易就把它撕去，特别是在战争的压力下。 尽管中国俘虏的人数大大超过要杀死他们的日本人，而且有可能战胜他们，但却没有一个人行动，每个人都畏","date":"2023-07-31T22:57:22+08:00","objectID":"775b57e2e95e90fd6915e39909fb4748_4","order":4,"summary":"是毫无意义也不公正的对生命的剥夺。但我们也知道，大多数人都尊重生命和死亡的过程。如果你被一辆巴士装撞了，也许有人会乘你受伤的时候偷走你的钱包，但更多的人会来帮你，抢救你宝贵的生命。有人会拨急救电话，有人会奔跑到街上叫当班的警察，还有人会脱下大衣，叠起来垫在你的脑后。这样，即使这是你生命的最后时刻，你也能从这些很小却很温暖的事情中感受到他人的关心。挂在普库提诺墙上的照片却展示了千千万万的生命会因他人的狂妄念头而遭到毁灭，而这种死亡在第二天就变得毫无意义。更重要的是，那些带来死亡的人竟还羞辱受难者，逼使他们在最大限度的痛苦和耻辱中死去。这样对死亡的残忍的不敬，这样人类社会过程的倒退，将只会缩成历史的一个脚注。除非有人迫使这个世界去记住它，否则它就像计算机程序中的一个无害的小错，也许会，又也许不会引起任何问题。想到这里，我感到一阵心悸。 回顾千年历史，使人清楚的是，没有一个种族或一种文化在战争的残酷性方便占有垄断权。文明的外衣看起来是太薄了——以致人们能够很容易就把它撕去，特别是在战争的压力下。 尽管中国俘虏的人数大大超过要杀死他们的日本人，而且有可能战胜他们，但却没有一个人行动，每个人都畏","tags":["Life","Books"],"title":"文字摘录","url":"http://localhost:1313/posts/life/book-list/"},{"categories":["life"],"content":"怯的顺从。可悲的是，在这个大坑周围的所有人当中，唐记得只有这位孕妇表现出一点点勇气。 我们应以慎重的天都看待南京的暴行——它阐明了人是多么容易被鼓励让十几岁的孩子泯灭天性，成为可怕的杀人机器。 只要罪恶离我们远得不足以对个人形成威胁，人性中一些扭曲的东西，社会会使得最令人难以言说的罪恶在瞬间变成平常琐事。 白鹿原 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/10564071/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/活着就要记住，人生最痛苦最绝望的那一刻是最难熬的一刻，但不是生命结束的最后一刻；熬过去挣过去就会开始一个重要的转折，开始一个新的辉煌历程；心软一下熬不过去就死了，死了一切就都完了。 长安的荔枝 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/36104107/无限期待修改代码，参考https://immmmm.com/hi-n","date":"2023-07-31T22:57:22+08:00","objectID":"775b57e2e95e90fd6915e39909fb4748_5","order":5,"summary":"怯的顺从。可悲的是，在这个大坑周围的所有人当中，唐记得只有这位孕妇表现出一点点勇气。 我们应以慎重的天都看待南京的暴行——它阐明了人是多么容易被鼓励让十几岁的孩子泯灭天性，成为可怕的杀人机器。 只要罪恶离我们远得不足以对个人形成威胁，人性中一些扭曲的东西，社会会使得最令人难以言说的罪恶在瞬间变成平常琐事。 白鹿原 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/10564071/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/活着就要记住，人生最痛苦最绝望的那一刻是最难熬的一刻，但不是生命结束的最后一刻；熬过去挣过去就会开始一个重要的转折，开始一个新的辉煌历程；心软一下熬不过去就死了，死了一切就都完了。 长安的荔枝 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/36104107/无限期待修改代码，参考https://immmmm.com/hi-n","tags":["Life","Books"],"title":"文字摘录","url":"http://localhost:1313/posts/life/book-list/"},{"categories":["life"],"content":"eodb-api/做官之道，其实就三句话：和光同尘，雨露均沾，花花轿子众人抬。 一骑红尘妃子笑，无人知是荔枝来 房思琪的初恋乐园 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/27614904/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/我一直是个苟且、得过且过的人，总以为生活就像背辞典，一天背十页就一定可以背完。 心 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/35341437/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/我真想在人的胸腔里装上一部复杂的机器，能像时钟的指针那样简单明了、毫无虚假地指向表盘上的数字。 往日跪在其人脚前的记忆，必使你下一步骑在其人头上。 我之所以摒弃今天的尊敬，是为了明天不受侮辱；之所以忍耐今天的寂寞，是为了明天不忍受更大的寂寞。 生活在充满自立、独立、自我的现代的","date":"2023-07-31T22:57:22+08:00","objectID":"775b57e2e95e90fd6915e39909fb4748_6","order":6,"summary":"eodb-api/做官之道，其实就三句话：和光同尘，雨露均沾，花花轿子众人抬。 一骑红尘妃子笑，无人知是荔枝来 房思琪的初恋乐园 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/27614904/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/我一直是个苟且、得过且过的人，总以为生活就像背辞典，一天背十页就一定可以背完。 心 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/35341437/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/我真想在人的胸腔里装上一部复杂的机器，能像时钟的指针那样简单明了、毫无虚假地指向表盘上的数字。 往日跪在其人脚前的记忆，必使你下一步骑在其人头上。 我之所以摒弃今天的尊敬，是为了明天不受侮辱；之所以忍耐今天的寂寞，是为了明天不忍受更大的寂寞。 生活在充满自立、独立、自我的现代的","tags":["Life","Books"],"title":"文字摘录","url":"http://localhost:1313/posts/life/book-list/"},{"categories":["life"],"content":"我们，作为代价恐怕人人都必须品尝这种寂寞。 小巷人家 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/30564617/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/每个人似乎都知道自己的目标，但又似乎身处迷茫中。 每个人似乎都有选择，但又似乎依旧身陷囹圄。 我与地坛 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/5910656/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/阳光在那儿慢慢地淡薄，脱离，凝作一缕孤哀凄寂的红光一步步爬上墙，爬上楼顶…… 假如世界上没有了苦难，世界还能够存在么?要是没有愚钝，机智还有什么光荣呢?要是没了丑陋，漂亮又怎么维系自己的幸运?要是没有了恶劣和卑下，善良与高尚又将如何界定自己又如何成为美德呢?要是没有了残疾，健全会否因其司空见惯而变得腻烦和乏味呢?我常梦想着在人间彻底消","date":"2023-07-31T22:57:22+08:00","objectID":"775b57e2e95e90fd6915e39909fb4748_7","order":7,"summary":"我们，作为代价恐怕人人都必须品尝这种寂寞。 小巷人家 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/30564617/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/每个人似乎都知道自己的目标，但又似乎身处迷茫中。 每个人似乎都有选择，但又似乎依旧身陷囹圄。 我与地坛 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/5910656/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/阳光在那儿慢慢地淡薄，脱离，凝作一缕孤哀凄寂的红光一步步爬上墙，爬上楼顶…… 假如世界上没有了苦难，世界还能够存在么?要是没有愚钝，机智还有什么光荣呢?要是没了丑陋，漂亮又怎么维系自己的幸运?要是没有了恶劣和卑下，善良与高尚又将如何界定自己又如何成为美德呢?要是没有了残疾，健全会否因其司空见惯而变得腻烦和乏味呢?我常梦想着在人间彻底消","tags":["Life","Books"],"title":"文字摘录","url":"http://localhost:1313/posts/life/book-list/"},{"categories":["life"],"content":"灭残疾，但可以相信，那时将由患病者代替残疾人去承担同样的苦难。如果能够把疾病也全数消灭，那么这份苦难又将由(比如说)像貌丑陋的人去承担了。就算我们连丑陋，连愚昧和卑鄙和一切我们所不喜欢的事物和行为，也都可以统统消灭掉，所有的人都一样健康、漂亮、聪慧、高尚，结果会怎样呢?怕是人间的剧目就全要收场了，一个失去差别的世界将是一条死水，是一块没有感觉没有肥力的沙漠。 看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。 于是就有一个最令人绝望的结论等在这里：由谁去充任那些苦难的角色？又有谁去体现这世间的幸福，骄傲和快乐?只好听凭偶然，是没有道理好讲的。 就命运而言，休论公道。 那么，一切不幸命运的救赎之路在哪里呢?设若智慧的悟性可以引领我们去找到救赎之路，难道所有的人都能够获得这样的智慧和悟性吗?我常以为是丑女造就了美人。我常以为是愚氓举出了智者。我常以为是懦夫衬照了英雄。我常以为是众生度化了佛祖。 山月记 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/s","date":"2023-07-31T22:57:22+08:00","objectID":"775b57e2e95e90fd6915e39909fb4748_8","order":8,"summary":"灭残疾，但可以相信，那时将由患病者代替残疾人去承担同样的苦难。如果能够把疾病也全数消灭，那么这份苦难又将由(比如说)像貌丑陋的人去承担了。就算我们连丑陋，连愚昧和卑鄙和一切我们所不喜欢的事物和行为，也都可以统统消灭掉，所有的人都一样健康、漂亮、聪慧、高尚，结果会怎样呢?怕是人间的剧目就全要收场了，一个失去差别的世界将是一条死水，是一块没有感觉没有肥力的沙漠。 看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。 于是就有一个最令人绝望的结论等在这里：由谁去充任那些苦难的角色？又有谁去体现这世间的幸福，骄傲和快乐?只好听凭偶然，是没有道理好讲的。 就命运而言，休论公道。 那么，一切不幸命运的救赎之路在哪里呢?设若智慧的悟性可以引领我们去找到救赎之路，难道所有的人都能够获得这样的智慧和悟性吗?我常以为是丑女造就了美人。我常以为是愚氓举出了智者。我常以为是懦夫衬照了英雄。我常以为是众生度化了佛祖。 山月记 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/s","tags":["Life","Books"],"title":"文字摘录","url":"http://localhost:1313/posts/life/book-list/"},{"categories":["life"],"content":"ubject/34795345/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/非但如此，他甚至隐约感觉自己沦落成了某种轻飘飘（仿佛不再是自己）、不着边际的东西。曾经的自己同样愚蠢，但至少比现在扎实——这完全是一种肉体上的感觉，总之他认为曾经的自己有着自己的分量。如今的他似乎失去了重量，轻易就能被吹走，外在无论如何改造修饰，内在可谓空无一物。 若选择艰险前路，历经苦难却未得解救，那便成了无法挽回的损失。这种想法在不知不觉间导致了自己的犹豫不决。 在犹豫之前先去尝试。不管结果成败，试着拼尽全力去尝试。 因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍，遂逐渐远离世间，疏避人群，结果在内心不断地用愤懑和羞怒饲育着自己懦弱的自尊心。世界上每个人都是驯兽师，而那匹猛兽，就是每个人各自的性情。 舞姬 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/27074020/无限期待修改代码，参考https://immmmm.com","date":"2023-07-31T22:57:22+08:00","objectID":"775b57e2e95e90fd6915e39909fb4748_9","order":9,"summary":"ubject/34795345/无限期待修改代码，参考https://immmmm.com/hi-neodb-api/非但如此，他甚至隐约感觉自己沦落成了某种轻飘飘（仿佛不再是自己）、不着边际的东西。曾经的自己同样愚蠢，但至少比现在扎实——这完全是一种肉体上的感觉，总之他认为曾经的自己有着自己的分量。如今的他似乎失去了重量，轻易就能被吹走，外在无论如何改造修饰，内在可谓空无一物。 若选择艰险前路，历经苦难却未得解救，那便成了无法挽回的损失。这种想法在不知不觉间导致了自己的犹豫不决。 在犹豫之前先去尝试。不管结果成败，试着拼尽全力去尝试。 因为害怕自己并非明珠而不敢刻苦琢磨，又因为有几分相信自己是明珠，而不能与瓦砾碌碌为伍，遂逐渐远离世间，疏避人群，结果在内心不断地用愤懑和羞怒饲育着自己懦弱的自尊心。世界上每个人都是驯兽师，而那匹猛兽，就是每个人各自的性情。 舞姬 https://neodb.social/api/catalog/fetch?url=https://book.douban.com/subject/27074020/无限期待修改代码，参考https://immmmm.com","tags":["Life","Books"],"title":"文字摘录","url":"http://localhost:1313/posts/life/book-list/"},{"categories":["life"],"content":"电脑间切换硬盘 这是不可行的，已经尝试过了，双系统丢失，但是装回来就可以复原如何大致规划研究生生活 如果你的导师是放养型，但是还是会试不试的关照你的话，前期多准备工作的事情，等后面老师给你 安排任务的时候，努力去钻研科研。纯放养型的话，只能早点确定方向，赶紧把毕业要求达到，如果想要工作学业两手抓的话，效果不太好 容易两边都忘。","date":"2023-06-12T22:32:10+08:00","objectID":"988f7ae108ebe11c212e5555142ec30f_0","order":0,"summary":"电脑间切换硬盘 这是不可行的，已经尝试过了，双系统丢失，但是装回来就可以复原如何大致规划研究生生活 如果你的导师是放养型，但是还是会试不试的关照你的话，前期多准备工作的事情，等后面老师给你 安排任务的时候，努力去钻研科研。纯放养型的话，只能早点确定方向，赶紧把毕业要求达到，如果想要工作学业两手抓的话，效果不太好 容易两边都忘。","tags":["Others"],"title":"2023年小记","url":"http://localhost:1313/posts/life/2023-mynote/"},{"categories":["learn"],"content":"翻译、思维导图（good）Instant-ngp 是做什么的 Given a fully connected neural network$m(\\mathbf{y} ; \\Phi)$ we are interested in an encoding of its inputs ${y}=\\operatorname{enc}(\\mathbf{x} ; \\theta)$ that improves the approximation quality and training speed across a wide range of applications without incurring a notable performance overhead.Instant-ngp 是怎么做的 Pipeline 定义一个$L\\ resolution\\ levels$ 的d维网格。其中红色框处在$1/ N_1$分辨率下，同理蓝色框处在$1/N_0$。以下都为2维网格，每个网格四个顶点。 每个$l\\ resolution\\ level$关联T个F维特征向量。(F是entry维数，d是图片的维数)对于","date":"2023-06-09T22:28:26+08:00","objectID":"f691769bcf5c920557d93b7a4aa8112d_0","order":0,"summary":"翻译、思维导图（good）Instant-ngp 是做什么的 Given a fully connected neural network$m(\\mathbf{y} ; \\Phi)$ we are interested in an encoding of its inputs ${y}=\\operatorname{enc}(\\mathbf{x} ; \\theta)$ that improves the approximation quality and training speed across a wide range of applications without incurring a notable performance overhead.Instant-ngp 是怎么做的 Pipeline 定义一个$L\\ resolution\\ levels$ 的d维网格。其中红色框处在$1/ N_1$分辨率下，同理蓝色框处在$1/N_0$。以下都为2维网格，每个网格四个顶点。 每个$l\\ resolution\\ level$关联T个F维特征向量。(F是entry维数，d是图片的维数)对于","tags":["ComputerVision"],"title":"Instant-ngp笔记","url":"http://localhost:1313/posts/learn/ngp_note/"},{"categories":["learn"],"content":"给定的输入坐标x，我们在$level \\ l$上找到周围的体素(d维网格)。即x落在$l_0$上的右下网格，落在$l_1$上的中间网格 。 将$level \\ l$上的体素的整数顶点映射成哈希表$\\theta_{l}$的索引值。 给定$level \\ l$的顶点数是$V=(N_l+1)^d$，例如对于level 1，有 (3 + 1)² = 16 个顶点。如果 V ≤ T，对应level的顶点和特征向量之间是 1:1 的映射。在更精细的level，其中 V \u003e T，使用哈希函数将每个d维顶点映射到对应level的 T 个特征向量中。其中的特征向量就是网络要更新的参数。从哈希表$\\theta_{l}$中查找四个索引值对应的F维特征向量，进行d-linearly interpolate。 将**每个 level **插值后的特征向量以及辅助向量$\\xi \\in \\mathbb{R}^{E}$concat，产生编码的MLP输入$y \\in \\mathbb{R}^{L F+E}$。（那么一张图片提取到的所有x，pipeline后都作为一个y样本送入网络中） 输入后进入全连接神经网络。之后就跟N","date":"2023-06-09T22:28:26+08:00","objectID":"f691769bcf5c920557d93b7a4aa8112d_1","order":1,"summary":"给定的输入坐标x，我们在$level \\ l$上找到周围的体素(d维网格)。即x落在$l_0$上的右下网格，落在$l_1$上的中间网格 。 将$level \\ l$上的体素的整数顶点映射成哈希表$\\theta_{l}$的索引值。 给定$level \\ l$的顶点数是$V=(N_l+1)^d$，例如对于level 1，有 (3 + 1)² = 16 个顶点。如果 V ≤ T，对应level的顶点和特征向量之间是 1:1 的映射。在更精细的level，其中 V \u003e T，使用哈希函数将每个d维顶点映射到对应level的 T 个特征向量中。其中的特征向量就是网络要更新的参数。从哈希表$\\theta_{l}$中查找四个索引值对应的F维特征向量，进行d-linearly interpolate。 将**每个 level **插值后的特征向量以及辅助向量$\\xi \\in \\mathbb{R}^{E}$concat，产生编码的MLP输入$y \\in \\mathbb{R}^{L F+E}$。（那么一张图片提取到的所有x，pipeline后都作为一个y样本送入网络中） 输入后进入全连接神经网络。之后就跟N","tags":["ComputerVision"],"title":"Instant-ngp笔记","url":"http://localhost:1313/posts/learn/ngp_note/"},{"categories":["learn"],"content":"erf差不多 哈希表 详细介绍参考视频，以及补充视频速度 vs 质量。随着哈希表大小 T 增大会带来高质量低速度，但是到一定瓶颈后，T带来的质量就没那么明显了，在文中 $T=2^{19}$效果最好。另外分辨率等级 L 和 特征维度 F 也有影响，文中$F=2,L=16$效果最好。 隐式哈希碰撞。重建效果这么好的关键是不同分辨率下带来不同的效果，可以互相弥补。在coarser下，哈希映射是一对一的，不会遇到哈希碰撞；但是在finer下，会经常造成哈希碰撞。文中作者指出越重要的区域对梯度的影响越大，越稀疏的区域对梯度影响较小，互相影响下梯度会趋于平均。在网络学习中自动从密集的区域内提取样本，而不是从更大范围内提取样本，从而避免哈希碰撞。 训练适应性。多分辨率哈希编码可以自动适应样本数据分布。 d-linear interpolation。确保编码 enc(x; 𝜃) 以及通过链式法则后它与神经网络 𝑚(enc(x; 𝜃); Φ) 的组合是连续的。 Instant-ngp 做的结果怎么样 优势 提高效率 范用性强，适合多个任务 适合现代GPU并行计算 减少control flow 和 poi","date":"2023-06-09T22:28:26+08:00","objectID":"f691769bcf5c920557d93b7a4aa8112d_2","order":2,"summary":"erf差不多 哈希表 详细介绍参考视频，以及补充视频速度 vs 质量。随着哈希表大小 T 增大会带来高质量低速度，但是到一定瓶颈后，T带来的质量就没那么明显了，在文中 $T=2^{19}$效果最好。另外分辨率等级 L 和 特征维度 F 也有影响，文中$F=2,L=16$效果最好。 隐式哈希碰撞。重建效果这么好的关键是不同分辨率下带来不同的效果，可以互相弥补。在coarser下，哈希映射是一对一的，不会遇到哈希碰撞；但是在finer下，会经常造成哈希碰撞。文中作者指出越重要的区域对梯度的影响越大，越稀疏的区域对梯度影响较小，互相影响下梯度会趋于平均。在网络学习中自动从密集的区域内提取样本，而不是从更大范围内提取样本，从而避免哈希碰撞。 训练适应性。多分辨率哈希编码可以自动适应样本数据分布。 d-linear interpolation。确保编码 enc(x; 𝜃) 以及通过链式法则后它与神经网络 𝑚(enc(x; 𝜃); Φ) 的组合是连续的。 Instant-ngp 做的结果怎么样 优势 提高效率 范用性强，适合多个任务 适合现代GPU并行计算 减少control flow 和 poi","tags":["ComputerVision"],"title":"Instant-ngp笔记","url":"http://localhost:1313/posts/learn/ngp_note/"},{"categories":["learn"],"content":"推荐一个专栏, 转载自来源, 再加入自己的东西NeRF 是做什么的 通过使用稀疏的输入视图优化底层的的连续辐射体积场函数，实现复杂场景的新视角合成NeRF 是怎么做的 ，(b)生成射线，(c)立体渲染，(d)算 mse loss。\")Pipeline nerf(二)---工作流程与基本原理a).沿着相机光线的方向采样 5D 坐标 b).将坐标信息输入到 MLP 中，产生颜色和体积密度 c).使用立体渲染将颜色和体积密度合成为图像 d).渲染函数是可微分的，因此可以通过最小化合成图像和实际观察到的图像之间的残差来优化场景表示 静态场景的表示 使用全连接（非卷积）深度网络(多层感知机，MLP)来表示场景 输入是一个连续的5D坐标：**空间位置 **$(x,y,z)$ 和 2D 观察方向$(\\theta, \\phi)$ 输出是该空间位置的**体积密度 $\\sigma$ 和视角相关的颜色 **$\\textbf{c} = (r,g,b)$这里的体积密度只对某一个空间点$(x,y,z)$ 而言，它表示一条穿过空间点$(x,y,z)$ 的射线累计了多少辐射(radiance)，后面会将它转化为概率密","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_0","order":0,"summary":"推荐一个专栏, 转载自来源, 再加入自己的东西NeRF 是做什么的 通过使用稀疏的输入视图优化底层的的连续辐射体积场函数，实现复杂场景的新视角合成NeRF 是怎么做的 ，(b)生成射线，(c)立体渲染，(d)算 mse loss。\")Pipeline nerf(二)---工作流程与基本原理a).沿着相机光线的方向采样 5D 坐标 b).将坐标信息输入到 MLP 中，产生颜色和体积密度 c).使用立体渲染将颜色和体积密度合成为图像 d).渲染函数是可微分的，因此可以通过最小化合成图像和实际观察到的图像之间的残差来优化场景表示 静态场景的表示 使用全连接（非卷积）深度网络(多层感知机，MLP)来表示场景 输入是一个连续的5D坐标：**空间位置 **$(x,y,z)$ 和 2D 观察方向$(\\theta, \\phi)$ 输出是该空间位置的**体积密度 $\\sigma$ 和视角相关的颜色 **$\\textbf{c} = (r,g,b)$这里的体积密度只对某一个空间点$(x,y,z)$ 而言，它表示一条穿过空间点$(x,y,z)$ 的射线累计了多少辐射(radiance)，后面会将它转化为概率密","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"度 多视图之间保持连续一致性体积密度 $\\sigma$ 函数只与空间位置 $\\mathbf{x}$ 有关 --\u003e $\\sigma(\\mathbf{x})$ 颜色 $c$ 函数与空间位置 $\\mathbf{x}$ 和视角 $\\mathbf{d}$ 都有关 --\u003e $c(\\mathbf{x},\\mathbf{d})$ MLP 的设计用 8 个全连接层来处理输入的空间坐标 $x$ (激活函数为 ReLU，每层256个通道) 输出 $\\sigma$ 和一个 256 维的特征向量 将特征向量和视角方向 $d$ 连接起来 传递到一个额外的全连接层 (激活函数为 ReLU，128个通道) 输出依赖于视图的 RGB 颜色 MLP 的 Loss 计算$\\mathcal{L}=\\sum_{\\mathbf{r} \\in \\mathcal{R}}\\left[\\left|\\hat{C}_c(\\mathbf{r})-C(\\mathbf{r})\\right|_2^2+\\left|\\hat{C}_f(\\mathbf{r})-C(\\mathbf{r})\\right|_2^2\\right]$用了两个 MLP 网络，分别是","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_1","order":1,"summary":"度 多视图之间保持连续一致性体积密度 $\\sigma$ 函数只与空间位置 $\\mathbf{x}$ 有关 --\u003e $\\sigma(\\mathbf{x})$ 颜色 $c$ 函数与空间位置 $\\mathbf{x}$ 和视角 $\\mathbf{d}$ 都有关 --\u003e $c(\\mathbf{x},\\mathbf{d})$ MLP 的设计用 8 个全连接层来处理输入的空间坐标 $x$ (激活函数为 ReLU，每层256个通道) 输出 $\\sigma$ 和一个 256 维的特征向量 将特征向量和视角方向 $d$ 连接起来 传递到一个额外的全连接层 (激活函数为 ReLU，128个通道) 输出依赖于视图的 RGB 颜色 MLP 的 Loss 计算$\\mathcal{L}=\\sum_{\\mathbf{r} \\in \\mathcal{R}}\\left[\\left|\\hat{C}_c(\\mathbf{r})-C(\\mathbf{r})\\right|_2^2+\\left|\\hat{C}_f(\\mathbf{r})-C(\\mathbf{r})\\right|_2^2\\right]$用了两个 MLP 网络，分别是","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"粗(coarse) 网络和细(fine) 网络 后续如何优化的部分会具体解释粗网络和细网络$\\mathcal{R}$ 是每个 batch 里面光线的集合，$\\mathbf{r}$ 是指集合里面的每一条光线 $C(\\mathbf{r})$，$\\hat{C}_c(\\mathbf{r})$，$\\hat{C}_f(\\mathbf{r})$ 分别是gt实景，粗网络，细网络中输出的光线 RGB 颜色 同时还将 $\\hat{C}_c(\\mathbf{r})$ 的损失最小化，以便粗网络的权重分布可以用于在细网络中分配样本 神经渲染 https://zhuanlan.zhihu.com/p/486642042沿着相机光线查询 5D 坐标来合成视图 使用立体渲染将输出颜色和密度投影到 2D 图像中 从特定的视角渲染 NeRF 的过程利用穿过场景的相机光线，生成一组采样的三维点 $P_{3D}$ 利用三维点和对应的 2D 视角方向作为 MLP 的输入，输出密度和颜色 使用立体渲染技术将输出颜色和密度累积到一个二维图像 $I_{2D}$ 中 由于具有可微性，所以可以利用梯度下降的方法来优化 MLP 网络，最小","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_2","order":2,"summary":"粗(coarse) 网络和细(fine) 网络 后续如何优化的部分会具体解释粗网络和细网络$\\mathcal{R}$ 是每个 batch 里面光线的集合，$\\mathbf{r}$ 是指集合里面的每一条光线 $C(\\mathbf{r})$，$\\hat{C}_c(\\mathbf{r})$，$\\hat{C}_f(\\mathbf{r})$ 分别是gt实景，粗网络，细网络中输出的光线 RGB 颜色 同时还将 $\\hat{C}_c(\\mathbf{r})$ 的损失最小化，以便粗网络的权重分布可以用于在细网络中分配样本 神经渲染 https://zhuanlan.zhihu.com/p/486642042沿着相机光线查询 5D 坐标来合成视图 使用立体渲染将输出颜色和密度投影到 2D 图像中 从特定的视角渲染 NeRF 的过程利用穿过场景的相机光线，生成一组采样的三维点 $P_{3D}$ 利用三维点和对应的 2D 视角方向作为 MLP 的输入，输出密度和颜色 使用立体渲染技术将输出颜色和密度累积到一个二维图像 $I_{2D}$ 中 由于具有可微性，所以可以利用梯度下降的方法来优化 MLP 网络，最小","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"化每个观察图像和 NeRF 渲染出来的相应视图之间的误差该部分详细内容参见 NeRF 的数学推导[NeRF数学公式从零推导](https://www.bilibili.com/video/BV1Wd4y1X7H1/)光线可以表示为一个 3D 空间坐标$\\mathbf{r}(t) = \\mathbf{o} + t \\mathbf{d}$原文中的一些假设：场景是由一团发光粒子组成的，这里粒子密度的空间分布会发生变化 发射的光（每一个体素都会向四周均匀发出光）不随观察视角而改变 假设距离 $t$ 的近场边界和远场边界分别为 $t_n$ 和 $t_f$ ，那么对于一条射线，它的期望颜色表达式应该如下：$C(\\mathbf{r})=\\int_{t_n}^{t_f} T(t) \\sigma(\\mathbf{r}(t)) \\mathbf{c}(\\mathbf{r}(t), \\mathbf{d}) d t, \\text{ where } T(t)=\\exp \\left(-\\int_{t_n}^t \\sigma(\\mathbf{r}(s)) d s\\right)$函数 $T(t)$ 表示的是光线在 $t","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_3","order":3,"summary":"化每个观察图像和 NeRF 渲染出来的相应视图之间的误差该部分详细内容参见 NeRF 的数学推导[NeRF数学公式从零推导](https://www.bilibili.com/video/BV1Wd4y1X7H1/)光线可以表示为一个 3D 空间坐标$\\mathbf{r}(t) = \\mathbf{o} + t \\mathbf{d}$原文中的一些假设：场景是由一团发光粒子组成的，这里粒子密度的空间分布会发生变化 发射的光（每一个体素都会向四周均匀发出光）不随观察视角而改变 假设距离 $t$ 的近场边界和远场边界分别为 $t_n$ 和 $t_f$ ，那么对于一条射线，它的期望颜色表达式应该如下：$C(\\mathbf{r})=\\int_{t_n}^{t_f} T(t) \\sigma(\\mathbf{r}(t)) \\mathbf{c}(\\mathbf{r}(t), \\mathbf{d}) d t, \\text{ where } T(t)=\\exp \\left(-\\int_{t_n}^t \\sigma(\\mathbf{r}(s)) d s\\right)$函数 $T(t)$ 表示的是光线在 $t","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"_n$ 到 $t$ 距离内的透射率，即光线在不碰到任何其他粒子的情况下能够传播的概率一张示例图：从连续的 NeRF 中渲染视图需要估计相机光线追踪的每个像素的积分 $C(\\mathbf{r})$这个很好理解，因为 2D 图像的每一个像素值实际上是相机发出的一条射线上的所有点累积叠加的结果文中估计积分的方法是 数值积分(Quadrature)简单来说，就是分层抽样，把 $[t_n, t_f]$ 等分成 $\\mathbf{N}$ 个区间，然后从每个区间内均匀随机地抽取一个样本$t_i \\sim \\mathcal{U}\\left[t_n+\\frac{i-1}{N}\\left(t_f-t_n\\right), t_n+\\frac{i}{N}\\left(t_f-t_n\\right)\\right] \\quad i =1,2,...N$这里得到的 $t_i$ 是每个小区间内的随机抽取样本点的空间坐标根据数值积分方法估计的颜色积分结果如下所示：$\\hat{C}(\\mathbf{r})=\\sum_{i=1}^N T_i\\left(1-\\exp \\left(-\\sigma_i \\delta_i\\right)","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_4","order":4,"summary":"_n$ 到 $t$ 距离内的透射率，即光线在不碰到任何其他粒子的情况下能够传播的概率一张示例图：从连续的 NeRF 中渲染视图需要估计相机光线追踪的每个像素的积分 $C(\\mathbf{r})$这个很好理解，因为 2D 图像的每一个像素值实际上是相机发出的一条射线上的所有点累积叠加的结果文中估计积分的方法是 数值积分(Quadrature)简单来说，就是分层抽样，把 $[t_n, t_f]$ 等分成 $\\mathbf{N}$ 个区间，然后从每个区间内均匀随机地抽取一个样本$t_i \\sim \\mathcal{U}\\left[t_n+\\frac{i-1}{N}\\left(t_f-t_n\\right), t_n+\\frac{i}{N}\\left(t_f-t_n\\right)\\right] \\quad i =1,2,...N$这里得到的 $t_i$ 是每个小区间内的随机抽取样本点的空间坐标根据数值积分方法估计的颜色积分结果如下所示：$\\hat{C}(\\mathbf{r})=\\sum_{i=1}^N T_i\\left(1-\\exp \\left(-\\sigma_i \\delta_i\\right)","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"\\right) \\mathbf{c}i, \\text { where } T_i=\\exp \\left(-\\sum{j=1}^{i-1} \\sigma_j \\delta_j\\right)$通过分层抽样的方式，将连续的积分变成了离散的求和，$\\delta_i = t_{i+1} - t_i$ 是样本间隔(距离)文中还提到了可以简化为传统的 Alpha 合成，对应的 alpha value 是$\\alpha_i = 1 - exp(-\\sigma_i \\delta_i)$如何优化 输入为一系列已知相机位姿的图像两方面的优化：使用位置编码来转换输入的 5D 坐标，将坐标映射到更高维度的空间中，使相似的内容分离到更远的地方，从而使 MLP 能够表示更高频率的函数，使得物体表面的几何和纹理更加逼真 采用了一种由粗到细的分层采样程序，对于颜色贡献大的点附近采样密集，贡献小的点附近采样稀疏，以减少必要的采样次数，充分采样整个高频场景表示 这个采样的过程应该是指相机光线对真实 3D 场景的采样，在输入到 MLP 之前位置编码(Positional encoding) 深度网络更偏向于学习低频函数，研究","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_5","order":5,"summary":"\\right) \\mathbf{c}i, \\text { where } T_i=\\exp \\left(-\\sum{j=1}^{i-1} \\sigma_j \\delta_j\\right)$通过分层抽样的方式，将连续的积分变成了离散的求和，$\\delta_i = t_{i+1} - t_i$ 是样本间隔(距离)文中还提到了可以简化为传统的 Alpha 合成，对应的 alpha value 是$\\alpha_i = 1 - exp(-\\sigma_i \\delta_i)$如何优化 输入为一系列已知相机位姿的图像两方面的优化：使用位置编码来转换输入的 5D 坐标，将坐标映射到更高维度的空间中，使相似的内容分离到更远的地方，从而使 MLP 能够表示更高频率的函数，使得物体表面的几何和纹理更加逼真 采用了一种由粗到细的分层采样程序，对于颜色贡献大的点附近采样密集，贡献小的点附近采样稀疏，以减少必要的采样次数，充分采样整个高频场景表示 这个采样的过程应该是指相机光线对真实 3D 场景的采样，在输入到 MLP 之前位置编码(Positional encoding) 深度网络更偏向于学习低频函数，研究","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"表明，在将输入通过高频函数映射到更高维空间后再传递给网络，可以更好地拟合包含高频变化的数据将原先的表示函数变成两个函数的组合：$F_{\\Theta}=F_{\\Theta}^{\\prime} \\circ \\gamma$两个函数，$F_{\\Theta}^{\\prime}$ 函数需要网络学习的，就是一个普通的 MLP，$\\gamma$ 函数则不需要学习$\\gamma$ 在这里是一个映射(mapping) 函数，从空间 $\\mathbf{R}$ 映射到高维空间 $\\mathbf{R}^{2L}$原文中使用的编码方程如下：$\\gamma(p)=\\left(\\sin \\left(2^0 \\pi p\\right), \\cos \\left(2^0 \\pi p\\right), \\cdots, \\sin \\left(2^{L-1} \\pi p\\right), \\cos \\left(2^{L-1} \\pi p\\right)\\right)$$\\gamma(\\cdot)$ 分别作用于空间坐标 $\\mathbf{x}$ 中的每一个分量(x,y,z) 和 视角方向的单位向量 $\\mathbf{d}$ 的三个分量，最","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_6","order":6,"summary":"表明，在将输入通过高频函数映射到更高维空间后再传递给网络，可以更好地拟合包含高频变化的数据将原先的表示函数变成两个函数的组合：$F_{\\Theta}=F_{\\Theta}^{\\prime} \\circ \\gamma$两个函数，$F_{\\Theta}^{\\prime}$ 函数需要网络学习的，就是一个普通的 MLP，$\\gamma$ 函数则不需要学习$\\gamma$ 在这里是一个映射(mapping) 函数，从空间 $\\mathbf{R}$ 映射到高维空间 $\\mathbf{R}^{2L}$原文中使用的编码方程如下：$\\gamma(p)=\\left(\\sin \\left(2^0 \\pi p\\right), \\cos \\left(2^0 \\pi p\\right), \\cdots, \\sin \\left(2^{L-1} \\pi p\\right), \\cos \\left(2^{L-1} \\pi p\\right)\\right)$$\\gamma(\\cdot)$ 分别作用于空间坐标 $\\mathbf{x}$ 中的每一个分量(x,y,z) 和 视角方向的单位向量 $\\mathbf{d}$ 的三个分量，最","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"后会被归一化到区间 [-1, 1] 之间(sinh 函数)文中用到的超参数$L = 10 \\quad \\text{for} \\quad \\gamma(\\mathbf{x})$ $L = 4 \\quad \\text{for} \\quad \\gamma(\\mathbf{d})$ 维度 $L$ 的选择和场景的复杂度以及算力有关，也决定了神经网络能学习到的最高频率的大小分层采样(Hierarchical volume sampling) 通过按照样本对最终渲染的预期影响进行比例分配提高渲染效率同时优化两个 MLP 网络：\"coarse\" 和 \"fine\"将在相机射线上，由 near 和 far 构成的区间范围等分，然后在每个小区间内均匀采样得到一个采样点，一共 $N_c$ 个采样点 利用这些空间点来评估粗网络 再在每条射线上生成更多信息的采样点 (猜想是粗网络的结果输出了样本点的概率密度分布，为第二次采样提供了参考) 使用逆变换采样采样第二组 $N_f$ 个空间位置点，用两组空间点评估细网络，并使用两组空间点来计算射线最后的颜色 $\\hat{C}_f(\\mathbf{r})$ 第三步具体是怎么","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_7","order":7,"summary":"后会被归一化到区间 [-1, 1] 之间(sinh 函数)文中用到的超参数$L = 10 \\quad \\text{for} \\quad \\gamma(\\mathbf{x})$ $L = 4 \\quad \\text{for} \\quad \\gamma(\\mathbf{d})$ 维度 $L$ 的选择和场景的复杂度以及算力有关，也决定了神经网络能学习到的最高频率的大小分层采样(Hierarchical volume sampling) 通过按照样本对最终渲染的预期影响进行比例分配提高渲染效率同时优化两个 MLP 网络：\"coarse\" 和 \"fine\"将在相机射线上，由 near 和 far 构成的区间范围等分，然后在每个小区间内均匀采样得到一个采样点，一共 $N_c$ 个采样点 利用这些空间点来评估粗网络 再在每条射线上生成更多信息的采样点 (猜想是粗网络的结果输出了样本点的概率密度分布，为第二次采样提供了参考) 使用逆变换采样采样第二组 $N_f$ 个空间位置点，用两组空间点评估细网络，并使用两组空间点来计算射线最后的颜色 $\\hat{C}_f(\\mathbf{r})$ 第三步具体是怎么","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"做的首先将原方程中粗网络 $\\hat{C_c}(\\mathbf{r})$ 的 Alpha 合成的颜色重写为沿着光线采样到的所有颜色 $c_i$ 的加权和$\\hat{C}c(\\mathbf{r})=\\sum{i=1}^{N_c} w_i c_i, \\quad w_i=T_i\\left(1-\\exp \\left(-\\sigma_i \\delta_i\\right)\\right)$这个权值 $w_i$ 和透过率以及体积密度有关将权值归一化后可以化为沿射线分布的分段常数概率密度函数(Piecewise-constant PDF), 目的是粗略估计射线上的物体分布情况$\\hat{w_i} = \\frac{w_i}{\\sum_{j=1}^{N_c}w_j}$细节说明 体积边界对于合成图像: 缩放场景，使其位于以原点为中心、边长为 2 $([-1,1])$的立方体内，并仅查询这个边界体积内的 NeRF 表示对于真实图像: 数据集包含可以存在于最近点和无穷远点之间的内容，用归一化的方式将这些点的深度范围映射到区间 [-1, 1]这将所有光线的起点移动到场景的近平面(near plane)，将相机的透视光","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_8","order":8,"summary":"做的首先将原方程中粗网络 $\\hat{C_c}(\\mathbf{r})$ 的 Alpha 合成的颜色重写为沿着光线采样到的所有颜色 $c_i$ 的加权和$\\hat{C}c(\\mathbf{r})=\\sum{i=1}^{N_c} w_i c_i, \\quad w_i=T_i\\left(1-\\exp \\left(-\\sigma_i \\delta_i\\right)\\right)$这个权值 $w_i$ 和透过率以及体积密度有关将权值归一化后可以化为沿射线分布的分段常数概率密度函数(Piecewise-constant PDF), 目的是粗略估计射线上的物体分布情况$\\hat{w_i} = \\frac{w_i}{\\sum_{j=1}^{N_c}w_j}$细节说明 体积边界对于合成图像: 缩放场景，使其位于以原点为中心、边长为 2 $([-1,1])$的立方体内，并仅查询这个边界体积内的 NeRF 表示对于真实图像: 数据集包含可以存在于最近点和无穷远点之间的内容，用归一化的方式将这些点的深度范围映射到区间 [-1, 1]这将所有光线的起点移动到场景的近平面(near plane)，将相机的透视光","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"映射为变换后体积中的平行光线，并使用视差而不是使用度量深度，因此所有坐标都是有界限的训练对于真实场景的数据，在优化过程中对输出结果 $\\sigma$ 添加了随机高斯噪声 (在通过 ReLU 之前)渲染在测试的时候，在每条射线上采样 64 个点输入到粗网络中，采样 64+128=192 个点到细网络中，每条光线一共采样 256 个点对于合成的图片，每张图片需要 640k 条光线；对于真实场景，每张图片需要 762k 条光线NeRF 做的结果怎么样 相关指标 PSNR: 峰值信噪比，是一种评价图像质量的指标 (越高越好) SSIM: 结构相似性，是一种衡量两幅图像相似度的指标 (越高越好) LPIPS: 学习感知图像块相似度，是一种度量两幅图像之间的差别的指标 (越低越好) 优势 继承了体积表示的优点，可以表示复杂的几何形状和外观 适合使用投影图像进行基于梯度（可微）的优化 克服了在高分辨率建模复杂场景时，离散化体素网格所带来的存储成本过高的问题 不足 训练速度太慢：每个像素都需要近 200 次 MLP 模型的前向预测 模型泛化性太差：NeRF 要针对每个场景单独进行训练，无法直接扩展到新","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_9","order":9,"summary":"映射为变换后体积中的平行光线，并使用视差而不是使用度量深度，因此所有坐标都是有界限的训练对于真实场景的数据，在优化过程中对输出结果 $\\sigma$ 添加了随机高斯噪声 (在通过 ReLU 之前)渲染在测试的时候，在每条射线上采样 64 个点输入到粗网络中，采样 64+128=192 个点到细网络中，每条光线一共采样 256 个点对于合成的图片，每张图片需要 640k 条光线；对于真实场景，每张图片需要 762k 条光线NeRF 做的结果怎么样 相关指标 PSNR: 峰值信噪比，是一种评价图像质量的指标 (越高越好) SSIM: 结构相似性，是一种衡量两幅图像相似度的指标 (越高越好) LPIPS: 学习感知图像块相似度，是一种度量两幅图像之间的差别的指标 (越低越好) 优势 继承了体积表示的优点，可以表示复杂的几何形状和外观 适合使用投影图像进行基于梯度（可微）的优化 克服了在高分辨率建模复杂场景时，离散化体素网格所带来的存储成本过高的问题 不足 训练速度太慢：每个像素都需要近 200 次 MLP 模型的前向预测 模型泛化性太差：NeRF 要针对每个场景单独进行训练，无法直接扩展到新","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"出现的场景 Nerf 不懂的地方 Positional Encoding 思考Positional Encodingmap each input 5D coordinate into a higher dimensional space。为什么要映射到高维空间：This is consistent with recent work by Rahaman et al. [35], which shows that deep networks are biased towards learning lower frequency functions. They additionally show that** mapping the inputs to a higher dimensional space using high frequency functions** before passing them to the network enables better fitting of data that contains high frequency variation.3D occ","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_10","order":10,"summary":"出现的场景 Nerf 不懂的地方 Positional Encoding 思考Positional Encodingmap each input 5D coordinate into a higher dimensional space。为什么要映射到高维空间：This is consistent with recent work by Rahaman et al. [35], which shows that deep networks are biased towards learning lower frequency functions. They additionally show that** mapping the inputs to a higher dimensional space using high frequency functions** before passing them to the network enables better fitting of data that contains high frequency variation.3D occ","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["learn"],"content":"upancy fields 推荐博客: 1, 2就是用一个隐函数来表示物体的连续边界.体素表示的缺点：内存随分辨率呈立方增加，故需要限制在323232或646464。使用例如八叉树的数据自适应表示来降低内存，实现起来又会复杂，现有数据自适应算法依旧局限于相对较小的256256256分辨率。 点云表示的缺点：由于缺少底层网格的连接结构，需要额外的后处理来从模型中提取三维几何图形。 网格表示的缺点：现有的网格表示通常基于对一个模板网格的变形，因此不允许任意拓扑。 Occupancy Networks基于对连续三维占据函数进行直接学习的三维重建新方法。利用神经网络实现对任意分辨率的占据函数的预测。训练时大大降低了内存，推理时利用简单的多分辨率等值面提取算法从学习的模型中提取网格。a neural 3D texture field a Texture Field as a mapping from 3D point p, shape embedding s and condition z to color c:light field sample interpolation technique","date":"2023-06-07T22:05:23+08:00","objectID":"6192c31b87c8124a3544c32094af29ed_11","order":11,"summary":"upancy fields 推荐博客: 1, 2就是用一个隐函数来表示物体的连续边界.体素表示的缺点：内存随分辨率呈立方增加，故需要限制在323232或646464。使用例如八叉树的数据自适应表示来降低内存，实现起来又会复杂，现有数据自适应算法依旧局限于相对较小的256256256分辨率。 点云表示的缺点：由于缺少底层网格的连接结构，需要额外的后处理来从模型中提取三维几何图形。 网格表示的缺点：现有的网格表示通常基于对一个模板网格的变形，因此不允许任意拓扑。 Occupancy Networks基于对连续三维占据函数进行直接学习的三维重建新方法。利用神经网络实现对任意分辨率的占据函数的预测。训练时大大降低了内存，推理时利用简单的多分辨率等值面提取算法从学习的模型中提取网格。a neural 3D texture field a Texture Field as a mapping from 3D point p, shape embedding s and condition z to color c:light field sample interpolation technique","tags":["ComputerVision"],"title":"Nerf初入门笔记","url":"http://localhost:1313/posts/learn/nerf_note/"},{"categories":["tech"],"content":"博主配置：ubuntu18.04 gcc11 （需要$\\geq$8） conda cuda11.8 安装教程（基本来源于此，除了Dependencies加入额外内容） Create environment 1 2 3 \u003e conda create --name nerfstudio -y python=3.8 \u003e conda activate nerfstudio \u003e python -m pip install --upgrade pip Dependencies 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u003e pip uninstall torch torchvision functorch tinycudann \u003e pip install ninja git+[https://github.com/NVlabs/tiny-cuda-nn/#subdirectory=bindings/torch](https://github.com/NVlabs/tiny-cuda-nn/#subdirectory=bindings/torch) 注意此处可","date":"2023-05-28T09:34:46+08:00","objectID":"88b82ca1ee87b3657ff84c99c8117c10_0","order":0,"summary":"博主配置：ubuntu18.04 gcc11 （需要$\\geq$8） conda cuda11.8 安装教程（基本来源于此，除了Dependencies加入额外内容） Create environment 1 2 3 \u003e conda create --name nerfstudio -y python=3.8 \u003e conda activate nerfstudio \u003e python -m pip install --upgrade pip Dependencies 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u003e pip uninstall torch torchvision functorch tinycudann \u003e pip install ninja git+[https://github.com/NVlabs/tiny-cuda-nn/#subdirectory=bindings/torch](https://github.com/NVlabs/tiny-cuda-nn/#subdirectory=bindings/torch) 注意此处可","tags":["ComputerVision","Ubuntu"],"title":"ubuntu安装nerfstudio","url":"http://localhost:1313/posts/tech/ubuntu-install-nerfstudio/"},{"categories":["tech"],"content":" 默认已安装 sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev管理GCC 前提是安装了多个gcc版本，可采取如下命令 sudo apt-get install gcc-11 g++-11然后选择要使用的gcc版本 update-alternatives --config gcc输入你想使用的版本的序号，如1 查看当前版本 gcc -v参考链接管理opencv 下载源文件，本文选的是opencv3.4.15 ..source..版本 在任意目录下创建存放opencv安装路径 1 2 3 4 conda dea","date":"2023-05-28T09:33:29+08:00","objectID":"e5069ef9d806e17f6aa421be22bf82c0_0","order":0,"summary":" 默认已安装 sudo apt-get install build-essential sudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-dev sudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev管理GCC 前提是安装了多个gcc版本，可采取如下命令 sudo apt-get install gcc-11 g++-11然后选择要使用的gcc版本 update-alternatives --config gcc输入你想使用的版本的序号，如1 查看当前版本 gcc -v参考链接管理opencv 下载源文件，本文选的是opencv3.4.15 ..source..版本 在任意目录下创建存放opencv安装路径 1 2 3 4 conda dea","tags":["Ubuntu","C++"],"title":"ubuntu多版本管理","url":"http://localhost:1313/posts/tech/ubuntu-multi-version-management/"},{"categories":["create"],"content":"hugo坑 使用shortcode时，无论放何处都会生效，必须取消shortcode格式，如： {a(加入a破坏shortcode){ music }} 目前已知问题:目录跳转无法生效 配置front matter 使用vscode snippet快捷生成front matter 参考博客：vs-code-workflows-for-hugo、 markdown-snippets-not-working-in-vscode 在使用了obsidian后，加入一些插件如quickadd等，优化了文章撰写，但是obsidian不能在网页端登陆，虽然多个平台都有部署安装包，此外仅支持md文件使我不能继续使用下去。 后来沉思一下现有写文章流程，缺点是什么，发现是不能生成front matter，故东找西找，甚至一度又回归到obsidian后，终于发现vscode的snippet，正好几乎完美符合我的需求（不能自动呈现所有tags）。 目前我的写作流程是：语雀上写好文章后导出md 用pic-go插件pic-migrate转换语雀图片并生成新md文件 在vscode上加入front matter 在","date":"2023-05-27T19:59:46+08:00","objectID":"a6d58eaab69aefadc9bce63bf97fcef4_0","order":0,"summary":"hugo坑 使用shortcode时，无论放何处都会生效，必须取消shortcode格式，如： {a(加入a破坏shortcode){ music }} 目前已知问题:目录跳转无法生效 配置front matter 使用vscode snippet快捷生成front matter 参考博客：vs-code-workflows-for-hugo、 markdown-snippets-not-working-in-vscode 在使用了obsidian后，加入一些插件如quickadd等，优化了文章撰写，但是obsidian不能在网页端登陆，虽然多个平台都有部署安装包，此外仅支持md文件使我不能继续使用下去。 后来沉思一下现有写文章流程，缺点是什么，发现是不能生成front matter，故东找西找，甚至一度又回归到obsidian后，终于发现vscode的snippet，正好几乎完美符合我的需求（不能自动呈现所有tags）。 目前我的写作流程是：语雀上写好文章后导出md 用pic-go插件pic-migrate转换语雀图片并生成新md文件 在vscode上加入front matter 在","tags":["Blog"],"title":"MemE关键美化","url":"http://localhost:1313/posts/create/meme-custom-important/"},{"categories":["create"],"content":"vscode上上传至github 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \"hugo post template\":{ \"scope\": \"markdown\", // Add comma separated ids of the languages where the snippet is applicable in the scope field. \"prefix\": \"post\", // trigger the snippet \"body\": [ // expanded and inserted where trigger \"---\", \"title: ${TM_FILENAME/(.*)\\\\..+$/$1/}\", \"date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND +0800\", \"lastmod: \", \"summary:","date":"2023-05-27T19:59:46+08:00","objectID":"a6d58eaab69aefadc9bce63bf97fcef4_1","order":1,"summary":"vscode上上传至github 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \"hugo post template\":{ \"scope\": \"markdown\", // Add comma separated ids of the languages where the snippet is applicable in the scope field. \"prefix\": \"post\", // trigger the snippet \"body\": [ // expanded and inserted where trigger \"---\", \"title: ${TM_FILENAME/(.*)\\\\..+$/$1/}\", \"date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND +0800\", \"lastmod: \", \"summary:","tags":["Blog"],"title":"MemE关键美化","url":"http://localhost:1313/posts/create/meme-custom-important/"},{"categories":["create"],"content":" \", \"slug: $2\", // url: www.keepjolly.com/tags/:slug/ \"toc: ${3|true,false|}\", \"rightToc: ${4|false,true|}\", \"categories: \", \"- ${5|tech,learn,algorithm,error,create,other,life|}\", \"tags: \", \"- ${6|ComputerVision,C++,LeetCode,Blog,Others,Install|}\", \"original: true\", \"author: Rurouni\", \"website: www.keepjolly.com\", \"---\" ] }, \"update time\":{ \"scope\": \"yaml\", \"prefix\": \"update\", \"body\": \"$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND +0800\" } } 完整可支持的fron","date":"2023-05-27T19:59:46+08:00","objectID":"a6d58eaab69aefadc9bce63bf97fcef4_2","order":2,"summary":" \", \"slug: $2\", // url: www.keepjolly.com/tags/:slug/ \"toc: ${3|true,false|}\", \"rightToc: ${4|false,true|}\", \"categories: \", \"- ${5|tech,learn,algorithm,error,create,other,life|}\", \"tags: \", \"- ${6|ComputerVision,C++,LeetCode,Blog,Others,Install|}\", \"original: true\", \"author: Rurouni\", \"website: www.keepjolly.com\", \"---\" ] }, \"update time\":{ \"scope\": \"yaml\", \"prefix\": \"update\", \"body\": \"$CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND +0800\" } } 完整可支持的fron","tags":["Blog"],"title":"MemE关键美化","url":"http://localhost:1313/posts/create/meme-custom-important/"},{"categories":["create"],"content":"t-matter，貌似也可以定制，自行百度吧配置搜索功能 参考博客：修改algolia的设置、hugo添加algolia搜索支持配置config.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # Algolia 的搜索索引 [outputFormats.Algolia] mediaType = \"application/json\" baseName = \"algolia\" isPlainText = true notAlternative = true # 摘要的字数限制 此处用于algolia检索 summaryLength = 70 # Hugo 的输出控制 [outputs] page = [\"HTML\"] home = [\"HTML\", \"SectionsAtom\", \"SectionsRSS\", \"SearchIndex\", \"Algolia\"] section = [\"HTML\"] taxonomy =","date":"2023-05-27T19:59:46+08:00","objectID":"a6d58eaab69aefadc9bce63bf97fcef4_3","order":3,"summary":"t-matter，貌似也可以定制，自行百度吧配置搜索功能 参考博客：修改algolia的设置、hugo添加algolia搜索支持配置config.toml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # Algolia 的搜索索引 [outputFormats.Algolia] mediaType = \"application/json\" baseName = \"algolia\" isPlainText = true notAlternative = true # 摘要的字数限制 此处用于algolia检索 summaryLength = 70 # Hugo 的输出控制 [outputs] page = [\"HTML\"] home = [\"HTML\", \"SectionsAtom\", \"SectionsRSS\", \"SearchIndex\", \"Algolia\"] section = [\"HTML\"] taxonomy =","tags":["Blog"],"title":"MemE关键美化","url":"http://localhost:1313/posts/create/meme-custom-important/"},{"categories":["create"],"content":" [\"HTML\"] term = [\"HTML\"] # 菜单配置 [menu] ## 菜单栏 [[menu.main]] # 多加入一个搜索栏 weight = 8 identifier = \"search\" post = \"search\" ###################################### # Algolia search # 说明：需要开启 `Algolia` 在Hugo 的输出控制，且需要每 # 次将生成的 algolia.json 文件上传到 # Algolia enableAlgoliaSearch = true algoliaAppId = \"\" algoliaApiKey = \"\" algoliaIndexName = \"\" # 说明：https://www.algolia.com/ algolia官网查找key 或者登录后访问网址，然后找到对应Application ID、ApiKey、IndexName，找不到可以自行在参考博客中查找。覆盖index.algolia.json配置 然后在博客主目录/layouts下新建index.algoli","date":"2023-05-27T19:59:46+08:00","objectID":"a6d58eaab69aefadc9bce63bf97fcef4_4","order":4,"summary":" [\"HTML\"] term = [\"HTML\"] # 菜单配置 [menu] ## 菜单栏 [[menu.main]] # 多加入一个搜索栏 weight = 8 identifier = \"search\" post = \"search\" ###################################### # Algolia search # 说明：需要开启 `Algolia` 在Hugo 的输出控制，且需要每 # 次将生成的 algolia.json 文件上传到 # Algolia enableAlgoliaSearch = true algoliaAppId = \"\" algoliaApiKey = \"\" algoliaIndexName = \"\" # 说明：https://www.algolia.com/ algolia官网查找key 或者登录后访问网址，然后找到对应Application ID、ApiKey、IndexName，找不到可以自行在参考博客中查找。覆盖index.algolia.json配置 然后在博客主目录/layouts下新建index.algoli","tags":["Blog"],"title":"MemE关键美化","url":"http://localhost:1313/posts/create/meme-custom-important/"},{"categories":["create"],"content":"a.json来覆盖meme中的配置，此处内容参考dreamsafari的json 此处需多加一个参数summary，内容为content内容，或者$page.Summary（但是此处显示会无法转义字符，目前无法解决，以后应该也不会解决，等有缘人），否则会显示undefined1 2 3 {{- range $i, $c := $chunked -}} {{- $index = $index | append (dict \"objectID\" (print $page.File.UniqueID \"_\" $i) \"order\" $i \"title\" $page.Title \"date\" $page.Date \"url\" $page.Permalink \"tags\" $page.Params.tags \"categories\" $page.Params.Categories \"summary\" $c) -}} {{- end -}} 修改algolia搜索配置 此处配置搜索选项，参考修改algolia的设置 自动上传algolia.json 详见github action处配置about页","date":"2023-05-27T19:59:46+08:00","objectID":"a6d58eaab69aefadc9bce63bf97fcef4_5","order":5,"summary":"a.json来覆盖meme中的配置，此处内容参考dreamsafari的json 此处需多加一个参数summary，内容为content内容，或者$page.Summary（但是此处显示会无法转义字符，目前无法解决，以后应该也不会解决，等有缘人），否则会显示undefined1 2 3 {{- range $i, $c := $chunked -}} {{- $index = $index | append (dict \"objectID\" (print $page.File.UniqueID \"_\" $i) \"order\" $i \"title\" $page.Title \"date\" $page.Date \"url\" $page.Permalink \"tags\" $page.Params.tags \"categories\" $page.Params.Categories \"summary\" $c) -}} {{- end -}} 修改algolia搜索配置 此处配置搜索选项，参考修改algolia的设置 自动上传algolia.json 详见github action处配置about页","tags":["Blog"],"title":"MemE关键美化","url":"http://localhost:1313/posts/create/meme-custom-important/"},{"categories":["create"],"content":"及视频 视频 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;video src=\"QmTz7jzWdGrTVKT7YwNwX9cEgfg4smNFHVxnaFDR82BrXt\" poster=\"../images/Gypsy Heart.jpg\" controls \u003e 如需下载：\u0026lt;a href=\"https://gateway.pinata.cloud/ipfs/QmTz7jzWdGrTVKT7YwNwX9cEgfg4smNFHVxnaFDR82BrXt\"\u003eMP4\u0026lt;/a\u003e \u0026lt;/video\u003e config.toml # 是否开启 enableVideoHost = true # 相对路径获取图片，用于poster属性 # 视频外链地址 videoHostURL = \"https://gateway.pinata.cloud/ipfs/\" # 用于src属性，使其链接干净 # !!必须src开头，否则无法识别到hash!! 为了使封面图poster与视频适配： 设置object-fit: 无效，被迫剪裁图片以适配视频。音乐 如果想配置音乐根目录下的layouts","date":"2023-05-27T19:59:46+08:00","objectID":"a6d58eaab69aefadc9bce63bf97fcef4_6","order":6,"summary":"及视频 视频 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;video src=\"QmTz7jzWdGrTVKT7YwNwX9cEgfg4smNFHVxnaFDR82BrXt\" poster=\"../images/Gypsy Heart.jpg\" controls \u003e 如需下载：\u0026lt;a href=\"https://gateway.pinata.cloud/ipfs/QmTz7jzWdGrTVKT7YwNwX9cEgfg4smNFHVxnaFDR82BrXt\"\u003eMP4\u0026lt;/a\u003e \u0026lt;/video\u003e config.toml # 是否开启 enableVideoHost = true # 相对路径获取图片，用于poster属性 # 视频外链地址 videoHostURL = \"https://gateway.pinata.cloud/ipfs/\" # 用于src属性，使其链接干净 # !!必须src开头，否则无法识别到hash!! 为了使封面图poster与视频适配： 设置object-fit: 无效，被迫剪裁图片以适配视频。音乐 如果想配置音乐根目录下的layouts","tags":["Blog"],"title":"MemE关键美化","url":"http://localhost:1313/posts/create/meme-custom-important/"},{"categories":["create"],"content":"设置为section 文章路径放在 blog/content/posts ，其内每个文件夹必须有个_index.md文件，为空没事，并且posts下也需要有。如果需要在第一个section内创建文件夹但是不显示该文件夹名可以配置Permalinks属性为[permalinks] posts = '/posts/:sections[1]/:slug/'url pattern.└── content└── about| └── index.md // \u0026lt;- https://example.com/about/├── posts| ├── _index.md // \u0026lt;- https://example.com/posts/| ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/| ├── happy| | └── ness.md // \u0026lt;- https://example.com/posts/ness/ 不显示happy| └── secondpost.md // \u0026lt;- https://examp","date":"2023-05-27T19:51:00+08:00","objectID":"ce7aa26d27b9cbf04edb3d6094670a1a_0","order":0,"summary":"设置为section 文章路径放在 blog/content/posts ，其内每个文件夹必须有个_index.md文件，为空没事，并且posts下也需要有。如果需要在第一个section内创建文件夹但是不显示该文件夹名可以配置Permalinks属性为[permalinks] posts = '/posts/:sections[1]/:slug/'url pattern.└── content└── about| └── index.md // \u0026lt;- https://example.com/about/├── posts| ├── _index.md // \u0026lt;- https://example.com/posts/| ├── firstpost.md // \u0026lt;- https://example.com/posts/firstpost/| ├── happy| | └── ness.md // \u0026lt;- https://example.com/posts/ness/ 不显示happy| └── secondpost.md // \u0026lt;- https://examp","tags":["Blog"],"title":"MemE美化1","url":"http://localhost:1313/posts/create/meme-custom-1/"},{"categories":["create"],"content":"le.com/posts/secondpost/└── quote├── first.md // \u0026lt;- https://example.com/quote/first/└── second.md // \u0026lt;- https://example.com/quote/second/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ###################################### # 分类方式 # MemE 主题支持以下两种分类方式： # 1. sections 分区 # 2. categories 部类 # 其中，分区是基于站点的 content 目录下的 # 文件夹和子文件夹；部类是基于文章的 Front # Matter。分类即树状分类，Hexo 是基于文章 # 的 Front Matter，Hugo 则是基于文件系统 # 的结构。由于设计理念的不同，导致了 Hexo # 与 Hugo 的这个差异，故在此设计这个选项， # 以对从 Hexo 过来的用户友好。但是请注意： #","date":"2023-05-27T19:51:00+08:00","objectID":"ce7aa26d27b9cbf04edb3d6094670a1a_1","order":1,"summary":"le.com/posts/secondpost/└── quote├── first.md // \u0026lt;- https://example.com/quote/first/└── second.md // \u0026lt;- https://example.com/quote/second/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ###################################### # 分类方式 # MemE 主题支持以下两种分类方式： # 1. sections 分区 # 2. categories 部类 # 其中，分区是基于站点的 content 目录下的 # 文件夹和子文件夹；部类是基于文章的 Front # Matter。分类即树状分类，Hexo 是基于文章 # 的 Front Matter，Hugo 则是基于文件系统 # 的结构。由于设计理念的不同，导致了 Hexo # 与 Hugo 的这个差异，故在此设计这个选项， # 以对从 Hexo 过来的用户友好。但是请注意： #","tags":["Blog"],"title":"MemE美化1","url":"http://localhost:1313/posts/create/meme-custom-1/"},{"categories":["create"],"content":" Hugo 中无法完全实现基于 Front Matter # 的树状分类，故如需保留树状分类，建议适应 # Hugo 的设计理念——分区。 categoryBy = \"sections\" # 注意：如果你设置为 `sections`，请务必将 # 此配置文件中的类别（taxonomies）中 # 的 `categories` 删除，不然分类页 # 面会失效。同时，你还需要自己新建一个 # `content/categories/_index.md` # 文件。 列表页面 此处页面在点击分类页中任意文件夹名即可显示设置网址图标 1 2 3 4 5 6 7 8 9 10 11 12 # 说明：前往 https://realfavicongenerator.net/ # 生成相关图标和文件，下载后解压，仅保留 # android-chrome-512x512.png、 # apple-touch-icon.png、 # mstile-150x150.png、 # safari-pinned-tab.svg、favicon.ico、 # site.webmanifest 这些文件，删除其余。 ","date":"2023-05-27T19:51:00+08:00","objectID":"ce7aa26d27b9cbf04edb3d6094670a1a_2","order":2,"summary":" Hugo 中无法完全实现基于 Front Matter # 的树状分类，故如需保留树状分类，建议适应 # Hugo 的设计理念——分区。 categoryBy = \"sections\" # 注意：如果你设置为 `sections`，请务必将 # 此配置文件中的类别（taxonomies）中 # 的 `categories` 删除，不然分类页 # 面会失效。同时，你还需要自己新建一个 # `content/categories/_index.md` # 文件。 列表页面 此处页面在点击分类页中任意文件夹名即可显示设置网址图标 1 2 3 4 5 6 7 8 9 10 11 12 # 说明：前往 https://realfavicongenerator.net/ # 生成相关图标和文件，下载后解压，仅保留 # android-chrome-512x512.png、 # apple-touch-icon.png、 # mstile-150x150.png、 # safari-pinned-tab.svg、favicon.ico、 # site.webmanifest 这些文件，删除其余。 ","tags":["Blog"],"title":"MemE美化1","url":"http://localhost:1313/posts/create/meme-custom-1/"},{"categories":["tech"],"content":"做记录用cuda下载 https://developer.download.nvidia.com/compute/cuda/12.1.1/local_installers/cuda_12.1.1_530.30.02_linux.run 将其中的.nvidia.com改为.. .cn ..即可，并将链接复制到浏览器，由浏览器托管下载 sudo sh cuda_12.1.1_530.30.02_linux.run git clone 搜索IP地址 https://www.ipaddress.com/ github.global.ssl.fastly.net 随便挑一个 github.com 修改host 打开hosts文件 Windows上的hosts文件路径在C:/WindowsSystem32/driversetchosts Linux的hosts文件路径在：sudo vim /etc/hosts append files 151.101.1.194 github.global-ssl.fastly.net 140.82.112.4 github.com刷新DNS sudo syste","date":"2023-05-26T21:16:39+08:00","objectID":"4680411b40a989460089ebbb1c139298_0","order":0,"summary":"做记录用cuda下载 https://developer.download.nvidia.com/compute/cuda/12.1.1/local_installers/cuda_12.1.1_530.30.02_linux.run 将其中的.nvidia.com改为.. .cn ..即可，并将链接复制到浏览器，由浏览器托管下载 sudo sh cuda_12.1.1_530.30.02_linux.run git clone 搜索IP地址 https://www.ipaddress.com/ github.global.ssl.fastly.net 随便挑一个 github.com 修改host 打开hosts文件 Windows上的hosts文件路径在C:/WindowsSystem32/driversetchosts Linux的hosts文件路径在：sudo vim /etc/hosts append files 151.101.1.194 github.global-ssl.fastly.net 140.82.112.4 github.com刷新DNS sudo syste","tags":["Others"],"title":"提高一些链接的下载速度","url":"http://localhost:1313/posts/tech/improve-download-speed/"},{"categories":["create"],"content":"上个版本: 只是用到ctypes进行传输, 这次将python服务端更改为C++服务端,方便后续维护. 本文实现功能: python传输图片给C++, C++接受图片后对图片进行处理,并将结果返回给python客户端, pass image from python to C++C++ 服务端 .h文件 注意文中的model1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // .h #pragma once #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;sys/socket.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;netinet/in.h\u003e #include \u0026lt;signal.h\u003e #include \u0026lt;opencv2/openc","date":"2023-05-26T21:14:31+08:00","objectID":"533ddc2567aaa3fdfeb98e04d472655c_0","order":0,"summary":"上个版本: 只是用到ctypes进行传输, 这次将python服务端更改为C++服务端,方便后续维护. 本文实现功能: python传输图片给C++, C++接受图片后对图片进行处理,并将结果返回给python客户端, pass image from python to C++C++ 服务端 .h文件 注意文中的model1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // .h #pragma once #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;sys/socket.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;netinet/in.h\u003e #include \u0026lt;signal.h\u003e #include \u0026lt;opencv2/openc","tags":["C++","Python","TCP"],"title":"混合编程python与C++","url":"http://localhost:1313/posts/create/python-client-c-server/"},{"categories":["create"],"content":"v.hpp\u003e using namespace std; using namespace cv; class ModelManager; class ServerManager { private: int m_port; char *m_addr; cv::VideoCapture m_cap; int m_server; int m_accept; // client conn public: bool initialization(const int \u0026port, const cv::VideoCapture \u0026cap, char *addr = nullptr); bool initialization(const int \u0026port, char *addr = nullptr); bool build_connect(); bool acceptClient(); void error_print(const char *ptr); bool free_connect(); bool send_data_frame(ModelManager\u0026 model); bool rece","date":"2023-05-26T21:14:31+08:00","objectID":"533ddc2567aaa3fdfeb98e04d472655c_1","order":1,"summary":"v.hpp\u003e using namespace std; using namespace cv; class ModelManager; class ServerManager { private: int m_port; char *m_addr; cv::VideoCapture m_cap; int m_server; int m_accept; // client conn public: bool initialization(const int \u0026port, const cv::VideoCapture \u0026cap, char *addr = nullptr); bool initialization(const int \u0026port, char *addr = nullptr); bool build_connect(); bool acceptClient(); void error_print(const char *ptr); bool free_connect(); bool send_data_frame(ModelManager\u0026 model); bool rece","tags":["C++","Python","TCP"],"title":"混合编程python与C++","url":"http://localhost:1313/posts/create/python-client-c-server/"},{"categories":["create"],"content":"ive_data_frame(cv::Mat \u0026frame, ModelManager\u0026 model); }; .cpp文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #include \"Ser","date":"2023-05-26T21:14:31+08:00","objectID":"533ddc2567aaa3fdfeb98e04d472655c_2","order":2,"summary":"ive_data_frame(cv::Mat \u0026frame, ModelManager\u0026 model); }; .cpp文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 #include \"Ser","tags":["C++","Python","TCP"],"title":"混合编程python与C++","url":"http://localhost:1313/posts/create/python-client-c-server/"},{"categories":["create"],"content":"verManager.h\" #include \"ModelManager.h\" #define BUFFER_SIZE 65538 void ServerManager::error_print(const char * ptr) { perror(ptr); exit(EXIT_FAILURE); } bool ServerManager::initialization(const int\u0026 port, const cv::VideoCapture\u0026 cap, char* addr){ m_port = htons(port); m_addr = addr; m_cap = cap; return true; } bool ServerManager::initialization(const int\u0026 port, char* addr){ m_port = htons(port); m_addr = addr; return true; } bool ServerManager::build_connect() { struct sockaddr_in server_addr; b","date":"2023-05-26T21:14:31+08:00","objectID":"533ddc2567aaa3fdfeb98e04d472655c_3","order":3,"summary":"verManager.h\" #include \"ModelManager.h\" #define BUFFER_SIZE 65538 void ServerManager::error_print(const char * ptr) { perror(ptr); exit(EXIT_FAILURE); } bool ServerManager::initialization(const int\u0026 port, const cv::VideoCapture\u0026 cap, char* addr){ m_port = htons(port); m_addr = addr; m_cap = cap; return true; } bool ServerManager::initialization(const int\u0026 port, char* addr){ m_port = htons(port); m_addr = addr; return true; } bool ServerManager::build_connect() { struct sockaddr_in server_addr; b","tags":["C++","Python","TCP"],"title":"混合编程python与C++","url":"http://localhost:1313/posts/create/python-client-c-server/"},{"categories":["create"],"content":"zero(\u0026server_addr,sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = m_addr?inet_addr(m_addr):INADDR_ANY; server_addr.sin_port = m_port; // create socket m_server = socket(AF_INET, SOCK_STREAM, 0); if(m_server \u0026lt; 0) error_print(\"socket bind error\"); // can reuse port int on = 1; if(setsockopt(m_server,SOL_SOCKET,SO_REUSEADDR,\u0026on,sizeof(on)) \u0026lt; 0) error_print(\"setsockopt error\"); // bind addr if(bind(m_server, (struct sockaddr*)\u0026server_addr, sizeof(server_ad","date":"2023-05-26T21:14:31+08:00","objectID":"533ddc2567aaa3fdfeb98e04d472655c_4","order":4,"summary":"zero(\u0026server_addr,sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = m_addr?inet_addr(m_addr):INADDR_ANY; server_addr.sin_port = m_port; // create socket m_server = socket(AF_INET, SOCK_STREAM, 0); if(m_server \u0026lt; 0) error_print(\"socket bind error\"); // can reuse port int on = 1; if(setsockopt(m_server,SOL_SOCKET,SO_REUSEADDR,\u0026on,sizeof(on)) \u0026lt; 0) error_print(\"setsockopt error\"); // bind addr if(bind(m_server, (struct sockaddr*)\u0026server_addr, sizeof(server_ad","tags":["C++","Python","TCP"],"title":"混合编程python与C++","url":"http://localhost:1313/posts/create/python-client-c-server/"},{"categories":["learn"],"content":"音频原理 博客声音 频率（音调）：声音1秒内周期性变化的次数人耳的听觉范围在20Hz-20kHz。 低频的声音沉闷厚重，高频的声音尖锐刺耳。 高于 20kHz的声音为超声波。振幅（响度）：声音的大小有的时候，我们用分贝（dB）形容声音大小。值得注意的是，dB是一个比值，是一个数值，没有任何单位标注。（功率强度之比的对数的10倍）声音采集与存储 采样，指把时间域或空间域的连续量转化成离散量的过程 。对声音的采样常用麦克风等设备将声音信号转换成电信号，再用模/数转换器将电信号转换成一串用1和0表示的二进制数字（数字信号）。采样频率指录音设备在一秒钟内对声音信号的采样次数。采样频率越高，声音的还原就越真实越自然。目前主流的采样频率有22.05KHz、44.1KHz、48KHz三种。PCM PCM(Pulse Code Modulation)也被称为 脉码编码调制。PCM中的声音数据没有被压缩，如果是单声道的文件，采样数据按时间的先后顺序依次存入。(它的基本组织单位是BYTE(8bit)或WORD(16bit))一般情况下，一帧PCM是由2048次采样组成的（参考请问PCM格式的音频流，每次读","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_0","order":0,"summary":"音频原理 博客声音 频率（音调）：声音1秒内周期性变化的次数人耳的听觉范围在20Hz-20kHz。 低频的声音沉闷厚重，高频的声音尖锐刺耳。 高于 20kHz的声音为超声波。振幅（响度）：声音的大小有的时候，我们用分贝（dB）形容声音大小。值得注意的是，dB是一个比值，是一个数值，没有任何单位标注。（功率强度之比的对数的10倍）声音采集与存储 采样，指把时间域或空间域的连续量转化成离散量的过程 。对声音的采样常用麦克风等设备将声音信号转换成电信号，再用模/数转换器将电信号转换成一串用1和0表示的二进制数字（数字信号）。采样频率指录音设备在一秒钟内对声音信号的采样次数。采样频率越高，声音的还原就越真实越自然。目前主流的采样频率有22.05KHz、44.1KHz、48KHz三种。PCM PCM(Pulse Code Modulation)也被称为 脉码编码调制。PCM中的声音数据没有被压缩，如果是单声道的文件，采样数据按时间的先后顺序依次存入。(它的基本组织单位是BYTE(8bit)或WORD(16bit))一般情况下，一帧PCM是由2048次采样组成的（参考请问PCM格式的音频流，每次读","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":"入或输出的块的大小是必须固定为4096B么）。如果是双声道的文件，采样数据按时间先后顺序交叉地存入。如图所示:aac的码流格式 AAC的ADTS头文件信息介绍、C++ 解析aac-adts的头部信息、AAC ADTS格式分析、保留用AAC音频格式：Advanced Audio Coding(高级音频解码)，是一种由MPEG-4标准定义的有损音频压缩格式，由Fraunhofer发展，Dolby, Sony和AT\u0026T是主要的贡献者。ADIF：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。 ADTS的全称是Audio Data Transport Stream。是AAC音频的传输流格式。AAC音频格式在MPEG-2（ISO-13318-7 2003）中有定义。AAC后来又被采用到MPEG-4标准中。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。常用在数","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_1","order":1,"summary":"入或输出的块的大小是必须固定为4096B么）。如果是双声道的文件，采样数据按时间先后顺序交叉地存入。如图所示:aac的码流格式 AAC的ADTS头文件信息介绍、C++ 解析aac-adts的头部信息、AAC ADTS格式分析、保留用AAC音频格式：Advanced Audio Coding(高级音频解码)，是一种由MPEG-4标准定义的有损音频压缩格式，由Fraunhofer发展，Dolby, Sony和AT\u0026T是主要的贡献者。ADIF：Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。 ADTS的全称是Audio Data Transport Stream。是AAC音频的传输流格式。AAC音频格式在MPEG-2（ISO-13318-7 2003）中有定义。AAC后来又被采用到MPEG-4标准中。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。它的特征类似于mp3数据流格式。常用在数","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":"据传输中。 ADTS Header syncword ：总是0xFFF, 代表一个ADTS帧的开始, 用于同步.解码器可通过0xFFF确定每个ADTS的开始位置.因为它的存在，解码可以在这个流中任何位置开始, 即可以在任意帧解码。 ID：MPEG Version: 0 for MPEG-4，1 for MPEG-2 Layer：always: '00' protection_absent：Warning, set to 1 if there is no CRC and 0 if there is CRC profile：表示使用哪个级别的AAC profile的值等于 Audio Object Type的值减1. 但是有17个，2bit能表示？ profile = MPEG-4 Audio Object Type - 1 sampling_frequency_index：采样率的下标 channel_configuration：声道数，比如2表示立体声双声道 接下来看下adts_variable_header();aac_frame_length：一个ADTS帧的长度包括ADTS头和A","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_2","order":2,"summary":"据传输中。 ADTS Header syncword ：总是0xFFF, 代表一个ADTS帧的开始, 用于同步.解码器可通过0xFFF确定每个ADTS的开始位置.因为它的存在，解码可以在这个流中任何位置开始, 即可以在任意帧解码。 ID：MPEG Version: 0 for MPEG-4，1 for MPEG-2 Layer：always: '00' protection_absent：Warning, set to 1 if there is no CRC and 0 if there is CRC profile：表示使用哪个级别的AAC profile的值等于 Audio Object Type的值减1. 但是有17个，2bit能表示？ profile = MPEG-4 Audio Object Type - 1 sampling_frequency_index：采样率的下标 channel_configuration：声道数，比如2表示立体声双声道 接下来看下adts_variable_header();aac_frame_length：一个ADTS帧的长度包括ADTS头和A","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":"AC原始流。 frame length, this value must include 7 or 9 bytes of header length: aac_frame_length = (protection_absent == 1 ? 7 : 9) + size(AACFrame) protection_absent=0时, header length=9bytes protection_absent=1时, header length=7bytes adts_buffer_fullness：0x7FF 说明是码率可变的码流。 number_of_raw_data_blocks_in_frame：表示ADTS帧中有number_of_raw_data_blocks_in_frame + 1个AAC原始帧。所以说number_of_raw_data_blocks_in_frame == 0 表示说ADTS帧中有一个AAC数据块。(一个AAC原始帧包含一段时间内1024个采样及相关数据) 代码 rtp.h、 rtp.cpp参考前文1 2 3 4 5 6 7 8 9 10 11 12 ","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_3","order":3,"summary":"AC原始流。 frame length, this value must include 7 or 9 bytes of header length: aac_frame_length = (protection_absent == 1 ? 7 : 9) + size(AACFrame) protection_absent=0时, header length=9bytes protection_absent=1时, header length=7bytes adts_buffer_fullness：0x7FF 说明是码率可变的码流。 number_of_raw_data_blocks_in_frame：表示ADTS帧中有number_of_raw_data_blocks_in_frame + 1个AAC原始帧。所以说number_of_raw_data_blocks_in_frame == 0 表示说ADTS帧中有一个AAC数据块。(一个AAC原始帧包含一段时间内1024个采样及相关数据) 代码 rtp.h、 rtp.cpp参考前文1 2 3 4 5 6 7 8 9 10 11 12 ","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":"13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_4","order":4,"summary":"13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":" 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_5","order":5,"summary":" 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":" 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_6","order":6,"summary":" 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":" 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 #include \"rtp.h\" #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;sys/socket.h\u003e #include \u0026lt;string\u003e #include \u0026lt;","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_7","order":7,"summary":" 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 #include \"rtp.h\" #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;sys/socket.h\u003e #include \u0026lt;string\u003e #include \u0026lt;","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":"stdint.h\u003e #define SERVER_PORT 8554 #define SERVER_RTP_PORT 55532 #define SERVER_RTCP_PORT 55533 #define BUF_MAX_SIZE (1024*1024) #define AAC_FILE_NAME \"./data/test.aac\" static int createTcpSocket() { int sockfd; int on = 1; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) return -1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)\u0026on, sizeof(on)); return sockfd; } static int createUdpSocket() { int sockfd; int on = 1; sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd \u0026lt;","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_8","order":8,"summary":"stdint.h\u003e #define SERVER_PORT 8554 #define SERVER_RTP_PORT 55532 #define SERVER_RTCP_PORT 55533 #define BUF_MAX_SIZE (1024*1024) #define AAC_FILE_NAME \"./data/test.aac\" static int createTcpSocket() { int sockfd; int on = 1; sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd \u0026lt; 0) return -1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)\u0026on, sizeof(on)); return sockfd; } static int createUdpSocket() { int sockfd; int on = 1; sockfd = socket(AF_INET, SOCK_DGRAM, 0); if (sockfd \u0026lt;","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":" 0) return -1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)\u0026on, sizeof(on)); return sockfd; } static int bindSocketAddr(int sockfd, const char* ip, int port) { struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = inet_addr(ip); if (bind(sockfd, (struct sockaddr*)\u0026addr, sizeof(struct sockaddr)) \u0026lt; 0) return -1; return 0; } static int closesocket(int fd){ close(fd); return 1; } struct AdtsHeader { unsigned int syncword; //12 bit 同步","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_9","order":9,"summary":" 0) return -1; setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, (const char*)\u0026on, sizeof(on)); return sockfd; } static int bindSocketAddr(int sockfd, const char* ip, int port) { struct sockaddr_in addr; addr.sin_family = AF_INET; addr.sin_port = htons(port); addr.sin_addr.s_addr = inet_addr(ip); if (bind(sockfd, (struct sockaddr*)\u0026addr, sizeof(struct sockaddr)) \u0026lt; 0) return -1; return 0; } static int closesocket(int fd){ close(fd); return 1; } struct AdtsHeader { unsigned int syncword; //12 bit 同步","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":"字 '1111 1111 1111'，一个ADTS帧的开始 uint8_t id; //1 bit 0代表MPEG-4, 1代表MPEG-2。 uint8_t layer; //2 bit 必须为0 uint8_t protectionAbsent; //1 bit 1代表没有CRC，0代表有CRC uint8_t profile; //2 bit AAC级别（MPEG-2 AAC中定义了3种profile，MPEG-4 AAC中定义了6种profile） uint8_t samplingFreqIndex; //4 bit 采样率 uint8_t privateBit; //1bit 编码时设置为0，解码时忽略 uint8_t channelCfg; //3 bit 声道数量 uint8_t originalCopy; //1bit 编码时设置为0，解码时忽略 uint8_t home; //1 bit 编码时设置为0，解码时忽略 uint8_t copyrightIdentificationBit; //1 bit 编码时设置为0，解码时忽略 uint8_t copyrightId","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_10","order":10,"summary":"字 '1111 1111 1111'，一个ADTS帧的开始 uint8_t id; //1 bit 0代表MPEG-4, 1代表MPEG-2。 uint8_t layer; //2 bit 必须为0 uint8_t protectionAbsent; //1 bit 1代表没有CRC，0代表有CRC uint8_t profile; //2 bit AAC级别（MPEG-2 AAC中定义了3种profile，MPEG-4 AAC中定义了6种profile） uint8_t samplingFreqIndex; //4 bit 采样率 uint8_t privateBit; //1bit 编码时设置为0，解码时忽略 uint8_t channelCfg; //3 bit 声道数量 uint8_t originalCopy; //1bit 编码时设置为0，解码时忽略 uint8_t home; //1 bit 编码时设置为0，解码时忽略 uint8_t copyrightIdentificationBit; //1 bit 编码时设置为0，解码时忽略 uint8_t copyrightId","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":"entificationStart; //1 bit 编码时设置为0，解码时忽略 unsigned int aacFrameLength; //13 bit 一个ADTS帧的长度包括ADTS头和AAC原始流 unsigned int adtsBufferFullness; //11 bit 缓冲区充满度，0x7FF说明是码率可变的码流，不需要此字段。CBR可能需要此字段，不同编码器使用情况不同。这个在使用音频编码的时候需要注意。 /* number_of_raw_data_blocks_in_frame * 表示ADTS帧中有number_of_raw_data_blocks_in_frame + 1个AAC原始帧 * 所以说number_of_raw_data_blocks_in_frame == 0 * 表示说ADTS帧中有一个AAC数据块并不是说没有。(一个AAC原始帧包含一段时间内1024个采样及相关数据) */ uint8_t numberOfRawDataBlockInFrame; //2 bit }; static int parseAdtsHeader(uint8_t*","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_11","order":11,"summary":"entificationStart; //1 bit 编码时设置为0，解码时忽略 unsigned int aacFrameLength; //13 bit 一个ADTS帧的长度包括ADTS头和AAC原始流 unsigned int adtsBufferFullness; //11 bit 缓冲区充满度，0x7FF说明是码率可变的码流，不需要此字段。CBR可能需要此字段，不同编码器使用情况不同。这个在使用音频编码的时候需要注意。 /* number_of_raw_data_blocks_in_frame * 表示ADTS帧中有number_of_raw_data_blocks_in_frame + 1个AAC原始帧 * 所以说number_of_raw_data_blocks_in_frame == 0 * 表示说ADTS帧中有一个AAC数据块并不是说没有。(一个AAC原始帧包含一段时间内1024个采样及相关数据) */ uint8_t numberOfRawDataBlockInFrame; //2 bit }; static int parseAdtsHeader(uint8_t*","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":" in, struct AdtsHeader* res) { static int frame_number = 0; memset(res, 0, sizeof(*res)); if ((in[0] == 0xFF) \u0026\u0026 ((in[1] \u0026 0xF0) == 0xF0)) { res-\u003eid = ((uint8_t)in[1] \u0026 0x08) \u003e\u003e 3;//第二个字节与0x08与运算之后，获得第13位bit对应的值 res-\u003elayer = ((uint8_t)in[1] \u0026 0x06) \u003e\u003e 1;//第二个字节与0x06与运算之后，右移1位，获得第14,15位两个bit对应的值 res-\u003eprotectionAbsent = (uint8_t)in[1] \u0026 0x01; res-\u003eprofile = ((uint8_t)in[2] \u0026 0xc0) \u003e\u003e 6; res-\u003esamplingFreqIndex = ((uint8_t)in[2] \u0026 0x3c) \u003e\u003e 2; res-\u003eprivateBit = ((uint8_t)in[2] \u0026 0x02) \u003e\u003e 1; res-\u003echan","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_12","order":12,"summary":" in, struct AdtsHeader* res) { static int frame_number = 0; memset(res, 0, sizeof(*res)); if ((in[0] == 0xFF) \u0026\u0026 ((in[1] \u0026 0xF0) == 0xF0)) { res-\u003eid = ((uint8_t)in[1] \u0026 0x08) \u003e\u003e 3;//第二个字节与0x08与运算之后，获得第13位bit对应的值 res-\u003elayer = ((uint8_t)in[1] \u0026 0x06) \u003e\u003e 1;//第二个字节与0x06与运算之后，右移1位，获得第14,15位两个bit对应的值 res-\u003eprotectionAbsent = (uint8_t)in[1] \u0026 0x01; res-\u003eprofile = ((uint8_t)in[2] \u0026 0xc0) \u003e\u003e 6; res-\u003esamplingFreqIndex = ((uint8_t)in[2] \u0026 0x3c) \u003e\u003e 2; res-\u003eprivateBit = ((uint8_t)in[2] \u0026 0x02) \u003e\u003e 1; res-\u003echan","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":"nelCfg = ((((uint8_t)in[2] \u0026 0x01) \u0026lt;\u0026lt; 2) | (((unsigned int)in[3] \u0026 0xc0) \u003e\u003e 6)); res-\u003eoriginalCopy = ((uint8_t)in[3] \u0026 0x20) \u003e\u003e 5; res-\u003ehome = ((uint8_t)in[3] \u0026 0x10) \u003e\u003e 4; res-\u003ecopyrightIdentificationBit = ((uint8_t)in[3] \u0026 0x08) \u003e\u003e 3; res-\u003ecopyrightIdentificationStart = (uint8_t)in[3] \u0026 0x04 \u003e\u003e 2; res-\u003eaacFrameLength = (((((unsigned int)in[3]) \u0026 0x03) \u0026lt;\u0026lt; 11) | (((unsigned int)in[4] \u0026 0xFF) \u0026lt;\u0026lt; 3) | ((unsigned int)in[5] \u0026 0xE0) \u003e\u003e 5); res-\u003eadtsBufferFullness = (((unsigned int)i","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_13","order":13,"summary":"nelCfg = ((((uint8_t)in[2] \u0026 0x01) \u0026lt;\u0026lt; 2) | (((unsigned int)in[3] \u0026 0xc0) \u003e\u003e 6)); res-\u003eoriginalCopy = ((uint8_t)in[3] \u0026 0x20) \u003e\u003e 5; res-\u003ehome = ((uint8_t)in[3] \u0026 0x10) \u003e\u003e 4; res-\u003ecopyrightIdentificationBit = ((uint8_t)in[3] \u0026 0x08) \u003e\u003e 3; res-\u003ecopyrightIdentificationStart = (uint8_t)in[3] \u0026 0x04 \u003e\u003e 2; res-\u003eaacFrameLength = (((((unsigned int)in[3]) \u0026 0x03) \u0026lt;\u0026lt; 11) | (((unsigned int)in[4] \u0026 0xFF) \u0026lt;\u0026lt; 3) | ((unsigned int)in[5] \u0026 0xE0) \u003e\u003e 5); res-\u003eadtsBufferFullness = (((unsigned int)i","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":"n[5] \u0026 0x1f) \u0026lt;\u0026lt; 6 | ((unsigned int)in[6] \u0026 0xfc) \u003e\u003e 2); res-\u003enumberOfRawDataBlockInFrame = ((uint8_t)in[6] \u0026 0x03); return 0; } else { printf(\"failed to parse adts header\\n\"); return -1; } } static int rtpSendAACFrame(int socket, const char* ip, int16_t port, struct RtpPacket* rtpPacket, uint8_t* frame, uint32_t frameSize) { //打包文档：https://blog.csdn.net/yangguoyu8023/article/details/106517251/ int ret; rtpPacket-\u003epayload[0] = 0x00; rtpPacket-\u003epayload[1] = 0x10; rtpPacket-\u003epayload[2] = (fra","date":"2023-05-26T21:04:25+08:00","objectID":"e8c3e6cae16f0d6a37dc848d05e1f226_14","order":14,"summary":"n[5] \u0026 0x1f) \u0026lt;\u0026lt; 6 | ((unsigned int)in[6] \u0026 0xfc) \u003e\u003e 2); res-\u003enumberOfRawDataBlockInFrame = ((uint8_t)in[6] \u0026 0x03); return 0; } else { printf(\"failed to parse adts header\\n\"); return -1; } } static int rtpSendAACFrame(int socket, const char* ip, int16_t port, struct RtpPacket* rtpPacket, uint8_t* frame, uint32_t frameSize) { //打包文档：https://blog.csdn.net/yangguoyu8023/article/details/106517251/ int ret; rtpPacket-\u003epayload[0] = 0x00; rtpPacket-\u003epayload[1] = 0x10; rtpPacket-\u003epayload[2] = (fra","tags":["C++","RTSP"],"title":"第3、4讲：实现一个基于TCP的RTP同时传输h264和aac的RTSP服务器","url":"http://localhost:1313/posts/learn/rtsp-server-of-h264-and-aac-based-on-rtp-over-tcp/"},{"categories":["learn"],"content":"vscode配置 vscode编译多个cpp文件将${file}更改为选中部分，使之编译所有cpp文件。注意：变更之后本工程内不能出现多个main函数！！或者使用命令行：gcc file1.cpp file2.cpp main.cpp -o myprogram或者使用cmake1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #假设我们有三个源代码文件： #main.cpp #myclass.cpp #utils.cpp #以及两个头文件： #myclass.h #utils.h #那么，我们首先需要在CMakeLists.txt中指定这些源代码文件，并创建一个库： cmake_minimum_required(VERSION 3.5) project(myproject) ## 添加源代码文件 add_library(mylib SHARED myclass.cpp utils.cpp ) ## 包含头文件搜索路径 include_directories(","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_0","order":0,"summary":"vscode配置 vscode编译多个cpp文件将${file}更改为选中部分，使之编译所有cpp文件。注意：变更之后本工程内不能出现多个main函数！！或者使用命令行：gcc file1.cpp file2.cpp main.cpp -o myprogram或者使用cmake1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #假设我们有三个源代码文件： #main.cpp #myclass.cpp #utils.cpp #以及两个头文件： #myclass.h #utils.h #那么，我们首先需要在CMakeLists.txt中指定这些源代码文件，并创建一个库： cmake_minimum_required(VERSION 3.5) project(myproject) ## 添加源代码文件 add_library(mylib SHARED myclass.cpp utils.cpp ) ## 包含头文件搜索路径 include_directories(","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":"${CMAKE_CURRENT_SOURCE_DIR}) ## 指定头文件 set(MY_HEADERS myclass.h utils.h ) ## 指定生成可执行文件，并链接库 add_executable(myapp main.cpp) target_link_libraries(myapp mylib) 项目功能 服务端需要源源不断的读取一个本地h264视频文件，并将读取到的h264视频流封装到RTP数据包中，再推送至客户端。这样我们就实现了一个简单的支持RTSP协议流媒体分发服务。RTP理解 RTP:实时传输协议（Real-time Transport Protocol或简写RTP）是一个网络传输协议.RTP定义了两种报文：RTP报文和RTCP报文，RTP报文用于传送媒体数据（如音频和视频），它由 RTP报头和数据两部分组成，RTP数据部分称为有效载荷(payload)；RTCP报文用于传送控制信息，以实现协议控制功能。RTP报文和RTCP 报文将作为下层协议（TCP/UDP）的数据单元进行传输。如果使用UDP，则RTP报文和RTCP报文分别使用两个相邻的UDP端口，RTP报","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_1","order":1,"summary":"${CMAKE_CURRENT_SOURCE_DIR}) ## 指定头文件 set(MY_HEADERS myclass.h utils.h ) ## 指定生成可执行文件，并链接库 add_executable(myapp main.cpp) target_link_libraries(myapp mylib) 项目功能 服务端需要源源不断的读取一个本地h264视频文件，并将读取到的h264视频流封装到RTP数据包中，再推送至客户端。这样我们就实现了一个简单的支持RTSP协议流媒体分发服务。RTP理解 RTP:实时传输协议（Real-time Transport Protocol或简写RTP）是一个网络传输协议.RTP定义了两种报文：RTP报文和RTCP报文，RTP报文用于传送媒体数据（如音频和视频），它由 RTP报头和数据两部分组成，RTP数据部分称为有效载荷(payload)；RTCP报文用于传送控制信息，以实现协议控制功能。RTP报文和RTCP 报文将作为下层协议（TCP/UDP）的数据单元进行传输。如果使用UDP，则RTP报文和RTCP报文分别使用两个相邻的UDP端口，RTP报","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":"文使用低端口，RTCP报文使用高端口。如果使用其它的下层协议（TCP），RTP报文和RTCP报文可以合并，放在一个数据单元中一起传送，控制信息在前，媒体数据在后。通常，RTP是由应用程序实现的。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // RTP头的结构体 struct RtpHeader { /* byte 0 */ uint8_t csrcLen : 4; //CSRC计数器，占后4位，指示CSRC 标识符的个数。 uint8_t extension : 1; //占1位，后第五位，如果X=1，则在RTP报头后跟有一个扩展报头。 uint8_t padding : 1; //填充标志，占1位，如果P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。 uint8_t version : 2; //RTP协议的版本号，占2位，当前协议版本号为2。 /* byte 1 */ uint8_t paylo","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_2","order":2,"summary":"文使用低端口，RTCP报文使用高端口。如果使用其它的下层协议（TCP），RTP报文和RTCP报文可以合并，放在一个数据单元中一起传送，控制信息在前，媒体数据在后。通常，RTP是由应用程序实现的。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // RTP头的结构体 struct RtpHeader { /* byte 0 */ uint8_t csrcLen : 4; //CSRC计数器，占后4位，指示CSRC 标识符的个数。 uint8_t extension : 1; //占1位，后第五位，如果X=1，则在RTP报头后跟有一个扩展报头。 uint8_t padding : 1; //填充标志，占1位，如果P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。 uint8_t version : 2; //RTP协议的版本号，占2位，当前协议版本号为2。 /* byte 1 */ uint8_t paylo","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":"adType : 7;//有效载荷类型，占7位，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等。 uint8_t marker : 1;//标记，占1位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。 /* bytes 2,3 */ uint16_t seq;//占16位，用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。接收者通过序列号来检测报文丢失情况，重新排序报文，恢复数据。 /* bytes 4-7 */ uint32_t timestamp;//占32位，时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。 /* bytes 8-11 */ uint32_t ssrc;//占32位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。 /*标准的RTP Header 还可能存在 0-15个特约信源(CSRC)标识符 每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_3","order":3,"summary":"adType : 7;//有效载荷类型，占7位，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等。 uint8_t marker : 1;//标记，占1位，不同的有效载荷有不同的含义，对于视频，标记一帧的结束；对于音频，标记会话的开始。 /* bytes 2,3 */ uint16_t seq;//占16位，用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。接收者通过序列号来检测报文丢失情况，重新排序报文，恢复数据。 /* bytes 4-7 */ uint32_t timestamp;//占32位，时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。 /* bytes 8-11 */ uint32_t ssrc;//占32位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。 /*标准的RTP Header 还可能存在 0-15个特约信源(CSRC)标识符 每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":"源 */ }; // RTP包的结构体 // 包含一个RTP头部和RTP载荷 struct RtpPacket { struct RtpHeader rtpHeader; uint8_t payload[0]; }; H264理解 链接I帧(intraframe frame),关键帧。 采用帧内压缩技术。I帧是所有数据帧最关键的帧，如果缺少了I帧，后面的数据帧将无法使用。IDR帧属于I帧。举例我将GOP中第一帧就可以称作I帧。在编码时，I帧是不需要参考前后帧数据，是独立编码。GOP至少有一个I帧。 P帧(forward Predicted frame)，向前参考帧。 压缩时，只参考前面已经处理的帧，采用帧间压缩技术。它占I帧的一半大小。 B帧(Bidirectionally predicted frame)，双向参考帧。 压缩时，既参考前面已经处理的帧，也参考后面的帧，帧间压缩技术。它占I帧1/4大小。压缩率变高 编码后数据，根据I帧P帧B帧的特性，在解码的过程是按I帧、P帧和B帧进行解码，文件播放还是按I帧、B帧和P帧顺序播放 IDR帧和I帧的关系：IDR(Instantannous","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_4","order":4,"summary":"源 */ }; // RTP包的结构体 // 包含一个RTP头部和RTP载荷 struct RtpPacket { struct RtpHeader rtpHeader; uint8_t payload[0]; }; H264理解 链接I帧(intraframe frame),关键帧。 采用帧内压缩技术。I帧是所有数据帧最关键的帧，如果缺少了I帧，后面的数据帧将无法使用。IDR帧属于I帧。举例我将GOP中第一帧就可以称作I帧。在编码时，I帧是不需要参考前后帧数据，是独立编码。GOP至少有一个I帧。 P帧(forward Predicted frame)，向前参考帧。 压缩时，只参考前面已经处理的帧，采用帧间压缩技术。它占I帧的一半大小。 B帧(Bidirectionally predicted frame)，双向参考帧。 压缩时，既参考前面已经处理的帧，也参考后面的帧，帧间压缩技术。它占I帧1/4大小。压缩率变高 编码后数据，根据I帧P帧B帧的特性，在解码的过程是按I帧、P帧和B帧进行解码，文件播放还是按I帧、B帧和P帧顺序播放 IDR帧和I帧的关系：IDR(Instantannous","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":" Decoder Refresh) 解码器立即刷新作用：在解码的过程，一旦有一帧数据出现错误，将是无法恢复的过程，后面数据帧不能使用。当有了IDR帧，解码器收到IDR帧时，就会将缓冲区的数据清空，找到第一个IDR帧，重新解码。I和IDR帧都使用帧内预测，在编码解码中为了方便，首个I帧要和其他I帧区别开，把第一个I帧叫IDR，这样方便控制编码和解码流程。IDR帧必须是一个I帧，但是I帧不一定是IDR帧，这个帧出现的时候，是告诉解码器，可以清除掉所有的参考帧，这是一个全新的序列，新的GOP已经开始。I帧有被跨帧参考的可能,IDR不会。每个GOP中的第一帧就是IDR帧。H264码流进行RTP封装 RTP封装H.264由一个一个的NALU组成，每个NALU之间使用00 00 00 01或00 00 01分隔开F(forbiden):禁止位，占用NALU头的第一个位，当禁止位值为1时表示语法错误； NRI:参考级别，占用NALU头的第二到第三个位；值越大，该NAL越重要。 Type:Nalu数据类型，也就是标识该NALu的数据类型是哪种，占用NALU头的第4到第8个位； 图片来源 0x61 (0","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_5","order":5,"summary":" Decoder Refresh) 解码器立即刷新作用：在解码的过程，一旦有一帧数据出现错误，将是无法恢复的过程，后面数据帧不能使用。当有了IDR帧，解码器收到IDR帧时，就会将缓冲区的数据清空，找到第一个IDR帧，重新解码。I和IDR帧都使用帧内预测，在编码解码中为了方便，首个I帧要和其他I帧区别开，把第一个I帧叫IDR，这样方便控制编码和解码流程。IDR帧必须是一个I帧，但是I帧不一定是IDR帧，这个帧出现的时候，是告诉解码器，可以清除掉所有的参考帧，这是一个全新的序列，新的GOP已经开始。I帧有被跨帧参考的可能,IDR不会。每个GOP中的第一帧就是IDR帧。H264码流进行RTP封装 RTP封装H.264由一个一个的NALU组成，每个NALU之间使用00 00 00 01或00 00 01分隔开F(forbiden):禁止位，占用NALU头的第一个位，当禁止位值为1时表示语法错误； NRI:参考级别，占用NALU头的第二到第三个位；值越大，该NAL越重要。 Type:Nalu数据类型，也就是标识该NALu的数据类型是哪种，占用NALU头的第4到第8个位； 图片来源 0x61 (0","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":" 11 00001) I帧 type = 1 0x41 (0 10 00001) P帧 type = 1 0x01 (0 00 00001) B帧 type = 1 打包方式：单NALU打包 所谓单NALU打包就是将一整个NALU的数据放入RTP包（RTP头+RTP载荷）的载荷中，这是最简单的一种方式。分片打包 每个RTP包都有大小限制的，因为RTP一般都是使用UDP发送，UDP没有流量控制，所以要限制每一次发送的大小，所以如果一个NALU的太大，就需要分成多个RTP包发送，至于如何分成多个RTP包，如下：首先要明确，RTP包的格式是绝不会变的，永远都是RTP头+RTP载荷RTP头部是固定的，那么只能在RTP载荷中去添加额外信息来说明这个RTP包是表示同一个NALU如果是分片打包的话，那么在RTP载荷开始有两个字节的信息，然后再是NALU的内容第一个字节FU Indicator，其格式如下高三位：与NALU第一个字节的高三位相同Type：28，表示该RTP包一个分片，为什么是28？因为H.264的规范中定义的，此外还有许多其他Type，这里不详讲第二个字节FU Header，其格式如下","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_6","order":6,"summary":" 11 00001) I帧 type = 1 0x41 (0 10 00001) P帧 type = 1 0x01 (0 00 00001) B帧 type = 1 打包方式：单NALU打包 所谓单NALU打包就是将一整个NALU的数据放入RTP包（RTP头+RTP载荷）的载荷中，这是最简单的一种方式。分片打包 每个RTP包都有大小限制的，因为RTP一般都是使用UDP发送，UDP没有流量控制，所以要限制每一次发送的大小，所以如果一个NALU的太大，就需要分成多个RTP包发送，至于如何分成多个RTP包，如下：首先要明确，RTP包的格式是绝不会变的，永远都是RTP头+RTP载荷RTP头部是固定的，那么只能在RTP载荷中去添加额外信息来说明这个RTP包是表示同一个NALU如果是分片打包的话，那么在RTP载荷开始有两个字节的信息，然后再是NALU的内容第一个字节FU Indicator，其格式如下高三位：与NALU第一个字节的高三位相同Type：28，表示该RTP包一个分片，为什么是28？因为H.264的规范中定义的，此外还有许多其他Type，这里不详讲第二个字节FU Header，其格式如下","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":"S：标记该分片打包的第一个RTP包E：比较该分片打包的最后一个RTP包Type：NALU的Type，不同与FU Indicator的type代码 **ffmpeg -i test.mp4 -codec copy -bsf: h264_mp4toannexb -f h264 test.h264 **生成h264文件rtp.h文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #pragma once #include \u0026lt;stdint.h\u003e #define RTP_VERSION 2 #define RTP_PAYLOAD_TYPE_H264 96 #define RTP_PAYLOAD_TYPE_AAC 97 #define RTP_HEADER_SIZE","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_7","order":7,"summary":"S：标记该分片打包的第一个RTP包E：比较该分片打包的最后一个RTP包Type：NALU的Type，不同与FU Indicator的type代码 **ffmpeg -i test.mp4 -codec copy -bsf: h264_mp4toannexb -f h264 test.h264 **生成h264文件rtp.h文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #pragma once #include \u0026lt;stdint.h\u003e #define RTP_VERSION 2 #define RTP_PAYLOAD_TYPE_H264 96 #define RTP_PAYLOAD_TYPE_AAC 97 #define RTP_HEADER_SIZE","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":" 12 #define RTP_MAX_PKT_SIZE 1400 /* * 0 1 2 3 * 7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ * |V=2|P|X| CC |M| PT | sequence number | * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ * | timestamp | * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ * | synchronization source (SSRC) identifier | * +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ * | contri","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_8","order":8,"summary":" 12 #define RTP_MAX_PKT_SIZE 1400 /* * 0 1 2 3 * 7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0|7 6 5 4 3 2 1 0 * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ * |V=2|P|X| CC |M| PT | sequence number | * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ * | timestamp | * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ * | synchronization source (SSRC) identifier | * +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+ * | contri","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":"buting source (CSRC) identifiers | * : .... : * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ * */ struct RtpHeader { /* byte 0 */ uint8_t csrcLen : 4;//CSRC计数器，占4位，指示CSRC 标识符的个数。 uint8_t extension : 1;//占1位，如果X=1，则在RTP报头后跟有一个扩展报头。 uint8_t padding : 1;//填充标志，占1位，如果P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。 uint8_t version : 2;//RTP协议的版本号，占2位，当前协议版本号为2。 /* byte 1 */ uint8_t payloadType : 7;//有效载荷类型，占7位，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等。 uint8_t marker : 1;//标记，占1位，不同的有效载荷有不同的含义，对于","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_9","order":9,"summary":"buting source (CSRC) identifiers | * : .... : * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ * */ struct RtpHeader { /* byte 0 */ uint8_t csrcLen : 4;//CSRC计数器，占4位，指示CSRC 标识符的个数。 uint8_t extension : 1;//占1位，如果X=1，则在RTP报头后跟有一个扩展报头。 uint8_t padding : 1;//填充标志，占1位，如果P=1，则在该报文的尾部填充一个或多个额外的八位组，它们不是有效载荷的一部分。 uint8_t version : 2;//RTP协议的版本号，占2位，当前协议版本号为2。 /* byte 1 */ uint8_t payloadType : 7;//有效载荷类型，占7位，用于说明RTP报文中有效载荷的类型，如GSM音频、JPEM图像等。 uint8_t marker : 1;//标记，占1位，不同的有效载荷有不同的含义，对于","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":"视频，标记一帧的结束；对于音频，标记会话的开始。 /* bytes 2,3 */ uint16_t seq;//占16位，用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。接收者通过序列号来检测报文丢失情况，重新排序报文，恢复数据。 /* bytes 4-7 */ uint32_t timestamp;//占32位，时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。 /* bytes 8-11 */ uint32_t ssrc;//占32位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。 /*标准的RTP Header 还可能存在 0-15个特约信源(CSRC)标识符 每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信源 */ }; struct RtpPacket { struct RtpHeader rtpHeader; uint8_t payload[0]; }; void rtpHeaderInit(struc","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_10","order":10,"summary":"视频，标记一帧的结束；对于音频，标记会话的开始。 /* bytes 2,3 */ uint16_t seq;//占16位，用于标识发送者所发送的RTP报文的序列号，每发送一个报文，序列号增1。接收者通过序列号来检测报文丢失情况，重新排序报文，恢复数据。 /* bytes 4-7 */ uint32_t timestamp;//占32位，时戳反映了该RTP报文的第一个八位组的采样时刻。接收者使用时戳来计算延迟和延迟抖动，并进行同步控制。 /* bytes 8-11 */ uint32_t ssrc;//占32位，用于标识同步信源。该标识符是随机选择的，参加同一视频会议的两个同步信源不能有相同的SSRC。 /*标准的RTP Header 还可能存在 0-15个特约信源(CSRC)标识符 每个CSRC标识符占32位，可以有0～15个。每个CSRC标识了包含在该RTP报文有效载荷中的所有特约信源 */ }; struct RtpPacket { struct RtpHeader rtpHeader; uint8_t payload[0]; }; void rtpHeaderInit(struc","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":"t RtpPacket* rtpPacket, uint8_t csrcLen, uint8_t extension, uint8_t padding, uint8_t version, uint8_t payloadType, uint8_t marker, uint16_t seq, uint32_t timestamp, uint32_t ssrc); int rtpSendPacketOverTcp(int clientSockfd, struct RtpPacket* rtpPacket, uint32_t dataSize, char channel); int rtpSendPacketOverUdp(int serverRtpSockfd, const char* ip, int16_t port, struct RtpPacket* rtpPacket, uint32_t dataSize); rtp.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_11","order":11,"summary":"t RtpPacket* rtpPacket, uint8_t csrcLen, uint8_t extension, uint8_t padding, uint8_t version, uint8_t payloadType, uint8_t marker, uint16_t seq, uint32_t timestamp, uint32_t ssrc); int rtpSendPacketOverTcp(int clientSockfd, struct RtpPacket* rtpPacket, uint32_t dataSize, char channel); int rtpSendPacketOverUdp(int serverRtpSockfd, const char* ip, int16_t port, struct RtpPacket* rtpPacket, uint32_t dataSize); rtp.cpp 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":" 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \"rtp.h\" #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;sys/socket.h\u003e #include \u0026lt;string\u003e #include \u0026lt;stdint.h\u003e void rtpHeaderInit(struct RtpPacket* rtpPacket, uint8_t csrcLen, uint8_t extension, uint8_t padding, uint8_t version, uint8_t payloadType, uint8_t marker, uint16_t s","date":"2023-05-26T21:03:50+08:00","objectID":"d052d9cd3ad1ef87fd9a2e76f9d353c8_12","order":12,"summary":" 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \"rtp.h\" #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;sys/socket.h\u003e #include \u0026lt;string\u003e #include \u0026lt;stdint.h\u003e void rtpHeaderInit(struct RtpPacket* rtpPacket, uint8_t csrcLen, uint8_t extension, uint8_t padding, uint8_t version, uint8_t payloadType, uint8_t marker, uint16_t s","tags":["C++","RTSP"],"title":"第2讲：实现一个传输h264的RTSP服务器","url":"http://localhost:1313/posts/learn/h264-rtsp-server/"},{"categories":["learn"],"content":" RTSP是一个实时传输流协议，是一个应用层的协议。通常说的RTSP包括RTSP协议、RTP协议、RTCP协议，对于这些协议的作用简单的理解如下 RTSP协议：负责服务器与客户端之间的请求与响应 RTP协议：负责服务器与客户端之间传输媒体数据 RTCP协议：负责提供有关RTP传输质量的反馈，就是确保RTP传输的质量 三者的关系：rtsp并不会发送媒体数据，只是完成服务器和客户端之间的信令交互，rtp协议负责媒体数据传输，rtcp负责rtp数据包的监视和反馈。rtp和rtcp并没有规定传输层的类型，可以选择udp和tcp。Rtsp的传输层则要求是基于tcp。 准备工作 安装ffmepg 因为已经装过了，所以这里自行安装。安装wireshark sudo apt-get update sudo apt-get install wireshark 出现一个对话框选yes 将wireshark加入到当前用户，使其可以命令行访问，sudo vim /etc/group （应该在最后一行）找到wireshark，最后加入你的ubuntu用户名 wireshark:x:129:ubuntu用户名 然","date":"2023-05-26T21:02:17+08:00","objectID":"558a1ebcbea6cb98e2c06c0db60a3359_0","order":0,"summary":" RTSP是一个实时传输流协议，是一个应用层的协议。通常说的RTSP包括RTSP协议、RTP协议、RTCP协议，对于这些协议的作用简单的理解如下 RTSP协议：负责服务器与客户端之间的请求与响应 RTP协议：负责服务器与客户端之间传输媒体数据 RTCP协议：负责提供有关RTP传输质量的反馈，就是确保RTP传输的质量 三者的关系：rtsp并不会发送媒体数据，只是完成服务器和客户端之间的信令交互，rtp协议负责媒体数据传输，rtcp负责rtp数据包的监视和反馈。rtp和rtcp并没有规定传输层的类型，可以选择udp和tcp。Rtsp的传输层则要求是基于tcp。 准备工作 安装ffmepg 因为已经装过了，所以这里自行安装。安装wireshark sudo apt-get update sudo apt-get install wireshark 出现一个对话框选yes 将wireshark加入到当前用户，使其可以命令行访问，sudo vim /etc/group （应该在最后一行）找到wireshark，最后加入你的ubuntu用户名 wireshark:x:129:ubuntu用户名 然","tags":["C++","RTSP"],"title":"第1讲：RTSP协议讲解及代码实现","url":"http://localhost:1313/posts/learn/rtsp-protocol-explanation-and-code-implementation/"},{"categories":["learn"],"content":"后命令行输入sudo wireshark即可 参考博客 注意运行需要管理员运行，即sudo选择本地回环：loopback然后双击该行，进入监听随后运行程序即可，然后再开启一个终端（ctrl+alt+T），输入ffplay -i rtsp://127.0.0.1:8554然后wireshark就会出现RTSP相关选项 options请求，用于查询RTSP服务器支持的方法（如DESCRIBE、SETUP、PLAY等）。 DESCRIBE请求，用于获取有关流媒体的信息，例如它的编码格式、分辨率、码率等。（sdp） SETUP请求，作用是指明媒体流该以什么方式传输；每个流PLAY之前必须执行SETUP操作；发送SETUP请求时，客户端会指定两个端口，一个端口用于接收RTP数据；另一个端口接收RTCP数据，偶数端口用来接收RTP数据，相邻的奇数端口用于接收RTCP数据！ PLAY请求，发送播放请求的时候可以指定播放区间！发起播放请求后，如果连接正常，则服务端开始播放，即开始向客户端按照之前在TRASPORT中约定好的方式发送音视频数据包！播放流程便这样开始了 Linux代码 1 2 3 4 5 ","date":"2023-05-26T21:02:17+08:00","objectID":"558a1ebcbea6cb98e2c06c0db60a3359_1","order":1,"summary":"后命令行输入sudo wireshark即可 参考博客 注意运行需要管理员运行，即sudo选择本地回环：loopback然后双击该行，进入监听随后运行程序即可，然后再开启一个终端（ctrl+alt+T），输入ffplay -i rtsp://127.0.0.1:8554然后wireshark就会出现RTSP相关选项 options请求，用于查询RTSP服务器支持的方法（如DESCRIBE、SETUP、PLAY等）。 DESCRIBE请求，用于获取有关流媒体的信息，例如它的编码格式、分辨率、码率等。（sdp） SETUP请求，作用是指明媒体流该以什么方式传输；每个流PLAY之前必须执行SETUP操作；发送SETUP请求时，客户端会指定两个端口，一个端口用于接收RTP数据；另一个端口接收RTCP数据，偶数端口用来接收RTP数据，相邻的奇数端口用于接收RTCP数据！ PLAY请求，发送播放请求的时候可以指定播放区间！发起播放请求后，如果连接正常，则服务端开始播放，即开始向客户端按照之前在TRASPORT中约定好的方式发送音视频数据包！播放流程便这样开始了 Linux代码 1 2 3 4 5 ","tags":["C++","RTSP"],"title":"第1讲：RTSP协议讲解及代码实现","url":"http://localhost:1313/posts/learn/rtsp-protocol-explanation-and-code-implementation/"},{"categories":["learn"],"content":"6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 15","date":"2023-05-26T21:02:17+08:00","objectID":"558a1ebcbea6cb98e2c06c0db60a3359_2","order":2,"summary":"6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 15","tags":["C++","RTSP"],"title":"第1讲：RTSP协议讲解及代码实现","url":"http://localhost:1313/posts/learn/rtsp-protocol-explanation-and-code-implementation/"},{"categories":["learn"],"content":"5 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 28","date":"2023-05-26T21:02:17+08:00","objectID":"558a1ebcbea6cb98e2c06c0db60a3359_3","order":3,"summary":"5 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 28","tags":["C++","RTSP"],"title":"第1讲：RTSP协议讲解及代码实现","url":"http://localhost:1313/posts/learn/rtsp-protocol-explanation-and-code-implementation/"},{"categories":["learn"],"content":"0 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;sys/socket.h\u003e #include \u0026lt;string\u003e #pragma comment(lib, \"ws2_32.lib\") #include \u0026lt;stdint.h\u003e #pragma warning( disable : 4996 ) #define SERVER_PORT 8554 #define SERVER_RTP_PORT 55532 #define SERVER_RTCP_PORT 55533 static int createTcpSocket() { int sockfd; int on = 1; sockfd = socket(AF_INET, SOCK_ST","date":"2023-05-26T21:02:17+08:00","objectID":"558a1ebcbea6cb98e2c06c0db60a3359_4","order":4,"summary":"0 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 #include \u0026lt;stdio.h\u003e #include \u0026lt;stdlib.h\u003e #include \u0026lt;string.h\u003e #include \u0026lt;unistd.h\u003e #include \u0026lt;arpa/inet.h\u003e #include \u0026lt;sys/socket.h\u003e #include \u0026lt;string\u003e #pragma comment(lib, \"ws2_32.lib\") #include \u0026lt;stdint.h\u003e #pragma warning( disable : 4996 ) #define SERVER_PORT 8554 #define SERVER_RTP_PORT 55532 #define SERVER_RTCP_PORT 55533 static int createTcpSocket() { int sockfd; int on = 1; sockfd = socket(AF_INET, SOCK_ST","tags":["C++","RTSP"],"title":"第1讲：RTSP协议讲解及代码实现","url":"http://localhost:1313/posts/learn/rtsp-protocol-explanation-and-code-implementation/"},{"categories":["tech"],"content":"主要参考博客: 在cmake工程中使用ZeroMQ,并加以补充 次要博客:Linux下ZeroMQ的编译安装与运行 文中提到arm,我只装在linux系统上，原本想用在通信中，最后还是用tcp实现了安装libzmq git clone https://github.com/zeromq/libzmq.git 在当前文件夹内下载libzmq文件夹,建议先cd到你想要放的文件夹 cd libzmq ./autogen.sh ./configure 安装zmqpp git clone https://github.com/zeromq/zmqpp.git 同理,找个文件夹放 make -j4 \u0026\u0026 sudo make install 上述安装完成后查看头文件和库文件路径如果当前在用户路径下 cd ../../user头文件路径 ： /usr/local/include库文件路径 : /usr/local/libCMakeList.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 cmake_","date":"2023-05-26T20:55:03+08:00","objectID":"91992edc0bc6c709dc40f746393a0242_0","order":0,"summary":"主要参考博客: 在cmake工程中使用ZeroMQ,并加以补充 次要博客:Linux下ZeroMQ的编译安装与运行 文中提到arm,我只装在linux系统上，原本想用在通信中，最后还是用tcp实现了安装libzmq git clone https://github.com/zeromq/libzmq.git 在当前文件夹内下载libzmq文件夹,建议先cd到你想要放的文件夹 cd libzmq ./autogen.sh ./configure 安装zmqpp git clone https://github.com/zeromq/zmqpp.git 同理,找个文件夹放 make -j4 \u0026\u0026 sudo make install 上述安装完成后查看头文件和库文件路径如果当前在用户路径下 cd ../../user头文件路径 ： /usr/local/include库文件路径 : /usr/local/libCMakeList.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 cmake_","tags":["Install"],"title":"zmq 小白简易安装C++版","url":"http://localhost:1313/posts/tech/zmq-install/"},{"categories":["create"],"content":" 前言: 小白一个, 没有系统性的学习过python网络通信,只是单纯的cv加修改代码,仅作留念以及参考用,感谢互联网博主们和bito插件,使得chatGPT得以免费使用. 另外该多线程传输图片的速度比没有多线程执行还满,后续不对python服务端做优化,而改为C++服务端实现.写出来继续再分享把前篇博客地址python客户端 采用生存者消费者模式、模式２和joinablequeue库. 客户端实现还是比较简单的,麻烦在server端1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import pickle import time from multiprocessing import Process,","date":"2023-05-26T20:34:37+08:00","objectID":"34f3af3b6333bf968a64655ce1d5d8ec_0","order":0,"summary":" 前言: 小白一个, 没有系统性的学习过python网络通信,只是单纯的cv加修改代码,仅作留念以及参考用,感谢互联网博主们和bito插件,使得chatGPT得以免费使用. 另外该多线程传输图片的速度比没有多线程执行还满,后续不对python服务端做优化,而改为C++服务端实现.写出来继续再分享把前篇博客地址python客户端 采用生存者消费者模式、模式２和joinablequeue库. 客户端实现还是比较简单的,麻烦在server端1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 import pickle import time from multiprocessing import Process,","tags":["Ctype","TCP","Python"],"title":"混合编程之多线程","url":"http://localhost:1313/posts/create/ctype-with-threading/"},{"categories":["create"],"content":" JoinableQueue from queue import Queue from multiprocessing.connection import Client, Listener from client_apart import draw_box from image import plot_boxes, img_encode import os from natsort import ns, natsorted host = 'localhost' port = 9006 total_time = 0 def img_product(img_queue, path, path_mode='image'): if path_mode == 'image': img = img_encode(path) img_obj = {'frame_num': 1, 'image': img} # need frame_num? img_queue.put(img_obj) elif path_mode == 'dir': dir_list = os.listdir(path) file","date":"2023-05-26T20:34:37+08:00","objectID":"34f3af3b6333bf968a64655ce1d5d8ec_1","order":1,"summary":" JoinableQueue from queue import Queue from multiprocessing.connection import Client, Listener from client_apart import draw_box from image import plot_boxes, img_encode import os from natsort import ns, natsorted host = 'localhost' port = 9006 total_time = 0 def img_product(img_queue, path, path_mode='image'): if path_mode == 'image': img = img_encode(path) img_obj = {'frame_num': 1, 'image': img} # need frame_num? img_queue.put(img_obj) elif path_mode == 'dir': dir_list = os.listdir(path) file","tags":["Ctype","TCP","Python"],"title":"混合编程之多线程","url":"http://localhost:1313/posts/create/ctype-with-threading/"},{"categories":["create"],"content":"s = natsorted(dir_list, alg=ns.PATH) # 顺序读取文件名 i = 1 for filename in files: img_path = path + '/' + filename img = img_encode(img_path) img_obj = {'frame_num': i, 'image': img} # need frame_num? i += 1 img_queue.put(img_obj) img_queue.put({'frame_num': 0, 'image': \"end\"}) # end signal img_queue.join() def server_consumer(img_queue): # 1. send data while True: img_obj = img_queue.get() if img_obj is None: client.close() # avoid connection-reset-by-peer break # exit end data_bytes = pickle.dumps(i","date":"2023-05-26T20:34:37+08:00","objectID":"34f3af3b6333bf968a64655ce1d5d8ec_2","order":2,"summary":"s = natsorted(dir_list, alg=ns.PATH) # 顺序读取文件名 i = 1 for filename in files: img_path = path + '/' + filename img = img_encode(img_path) img_obj = {'frame_num': i, 'image': img} # need frame_num? i += 1 img_queue.put(img_obj) img_queue.put({'frame_num': 0, 'image': \"end\"}) # end signal img_queue.join() def server_consumer(img_queue): # 1. send data while True: img_obj = img_queue.get() if img_obj is None: client.close() # avoid connection-reset-by-peer break # exit end data_bytes = pickle.dumps(i","tags":["Ctype","TCP","Python"],"title":"混合编程之多线程","url":"http://localhost:1313/posts/create/ctype-with-threading/"},{"categories":["create"],"content":"mg_obj) start = int(round(time.time() * 1000)) start_time = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) client.send(data_bytes) # 40ms/per send img # print('send cost time: ', (end - start)) img_queue.task_done() try: det_result = client.recv() end = int(round(time.time() * 1000)) end_time = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) print('recv cost time: ', (end-start)) except EOFError: break det_result = pickle.loads(det_result) draw_box(det_result, img_obj) if __name__ == ","date":"2023-05-26T20:34:37+08:00","objectID":"34f3af3b6333bf968a64655ce1d5d8ec_3","order":3,"summary":"mg_obj) start = int(round(time.time() * 1000)) start_time = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) client.send(data_bytes) # 40ms/per send img # print('send cost time: ', (end - start)) img_queue.task_done() try: det_result = client.recv() end = int(round(time.time() * 1000)) end_time = time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) print('recv cost time: ', (end-start)) except EOFError: break det_result = pickle.loads(det_result) draw_box(det_result, img_obj) if __name__ == ","tags":["Ctype","TCP","Python"],"title":"混合编程之多线程","url":"http://localhost:1313/posts/create/ctype-with-threading/"},{"categories":["learn"],"content":"三维重建与极几何 单视图重构会受到多义性的影响，并且需要场景知识 而人眼是有两个眼睛，可以组合两种图片，采用多视图几何三维重建基础 三角化 未知参数：xyz 难点： 需要知道摄像机的内参矩阵，以及R、T矩阵，P点的三维坐标多视图几何的关键问题 极几何与基础矩阵 极几何 极几何描述了同一场景或者物体的两个视点图像间的几何关系；利用极几何解决第三个关键问题。 本质矩阵和基础矩阵就是通过p来求极线l平行视图 前向平移（无旋转） 用于深度估计，非课程内容 极几何约束--本质矩阵 通过极几何约束，将搜索范围缩小到对应的极线上。 本质矩阵是对规范化摄像机拍摄的两个视点图像间的极几何关系进行代数描述。 从本质矩阵到基础矩阵 基础矩阵是对一般的透视摄像机拍摄的两个视点图像间的极几何关系进行代数描述，具有泛化性 将O1看作世界坐标系 总结： 基础矩阵估计 八点算法 精度较低，采用 归一化八点法： 补充知识 单应矩阵 结合基础矩阵，使slam系统更鲁棒 空间平面在两个摄像机下的投影几何 双目立体视觉 基于平行试图的双目立体视觉 平行视图 F和e'的关系 平行视图基础矩阵 哦，平行视图基础矩阵长这样。 平行","date":"2023-05-26T20:28:22+08:00","objectID":"4f98d4ea4538903ea9ed4f154d4331d2_0","order":0,"summary":"三维重建与极几何 单视图重构会受到多义性的影响，并且需要场景知识 而人眼是有两个眼睛，可以组合两种图片，采用多视图几何三维重建基础 三角化 未知参数：xyz 难点： 需要知道摄像机的内参矩阵，以及R、T矩阵，P点的三维坐标多视图几何的关键问题 极几何与基础矩阵 极几何 极几何描述了同一场景或者物体的两个视点图像间的几何关系；利用极几何解决第三个关键问题。 本质矩阵和基础矩阵就是通过p来求极线l平行视图 前向平移（无旋转） 用于深度估计，非课程内容 极几何约束--本质矩阵 通过极几何约束，将搜索范围缩小到对应的极线上。 本质矩阵是对规范化摄像机拍摄的两个视点图像间的极几何关系进行代数描述。 从本质矩阵到基础矩阵 基础矩阵是对一般的透视摄像机拍摄的两个视点图像间的极几何关系进行代数描述，具有泛化性 将O1看作世界坐标系 总结： 基础矩阵估计 八点算法 精度较低，采用 归一化八点法： 补充知识 单应矩阵 结合基础矩阵，使slam系统更鲁棒 空间平面在两个摄像机下的投影几何 双目立体视觉 基于平行试图的双目立体视觉 平行视图 F和e'的关系 平行视图基础矩阵 哦，平行视图基础矩阵长这样。 平行","tags":["ComputerVision"],"title":"三维重建之路中","url":"http://localhost:1313/posts/learn/three-d-reconstruction-3/"},{"categories":["learn"],"content":"视图极线、p和p'关系 我的问题：找到pp'之后可以解决唯一确定一个三维点，从而构建三维模型？p'怎么确定，扫描线上哪个点：相似性处理 平行视图三角测量（三角化） 双目立体视觉系统构建的核心问题 如何获得平行视图 如何建立点对应关系 图像校正 在平行视图下极线平行，且极点位于无穷远处，则极点坐标e'=[1;0;0]，只要令非平行视图的e'变为平行视图的e'即可12步 计算出e' 3步 e'变换到无穷远点 45步 计算出H、H'进行重采样 H的计算不能通过上述步骤完成，可能最后算出来不在同一个平面，因此利用求最小值来近似结果。 重采样就是将非平行视图的像素点利用H、H'分别映射到对应平行视图的像素点上 对应点搜索 相关匹配 对亮度敏感 归一化相关匹配 对应点问题 引入约束 其中顺序约束，要在物体没被遮挡的假设下成立 多视图几何 运动恢复结构问题 通过三维场景的多张图像，恢复出该场景的三维结构信息以及每张图片对应的摄像机参数 数学表达： 欧式结构恢复问题 124问题已经解决，只需要处理本质矩阵即可 无视E的符号及尺度 分解出E中的R矩阵 分解出E中的T向量 分解本质矩阵总结 计算三角化 欧","date":"2023-05-26T20:28:22+08:00","objectID":"4f98d4ea4538903ea9ed4f154d4331d2_1","order":1,"summary":"视图极线、p和p'关系 我的问题：找到pp'之后可以解决唯一确定一个三维点，从而构建三维模型？p'怎么确定，扫描线上哪个点：相似性处理 平行视图三角测量（三角化） 双目立体视觉系统构建的核心问题 如何获得平行视图 如何建立点对应关系 图像校正 在平行视图下极线平行，且极点位于无穷远处，则极点坐标e'=[1;0;0]，只要令非平行视图的e'变为平行视图的e'即可12步 计算出e' 3步 e'变换到无穷远点 45步 计算出H、H'进行重采样 H的计算不能通过上述步骤完成，可能最后算出来不在同一个平面，因此利用求最小值来近似结果。 重采样就是将非平行视图的像素点利用H、H'分别映射到对应平行视图的像素点上 对应点搜索 相关匹配 对亮度敏感 归一化相关匹配 对应点问题 引入约束 其中顺序约束，要在物体没被遮挡的假设下成立 多视图几何 运动恢复结构问题 通过三维场景的多张图像，恢复出该场景的三维结构信息以及每张图片对应的摄像机参数 数学表达： 欧式结构恢复问题 124问题已经解决，只需要处理本质矩阵即可 无视E的符号及尺度 分解出E中的R矩阵 分解出E中的T向量 分解本质矩阵总结 计算三角化 欧","tags":["ComputerVision"],"title":"三维重建之路中","url":"http://localhost:1313/posts/learn/three-d-reconstruction-3/"},{"categories":["learn"],"content":"式结构恢复的歧义 仿射结构恢复问题 回顾：弱透视投影摄像机 v 应该是 1×3 仿射结构问题 基于因式分解的仿射结构恢复 数据中心化 这里有点没听懂，直接记结论了，为什么bi=0 因式分解 M也可以利用U3W3，S用V3T，解会不唯一，参考恢复歧义 总结 用欧式的话，每次拿两个点来算，会造成误差累积，而仿射一次性计算所有点，可以减少误差；但是仿射遇到被遮挡的点，其一列都不能参与计算，必须所有摄像机都看到 仿射结构恢复歧义 必须2mn\u003e8m+n-8才有解；2mn表示一对点在m个摄像机下映射到n个三维点透视变换结构恢复 透视结构恢复歧义 由歧义引出解 恢复方法 困难点：K1、K2、R、T均未知代数方法 F包含KRT矩阵信息，所以从F中分解出M1，M2矩阵即可 M1已知，M2未知 得到F关于A、b的表达式 计算A，b，求M2* N视图情况 Bundle Adjustment 代数法与分解法的局限性 最小化重投影误差 MiXj = xij' 即xij（真实值）的测量点 补充知识 PnP问题 原先欧式结构是已知三维点和像素点的对应关系求F→E→RT，而现在是已知摄像机位姿的视图来求新摄像机位姿，","date":"2023-05-26T20:28:22+08:00","objectID":"4f98d4ea4538903ea9ed4f154d4331d2_2","order":2,"summary":"式结构恢复的歧义 仿射结构恢复问题 回顾：弱透视投影摄像机 v 应该是 1×3 仿射结构问题 基于因式分解的仿射结构恢复 数据中心化 这里有点没听懂，直接记结论了，为什么bi=0 因式分解 M也可以利用U3W3，S用V3T，解会不唯一，参考恢复歧义 总结 用欧式的话，每次拿两个点来算，会造成误差累积，而仿射一次性计算所有点，可以减少误差；但是仿射遇到被遮挡的点，其一列都不能参与计算，必须所有摄像机都看到 仿射结构恢复歧义 必须2mn\u003e8m+n-8才有解；2mn表示一对点在m个摄像机下映射到n个三维点透视变换结构恢复 透视结构恢复歧义 由歧义引出解 恢复方法 困难点：K1、K2、R、T均未知代数方法 F包含KRT矩阵信息，所以从F中分解出M1，M2矩阵即可 M1已知，M2未知 得到F关于A、b的表达式 计算A，b，求M2* N视图情况 Bundle Adjustment 代数法与分解法的局限性 最小化重投影误差 MiXj = xij' 即xij（真实值）的测量点 补充知识 PnP问题 原先欧式结构是已知三维点和像素点的对应关系求F→E→RT，而现在是已知摄像机位姿的视图来求新摄像机位姿，","tags":["ComputerVision"],"title":"三维重建之路中","url":"http://localhost:1313/posts/learn/three-d-reconstruction-3/"},{"categories":["learn"],"content":"运动恢复结构SfM系统解析 回顾 本质矩阵与单应矩阵区别 Global Bundle Adjustment P3P 已知内参矩阵，3个像素点坐标及对应三维点坐标，求RT SfM系统问题描述 内参读取exif文件即可 用欧式结构恢复（2视图） 对应点计算--特征提取sift 对应点计算--特征匹配 其中计算出x'y'的128维描述子后，与左图找出的所有描述子计算距离，选出top2的点，再进行求比，防止x'y'与两个点都距离近，从而不好区分该匹配哪个点，所以直接不要。但是会出现特征点匹配错误的问题。 如果图像多、特征数多，用词袋模型，相同的单词就构成一对匹配。对应点计算--特征拟合 RANSAC 减轻特征点匹配的错误 求解步骤结束 对应点求解（SIFT特征提取+近邻匹配） 求解基础矩阵F （RANSAC+归一化八点法） 求解本质矩阵 （下面三步老方法即可） 分解本质矩阵 三角化 基于增量法的SfM系统--OpenMVG（多视图） 预处理 增量法总体步骤 计算轨迹 根据预处理的结果特征提取和特征匹配就可以构建轨迹 计算共视图（连通图） G中选边e 选出初始两张图构建初始三维模型。图中是三维点","date":"2023-05-26T20:09:59+08:00","objectID":"b35f679a7bdf43aa998a3d25b8aac9a0_0","order":0,"summary":"运动恢复结构SfM系统解析 回顾 本质矩阵与单应矩阵区别 Global Bundle Adjustment P3P 已知内参矩阵，3个像素点坐标及对应三维点坐标，求RT SfM系统问题描述 内参读取exif文件即可 用欧式结构恢复（2视图） 对应点计算--特征提取sift 对应点计算--特征匹配 其中计算出x'y'的128维描述子后，与左图找出的所有描述子计算距离，选出top2的点，再进行求比，防止x'y'与两个点都距离近，从而不好区分该匹配哪个点，所以直接不要。但是会出现特征点匹配错误的问题。 如果图像多、特征数多，用词袋模型，相同的单词就构成一对匹配。对应点计算--特征拟合 RANSAC 减轻特征点匹配的错误 求解步骤结束 对应点求解（SIFT特征提取+近邻匹配） 求解基础矩阵F （RANSAC+归一化八点法） 求解本质矩阵 （下面三步老方法即可） 分解本质矩阵 三角化 基于增量法的SfM系统--OpenMVG（多视图） 预处理 增量法总体步骤 计算轨迹 根据预处理的结果特征提取和特征匹配就可以构建轨迹 计算共视图（连通图） G中选边e 选出初始两张图构建初始三维模型。图中是三维点","tags":["ComputerVision"],"title":"三维重建之路下","url":"http://localhost:1313/posts/learn/three-d-reconstruction-2/"},{"categories":["learn"],"content":"在两幅图上的像素点 两视图重构 t是轨迹中大于2的点，e是连通边上两张图所有的匹配点，取交集 增量法 有了连通图，就由处理所有图片变成处理G中的边即可。选取最大化是为了使得P3P结果更加鲁棒，因为新加入的图片与重建完的图片匹配的点最多，通过前两幅图的像素点和三维点来构建新图片的位姿，因为新图片和旧图片的像素点是匹配的（track含义），所以旧图片的像素点和三维点的匹配可以推出新图片也跟该三维点匹配，由此再知道内参矩阵，就可以构建出位姿就是把未构建三维点的像素点拿来三角化（并且是tracks中的点）删边优化结果补充知识 词袋模型 提取特征 数据库所有的图片找到所有sift特征点 聚类 学习视觉词典 考虑的问题：词典大小适中 计算效率：词汇树、AKM 利用视觉词汇出现的频率表达图像 基于词袋模型的图像检索 搜索中使用相似性度量 排除无意义特征：TF-IDF SLAM系统解析 优化问题 生成树 SLAM介绍 Simultaneous Localization and Mapping(SLAM)：Localization：传感器的位置和姿态； Mapping：地图构建 SLAM：同时定位和建图","date":"2023-05-26T20:09:59+08:00","objectID":"b35f679a7bdf43aa998a3d25b8aac9a0_1","order":1,"summary":"在两幅图上的像素点 两视图重构 t是轨迹中大于2的点，e是连通边上两张图所有的匹配点，取交集 增量法 有了连通图，就由处理所有图片变成处理G中的边即可。选取最大化是为了使得P3P结果更加鲁棒，因为新加入的图片与重建完的图片匹配的点最多，通过前两幅图的像素点和三维点来构建新图片的位姿，因为新图片和旧图片的像素点是匹配的（track含义），所以旧图片的像素点和三维点的匹配可以推出新图片也跟该三维点匹配，由此再知道内参矩阵，就可以构建出位姿就是把未构建三维点的像素点拿来三角化（并且是tracks中的点）删边优化结果补充知识 词袋模型 提取特征 数据库所有的图片找到所有sift特征点 聚类 学习视觉词典 考虑的问题：词典大小适中 计算效率：词汇树、AKM 利用视觉词汇出现的频率表达图像 基于词袋模型的图像检索 搜索中使用相似性度量 排除无意义特征：TF-IDF SLAM系统解析 优化问题 生成树 SLAM介绍 Simultaneous Localization and Mapping(SLAM)：Localization：传感器的位置和姿态； Mapping：地图构建 SLAM：同时定位和建图","tags":["ComputerVision"],"title":"三维重建之路下","url":"http://localhost:1313/posts/learn/three-d-reconstruction-2/"},{"categories":["learn"],"content":" 应用场景：定位、导航、避障、重建、交互 SLAM传感器分类：携带于机器人本体上的，例如机器人的轮式编码器、相机、激光等； 安装于环境中的，如导轨、二维码标志等； 按照相机的工作方式，相机可分为：单目（Monocular）、双目（Stereo）和深度相机（RGB-D） 地图： 地图的用处 ORB-SLAM 开源方案 数据结构与数据库 核心数据库内容： 地图点世界坐标系下的3D点坐标； 观测方向，即所有可以观测到该特征点的视图所产生的观测方向均值； 排除离特征点方向过大的视图，提高鲁棒 ORB特征描述子； 该点能被观测到的最大距离与最小距离； 排除离特征点过远过近的视图，提高鲁棒 关键帧摄像机位姿； 内参数； 该帧中提取到的全部ORB特征描述子（近似SIFT），以及它们和地图点之间的对应关系； 没有对应关系的等待下次重建时再填充 共视图（近似OpenMVG连通图）一种有向无权图，节点为关键帧，如两个节点共享的地图点数量大于阈值（至少15个），则存在一条边，边的权重设置为共享地图点的个数。 后续用于bundle adjustment优化 本质图是共视图的子图，保留所有节点，边数量相较于共视","date":"2023-05-26T20:09:59+08:00","objectID":"b35f679a7bdf43aa998a3d25b8aac9a0_2","order":2,"summary":" 应用场景：定位、导航、避障、重建、交互 SLAM传感器分类：携带于机器人本体上的，例如机器人的轮式编码器、相机、激光等； 安装于环境中的，如导轨、二维码标志等； 按照相机的工作方式，相机可分为：单目（Monocular）、双目（Stereo）和深度相机（RGB-D） 地图： 地图的用处 ORB-SLAM 开源方案 数据结构与数据库 核心数据库内容： 地图点世界坐标系下的3D点坐标； 观测方向，即所有可以观测到该特征点的视图所产生的观测方向均值； 排除离特征点方向过大的视图，提高鲁棒 ORB特征描述子； 该点能被观测到的最大距离与最小距离； 排除离特征点过远过近的视图，提高鲁棒 关键帧摄像机位姿； 内参数； 该帧中提取到的全部ORB特征描述子（近似SIFT），以及它们和地图点之间的对应关系； 没有对应关系的等待下次重建时再填充 共视图（近似OpenMVG连通图）一种有向无权图，节点为关键帧，如两个节点共享的地图点数量大于阈值（至少15个），则存在一条边，边的权重设置为共享地图点的个数。 后续用于bundle adjustment优化 本质图是共视图的子图，保留所有节点，边数量相较于共视","tags":["ComputerVision"],"title":"三维重建之路下","url":"http://localhost:1313/posts/learn/three-d-reconstruction-2/"},{"categories":["learn"],"content":"图更少，尽量减少边，其作用是加速回环校正的计算。 本质图=生成树+共视图边权重超过100的边+回环边 回环边：检测中自己生成的边，把视图拉回正常视角的边 生成树：Kruskal算法 系统工作流程 ⭐ 跟踪 核心功能：1. 确定当前帧位姿（RT）；2. 确定其是否将其作为关键帧地图初始化 初始位姿估计 1. 2.2 对于每一个候选参考关键帧： 位姿优化 运用优化问题中的位姿优化公式 关键帧选取 Kref来自于数据集中的某帧 （前一步位姿优化中出现）建图 该线程核心功能：完成局部地图构建关键帧插入 地图点剔除 新地图点生成 局部地图优化 当前帧K1，共视关键帧K2，能看到但没有共视K3 局部关键帧剔除 回环校正 该线程核心功能：修正累计误差 回环候选帧检测 图中的第三步的绿云里红色圈假设就是关键帧，因为在前几帧里也出现了，然后选为候选帧计算Sim3变换 Sim3就是Sij 回环融合 位姿优化 总结 摄像机几何 在针孔摄像机下，建立世界坐标系上的三维点到像平面坐标系上像素点的关系外参矩阵将世界坐标系转换到摄像机坐标系 内参矩阵将摄像机坐标系上的空间点映射到像平面坐标上的像素点 摄像机标定 通","date":"2023-05-26T20:09:59+08:00","objectID":"b35f679a7bdf43aa998a3d25b8aac9a0_3","order":3,"summary":"图更少，尽量减少边，其作用是加速回环校正的计算。 本质图=生成树+共视图边权重超过100的边+回环边 回环边：检测中自己生成的边，把视图拉回正常视角的边 生成树：Kruskal算法 系统工作流程 ⭐ 跟踪 核心功能：1. 确定当前帧位姿（RT）；2. 确定其是否将其作为关键帧地图初始化 初始位姿估计 1. 2.2 对于每一个候选参考关键帧： 位姿优化 运用优化问题中的位姿优化公式 关键帧选取 Kref来自于数据集中的某帧 （前一步位姿优化中出现）建图 该线程核心功能：完成局部地图构建关键帧插入 地图点剔除 新地图点生成 局部地图优化 当前帧K1，共视关键帧K2，能看到但没有共视K3 局部关键帧剔除 回环校正 该线程核心功能：修正累计误差 回环候选帧检测 图中的第三步的绿云里红色圈假设就是关键帧，因为在前几帧里也出现了，然后选为候选帧计算Sim3变换 Sim3就是Sij 回环融合 位姿优化 总结 摄像机几何 在针孔摄像机下，建立世界坐标系上的三维点到像平面坐标系上像素点的关系外参矩阵将世界坐标系转换到摄像机坐标系 内参矩阵将摄像机坐标系上的空间点映射到像平面坐标上的像素点 摄像机标定 通","tags":["ComputerVision"],"title":"三维重建之路下","url":"http://localhost:1313/posts/learn/three-d-reconstruction-2/"},{"categories":["learn"],"content":"过已知二维点、三维点，利用p=MP求解摄像机内外参数矩阵，求出参数矩阵就可以应用摄像机几何 单视图几何 通过影消点和直线方向的关系，影消线和平面法向量的关系，摄像机几何（还是标定？）恢复三维场景结构 求出内参矩阵 利用影消点和直线方向的关系,找到互相垂直的点得到$v_{1}^{T} \\omega v_{2}=0 (\\theta =90^\\circ)$，然后利用$\\omega$获得K矩阵 求出平面法向量 求出K矩阵后利用影消线和平面法向量的关系，求出平面法向量 求出三维场景 已知内参矩阵、平面法向量、利用摄像机几何（还是摄像机标定？）中三维点和像素点的转换关系，求得最终的三维重建，不考虑外参矩阵三维重建基础知识 三角化 已知p, p', K, K', R, T，求三维点线性解法：奇异值分解 非线性解法：牛顿法、L-M方法 极几何 在同一场景下两个视点图像的几何关系：点线关系，点点关系，基础矩阵和极点关系 获得近似基础矩阵：归一化八点法 P3P 基于词袋模型的图像检索 本质矩阵于单应矩阵 Bundle Adjustment 双目立体视觉 利用平行视图获取深度构建双目立体视觉系统将非平行视图","date":"2023-05-26T20:09:59+08:00","objectID":"b35f679a7bdf43aa998a3d25b8aac9a0_4","order":4,"summary":"过已知二维点、三维点，利用p=MP求解摄像机内外参数矩阵，求出参数矩阵就可以应用摄像机几何 单视图几何 通过影消点和直线方向的关系，影消线和平面法向量的关系，摄像机几何（还是标定？）恢复三维场景结构 求出内参矩阵 利用影消点和直线方向的关系,找到互相垂直的点得到$v_{1}^{T} \\omega v_{2}=0 (\\theta =90^\\circ)$，然后利用$\\omega$获得K矩阵 求出平面法向量 求出K矩阵后利用影消线和平面法向量的关系，求出平面法向量 求出三维场景 已知内参矩阵、平面法向量、利用摄像机几何（还是摄像机标定？）中三维点和像素点的转换关系，求得最终的三维重建，不考虑外参矩阵三维重建基础知识 三角化 已知p, p', K, K', R, T，求三维点线性解法：奇异值分解 非线性解法：牛顿法、L-M方法 极几何 在同一场景下两个视点图像的几何关系：点线关系，点点关系，基础矩阵和极点关系 获得近似基础矩阵：归一化八点法 P3P 基于词袋模型的图像检索 本质矩阵于单应矩阵 Bundle Adjustment 双目立体视觉 利用平行视图获取深度构建双目立体视觉系统将非平行视图","tags":["ComputerVision"],"title":"三维重建之路下","url":"http://localhost:1313/posts/learn/three-d-reconstruction-2/"},{"categories":["learn"],"content":"转换为平行视图 平行视图的双目立体视觉 平行视图基础矩阵：$F = \\begin{bmatrix} 0\u00260 \u00260 \\ 0\u00260 \u0026-1 \\ 0\u00261 \u00260 \\end{bmatrix}$ 平行视图的极线平行于u轴，p和p'的v坐标相等，因此沿着扫描线搜索即可 对应点搜索使用归一化相关匹配，再加上一些约束 由此构建点对应关系 通过p'和p坐标，利用平行视图三角化公式$p_{u}-p_{u}^{\\prime}=\\frac{B \\cdot f}{z}$，就可求出深度z 有了深度，就可以形成深度图或者3D电影，构建双目立体视觉系统 多视图几何 通过三维场景的多张二维图像，恢复出该场景的三维结构信息以及每张图片对应的摄像机参数欧式结构恢复 求解步骤：求解基础矩阵F (归一化八点法) 求解本质矩阵 $(E=K_{2}^{T} F K_{1})$ 分解本质矩阵 三角化 （线性法、非线性法） SfM系统 欧式结构运动恢复(两视图) 欧式结构恢复(两视图)求解步骤：对应点求解（SIFT特征提取+近邻匹配） 求解基础矩阵F （RANSAC+归一化八点法） 求解本质矩阵 $E=K_{2}^{T} F K_{1}$","date":"2023-05-26T20:09:59+08:00","objectID":"b35f679a7bdf43aa998a3d25b8aac9a0_5","order":5,"summary":"转换为平行视图 平行视图的双目立体视觉 平行视图基础矩阵：$F = \\begin{bmatrix} 0\u00260 \u00260 \\ 0\u00260 \u0026-1 \\ 0\u00261 \u00260 \\end{bmatrix}$ 平行视图的极线平行于u轴，p和p'的v坐标相等，因此沿着扫描线搜索即可 对应点搜索使用归一化相关匹配，再加上一些约束 由此构建点对应关系 通过p'和p坐标，利用平行视图三角化公式$p_{u}-p_{u}^{\\prime}=\\frac{B \\cdot f}{z}$，就可求出深度z 有了深度，就可以形成深度图或者3D电影，构建双目立体视觉系统 多视图几何 通过三维场景的多张二维图像，恢复出该场景的三维结构信息以及每张图片对应的摄像机参数欧式结构恢复 求解步骤：求解基础矩阵F (归一化八点法) 求解本质矩阵 $(E=K_{2}^{T} F K_{1})$ 分解本质矩阵 三角化 （线性法、非线性法） SfM系统 欧式结构运动恢复(两视图) 欧式结构恢复(两视图)求解步骤：对应点求解（SIFT特征提取+近邻匹配） 求解基础矩阵F （RANSAC+归一化八点法） 求解本质矩阵 $E=K_{2}^{T} F K_{1}$","tags":["ComputerVision"],"title":"三维重建之路下","url":"http://localhost:1313/posts/learn/three-d-reconstruction-2/"},{"categories":["tech"],"content":"安装git和go Installing on Windows git 官方文档 There are also a few ways to install Git on Windows. The most official build is available for download on the Git website. Just go to https://git-scm.com/download/win and the download will start automatically. Note that this is a project called Git for Windows, which is separate from Git itself; for more information on it, go to https://gitforwindows.org. To get an automated installation you can use the Git Chocolatey package. Note that the Chocolatey pack","date":"2023-05-24T21:51:34+08:00","objectID":"6e240eceaf31675b0f21334021bd7702_0","order":0,"summary":"安装git和go Installing on Windows git 官方文档 There are also a few ways to install Git on Windows. The most official build is available for download on the Git website. Just go to https://git-scm.com/download/win and the download will start automatically. Note that this is a project called Git for Windows, which is separate from Git itself; for more information on it, go to https://gitforwindows.org. To get an automated installation you can use the Git Chocolatey package. Note that the Chocolatey pack","tags":["Blog","Hugo"],"title":"hugo主题-meme配置","url":"http://localhost:1313/posts/tech/hugo_theme_meme_configuration/"},{"categories":["tech"],"content":"age is community maintained.Go installation 官方文档 download goOpen the MSI file you downloaded and follow the prompts to install Go.By default, the installer will install Go to Program Files or Program Files (x86). You can change the location as needed. After installing, you will need to close and reopen any open command prompts so that changes to the environment made by the installer are reflected at the command prompt.(安装完成后关闭所有cmd) Verify that you've installed Go. In Windows, click the Start me","date":"2023-05-24T21:51:34+08:00","objectID":"6e240eceaf31675b0f21334021bd7702_1","order":1,"summary":"age is community maintained.Go installation 官方文档 download goOpen the MSI file you downloaded and follow the prompts to install Go.By default, the installer will install Go to Program Files or Program Files (x86). You can change the location as needed. After installing, you will need to close and reopen any open command prompts so that changes to the environment made by the installer are reflected at the command prompt.(安装完成后关闭所有cmd) Verify that you've installed Go. In Windows, click the Start me","tags":["Blog","Hugo"],"title":"hugo主题-meme配置","url":"http://localhost:1313/posts/tech/hugo_theme_meme_configuration/"},{"categories":["learn"],"content":"instant-ngp --scene data/nerf/fox 视频：计算机视觉之三维重建 找到一个同样是这个视频的笔记网址 摄像机几何 针孔模型 \u0026 透镜 针孔摄像机 物体直接映射到胶片上，会导致多个点映射到同一个点上，因此采用针孔成像。如下图，其中x,y,z是世界点Pw在摄像机坐标系上的坐标，已知；f是焦距，已知；由此可求得P'在像平面坐标。 加透镜 可以让上述摄像机保持焦距越小，图像越清晰的情况下，增加亮度。 透镜将所有平行于光轴的光线汇聚到焦点，焦点到透镜中心的距离称为焦距（非上述焦距）。穿过透镜中心的光线的方向不会改变。 产生的问题：失焦，物体“聚焦”有特定距离，一些地方清晰，一些地方模糊 径向畸变 摄像机几何 为了将像平面图像（连续）转到数字图像（离散），使其可被建模。进行一些修正： 前三步是摄像机坐标系下 偏置 单位变换 （下图f=f+z0,简化符号）转化为齐次坐标系 其中M是相机内参，不变矩阵，P是3D点，变化向量，建立了P'到P的线性关系 插曲：将坐标转为线性关系 齐次坐标：EtoH：多加一维，值为1；HtoE：前n-1维除以第n维（E欧氏空间、H齐次空间） （α","date":"2023-03-26T09:07:02.96Z","objectID":"28ba0bac5901645a3fe781303a6e3fc5_0","order":0,"summary":"instant-ngp --scene data/nerf/fox 视频：计算机视觉之三维重建 找到一个同样是这个视频的笔记网址 摄像机几何 针孔模型 \u0026 透镜 针孔摄像机 物体直接映射到胶片上，会导致多个点映射到同一个点上，因此采用针孔成像。如下图，其中x,y,z是世界点Pw在摄像机坐标系上的坐标，已知；f是焦距，已知；由此可求得P'在像平面坐标。 加透镜 可以让上述摄像机保持焦距越小，图像越清晰的情况下，增加亮度。 透镜将所有平行于光轴的光线汇聚到焦点，焦点到透镜中心的距离称为焦距（非上述焦距）。穿过透镜中心的光线的方向不会改变。 产生的问题：失焦，物体“聚焦”有特定距离，一些地方清晰，一些地方模糊 径向畸变 摄像机几何 为了将像平面图像（连续）转到数字图像（离散），使其可被建模。进行一些修正： 前三步是摄像机坐标系下 偏置 单位变换 （下图f=f+z0,简化符号）转化为齐次坐标系 其中M是相机内参，不变矩阵，P是3D点，变化向量，建立了P'到P的线性关系 插曲：将坐标转为线性关系 齐次坐标：EtoH：多加一维，值为1；HtoE：前n-1维除以第n维（E欧氏空间、H齐次空间） （α","tags":["ComputerVision"],"title":"三维重建之路上","url":"http://localhost:1313/archives/three-d-reconstruction-1/"},{"categories":["learn"],"content":"=fk。β=fl） 约定后续Ph写做P，除非特别指明是欧式空间下的P 摄像机偏移 工艺问题，不能垂直，所以需要加偏移系数 自由度：α，β，θ，Cx，Cy 世界坐标系转换到摄像机坐标系 摄像机模型P'=K[R T]Pw RT矩阵具体内容不知道是什么，如有链接欢迎评论，后面的摄像机标定的补充知识有讲物理意义、自由度、欧式空间 自由度：五个内参+6个外参（3个旋转3个平移）= 11个自由度（图中应该是1×4） 齐次空间转换为欧式空间： Fauferas定理 零倾斜就是没有θ 投影变换的性质 其他摄像机模型 规范化摄像机 弱透视投影摄像机 当相对景深小于其与相机的距离时，可以对其进行一些简化，就简单地认为这些点就在一个深度上，直接投影到平面上，适合拍摄中远距离图像 其中f'为焦距，z0是物体到光圈O的距离，xy物体真实位置，x'y'像素面位置。这样子将z0固定为常数，使其为线性变换，而不是非线性变换。 v应该是 1×3 矩阵，Abv是K[R T]之后的结果 正交投影摄像机 当摄像机中心到像平面距离无限远时，直接映射。 总结 正交投影，更多地应用在建筑设计AUTOCAD，或者工业设计行业 弱透视","date":"2023-03-26T09:07:02.96Z","objectID":"28ba0bac5901645a3fe781303a6e3fc5_1","order":1,"summary":"=fk。β=fl） 约定后续Ph写做P，除非特别指明是欧式空间下的P 摄像机偏移 工艺问题，不能垂直，所以需要加偏移系数 自由度：α，β，θ，Cx，Cy 世界坐标系转换到摄像机坐标系 摄像机模型P'=K[R T]Pw RT矩阵具体内容不知道是什么，如有链接欢迎评论，后面的摄像机标定的补充知识有讲物理意义、自由度、欧式空间 自由度：五个内参+6个外参（3个旋转3个平移）= 11个自由度（图中应该是1×4） 齐次空间转换为欧式空间： Fauferas定理 零倾斜就是没有θ 投影变换的性质 其他摄像机模型 规范化摄像机 弱透视投影摄像机 当相对景深小于其与相机的距离时，可以对其进行一些简化，就简单地认为这些点就在一个深度上，直接投影到平面上，适合拍摄中远距离图像 其中f'为焦距，z0是物体到光圈O的距离，xy物体真实位置，x'y'像素面位置。这样子将z0固定为常数，使其为线性变换，而不是非线性变换。 v应该是 1×3 矩阵，Abv是K[R T]之后的结果 正交投影摄像机 当摄像机中心到像平面距离无限远时，直接映射。 总结 正交投影，更多地应用在建筑设计AUTOCAD，或者工业设计行业 弱透视","tags":["ComputerVision"],"title":"三维重建之路上","url":"http://localhost:1313/archives/three-d-reconstruction-1/"},{"categories":["learn"],"content":"投影在数学方面更简单，当物体较小且较远时准确，常用于图像识别任务 透视投影对于3D到2D映射的建模更为准确，用于运动恢复结构或SLAM 参考博客 机器视觉学习（七）摄像机模型 常用相机投影及畸变模型（针孔|广角|鱼眼） 针孔相机成像模型 二维坐标转换与坐标系转换 三维空间中的几何变换-平移旋转缩放 计算机图形学 补充知识 线性方程组的最小二乘解 齐次线性方程组的最小二乘解 只需记住齐次线性用奇异值分解即可，后面经常用 非线性方程组的最小二乘解 只需记住齐次非线性用牛顿、L-M方法即可，后面经常用 摄像机标定 摄像机标定，即已知点坐标求解摄像机内、外参数矩阵，使得二维转三维可行。 更换符号：p=P'（像平面P'变为p） P=Pw（世界坐标Pw变为P）。 标定问题基本思路 超定齐次方程的原因 转换成矩阵形式 利用奇异值分解求超定齐次方程 其中M求解的值是真实世界的值差一个放大系数 提取摄像机系数 详细过程参见：提取摄像机内参数 课堂知识：互相垂直点乘·为0（r1r2r3互相垂直）；r1×r2=r3 （另外图中矩阵大小可能有误） 求u0、v0，放大系数ρ 不知道为什么a有时候转置有时候不转置","date":"2023-03-26T09:07:02.96Z","objectID":"28ba0bac5901645a3fe781303a6e3fc5_2","order":2,"summary":"投影在数学方面更简单，当物体较小且较远时准确，常用于图像识别任务 透视投影对于3D到2D映射的建模更为准确，用于运动恢复结构或SLAM 参考博客 机器视觉学习（七）摄像机模型 常用相机投影及畸变模型（针孔|广角|鱼眼） 针孔相机成像模型 二维坐标转换与坐标系转换 三维空间中的几何变换-平移旋转缩放 计算机图形学 补充知识 线性方程组的最小二乘解 齐次线性方程组的最小二乘解 只需记住齐次线性用奇异值分解即可，后面经常用 非线性方程组的最小二乘解 只需记住齐次非线性用牛顿、L-M方法即可，后面经常用 摄像机标定 摄像机标定，即已知点坐标求解摄像机内、外参数矩阵，使得二维转三维可行。 更换符号：p=P'（像平面P'变为p） P=Pw（世界坐标Pw变为P）。 标定问题基本思路 超定齐次方程的原因 转换成矩阵形式 利用奇异值分解求超定齐次方程 其中M求解的值是真实世界的值差一个放大系数 提取摄像机系数 详细过程参见：提取摄像机内参数 课堂知识：互相垂直点乘·为0（r1r2r3互相垂直）；r1×r2=r3 （另外图中矩阵大小可能有误） 求u0、v0，放大系数ρ 不知道为什么a有时候转置有时候不转置","tags":["ComputerVision"],"title":"三维重建之路上","url":"http://localhost:1313/archives/three-d-reconstruction-1/"},{"categories":["learn"],"content":" u0、v0就是偏置Cx、Cy r1·r3 = 0；r2·r3=0；r3·r3=1，且都互不相关，正交矩阵 （图中是点乘不是叉乘） 求θ 然后左式子点乘 比上 右式子点乘即可出现下图 （具体看视频，虽然讲的也不怎么清楚，参考弹幕或前面的链接） ps. 如果θ=90° 则符合faugeras定理 求α和β 如果α=β，则符合faugeras定理 求外参r1，r2，r3 求外参T K满秩所必可逆 总结 取点不能都位于同一平面，否则三点确定一个平面，多余的点都是没用的 径向畸变的摄像机标定 畸变模型 Sλ就是畸变矩阵 非线性求解 m1m2m3是提取摄像机系数里的投影矩阵的三行 求解线性部分加快迭代 ui÷vi即在原世界坐标下的等比例缩放直线，就那个d2 补充知识 2D平面上的变换 欧式变换 相似变换 仿射变换 透视变换 3D变换 欧式+相似变换 仿射变换 透视变换 单视图几何 用单张图构建三维模型 单视测量 00:17:46 影消点 无穷远点、无穷远线、无穷远面 2D空间 $url?imageMogr2/format/webp|?watermark/3/type/3/text/a2VlcGp","date":"2023-03-26T09:07:02.96Z","objectID":"28ba0bac5901645a3fe781303a6e3fc5_3","order":3,"summary":" u0、v0就是偏置Cx、Cy r1·r3 = 0；r2·r3=0；r3·r3=1，且都互不相关，正交矩阵 （图中是点乘不是叉乘） 求θ 然后左式子点乘 比上 右式子点乘即可出现下图 （具体看视频，虽然讲的也不怎么清楚，参考弹幕或前面的链接） ps. 如果θ=90° 则符合faugeras定理 求α和β 如果α=β，则符合faugeras定理 求外参r1，r2，r3 求外参T K满秩所必可逆 总结 取点不能都位于同一平面，否则三点确定一个平面，多余的点都是没用的 径向畸变的摄像机标定 畸变模型 Sλ就是畸变矩阵 非线性求解 m1m2m3是提取摄像机系数里的投影矩阵的三行 求解线性部分加快迭代 ui÷vi即在原世界坐标下的等比例缩放直线，就那个d2 补充知识 2D平面上的变换 欧式变换 相似变换 仿射变换 透视变换 3D变换 欧式+相似变换 仿射变换 透视变换 单视图几何 用单张图构建三维模型 单视测量 00:17:46 影消点 无穷远点、无穷远线、无穷远面 2D空间 $url?imageMogr2/format/webp|?watermark/3/type/3/text/a2VlcGp","tags":["ComputerVision"],"title":"三维重建之路上","url":"http://localhost:1313/archives/three-d-reconstruction-1/"},{"categories":["learn"],"content":"vbGx5 用l表示一条直线 x是两条直线的交点，x是l和l'的叉乘 2D空间中的无穷远点即当前直线方向的前两行加0即可。[a,b,0] 2D空间中的无穷远直线 3D空间 3D空间的面 3D空间中的直线 为了方便，将其直线定义为直线方向，或者两平面的交线 3D空间中的无穷远点 根据2D中的无穷远点，即在直线方向上（a,b,c）最后一行多加0即可 3D空间中的无穷远平面 无穷远直线即为同个平面上的平行线上的无穷远点集汇聚成无穷远直线；或者是两个平行平面在无穷远处交与一条直线。视频位置33:30. 影消点和影消面 2D平面 无穷远点的变换 只要第三行为0就是无穷远点，透视除非v为0否则就不是。 无穷远线的变换 透视一般不是无穷远线，仿射一般是无穷远线。 因为仿射变换保持平行线不变，而透视变换可能会有在近处有交点而不会在无穷远处相交。 影消点 影消点与直线方向 也可这样理解：K是做仿射变换，所以v=Kd（为什么这里证明的时候不考虑外参矩阵，摄像机坐标系？） 影消线 橙色即影消线 影消线与平面法向量 总结（单视图重构关键） 单视图重构 在假设下，θ已知，α=β，则还剩下Cx，Cy未知，一共三个","date":"2023-03-26T09:07:02.96Z","objectID":"28ba0bac5901645a3fe781303a6e3fc5_4","order":4,"summary":"vbGx5 用l表示一条直线 x是两条直线的交点，x是l和l'的叉乘 2D空间中的无穷远点即当前直线方向的前两行加0即可。[a,b,0] 2D空间中的无穷远直线 3D空间 3D空间的面 3D空间中的直线 为了方便，将其直线定义为直线方向，或者两平面的交线 3D空间中的无穷远点 根据2D中的无穷远点，即在直线方向上（a,b,c）最后一行多加0即可 3D空间中的无穷远平面 无穷远直线即为同个平面上的平行线上的无穷远点集汇聚成无穷远直线；或者是两个平行平面在无穷远处交与一条直线。视频位置33:30. 影消点和影消面 2D平面 无穷远点的变换 只要第三行为0就是无穷远点，透视除非v为0否则就不是。 无穷远线的变换 透视一般不是无穷远线，仿射一般是无穷远线。 因为仿射变换保持平行线不变，而透视变换可能会有在近处有交点而不会在无穷远处相交。 影消点 影消点与直线方向 也可这样理解：K是做仿射变换，所以v=Kd（为什么这里证明的时候不考虑外参矩阵，摄像机坐标系？） 影消线 橙色即影消线 影消线与平面法向量 总结（单视图重构关键） 单视图重构 在假设下，θ已知，α=β，则还剩下Cx，Cy未知，一共三个","tags":["ComputerVision"],"title":"三维重建之路上","url":"http://localhost:1313/archives/three-d-reconstruction-1/"},{"categories":["learn"],"content":"变量未知？，并且v1v2v3互相在三维中是垂直关系，然后三个方程求解。 总结 根据前面的求出摄像机内参矩阵后，就可以根据摄像机几何来获取像素点和三维点的关系，然后根据场景平面方向n来重建三维场景。 缺点是：场景的实际比例无法恢复，需要手动选择影消点与影消线，还需要场景先验信息（点对应关系，线、面几何信息等） 总结 01:16:00.知道法向量和影消线的关系，影消点和直线的方向后，然后通过取三垂直的面来计算摄像机的内参矩阵，在两个假设下成立。然后通过法向量和影消线的关系，已知影消线就可求平面法向量，然后通过p=MP，获得三维点就可以三维重构了吗？期待评论单视图重构详细过程 推荐阅读博客：单视图测量 Harris角点 视频地址 uv与Euv的关系 通过观察uv的变化进而观察E(u, v)的变化，从而发现是不是角点，但是此处不方便，都需要经过I来计算，下面通过泰勒二阶展开，简化运算 泰勒展开 得到M与Euv的关系，进而只需要分析M矩阵 M矩阵对变化程度的关系 R是旋转矩阵使其变为水平椭圆， λ是方向变化剧烈程度，其值越大（λ1，λ2）则变化越快 更进一步转化 总结 Partially inv","date":"2023-03-26T09:07:02.96Z","objectID":"28ba0bac5901645a3fe781303a6e3fc5_5","order":5,"summary":"变量未知？，并且v1v2v3互相在三维中是垂直关系，然后三个方程求解。 总结 根据前面的求出摄像机内参矩阵后，就可以根据摄像机几何来获取像素点和三维点的关系，然后根据场景平面方向n来重建三维场景。 缺点是：场景的实际比例无法恢复，需要手动选择影消点与影消线，还需要场景先验信息（点对应关系，线、面几何信息等） 总结 01:16:00.知道法向量和影消线的关系，影消点和直线的方向后，然后通过取三垂直的面来计算摄像机的内参矩阵，在两个假设下成立。然后通过法向量和影消线的关系，已知影消线就可求平面法向量，然后通过p=MP，获得三维点就可以三维重构了吗？期待评论单视图重构详细过程 推荐阅读博客：单视图测量 Harris角点 视频地址 uv与Euv的关系 通过观察uv的变化进而观察E(u, v)的变化，从而发现是不是角点，但是此处不方便，都需要经过I来计算，下面通过泰勒二阶展开，简化运算 泰勒展开 得到M与Euv的关系，进而只需要分析M矩阵 M矩阵对变化程度的关系 R是旋转矩阵使其变为水平椭圆， λ是方向变化剧烈程度，其值越大（λ1，λ2）则变化越快 更进一步转化 总结 Partially inv","tags":["ComputerVision"],"title":"三维重建之路上","url":"http://localhost:1313/archives/three-d-reconstruction-1/"},{"categories":["learn"],"content":"ariant to affine intensity change Corner location is covariant w.r.t. translation Corner location is covariant w.r.t. rotation Corner location is not covariant to scaling!SIFT特征 Scale selection Spatial selection: the magnitude of the Laplacian response will achieve a maximum at the center of the blob, provided the scale of the Laplacian is “matched” to the scale of the blobThe response of a derivative of Gaussian filter to a perfect step **edge decreases as σ increases ** To keep response the sa","date":"2023-03-26T09:07:02.96Z","objectID":"28ba0bac5901645a3fe781303a6e3fc5_6","order":6,"summary":"ariant to affine intensity change Corner location is covariant w.r.t. translation Corner location is covariant w.r.t. rotation Corner location is not covariant to scaling!SIFT特征 Scale selection Spatial selection: the magnitude of the Laplacian response will achieve a maximum at the center of the blob, provided the scale of the Laplacian is “matched” to the scale of the blobThe response of a derivative of Gaussian filter to a perfect step **edge decreases as σ increases ** To keep response the sa","tags":["ComputerVision"],"title":"三维重建之路上","url":"http://localhost:1313/archives/three-d-reconstruction-1/"},{"categories":["learn"],"content":"me (scale-invariant), must **multiply Gaussian derivative by σ，**固定为1/√2Π Laplacian is the second Gaussian derivative, so it **must be multiplied by σ2 ** Blob detection in 2D 前面听完一遍没听懂，可以去26:30min Characteristic scale 尺度特性 找到对应核后，就可以在图中画出对应圆圈，r=√2Πσ Scale-space blob detector 三个尺度为一组进行判断，只有尺度变化σ最大的那个点并且在333-1个点内是尺度变化σ最大的，才输出圆 SIFT，更高效的做法 原先用拉普拉斯太耗时，图片越大计算量越大 下图听不懂的话继续往后听，在老师问大家的时候 回复3后面的时间讲的很清晰 1:09:20 首先DoG近似于拉普拉斯算子，它利用差分来逼近，所以通过构造DoG减少运算量 为了输出一个尺度空间，需要三个DoG结果，因此图中只能输出两个尺度空间k、k2（有可能会因为nms而减少，暂不","date":"2023-03-26T09:07:02.96Z","objectID":"28ba0bac5901645a3fe781303a6e3fc5_7","order":7,"summary":"me (scale-invariant), must **multiply Gaussian derivative by σ，**固定为1/√2Π Laplacian is the second Gaussian derivative, so it **must be multiplied by σ2 ** Blob detection in 2D 前面听完一遍没听懂，可以去26:30min Characteristic scale 尺度特性 找到对应核后，就可以在图中画出对应圆圈，r=√2Πσ Scale-space blob detector 三个尺度为一组进行判断，只有尺度变化σ最大的那个点并且在333-1个点内是尺度变化σ最大的，才输出圆 SIFT，更高效的做法 原先用拉普拉斯太耗时，图片越大计算量越大 下图听不懂的话继续往后听，在老师问大家的时候 回复3后面的时间讲的很清晰 1:09:20 首先DoG近似于拉普拉斯算子，它利用差分来逼近，所以通过构造DoG减少运算量 为了输出一个尺度空间，需要三个DoG结果，因此图中只能输出两个尺度空间k、k2（有可能会因为nms而减少，暂不","tags":["ComputerVision"],"title":"三维重建之路上","url":"http://localhost:1313/archives/three-d-reconstruction-1/"},{"categories":["learn"],"content":"source insightC++ 概括 C++优点强大的封装能力：既有开发工程能力，又保留高性能 高性能：运行快，快并且占用资源少是C++的追求 低功耗：适合嵌入式 C++缺点：语法复杂，细节多 需要好的规范和范式 C++ 基础语法 编程语言层次 机器语言，汇编语言 编译型语言 C++，C 解释型语言 Basic Python Java 脚本语言 bash csh 逐级运行效率低，更易理解 数据类型 疑问，为什么64位三个字节对齐常量 定义常量的方法：#define： #define PI 3.14159 #define MA(x) x*(x-1) MA(1 + (a + b)) = 1+(a+b)*(1+(a+b)-1) const：const double PI = 3.14159 （推荐） 整数常量前缀：0x 十六进制、0 八进制、0b整数常量后缀：u(unsigned)、l(long)、可组合使用，大小写任意字符常量：单引号括起来，用L（必须大写）表示宽字符常量运算符与表达式 关系运算符 A == B 其值为bool类型 而直接判断为1为int类型，注意空间大小杂项运算符 ，","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_0","order":0,"summary":"source insightC++ 概括 C++优点强大的封装能力：既有开发工程能力，又保留高性能 高性能：运行快，快并且占用资源少是C++的追求 低功耗：适合嵌入式 C++缺点：语法复杂，细节多 需要好的规范和范式 C++ 基础语法 编程语言层次 机器语言，汇编语言 编译型语言 C++，C 解释型语言 Basic Python Java 脚本语言 bash csh 逐级运行效率低，更易理解 数据类型 疑问，为什么64位三个字节对齐常量 定义常量的方法：#define： #define PI 3.14159 #define MA(x) x*(x-1) MA(1 + (a + b)) = 1+(a+b)*(1+(a+b)-1) const：const double PI = 3.14159 （推荐） 整数常量前缀：0x 十六进制、0 八进制、0b整数常量后缀：u(unsigned)、l(long)、可组合使用，大小写任意字符常量：单引号括起来，用L（必须大写）表示宽字符常量运算符与表达式 关系运算符 A == B 其值为bool类型 而直接判断为1为int类型，注意空间大小杂项运算符 ，","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"：顺序执行一系列运算后，取最后一个表达式的值（int o = a,b,c）补码 正数原补反码一致负数反码是原码除符号位取反，补码=反码+1，反码=补码-1 二进制to补码：$B 2 T_{w}(\\vec{x}) \\stackrel{.}{=} x_{w-1} 2^{w-1}+\\sum_{i=0}^{w-2} x_{i} 2^{i}$ 一文搞清二进制补码字节序 一个字在内存中如何以byte存放大端法：大多数IBM机器、网络传输，正序存放 8f ff ff ff 小端法：Intel兼容机，逆序存放，但字节内正序 ff ff ff 8f 位运算 C陷阱和C++改进 char语法陷阱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u003e void main() { char c1 = 'yes'; // 截断：1.保留第一个字符 2.保留第二个字符 std::cout \u0026lt;\u0026lt; c1 \u0026lt;\u0026lt; std::endl; // char* 32bi机器占4位，64占8位，为了搜索整个地址空间 const char* s1 = ","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_1","order":1,"summary":"：顺序执行一系列运算后，取最后一个表达式的值（int o = a,b,c）补码 正数原补反码一致负数反码是原码除符号位取反，补码=反码+1，反码=补码-1 二进制to补码：$B 2 T_{w}(\\vec{x}) \\stackrel{.}{=} x_{w-1} 2^{w-1}+\\sum_{i=0}^{w-2} x_{i} 2^{i}$ 一文搞清二进制补码字节序 一个字在内存中如何以byte存放大端法：大多数IBM机器、网络传输，正序存放 8f ff ff ff 小端法：Intel兼容机，逆序存放，但字节内正序 ff ff ff 8f 位运算 C陷阱和C++改进 char语法陷阱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u003e void main() { char c1 = 'yes'; // 截断：1.保留第一个字符 2.保留第二个字符 std::cout \u0026lt;\u0026lt; c1 \u0026lt;\u0026lt; std::endl; // char* 32bi机器占4位，64占8位，为了搜索整个地址空间 const char* s1 = ","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"\"/\"; // ==\u003e '/''\\0' // const char* s2 = '/'; 字符常量-\u003echar* 类型不匹配 const char* s2 = \u0026c1; // C++ 改进， string 在namespace std中 std::string s1(3, 'yes'); // s std::string s2(\"yes\"); // yes } 数组退化陷阱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u003e #include \u0026lt;vector\u003e // double average1(int arr[10], int len) { double average1(int* arr, int len) { // C：数组退化成指针 // 传递char数组可以通过计算到'\\0'的长度来不借助len ","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_2","order":2,"summary":"\"/\"; // ==\u003e '/''\\0' // const char* s2 = '/'; 字符常量-\u003echar* 类型不匹配 const char* s2 = \u0026c1; // C++ 改进， string 在namespace std中 std::string s1(3, 'yes'); // s std::string s2(\"yes\"); // yes } 数组退化陷阱 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u003e #include \u0026lt;vector\u003e // double average1(int arr[10], int len) { double average1(int* arr, int len) { // C：数组退化成指针 // 传递char数组可以通过计算到'\\0'的长度来不借助len ","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"double result = 0; // 形参arr[10]变为int指针,arr[0]为int类型 =\u003e len = 4/4 = 1 // int len = sizeof(arr) / sizeof(arr[0]); for (int i = 0; i \u0026lt; len; i++){ result += arr[i]; } return result / len; } // C++ 改进 double average3(std::vector\u0026lt;int\u003e \u0026v) { double result = 0; std::vector\u0026lt;int\u003e::iterator it = v.begin(); // auto it = v.begin(); for (; it != v.end(); ++it){ result += *it; } return result / v.size(); } double average2DV(std::vector\u0026lt;std::vector\u0026lt;int\u003e\u003e\u0026 vv) { double result = 0.0; unsigned int s","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_3","order":3,"summary":"double result = 0; // 形参arr[10]变为int指针,arr[0]为int类型 =\u003e len = 4/4 = 1 // int len = sizeof(arr) / sizeof(arr[0]); for (int i = 0; i \u0026lt; len; i++){ result += arr[i]; } return result / len; } // C++ 改进 double average3(std::vector\u0026lt;int\u003e \u0026v) { double result = 0; std::vector\u0026lt;int\u003e::iterator it = v.begin(); // auto it = v.begin(); for (; it != v.end(); ++it){ result += *it; } return result / v.size(); } double average2DV(std::vector\u0026lt;std::vector\u0026lt;int\u003e\u003e\u0026 vv) { double result = 0.0; unsigned int s","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"ize = 0; for (unsigned int i = 0; i \u0026lt; vv.size(); ++i) { for (unsigned int j = 0; j \u0026lt; vv[i].size(); ++j) { result += vv[i][j]; size += 1; std::cout \u0026lt;\u0026lt; (vv[i][j])+\" \"; // +' '自动变为int } std::cout \u0026lt;\u0026lt; std::endl; } return result / size; } void main() { int arr[10] = { 10, 20, 30, 40,50 }; int len = sizeof(arr) / sizeof(arr[0]); // std::cout \u0026lt;\u0026lt; average1(arr, len) \u0026lt;\u0026lt; std::endl; std::vector\u0026lt;int\u003e vt{ 12,3,4,5,6,5 }; std::cout \u0026lt;\u0026lt; average3(vt) \u0026lt;\u0026lt; std::endl; std::","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_4","order":4,"summary":"ize = 0; for (unsigned int i = 0; i \u0026lt; vv.size(); ++i) { for (unsigned int j = 0; j \u0026lt; vv[i].size(); ++j) { result += vv[i][j]; size += 1; std::cout \u0026lt;\u0026lt; (vv[i][j])+\" \"; // +' '自动变为int } std::cout \u0026lt;\u0026lt; std::endl; } return result / size; } void main() { int arr[10] = { 10, 20, 30, 40,50 }; int len = sizeof(arr) / sizeof(arr[0]); // std::cout \u0026lt;\u0026lt; average1(arr, len) \u0026lt;\u0026lt; std::endl; std::vector\u0026lt;int\u003e vt{ 12,3,4,5,6,5 }; std::cout \u0026lt;\u0026lt; average3(vt) \u0026lt;\u0026lt; std::endl; std::","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"vector\u0026lt; std::vector\u0026lt;int\u003e\u003e vv{8,std::vector\u0026lt;int\u003e(12, 3) }; std::cout \u0026lt;\u0026lt; average2DV(vv); } 移位问题 问题：逻辑右移还是算数右移 -\u003e 右移只对无符号数移位操作位数的限制 -\u003e 移位数大于0， 小于位数C中需要考虑整数移位上下文情况（有无符号数，类型占字节数） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u003e #include \u0026lt;bitset\u003e using namespace std; int main() { char a1 = 0x63; // 0110 0011 a1 = (a1 \u003e\u003e 4); // 0000 0110 逻辑右移 printf(\"0x%x\\n\", a1); char a2 = 0x95; // 1001 0101 a2 = (a2 \u003e\u003e 4); // 1111 1001 算法右移 prin","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_5","order":5,"summary":"vector\u0026lt; std::vector\u0026lt;int\u003e\u003e vv{8,std::vector\u0026lt;int\u003e(12, 3) }; std::cout \u0026lt;\u0026lt; average2DV(vv); } 移位问题 问题：逻辑右移还是算数右移 -\u003e 右移只对无符号数移位操作位数的限制 -\u003e 移位数大于0， 小于位数C中需要考虑整数移位上下文情况（有无符号数，类型占字节数） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u003e #include \u0026lt;bitset\u003e using namespace std; int main() { char a1 = 0x63; // 0110 0011 a1 = (a1 \u003e\u003e 4); // 0000 0110 逻辑右移 printf(\"0x%x\\n\", a1); char a2 = 0x95; // 1001 0101 a2 = (a2 \u003e\u003e 4); // 1111 1001 算法右移 prin","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"tf(\"0x%x\\n\", a2); unsigned char a3 = 0x95; // 1001 0101 C建议先转无符号再右移 a3 = (a3 \u003e\u003e 4);\t// 0000 1001 逻辑右移 printf(\"0x%x\\n\", a3); //const unsigned char priv = 0xff; //const unsigned char P_BACKUP = (1 \u0026lt;\u0026lt; 7); //const unsigned char P_ADMIN = (1 \u0026lt;\u0026lt; 8); // 超过char位数-\u003e =0 //// 判断用户权限的技巧 //if (priv \u0026 P_BACKUP) cout \u0026lt;\u0026lt; \"BACKUP\" \u0026lt;\u0026lt; endl; // C++ 改进 bitset\u0026lt;10\u003e priv = 0xff; bitset\u0026lt;10\u003e P_BACKUP = (1 \u0026lt;\u0026lt; 6); bitset\u0026lt;10\u003e P_ADMIN = (1 \u0026lt;\u0026lt; 7); // 超过char位数-\u003e =0 // 判断用户权限的技巧 if ","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_6","order":6,"summary":"tf(\"0x%x\\n\", a2); unsigned char a3 = 0x95; // 1001 0101 C建议先转无符号再右移 a3 = (a3 \u003e\u003e 4);\t// 0000 1001 逻辑右移 printf(\"0x%x\\n\", a3); //const unsigned char priv = 0xff; //const unsigned char P_BACKUP = (1 \u0026lt;\u0026lt; 7); //const unsigned char P_ADMIN = (1 \u0026lt;\u0026lt; 8); // 超过char位数-\u003e =0 //// 判断用户权限的技巧 //if (priv \u0026 P_BACKUP) cout \u0026lt;\u0026lt; \"BACKUP\" \u0026lt;\u0026lt; endl; // C++ 改进 bitset\u0026lt;10\u003e priv = 0xff; bitset\u0026lt;10\u003e P_BACKUP = (1 \u0026lt;\u0026lt; 6); bitset\u0026lt;10\u003e P_ADMIN = (1 \u0026lt;\u0026lt; 7); // 超过char位数-\u003e =0 // 判断用户权限的技巧 if ","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"((priv \u0026 P_BACKUP) == P_BACKUP) cout \u0026lt;\u0026lt; \"BACKUP\" \u0026lt;\u0026lt; endl; } 类型转换问题 C缺陷：隐式转换问题（sizeof(unsigned long long) 跟int比较，int转换为unsigned int）、double除法问题C++改进：static_cast、const_cast、dynamic_cast、reinterpret_cast，建议尽量少使用转换，多长啊溢出问题 C整数固定为int所占字节，溢出会有问题C++：使用boost库的cpp_int字符串问题 C 以'\\0'结尾，遇到即停止，忽视其后面的值，运行效率低，只能以'\\0'表示字符串结束C++：string库（仍保留'\\0'）、redis库（用多个结构体优化存储空间，并用len防止'\\0'问题）字符串比较 \u003e\u0026lt; 比较的是首地址大小头文件顺序 系统的头文件要放在最前面； 其次是语言相关的； 然后比较古老的第三方库头文件； 比较新的第三方库头文件； 最后才是自定义的头文件。 基础容器 数组（差一错误） off-by-one error ","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_7","order":7,"summary":"((priv \u0026 P_BACKUP) == P_BACKUP) cout \u0026lt;\u0026lt; \"BACKUP\" \u0026lt;\u0026lt; endl; } 类型转换问题 C缺陷：隐式转换问题（sizeof(unsigned long long) 跟int比较，int转换为unsigned int）、double除法问题C++改进：static_cast、const_cast、dynamic_cast、reinterpret_cast，建议尽量少使用转换，多长啊溢出问题 C整数固定为int所占字节，溢出会有问题C++：使用boost库的cpp_int字符串问题 C 以'\\0'结尾，遇到即停止，忽视其后面的值，运行效率低，只能以'\\0'表示字符串结束C++：string库（仍保留'\\0'）、redis库（用多个结构体优化存储空间，并用len防止'\\0'问题）字符串比较 \u003e\u0026lt; 比较的是首地址大小头文件顺序 系统的头文件要放在最前面； 其次是语言相关的； 然后比较古老的第三方库头文件； 比较新的第三方库头文件； 最后才是自定义的头文件。 基础容器 数组（差一错误） off-by-one error ","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"解决思路：先考虑简单特例，然后外推结果；仔细计算边界 判断范围时采取左闭右开，使其相减为元素个数 for (int i =0; i\u0026lt;10; i++) 数组的下标访问和指针访问方式效率分析二维数组访问时的原则：尽可能满足空间局部性在一个小的时间窗口内，访问的变量地址越接近越好，执行速度越快 一般将最长的循环放最内层，最短的放最外层，以减少CPU跨切循环层的次数 vector 字符串 表示Unicode字符集：UTF-8：1byte表示字符，兼容ASCII码；特点是存储效率高，变长（不方便内部随机访问），无字节序问题（作为外部编码，供其他平台使用Linux） 微软平台下又细分为UTF-8-BOM，二进制首位为EF BB BF，可能在其他平台有问题，可以删去首位来适配 UTF-16：分为UTF-16BD(big endian)、UTF-16LD(little endian)；特点是定长（方便内部随机访问），有字节序问题。 BD文件的二进制首位为FE FF、LD为FF FE（正序） UTF-32：分为UTF-32BD、UTF-32LD；特点同上 字符串的指针表示方法char[] 和 ch","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_8","order":8,"summary":"解决思路：先考虑简单特例，然后外推结果；仔细计算边界 判断范围时采取左闭右开，使其相减为元素个数 for (int i =0; i\u0026lt;10; i++) 数组的下标访问和指针访问方式效率分析二维数组访问时的原则：尽可能满足空间局部性在一个小的时间窗口内，访问的变量地址越接近越好，执行速度越快 一般将最长的循环放最内层，最短的放最外层，以减少CPU跨切循环层的次数 vector 字符串 表示Unicode字符集：UTF-8：1byte表示字符，兼容ASCII码；特点是存储效率高，变长（不方便内部随机访问），无字节序问题（作为外部编码，供其他平台使用Linux） 微软平台下又细分为UTF-8-BOM，二进制首位为EF BB BF，可能在其他平台有问题，可以删去首位来适配 UTF-16：分为UTF-16BD(big endian)、UTF-16LD(little endian)；特点是定长（方便内部随机访问），有字节序问题。 BD文件的二进制首位为FE FF、LD为FF FE（正序） UTF-32：分为UTF-32BD、UTF-32LD；特点同上 字符串的指针表示方法char[] 和 ch","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"ar*的区别： char[] 地址不可变 其内的值可变 char* 地址可变，其内的值取决于所指存储区域是否可变 常用函数安全问题 strlen、strcpy等没有对边界检查容易导致缓冲区溢出，修改一些值 修改为strlen_s、strcpy_s等函数 调试时加入_CRT_SECURE_NO_WARNINGS String 和 char* char* / char[] ：strcpy_s 拷贝 strlen 字符串长度 strcat 拼接 strcmp 比较ASCII码 String：= str.size() \\ str.length() += == str.capacity() 容量，自动扩容 相比来说String 性能不是特别好C++指针 指针占用空间由操作系统位数决定，因为要指向所有地址左值与右值 左值为编译器为其单独分配一块存储空间，可以取其地址。可以放在任意侧赋值运算符函数或数据成员的名字 右值为数据本身，不能取其地址。只能放在赋值运算符右侧。没有标识符(变量名)，不可以\u0026取地址的表达式，一般称为“临时对象”。 指针分类 数组指针 array of pointers：int*","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_9","order":9,"summary":"ar*的区别： char[] 地址不可变 其内的值可变 char* 地址可变，其内的值取决于所指存储区域是否可变 常用函数安全问题 strlen、strcpy等没有对边界检查容易导致缓冲区溢出，修改一些值 修改为strlen_s、strcpy_s等函数 调试时加入_CRT_SECURE_NO_WARNINGS String 和 char* char* / char[] ：strcpy_s 拷贝 strlen 字符串长度 strcat 拼接 strcmp 比较ASCII码 String：= str.size() \\ str.length() += == str.capacity() 容量，自动扩容 相比来说String 性能不是特别好C++指针 指针占用空间由操作系统位数决定，因为要指向所有地址左值与右值 左值为编译器为其单独分配一块存储空间，可以取其地址。可以放在任意侧赋值运算符函数或数据成员的名字 右值为数据本身，不能取其地址。只能放在赋值运算符右侧。没有标识符(变量名)，不可以\u0026取地址的表达式，一般称为“临时对象”。 指针分类 数组指针 array of pointers：int*","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":" a[4]，包含四个指针的a数组 输出结果：*(a[3]) a pointer to an array：int (*a)[4]，指向一个包含四个值的数组，其中4要与数组个数匹配 输出结果：(*a)[3] -\u003e array[3] \u0026lt;=\u003e *(array+3) \u0026lt;=\u003e array[3] 同样的 int *a = array 输出结果：*(a+3) const指针 const修饰的部分为不可修改内容，其修饰的部分看左侧最近的部分，如果左侧没有，则看右侧1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \"stdafx.h\" #include \u0026lt;iostream\u003e using namespace std; unsigned int MAX_LEN = 11; int main() { char strHelloworld[] = { \"helloworld\" }; // 与strHelloWorld变量共享内存 char const * pStr1 = \"","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_10","order":10,"summary":" a[4]，包含四个指针的a数组 输出结果：*(a[3]) a pointer to an array：int (*a)[4]，指向一个包含四个值的数组，其中4要与数组个数匹配 输出结果：(*a)[3] -\u003e array[3] \u0026lt;=\u003e *(array+3) \u0026lt;=\u003e array[3] 同样的 int *a = array 输出结果：*(a+3) const指针 const修饰的部分为不可修改内容，其修饰的部分看左侧最近的部分，如果左侧没有，则看右侧1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include \"stdafx.h\" #include \u0026lt;iostream\u003e using namespace std; unsigned int MAX_LEN = 11; int main() { char strHelloworld[] = { \"helloworld\" }; // 与strHelloWorld变量共享内存 char const * pStr1 = \"","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"helloworld\"; // const char* 不能修改指向的char内容 // 导致此处赋值后使得pStr1指向的空间可被修改，不能只读 char* const pStr2 = strHelloworld;\t// 不能修改指针值 char const* const pStr3 = \"helloworld\"; // const char* const 不能修改内容和指针 pStr1 = strHelloworld; //pStr2 = strHelloworld; // pStr2不可改 //pStr3 = strHelloworld; // pStr3不可改 unsigned int len = strnlen_s(pStr2, MAX_LEN); cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; for (unsigned int index = 0; index \u0026lt; len; ++index) { //pStr1[index] += 1; // pStr1里的值不可改 pStr2[index] += 1; //pStr3[index] += 1; /","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_11","order":11,"summary":"helloworld\"; // const char* 不能修改指向的char内容 // 导致此处赋值后使得pStr1指向的空间可被修改，不能只读 char* const pStr2 = strHelloworld;\t// 不能修改指针值 char const* const pStr3 = \"helloworld\"; // const char* const 不能修改内容和指针 pStr1 = strHelloworld; //pStr2 = strHelloworld; // pStr2不可改 //pStr3 = strHelloworld; // pStr3不可改 unsigned int len = strnlen_s(pStr2, MAX_LEN); cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; for (unsigned int index = 0; index \u0026lt; len; ++index) { //pStr1[index] += 1; // pStr1里的值不可改 pStr2[index] += 1; //pStr3[index] += 1; /","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"/ pStr3里的值不可改 } return 0; } 多级指针 1 2 3 4 5 int a = 12; int* b = \u0026a; int** c = \u0026b; // *有从右向左的结合性，不清楚优先级就用括号 *(*c) = *(b) = a = 12 野指针 未初始化的指针可能导致无法定位错误 用指针进行间接访问时，确保访问的值已被初始化赋值 NULL指针初始化指针，使其无地址 对指针进行间接引用时，最好判断指针是否NULL 不用，没有初始化，超出范围时，使其NULL 野指针分类指针变量没有初始化 已经释放不用的指针没有置NULL 指针操作超越了变量的作用范围，指向不确定的空间 指针基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 char ch = 'a'; char* cp = \u0026ch; // ++,--操作符 char* cp2 = ++cp; char* cp3 = cp++; char* cp4 = --cp; char* cp5 = cp--; // ++ 左值 //++cp2 = ","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_12","order":12,"summary":"/ pStr3里的值不可改 } return 0; } 多级指针 1 2 3 4 5 int a = 12; int* b = \u0026a; int** c = \u0026b; // *有从右向左的结合性，不清楚优先级就用括号 *(*c) = *(b) = a = 12 野指针 未初始化的指针可能导致无法定位错误 用指针进行间接访问时，确保访问的值已被初始化赋值 NULL指针初始化指针，使其无地址 对指针进行间接引用时，最好判断指针是否NULL 不用，没有初始化，超出范围时，使其NULL 野指针分类指针变量没有初始化 已经释放不用的指针没有置NULL 指针操作超越了变量的作用范围，指向不确定的空间 指针基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 char ch = 'a'; char* cp = \u0026ch; // ++,--操作符 char* cp2 = ++cp; char* cp3 = cp++; char* cp4 = --cp; char* cp5 = cp--; // ++ 左值 //++cp2 = ","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"97; //cp2++ = 97; // *++, ++* *++cp2 = 98; // cp2地址加1后赋值 char ch3 = *++cp2; // cp2地址加1后将引用的值给左值 *cp2++ = 98; // 将cp2指向的空间赋值后地址加1 char ch4 = *cp2++; // 将cp引用的值给左值后地址加1 // ++++, ----操作符等 int a = 1, b = 2, c, d; //c = a++b; // error c = a++ + b; // 贪心法 //d = a++++b; // error char ch5 = ++*++cp; // 1.先cp地址+1, 2.得到其引用的值, 3.值+1, 4.赋给左值 delete and delete[]、删除指针后并不会置为nullptr 对于像 int/char/long/int*/struct 等等简单数据类型，由于对象没有 destructor，所以用 delete 和 delete [] 是一样的！但是如果是C++ 对象数组就不同了！内存分配 stack：由程序分配地址 heap：由程序","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_13","order":13,"summary":"97; //cp2++ = 97; // *++, ++* *++cp2 = 98; // cp2地址加1后赋值 char ch3 = *++cp2; // cp2地址加1后将引用的值给左值 *cp2++ = 98; // 将cp2指向的空间赋值后地址加1 char ch4 = *cp2++; // 将cp引用的值给左值后地址加1 // ++++, ----操作符等 int a = 1, b = 2, c, d; //c = a++b; // error c = a++ + b; // 贪心法 //d = a++++b; // error char ch5 = ++*++cp; // 1.先cp地址+1, 2.得到其引用的值, 3.值+1, 4.赋给左值 delete and delete[]、删除指针后并不会置为nullptr 对于像 int/char/long/int*/struct 等等简单数据类型，由于对象没有 destructor，所以用 delete 和 delete [] 是一样的！但是如果是C++ 对象数组就不同了！内存分配 stack：由程序分配地址 heap：由程序","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"员分配地址 new/delete heap和bss之间是常量区 bss：未初始化区 gvap：初始化区 text：代码、函数。。。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;string\u003e int a = 0; // (GVAR)全局初始化区 int* p1; // (bss)全局未初始化区 int main() // (text)代码区 { int b=1; // (stack)栈区变量 32位/64位地址递减/递增 栈区初始化值cc char s[] = \"abc\"; // (stack)栈区变量 int*p2=NULL; // (stack)栈区变量 char *p3 = \"123456\"; // 123456\\0在常量区, p3在(stack)栈区 static int c = 0; // (GVAR)全局(静态)初始化区 p1 = new int(10); // (heap)堆区变量 32位/64位地址递增 堆区初始化值cd p2 = new int(20); // (heap)堆区变量 char* p4 =","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_14","order":14,"summary":"员分配地址 new/delete heap和bss之间是常量区 bss：未初始化区 gvap：初始化区 text：代码、函数。。。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;string\u003e int a = 0; // (GVAR)全局初始化区 int* p1; // (bss)全局未初始化区 int main() // (text)代码区 { int b=1; // (stack)栈区变量 32位/64位地址递减/递增 栈区初始化值cc char s[] = \"abc\"; // (stack)栈区变量 int*p2=NULL; // (stack)栈区变量 char *p3 = \"123456\"; // 123456\\0在常量区, p3在(stack)栈区 static int c = 0; // (GVAR)全局(静态)初始化区 p1 = new int(10); // (heap)堆区变量 32位/64位地址递增 堆区初始化值cd p2 = new int(20); // (heap)堆区变量 char* p4 =","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":" new char[7]; // (heap)堆区变量 strcpy_s(p4, 7, \"123456\"); // (text)代码区 return 0; // (text)代码区 } C++智能指针 auto_ptr:C++17 废弃 会自动删除指针以及指向的对象，会产生所有权转移现象 unique_ptr:专属所有权，unique_ptr管理的内存，只能被一个指针持有，不支持复制 该指针禁止复制，因此用是std::move()语句进行所有权转移 离开作用域后，自动释放指针和数据 share_ptr / weak_ptr：通过一个引用计数共享对象，当计数位0时，调用析构函数 会带来额外的存储开 销 weak_ptr用于防止循环引用 引用 一个特殊的指针，可以看作是变量的别名，但会同时修改变量的值，且不可更换指针对象有了指针为什么还要引用？为了支持函数运算符重载有了引用为什么还用指针？为了兼容C函数传参说明：对内置基础类型（如int，double）而言，函数传递时pass by value更高效，直接传值而不是指针/引用 对面向对象中的自定义类型而言，传递时pass by refere","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_15","order":15,"summary":" new char[7]; // (heap)堆区变量 strcpy_s(p4, 7, \"123456\"); // (text)代码区 return 0; // (text)代码区 } C++智能指针 auto_ptr:C++17 废弃 会自动删除指针以及指向的对象，会产生所有权转移现象 unique_ptr:专属所有权，unique_ptr管理的内存，只能被一个指针持有，不支持复制 该指针禁止复制，因此用是std::move()语句进行所有权转移 离开作用域后，自动释放指针和数据 share_ptr / weak_ptr：通过一个引用计数共享对象，当计数位0时，调用析构函数 会带来额外的存储开 销 weak_ptr用于防止循环引用 引用 一个特殊的指针，可以看作是变量的别名，但会同时修改变量的值，且不可更换指针对象有了指针为什么还要引用？为了支持函数运算符重载有了引用为什么还用指针？为了兼容C函数传参说明：对内置基础类型（如int，double）而言，函数传递时pass by value更高效，直接传值而不是指针/引用 对面向对象中的自定义类型而言，传递时pass by refere","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"nce to const更高效，因为防止传递大数据而使用地址占用空间更小，const为了防止无意的修改 C++基础语法 if if将命中率高（更容易判true/false）的条件放首位，使得判断条件更快与switch比较使用场景：switch只支持常量值固定相等的分支判断 if可以判断区间 switch是if的特集 性能比较：分支较少时，差别不大；分支多时，switch更快，因为是汇编是查表的形式 if多分支的开始几个分支效果高，之后效率递减；因为汇编下需要不断判断再跳转 switch所有case速度几乎一样，查表形式 枚举 枚举值不可以做左值 非枚举变量不可以赋值给枚举变量，除非强转；枚举可以赋值给非枚举 Union / Struct 共用体所有变量占用最大空间的变量的存储空间 大字节最后赋值会覆盖小字节内容 赋值从内存最右边赋值 缺省对齐原则char 任何地址 short 偶数地址 int 4的整数倍地址 double 8的整数倍地址 32位内存里一行四字节，变量占用空间不足会扩充到最大占用空间变量 32位，char+int=8；8+double=16 32位，char[5]+in","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_16","order":16,"summary":"nce to const更高效，因为防止传递大数据而使用地址占用空间更小，const为了防止无意的修改 C++基础语法 if if将命中率高（更容易判true/false）的条件放首位，使得判断条件更快与switch比较使用场景：switch只支持常量值固定相等的分支判断 if可以判断区间 switch是if的特集 性能比较：分支较少时，差别不大；分支多时，switch更快，因为是汇编是查表的形式 if多分支的开始几个分支效果高，之后效率递减；因为汇编下需要不断判断再跳转 switch所有case速度几乎一样，查表形式 枚举 枚举值不可以做左值 非枚举变量不可以赋值给枚举变量，除非强转；枚举可以赋值给非枚举 Union / Struct 共用体所有变量占用最大空间的变量的存储空间 大字节最后赋值会覆盖小字节内容 赋值从内存最右边赋值 缺省对齐原则char 任何地址 short 偶数地址 int 4的整数倍地址 double 8的整数倍地址 32位内存里一行四字节，变量占用空间不足会扩充到最大占用空间变量 32位，char+int=8；8+double=16 32位，char[5]+in","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["learn"],"content":"t = 16；16+double=24 修改默认编译选项： visual C++：#pragma pack(n) g++：attribute(aligned(n))、attribute(packed) 循环 do while更快 while 次之 for最慢，但实际开发不重视速度的话，无所谓函数重载 看debug运行过程 看反汇编的地址 找到debug/.obj文件，搜搜函数名，复制【?函数名@@xx】，搜索【undname】，cmd命令 【undname 复制值】 用函数指针来确定某个函数：一般形式：数据类型(*指针变量名)(参数表) bool ProcessNum(int i, int j, int(*p)(int a, int b)) // 回调函数 命名空间 namespace 空间名{ ... }注意使用using namespace std，会引入所有空间内方法，可能会导致方法名冲突建议引入特定空间内方法名，using namespace std::cout; 或直接指定该方法是该空间内，std::cout \u0026lt;\u0026lt; 函数体heck过程 函数调用方式：_cdecl(","date":"2023-03-26T09:06:56.507Z","objectID":"73bb10e51b7f067e544d9c61522cce91_17","order":17,"summary":"t = 16；16+double=24 修改默认编译选项： visual C++：#pragma pack(n) g++：attribute(aligned(n))、attribute(packed) 循环 do while更快 while 次之 for最慢，但实际开发不重视速度的话，无所谓函数重载 看debug运行过程 看反汇编的地址 找到debug/.obj文件，搜搜函数名，复制【?函数名@@xx】，搜索【undname】，cmd命令 【undname 复制值】 用函数指针来确定某个函数：一般形式：数据类型(*指针变量名)(参数表) bool ProcessNum(int i, int j, int(*p)(int a, int b)) // 回调函数 命名空间 namespace 空间名{ ... }注意使用using namespace std，会引入所有空间内方法，可能会导致方法名冲突建议引入特定空间内方法名，using namespace std::cout; 或直接指定该方法是该空间内，std::cout \u0026lt;\u0026lt; 函数体heck过程 函数调用方式：_cdecl(","tags":["C++"],"title":"C++学习","url":"http://localhost:1313/archives/cplusplus-learn/"},{"categories":["error"],"content":"持续更新中imshow：qt.qpa.plugin: could not find the Qt platform plugin \"xcb\" in \"\" 这个问题在我用python创建的虚拟环境后碰到，无法找到解决办法，只能用conda创建虚拟环境，然后opencv可以显示图片了pip install -i https://pypi.doubanio.com/simple/ --trusted-host pypi.doubanio.com xxx-package-name 更新：卸载重置qt即可Linux pycharm opencv不显示代码提示 参考：链接 Linux中anaconda地址是：anaconda3安装路径/envs/虚拟环境名/lib/python版本号/site-packages/cv2!ssize.empty() in function resize 顾名思义，某个地方调用opencv库的resize时，传入空值，导致该错误，仔细检查传入值的数据是否为0或者None即可。 但是给的错误信息有点误导意思，因为我用的是另一个版本的opencv，还以为是版本不一致导致的","date":"2023-03-11T20:27:34.663Z","objectID":"9fa14f9f230daec8541f980a478e376d_0","order":0,"summary":"持续更新中imshow：qt.qpa.plugin: could not find the Qt platform plugin \"xcb\" in \"\" 这个问题在我用python创建的虚拟环境后碰到，无法找到解决办法，只能用conda创建虚拟环境，然后opencv可以显示图片了pip install -i https://pypi.doubanio.com/simple/ --trusted-host pypi.doubanio.com xxx-package-name 更新：卸载重置qt即可Linux pycharm opencv不显示代码提示 参考：链接 Linux中anaconda地址是：anaconda3安装路径/envs/虚拟环境名/lib/python版本号/site-packages/cv2!ssize.empty() in function resize 顾名思义，某个地方调用opencv库的resize时，传入空值，导致该错误，仔细检查传入值的数据是否为0或者None即可。 但是给的错误信息有点误导意思，因为我用的是另一个版本的opencv，还以为是版本不一致导致的","tags":["Python","Collection"],"title":"Python编程 遇到的问题","url":"http://localhost:1313/archives/python-problem/"},{"categories":["error"],"content":"错误。如下，提示的是OpenCV3.4.15版本 ImportError: No module named tensorflow 如果你是在jupyter notebook中出现这个错误。先看你是否安装了tensorflow 其次看你是否安装了jupyter notebook。 我用conda管理环境的时候 运行的环境里没有jupyter notebook 他估计自动调用了全局的notebook ，但是全局没有tensorflow，然后就报错了。","date":"2023-03-11T20:27:34.663Z","objectID":"9fa14f9f230daec8541f980a478e376d_1","order":1,"summary":"错误。如下，提示的是OpenCV3.4.15版本 ImportError: No module named tensorflow 如果你是在jupyter notebook中出现这个错误。先看你是否安装了tensorflow 其次看你是否安装了jupyter notebook。 我用conda管理环境的时候 运行的环境里没有jupyter notebook 他估计自动调用了全局的notebook ，但是全局没有tensorflow，然后就报错了。","tags":["Python","Collection"],"title":"Python编程 遇到的问题","url":"http://localhost:1313/archives/python-problem/"},{"categories":["other"],"content":"因为后续转三维重建了，所以只能写到一半了，如有需要可以找我要源文件参考论文： Object Detection in 20 Years: A Survey总言 因为不是大神，所以都是摘自网络文章，如有错误欢迎评论目标检测 传统目标检测 Viola Jones Detector 论文：Rapid Object Detection using a Boosted Cascade of Simple Features 2001年提出，基于滑动窗口的目标检测算法，通过积分图像来加速对Haar-like特征的计算，使用如下方法来加速网络计算以及提高准确率。网络架构/使用方法 Integral image：解析 Feature selection：使用Adaboost对候选特征筛选，找到最有代表性的一小组特征 Detection cascades 优缺点 优点：具有里程碑的意义 缺点：使用的Harr-like特征较简单，稳定性较低 弱分类器采用简单的决策树，容易过拟合，对人脸的遮挡、光暗等因素处理效果不理想 鲁棒性较差 参考博客：目标检测之 Viola-Jones、viola jones人脸检测原","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_0","order":0,"summary":"因为后续转三维重建了，所以只能写到一半了，如有需要可以找我要源文件参考论文： Object Detection in 20 Years: A Survey总言 因为不是大神，所以都是摘自网络文章，如有错误欢迎评论目标检测 传统目标检测 Viola Jones Detector 论文：Rapid Object Detection using a Boosted Cascade of Simple Features 2001年提出，基于滑动窗口的目标检测算法，通过积分图像来加速对Haar-like特征的计算，使用如下方法来加速网络计算以及提高准确率。网络架构/使用方法 Integral image：解析 Feature selection：使用Adaboost对候选特征筛选，找到最有代表性的一小组特征 Detection cascades 优缺点 优点：具有里程碑的意义 缺点：使用的Harr-like特征较简单，稳定性较低 弱分类器采用简单的决策树，容易过拟合，对人脸的遮挡、光暗等因素处理效果不理想 鲁棒性较差 参考博客：目标检测之 Viola-Jones、viola jones人脸检测原","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"理HOG Detector 论文：Histograms of Oriented Gradients for Human Detection HOG（Histogram of Oriented Gridients的简写）特征检测算法，最早是由法国研究员Dalal等在CVPR-2005上提出来的，一种解决人体目标检测的图像描述子，是一种用于表征图像局部梯度方向和梯度强度分布特性的描述符。其主要思想是：在边缘具体位置未知的情况下，边缘方向的分布也可以很好的表示行人目标的外形轮廓。网络架构/使用方法 灰度化、颜色空间归一化：Gamma校正 计算图像中每个像素的梯度值和梯度方向 将图像划分成多个pixel×pixel cells，并计算每个cell的梯度直方图，即为描述子(descriptor) 梯度直方图的x为梯度方向的映射，y为梯度值的累加 将num个cells归一化后合并成一个block，最后会形成多个带重叠部分的block。每个block内为cells内的向量concat 最后将所有block的向量再次串联，即HOG特征 示例： 图像大小为：64×128, block大小为16×16， ","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_1","order":1,"summary":"理HOG Detector 论文：Histograms of Oriented Gradients for Human Detection HOG（Histogram of Oriented Gridients的简写）特征检测算法，最早是由法国研究员Dalal等在CVPR-2005上提出来的，一种解决人体目标检测的图像描述子，是一种用于表征图像局部梯度方向和梯度强度分布特性的描述符。其主要思想是：在边缘具体位置未知的情况下，边缘方向的分布也可以很好的表示行人目标的外形轮廓。网络架构/使用方法 灰度化、颜色空间归一化：Gamma校正 计算图像中每个像素的梯度值和梯度方向 将图像划分成多个pixel×pixel cells，并计算每个cell的梯度直方图，即为描述子(descriptor) 梯度直方图的x为梯度方向的映射，y为梯度值的累加 将num个cells归一化后合并成一个block，最后会形成多个带重叠部分的block。每个block内为cells内的向量concat 最后将所有block的向量再次串联，即HOG特征 示例： 图像大小为：64×128, block大小为16×16， ","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"block stride为8×8，cell size为8×8，bins=9（直方图等级数）；块个数为：((64-16)/8+1) × ((128-16)/8 +1) = 105 其中重叠部分就是因为16 \u003e 8 (64-16)/8 计算除第一个block后还可以走多少步，然后加上第一次不动的次数+1 每个块内cell个数； (16×16)/(8×8)=4 每张图特征维度：105×4×9=3780 获取到每张图的特征维度后，再用线性SVM训练分类器即可。优缺点 优点：使用contrast-normalize the local response来使得局部几何和光学形变具有不变性 容许行人有细微肢体动作，适合人体检测 分块分单元的方法，使得图像局部像素点之间的关系得到很好地表征 缺点特征维度大，实时性差 很难处理遮挡问题 对噪点敏感 参考博客：【特征检测】HOG特征算法、目标检测HOG特征解读、HOG 特征提取算法（实践篇）、HOG特征Deformable Part-based Model(DPM) 论文：Discriminatively trained deformable part m","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_2","order":2,"summary":"block stride为8×8，cell size为8×8，bins=9（直方图等级数）；块个数为：((64-16)/8+1) × ((128-16)/8 +1) = 105 其中重叠部分就是因为16 \u003e 8 (64-16)/8 计算除第一个block后还可以走多少步，然后加上第一次不动的次数+1 每个块内cell个数； (16×16)/(8×8)=4 每张图特征维度：105×4×9=3780 获取到每张图的特征维度后，再用线性SVM训练分类器即可。优缺点 优点：使用contrast-normalize the local response来使得局部几何和光学形变具有不变性 容许行人有细微肢体动作，适合人体检测 分块分单元的方法，使得图像局部像素点之间的关系得到很好地表征 缺点特征维度大，实时性差 很难处理遮挡问题 对噪点敏感 参考博客：【特征检测】HOG特征算法、目标检测HOG特征解读、HOG 特征提取算法（实践篇）、HOG特征Deformable Part-based Model(DPM) 论文：Discriminatively trained deformable part m","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"odels 由P. Felzenszwalb在2008提出，作为HOG的扩展版。DPM的设计理念是“divide and conquer”，训练时分解对象，推理时组合不同部件。DPM的本质就是弹簧形变模型。DPM算法采用了改进后的HOG特征，SVM分类器和滑动窗口（Sliding Windows）检测思想，针对目标的多视角问题，采用了多组件（Component）的策略，针对目标本身的形变问题，采用了基于图结构（Pictorial Structure）的部件模型策略。此外，将样本的所属的模型类别，部件模型的位置等作为潜变量（Latent Variable），采用多示例学习（Multiple-instance Learning）来自动确定。网络架构/使用方法 经典DPM由一个root-filter和多个part-filter组成。 LatentSVM：使得不用标出part框 使用硬负样本挖掘：解决样本不平衡问题 边界框回归 context priming：利用局部信息 混合模型：学习多个模型来适应物体不同形变 图像金字塔：适应形变 优缺点 优点运算速度快，适应物体形变，方法直观简单 Alt","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_3","order":3,"summary":"odels 由P. Felzenszwalb在2008提出，作为HOG的扩展版。DPM的设计理念是“divide and conquer”，训练时分解对象，推理时组合不同部件。DPM的本质就是弹簧形变模型。DPM算法采用了改进后的HOG特征，SVM分类器和滑动窗口（Sliding Windows）检测思想，针对目标的多视角问题，采用了多组件（Component）的策略，针对目标本身的形变问题，采用了基于图结构（Pictorial Structure）的部件模型策略。此外，将样本的所属的模型类别，部件模型的位置等作为潜变量（Latent Variable），采用多示例学习（Multiple-instance Learning）来自动确定。网络架构/使用方法 经典DPM由一个root-filter和多个part-filter组成。 LatentSVM：使得不用标出part框 使用硬负样本挖掘：解决样本不平衡问题 边界框回归 context priming：利用局部信息 混合模型：学习多个模型来适应物体不同形变 图像金字塔：适应形变 优缺点 优点运算速度快，适应物体形变，方法直观简单 Alt","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"hough today's object detectors have far surpassed DPM in terms of the detection accuracy, many of them are still deeply influenced by its valuable insights 缺点性能一般 无法适应大幅度旋转以及当图像中目标像素远小于root filter时无法检测 解惑 DPM首先采用的是HOG进行特征的提取，但是又有别于HOG，DPM中，只保留了HOG中的Cell。如上图所示，假设，一个88的Cell，将该细胞单元与其对角线临域的4个细胞单元做归一化操作。 提取有符号的HOG梯度，0-360度将产生18个梯度向量，提取无符号的HOG梯度，0-180度将产生9个梯度向量。因此，一个88的细胞单元将会产生，（18+9）4=108 （其中的4是4个相对邻域，这里看的时候没看懂），维度有点高，Felzenszwalb大神给出了其优化思想。 首先，只提取无符号的HOG梯度，将会产生49=36维特征，将其看成一个4*9的矩阵，分别将行和列分别相加，最终将生成4","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_4","order":4,"summary":"hough today's object detectors have far surpassed DPM in terms of the detection accuracy, many of them are still deeply influenced by its valuable insights 缺点性能一般 无法适应大幅度旋转以及当图像中目标像素远小于root filter时无法检测 解惑 DPM首先采用的是HOG进行特征的提取，但是又有别于HOG，DPM中，只保留了HOG中的Cell。如上图所示，假设，一个88的Cell，将该细胞单元与其对角线临域的4个细胞单元做归一化操作。 提取有符号的HOG梯度，0-360度将产生18个梯度向量，提取无符号的HOG梯度，0-180度将产生9个梯度向量。因此，一个88的细胞单元将会产生，（18+9）4=108 （其中的4是4个相对邻域，这里看的时候没看懂），维度有点高，Felzenszwalb大神给出了其优化思想。 首先，只提取无符号的HOG梯度，将会产生49=36维特征，将其看成一个4*9的矩阵，分别将行和列分别相加，最终将生成4","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"+9=13个特征向量，为了进一步提高精度，将提取的18维有符号的梯度特征也加进来，这样，一共产生13+18=31维梯度特征（另一个解释）。实现了很好的目标检测。参考博客：DPM（Deformable Part Model）原理详解、DPM(Deformable Parts Model)--原理(一)、DPM目标检测算法(毕业论文节选)、多个博客的组合体、什么是latent SVM？、DPM模型、传统目标检测算法之DPM总结 基于手工提取特征的传统目标检测算法主要有以下三个缺点：识别效果不够好，准确率不高 计算量较大，运算速度慢 可能产生多个正确识别的结果 深度学习检测 two-stage detection 总结性博客：RCNN系列总结、目标检测：R-CNN、SPP,Fast R-CNN、Faster R-CNN、Faster RCNN系列算法原理、目标检测-RCNN系列、小哲AI专栏文章分类索引 咱也不知道RCNN家族有多少，这里只好列举了RCNN→SPPnet→Fast RCNN→Faster RCNN→FPN→MaskRCNN→Cascade RCNN 另外二阶段检测所包含的这些","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_5","order":5,"summary":"+9=13个特征向量，为了进一步提高精度，将提取的18维有符号的梯度特征也加进来，这样，一共产生13+18=31维梯度特征（另一个解释）。实现了很好的目标检测。参考博客：DPM（Deformable Part Model）原理详解、DPM(Deformable Parts Model)--原理(一)、DPM目标检测算法(毕业论文节选)、多个博客的组合体、什么是latent SVM？、DPM模型、传统目标检测算法之DPM总结 基于手工提取特征的传统目标检测算法主要有以下三个缺点：识别效果不够好，准确率不高 计算量较大，运算速度慢 可能产生多个正确识别的结果 深度学习检测 two-stage detection 总结性博客：RCNN系列总结、目标检测：R-CNN、SPP,Fast R-CNN、Faster R-CNN、Faster RCNN系列算法原理、目标检测-RCNN系列、小哲AI专栏文章分类索引 咱也不知道RCNN家族有多少，这里只好列举了RCNN→SPPnet→Fast RCNN→Faster RCNN→FPN→MaskRCNN→Cascade RCNN 另外二阶段检测所包含的这些","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"网络如有误，欢迎评论 二阶段：1，先产生高质量框，2. 对框进行微调 coarse to fine 一阶段：一步到位RCNN（提出数据稀少的解决方案） 论文：Rich feature hierarchies for accurate object detection and semantic segmentation 最近几年，物体检测陷入停滞，表现最好的检测系统是复杂的将多低层级的图像特征与高层级的物体检测器环境与场景识别相结合。我们取得这个性能主要通过两个方面：第一是应用了自底向上的候选框训练的高容量的卷积神经网络进行定位和分割物体。另外一个是使用在标签数据匮乏的情况下训练大规模神经网络的一个方法。网络架构/使用方法 目标检测： 产生候选区域：Selective Search 选出2k个候选区域 对每个候选区域进行特征提取：CNN → 2000×4096 dim特征向量 候选区域类别判断：SVM 4096×N（20类别+1背景）+NMS 使用回归对其候选框调整：regression Selective Search → CNN→ SVM→ regression 分析网络采用Hoie","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_6","order":6,"summary":"网络如有误，欢迎评论 二阶段：1，先产生高质量框，2. 对框进行微调 coarse to fine 一阶段：一步到位RCNN（提出数据稀少的解决方案） 论文：Rich feature hierarchies for accurate object detection and semantic segmentation 最近几年，物体检测陷入停滞，表现最好的检测系统是复杂的将多低层级的图像特征与高层级的物体检测器环境与场景识别相结合。我们取得这个性能主要通过两个方面：第一是应用了自底向上的候选框训练的高容量的卷积神经网络进行定位和分割物体。另外一个是使用在标签数据匮乏的情况下训练大规模神经网络的一个方法。网络架构/使用方法 目标检测： 产生候选区域：Selective Search 选出2k个候选区域 对每个候选区域进行特征提取：CNN → 2000×4096 dim特征向量 候选区域类别判断：SVM 4096×N（20类别+1背景）+NMS 使用回归对其候选框调整：regression Selective Search → CNN→ SVM→ regression 分析网络采用Hoie","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"m等人的定位分析工具：Diagnosing error in object detectors，看到进化版分析工具：A General Toolbox for Identifying Object Detection Errors优缺点 优点：使用CNN来提取特征，减少人工操作 使用迁移学习来提高性能 当带标签的训练数据不足时，先针对辅助数据集进行有监督方式的预训练，再进行特定小数据集的调优，就可以产生明显的性能提升。（迁移学习） 缺点：速度慢，存在大量重复计算 训练步骤繁琐 参考博客：R-CNN论文详解（论文翻译）、RCNN 论文阅读记录 还介绍了一些方法SPPnet 论文：Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition 普遍的CNN需要固定输入图片大小，原因是卷积层后的全连接层需要固定长度的输入。SPP是Bag-of-words模型的扩展，是视觉最成功的方法之一。它将图像划分为从精细到粗糙空间，并聚合其中的局部特征。网络架构/使用方法 网络架构： 目标检测 提取2000个候选","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_7","order":7,"summary":"m等人的定位分析工具：Diagnosing error in object detectors，看到进化版分析工具：A General Toolbox for Identifying Object Detection Errors优缺点 优点：使用CNN来提取特征，减少人工操作 使用迁移学习来提高性能 当带标签的训练数据不足时，先针对辅助数据集进行有监督方式的预训练，再进行特定小数据集的调优，就可以产生明显的性能提升。（迁移学习） 缺点：速度慢，存在大量重复计算 训练步骤繁琐 参考博客：R-CNN论文详解（论文翻译）、RCNN 论文阅读记录 还介绍了一些方法SPPnet 论文：Spatial Pyramid Pooling in Deep Convolutional Networks for Visual Recognition 普遍的CNN需要固定输入图片大小，原因是卷积层后的全连接层需要固定长度的输入。SPP是Bag-of-words模型的扩展，是视觉最成功的方法之一。它将图像划分为从精细到粗糙空间，并聚合其中的局部特征。网络架构/使用方法 网络架构： 目标检测 提取2000个候选","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"框 对整张图片通过CNN进行特征提取 将候选框映射到最终的feature maps上，进行空间金字塔池化，得到固定长度的特征向量 SVM分类器来检测 优缺点 优点：输入任意大小的图片，防止剪裁、放缩降低精度 （优化RCNN） 使用CNN共享参数后，映射候选框加速计算（优化RCNN） 可应用在许多网络上 multi-scale feature extraction 可以提高精度 缺点：同R-CNN一样分开训练CNN和SVM、BB回归器，训练SVM的特征需要提前保存在磁盘需要巨大的存储空间；多段训练实现较复杂 CNN和SVM的训练独立导致SVM的训练Loss无法更新SPP-Layer之前的卷积层参数，因此即使采用更深的CNN网络进行特征提取，也无法保证SVMs分类器的准确率一定能够提升 (1)spp layer有multi-scale的pooling，正向还好，反向传播开销大。 (2)sppnet后，fast-rcnn的roi pooling 本质上就是一层的spp pooling, 这篇paper表明, 运算成本更低的 roi pooling(即 single-scale spp)并不比","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_8","order":8,"summary":"框 对整张图片通过CNN进行特征提取 将候选框映射到最终的feature maps上，进行空间金字塔池化，得到固定长度的特征向量 SVM分类器来检测 优缺点 优点：输入任意大小的图片，防止剪裁、放缩降低精度 （优化RCNN） 使用CNN共享参数后，映射候选框加速计算（优化RCNN） 可应用在许多网络上 multi-scale feature extraction 可以提高精度 缺点：同R-CNN一样分开训练CNN和SVM、BB回归器，训练SVM的特征需要提前保存在磁盘需要巨大的存储空间；多段训练实现较复杂 CNN和SVM的训练独立导致SVM的训练Loss无法更新SPP-Layer之前的卷积层参数，因此即使采用更深的CNN网络进行特征提取，也无法保证SVMs分类器的准确率一定能够提升 (1)spp layer有multi-scale的pooling，正向还好，反向传播开销大。 (2)sppnet后，fast-rcnn的roi pooling 本质上就是一层的spp pooling, 这篇paper表明, 运算成本更低的 roi pooling(即 single-scale spp)并不比","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"运算开销更大的multi-scale的spp 要差。这里的一层spp 池化指的应该是只有一层池化而不是像金字塔一样有多层池化。 (3)粘自 评论 参考博客：SPP优缺点、空间金字塔池化网络SPPNet详解、RCNN学习笔记(3)、ROI详解（英文原版）Fast-RCNN 论文：Fast R-CNN网络架构/使用方法 网络结构： 目标检测：产生候选区域：同RCNN一致 提取整张图片的特征生成特征图，并将候选区域映射到特征图上：同SPPnet一致 候选区域分类+BBox回归：对每个候选区域使用ROI Pooling，然后进行softmax分类+回归 优缺点 优点：加入多任务损失，使得模型由多阶段转为单阶段，实现端到端（除SS Region Proposal阶段）（创新点） 删除SVM后，可以一次更新所有层的参数，并且不需要存储到硬盘 （优化SPPnet） 缺点：使用的selective search只能在CPU上跑，速度慢 一些结论 多任务比多阶段训练好 发现SPPnet的多尺度训练并不比单尺度训练好，因为尺度不变性，所以使用ROI 池化 训练数据当然越多越好 softmax比SVM略好 ","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_9","order":9,"summary":"运算开销更大的multi-scale的spp 要差。这里的一层spp 池化指的应该是只有一层池化而不是像金字塔一样有多层池化。 (3)粘自 评论 参考博客：SPP优缺点、空间金字塔池化网络SPPNet详解、RCNN学习笔记(3)、ROI详解（英文原版）Fast-RCNN 论文：Fast R-CNN网络架构/使用方法 网络结构： 目标检测：产生候选区域：同RCNN一致 提取整张图片的特征生成特征图，并将候选区域映射到特征图上：同SPPnet一致 候选区域分类+BBox回归：对每个候选区域使用ROI Pooling，然后进行softmax分类+回归 优缺点 优点：加入多任务损失，使得模型由多阶段转为单阶段，实现端到端（除SS Region Proposal阶段）（创新点） 删除SVM后，可以一次更新所有层的参数，并且不需要存储到硬盘 （优化SPPnet） 缺点：使用的selective search只能在CPU上跑，速度慢 一些结论 多任务比多阶段训练好 发现SPPnet的多尺度训练并不比单尺度训练好，因为尺度不变性，所以使用ROI 池化 训练数据当然越多越好 softmax比SVM略好 ","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"候选框越多，mAP呈现先声后降的趋势 参考博客：物体检测之Fast R-CNN、RCNN 系列详解、目标检测算法之Fast R-CNN算法详解Faster-RCNN 论文：Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks网络架构/使用方法 网络结构： 特征提取：全卷积层 候选框生成+候选框调整：RPN网络 生成固定长度向量：Roi 池化 分类+微调：softamx+回归 优缺点 优点：端到端网络（改进Fast） 使用RPN替代选择性搜索，提高速度（改进Fast） 共享RPN和Fast R-CNN特征（改进Fast） RCNN集大成之作（改进Fast） 缺点：步骤繁琐、速度慢 重叠特征容易漏检（NMS的原因） 重新审视Faster RCNN：优缺点与改进 参考博客：一文读懂Faster RCNN（完善）、Faster R-CNN：详解目标检测的实现过程FPN+Faster RCNN 论文：Feature Pyramid Networks for Object Detection 融","date":"2023-03-11T20:25:51.917Z","objectID":"ff7cece43833fd3c349f3bcf44844b49_10","order":10,"summary":"候选框越多，mAP呈现先声后降的趋势 参考博客：物体检测之Fast R-CNN、RCNN 系列详解、目标检测算法之Fast R-CNN算法详解Faster-RCNN 论文：Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Networks网络架构/使用方法 网络结构： 特征提取：全卷积层 候选框生成+候选框调整：RPN网络 生成固定长度向量：Roi 池化 分类+微调：softamx+回归 优缺点 优点：端到端网络（改进Fast） 使用RPN替代选择性搜索，提高速度（改进Fast） 共享RPN和Fast R-CNN特征（改进Fast） RCNN集大成之作（改进Fast） 缺点：步骤繁琐、速度慢 重叠特征容易漏检（NMS的原因） 重新审视Faster RCNN：优缺点与改进 参考博客：一文读懂Faster RCNN（完善）、Faster R-CNN：详解目标检测的实现过程FPN+Faster RCNN 论文：Feature Pyramid Networks for Object Detection 融","tags":["ComputerVision"],"title":"小目标检测综述-半成品","url":"http://localhost:1313/archives/small-target-detection/"},{"categories":["other"],"content":"半路转C++了，所以没学完Java，相对来说，韩顺平这个Java视频讲的很详细，如果时间充裕可以看看。初阶知识 变量 加法运算 浮点数/byte/布尔值 浮点数 = 符号位 +指数位 +尾数位 浮点数默认为double类型，float n1 = 1.1+anything 报错boolean变量只能为true/false 给byte赋常数时，先判断该值是否在byte范围(-128~127)内，所以不会出现赋值为int类型 自动类型转换 进行赋值或运算时，小精度类型自动转化为大精度类型 char/(byte → short) → int → long → float → double byte/char/short 同类型计算或它们之间计算都会自动转成int类型 强制转换 (int)(long/float值)运算符 算数运算符运算 a % b = a - a / b * b 所以当b为负数反而为正，ab全为负数则为负 1 2 3 int i = 1; i = i++; // temp = i; i = i+1; i = temp; System.out.println(i); // i=1","date":"2023-03-11T20:23:47.173Z","objectID":"dc92fdb7514ecbc10fd0bed1accacd69_0","order":0,"summary":"半路转C++了，所以没学完Java，相对来说，韩顺平这个Java视频讲的很详细，如果时间充裕可以看看。初阶知识 变量 加法运算 浮点数/byte/布尔值 浮点数 = 符号位 +指数位 +尾数位 浮点数默认为double类型，float n1 = 1.1+anything 报错boolean变量只能为true/false 给byte赋常数时，先判断该值是否在byte范围(-128~127)内，所以不会出现赋值为int类型 自动类型转换 进行赋值或运算时，小精度类型自动转化为大精度类型 char/(byte → short) → int → long → float → double byte/char/short 同类型计算或它们之间计算都会自动转成int类型 强制转换 (int)(long/float值)运算符 算数运算符运算 a % b = a - a / b * b 所以当b为负数反而为正，ab全为负数则为负 1 2 3 int i = 1; i = i++; // temp = i; i = i+1; i = temp; System.out.println(i); // i=1","tags":["Java"],"title":"Java 学习 半成品","url":"http://localhost:1313/archives/java-study/"},{"categories":["other"],"content":" 复合赋值运算符会自动类型转换(包括++，--) b += 2; -\u003e b = (type)b + 2; 逻辑运算符 \u0026 和 | 用在检查特等奖和一等奖之间取最好的那个进制 整数有四种进制：二进制：以0b或0B开头 十进制 八进制：以0开头 十六进制：以0x或0X开头 二进制转八进制：从低位开始，二进制数每三位($2^{3}=8$)一组，换算成对应八进制数 二进制转十六进制：从低位开始，二进制数每四位一组，换算成对应八进制数 反之，则将八(十六)进制数每位转成对应**三(四)**位二进制数即可位运算 原码，反码，补码：正数三码合一 负数的反码 = 原码符号位不变，其他位取反 负数的反码 = 补码 - 1；补码 = 反码 + 1 0的反码、补码都是0 计算机以补码进行运算，Java的数都是有符号 运算结果用原码 二进制最高位为符号位：0正1负，位数取决于int大小 位运算符：算数右移\u003e\u003e：低位溢出，符号位不变，高位补符号位 \u0026lt;=\u003e b/2 算数左移\u0026lt;\u0026lt;：符号位不变，低位补0 \u0026lt;=\u003e b*2 逻辑右移\u003e\u003e\u003e：低位溢出，高位补0 低位溢出指的是删除最右边移动的数个；高","date":"2023-03-11T20:23:47.173Z","objectID":"dc92fdb7514ecbc10fd0bed1accacd69_1","order":1,"summary":" 复合赋值运算符会自动类型转换(包括++，--) b += 2; -\u003e b = (type)b + 2; 逻辑运算符 \u0026 和 | 用在检查特等奖和一等奖之间取最好的那个进制 整数有四种进制：二进制：以0b或0B开头 十进制 八进制：以0开头 十六进制：以0x或0X开头 二进制转八进制：从低位开始，二进制数每三位($2^{3}=8$)一组，换算成对应八进制数 二进制转十六进制：从低位开始，二进制数每四位一组，换算成对应八进制数 反之，则将八(十六)进制数每位转成对应**三(四)**位二进制数即可位运算 原码，反码，补码：正数三码合一 负数的反码 = 原码符号位不变，其他位取反 负数的反码 = 补码 - 1；补码 = 反码 + 1 0的反码、补码都是0 计算机以补码进行运算，Java的数都是有符号 运算结果用原码 二进制最高位为符号位：0正1负，位数取决于int大小 位运算符：算数右移\u003e\u003e：低位溢出，符号位不变，高位补符号位 \u0026lt;=\u003e b/2 算数左移\u0026lt;\u0026lt;：符号位不变，低位补0 \u0026lt;=\u003e b*2 逻辑右移\u003e\u003e\u003e：低位溢出，高位补0 低位溢出指的是删除最右边移动的数个；高","tags":["Java"],"title":"Java 学习 半成品","url":"http://localhost:1313/archives/java-study/"},{"categories":["other"],"content":"位补数指的是将数个加到最左边，整体右移 1000 0000 0000 0110 \u003e\u003e\u003e2：0010 0000 0000 00**01 ** 1 2 3 4 5 6 7 8 9 // -2原 10000000 00000000 00000000 00000010 // -2反 11111111 11111111 11111111 11111101 // -2补 11111111 11111111 11111111 11111110 // -2移 00111111 11111111 11111111 11111111 // -2反 11111111 11111111 11111111 11111011 // -2原 10000000 00000000 00000000 00000100 int a = 0b00111111111111111111111111111111; System.out.println(a); System.out.print(-2\u003e\u003e\u003e2); 控制结构 switch中表达式的返回值必须是：byte, short, int, char, enum, String b","date":"2023-03-11T20:23:47.173Z","objectID":"dc92fdb7514ecbc10fd0bed1accacd69_2","order":2,"summary":"位补数指的是将数个加到最左边，整体右移 1000 0000 0000 0110 \u003e\u003e\u003e2：0010 0000 0000 00**01 ** 1 2 3 4 5 6 7 8 9 // -2原 10000000 00000000 00000000 00000010 // -2反 11111111 11111111 11111111 11111101 // -2补 11111111 11111111 11111111 11111110 // -2移 00111111 11111111 11111111 11111111 // -2反 11111111 11111111 11111111 11111011 // -2原 10000000 00000000 00000000 00000100 int a = 0b00111111111111111111111111111111; System.out.println(a); System.out.print(-2\u003e\u003e\u003e2); 控制结构 switch中表达式的返回值必须是：byte, short, int, char, enum, String b","tags":["Java"],"title":"Java 学习 半成品","url":"http://localhost:1313/archives/java-study/"},{"categories":["other"],"content":"reak/continue 可以通过标签指明终止/跳过哪一层语句块（不建议使用） \"lucky\".equals(type) // 避免空指针 数组/排序/查找 二维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 动态创建数组 public static void main(String[] args){ int [][] arr = new int[3][]; // 确定一维数组个数 for (int i = 0; i \u0026lt; arr.length; ++i){ arr[i] = new int[i+1]; // 第i排上开辟空间 } } // 双下标经典用法 int insert_num = 15; for (int i = 0, j = 0; i\u0026lt;arrNew.length; ++i){ if (insert_num \u0026lt; arr[j]){ ++j; arrNew[i] = arr[j]; else arrNew[i] = insert_num; } 对象 对象内存布局 加载cat类信息从第一句代码就执行 Java内存的结构分析 栈：","date":"2023-03-11T20:23:47.173Z","objectID":"dc92fdb7514ecbc10fd0bed1accacd69_3","order":3,"summary":"reak/continue 可以通过标签指明终止/跳过哪一层语句块（不建议使用） \"lucky\".equals(type) // 避免空指针 数组/排序/查找 二维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 动态创建数组 public static void main(String[] args){ int [][] arr = new int[3][]; // 确定一维数组个数 for (int i = 0; i \u0026lt; arr.length; ++i){ arr[i] = new int[i+1]; // 第i排上开辟空间 } } // 双下标经典用法 int insert_num = 15; for (int i = 0, j = 0; i\u0026lt;arrNew.length; ++i){ if (insert_num \u0026lt; arr[j]){ ++j; arrNew[i] = arr[j]; else arrNew[i] = insert_num; } 对象 对象内存布局 加载cat类信息从第一句代码就执行 Java内存的结构分析 栈：","tags":["Java"],"title":"Java 学习 半成品","url":"http://localhost:1313/archives/java-study/"},{"categories":["tech"],"content":"数据集下载 密码：s2v2，文件路径mvsnet-\u003epreprocessed_inputsTutorial COLMAP 3.8-devQuickStart Reconstruction \u003e Automatic Reconstruction 分别填入workspace folder、Image folder 如果图片在dtu/scan4/images下，则workspace folder路径填dtu/scan4；image folder填dtu/scan4/images；mask folder作用不知 点两次OK即可生成如下3D模型【滚轮放大缩小，ctrl+滚轮增加粒子】，2080ti耗时半小时可能 等待重建完成，生成大致路径如下 project/sparse 表示所有重建组件的稀疏模型；project/dense表示相对应的dense model；其中dense point cloud fused.ply能通过【File \u003e Import model from ...】导入 整个大致流程为 the picture capture process 注意事项：拍摄的图片应具有丰富的纹理。","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_0","order":0,"summary":"数据集下载 密码：s2v2，文件路径mvsnet-\u003epreprocessed_inputsTutorial COLMAP 3.8-devQuickStart Reconstruction \u003e Automatic Reconstruction 分别填入workspace folder、Image folder 如果图片在dtu/scan4/images下，则workspace folder路径填dtu/scan4；image folder填dtu/scan4/images；mask folder作用不知 点两次OK即可生成如下3D模型【滚轮放大缩小，ctrl+滚轮增加粒子】，2080ti耗时半小时可能 等待重建完成，生成大致路径如下 project/sparse 表示所有重建组件的稀疏模型；project/dense表示相对应的dense model；其中dense point cloud fused.ply能通过【File \u003e Import model from ...】导入 整个大致流程为 the picture capture process 注意事项：拍摄的图片应具有丰富的纹理。","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":"最好避免纹理特别少的图片如一张白墙or空桌图片。通过加入一些物品来丰富纹理 具备相似的光照情况。避免high dynamic range scenes（如有太阳有影子，穿过门或窗拍摄）。避免镜面反射 具有高度视觉重叠的图片。确保一个物体至少有三张图片，尽量多一点 多视图拍摄。不要通过平移旋转相机来从同一个方向拍摄。但确保相似视角有少且精的图片，并不是越多越好。如果是视频，请减少帧率。 Preface 新手参数用默认的就好。也可以给不同重建场景设置“optimal”选项，Extras \u003e Set options for ... data（不知道干嘛用的，好像能修改图片质量，而不是生成的3D质量）。如需了解参数，查看源码 如果遇到非正常退出，介意用命令行运行可执行文件，以获取不同级别的日志记录详细程度。（命令不知）Data Structure COLMAP 假定所有输入图像都在一个输入目录中，该目录具有可能嵌套的子目录。它将读取存储在该目录中的所有图像，并且它支持各种不同的图像格式（请参阅 FreeImage）。其他文件将被自动忽略。如果需要高性能，那么您应该分离所有非图像文档。图像由它们","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_1","order":1,"summary":"最好避免纹理特别少的图片如一张白墙or空桌图片。通过加入一些物品来丰富纹理 具备相似的光照情况。避免high dynamic range scenes（如有太阳有影子，穿过门或窗拍摄）。避免镜面反射 具有高度视觉重叠的图片。确保一个物体至少有三张图片，尽量多一点 多视图拍摄。不要通过平移旋转相机来从同一个方向拍摄。但确保相似视角有少且精的图片，并不是越多越好。如果是视频，请减少帧率。 Preface 新手参数用默认的就好。也可以给不同重建场景设置“optimal”选项，Extras \u003e Set options for ... data（不知道干嘛用的，好像能修改图片质量，而不是生成的3D质量）。如需了解参数，查看源码 如果遇到非正常退出，介意用命令行运行可执行文件，以获取不同级别的日志记录详细程度。（命令不知）Data Structure COLMAP 假定所有输入图像都在一个输入目录中，该目录具有可能嵌套的子目录。它将读取存储在该目录中的所有图像，并且它支持各种不同的图像格式（请参阅 FreeImage）。其他文件将被自动忽略。如果需要高性能，那么您应该分离所有非图像文档。图像由它们","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":"的相对文档路径唯一标识。对于后期处理，例如图像去失真或密集重建，应保留相关文档夹结构。 COLMAP 不修改输入图像或目录，所有提取的数据都存储在一个独立的 SQLite 数据库文档中（请参阅数据库格式）。 第一步是通过运行预构建的二进制文件（Windows：COLMAP.bat，Mac：COLMAP.app）或通过从 CMake build 文档夹执行 ./src/exe/colmap gui 来启动 COLMAP 的图形用户界面。接下来，通过File \u003e New project。在此对话框中，您必须选择存储数据库的位置以及包含输入图像的文档夹。为方便起见，您可以通过选择File \u003e Save project将整个项目设置保存到配置文件中。除了任何其他参数设置外，项目配置还存储数据库和图像文档夹的绝对路径信息。如果您决定移动数据库或图像文档夹，则必须通过创建新项目相应地更改路径。或者，可以在您选择的文本编辑器中直接修改生成的 .ini 配置文档。要重新打开现有项目，只需选择File \u003e Open project即可打开配置文档然后恢复所有参数设置。请注意，所有 COLMAP 可执行文","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_2","order":2,"summary":"的相对文档路径唯一标识。对于后期处理，例如图像去失真或密集重建，应保留相关文档夹结构。 COLMAP 不修改输入图像或目录，所有提取的数据都存储在一个独立的 SQLite 数据库文档中（请参阅数据库格式）。 第一步是通过运行预构建的二进制文件（Windows：COLMAP.bat，Mac：COLMAP.app）或通过从 CMake build 文档夹执行 ./src/exe/colmap gui 来启动 COLMAP 的图形用户界面。接下来，通过File \u003e New project。在此对话框中，您必须选择存储数据库的位置以及包含输入图像的文档夹。为方便起见，您可以通过选择File \u003e Save project将整个项目设置保存到配置文件中。除了任何其他参数设置外，项目配置还存储数据库和图像文档夹的绝对路径信息。如果您决定移动数据库或图像文档夹，则必须通过创建新项目相应地更改路径。或者，可以在您选择的文本编辑器中直接修改生成的 .ini 配置文档。要重新打开现有项目，只需选择File \u003e Open project即可打开配置文档然后恢复所有参数设置。请注意，所有 COLMAP 可执行文","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":"件都可以通过将各个设置指定为命令行参数或通过提供项目配置文档的路径（see Interface）从命令行启动。 Feature Detection and Extraction 选择Processing \u003e feature extraction 在此对话框中，您必须首先决定使用的固有相机模型。您可以从嵌入的 EXIF 信息中自动提取焦距信息，也可以手动指定内部参数，例如在实验室校准中获得的参数（在custom parameters里？）。如果图像包含部分 EXIF 信息，COLMAP 会尝试在大型相机型号数据库中自动查找缺失的相机规格。如果您的所有图像都是由具有相同缩放系数的同一台物理相机拍摄的，建议在所有图像之间共享内在函数。请注意，如果所有图像共享相同的相机型号但并非所有图像都具有相同的尺寸或 EXIF 焦距，进程将不正常地退出。如果您有几组图像共享相同的内在相机参数，您也可以在以后轻松修改相机模型（see Database Management）。如果不确定在此步骤中选择什幺，只需坚持使用默认参数即可。 您可以从图像中检测和提取新特征，也可以从文本中导入现有特征。 COLMAP ","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_3","order":3,"summary":"件都可以通过将各个设置指定为命令行参数或通过提供项目配置文档的路径（see Interface）从命令行启动。 Feature Detection and Extraction 选择Processing \u003e feature extraction 在此对话框中，您必须首先决定使用的固有相机模型。您可以从嵌入的 EXIF 信息中自动提取焦距信息，也可以手动指定内部参数，例如在实验室校准中获得的参数（在custom parameters里？）。如果图像包含部分 EXIF 信息，COLMAP 会尝试在大型相机型号数据库中自动查找缺失的相机规格。如果您的所有图像都是由具有相同缩放系数的同一台物理相机拍摄的，建议在所有图像之间共享内在函数。请注意，如果所有图像共享相同的相机型号但并非所有图像都具有相同的尺寸或 EXIF 焦距，进程将不正常地退出。如果您有几组图像共享相同的内在相机参数，您也可以在以后轻松修改相机模型（see Database Management）。如果不确定在此步骤中选择什幺，只需坚持使用默认参数即可。 您可以从图像中检测和提取新特征，也可以从文本中导入现有特征。 COLMAP ","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":"在 GPU 或 CPU 上提取 SIFT 特征。 GPU 版本需要连接显示器，而 CPU 版本建议在服务器上使用。一般来说，GPU 版本是有利的，因为它具有定制的特征检测模式，通常在高对比度图像的情况下产生更高质量的特征。如果导入现有特征，则每个图像旁边都必须有一个文本文档（例如 /path/to/image1.jpg 和 /path/to/image1.jpg.txt），格式如下：NUM_FEATURES 128 X Y SCALE ORIENTATION D_1 D_2 D_3 ... D_128 ... X Y SCALE ORIENTATION D_1 D_2 D_3 ... D_128其中 X、Y、SCALE、ORIENTATION 是浮点数，D_1…D_128 值在 0…255 范围内。该文档应包含 NUM_FEATURES 行，每个功能一行。例如，如果图像有 4 个特征，则文本文档应如下所示：4 128 1.2 2.3 0.1 0.3 1 2 3 4 ... 21 2.2 3.3 1.1 0.3 3 2 3 2 ... 32 0.2 1.3 1.1 0.3 3 2 3 2","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_4","order":4,"summary":"在 GPU 或 CPU 上提取 SIFT 特征。 GPU 版本需要连接显示器，而 CPU 版本建议在服务器上使用。一般来说，GPU 版本是有利的，因为它具有定制的特征检测模式，通常在高对比度图像的情况下产生更高质量的特征。如果导入现有特征，则每个图像旁边都必须有一个文本文档（例如 /path/to/image1.jpg 和 /path/to/image1.jpg.txt），格式如下：NUM_FEATURES 128 X Y SCALE ORIENTATION D_1 D_2 D_3 ... D_128 ... X Y SCALE ORIENTATION D_1 D_2 D_3 ... D_128其中 X、Y、SCALE、ORIENTATION 是浮点数，D_1…D_128 值在 0…255 范围内。该文档应包含 NUM_FEATURES 行，每个功能一行。例如，如果图像有 4 个特征，则文本文档应如下所示：4 128 1.2 2.3 0.1 0.3 1 2 3 4 ... 21 2.2 3.3 1.1 0.3 3 2 3 2 ... 32 0.2 1.3 1.1 0.3 3 2 3 2","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":" ... 2 1.2 2.3 1.1 0.3 3 2 3 2 ... 3请注意，按照惯例，图像的左上角坐标为 (0, 0)，最左上角像素的中心坐标为 (0.5, 0.5)。如果您必须为大型图像集合导入特征，使用您喜欢的脚本语言直接访问数据库会更有效(see Database Format) 如果您完成了所有选项的设置，请选择“Extract”并等待提取完成或取消。如果您在提取过程中取消，下次您开始为同一项目提取图像时，COLMAP 会自动从中断处继续。这也允许您将图像添加到现有项目/重建中。在这种情况下，请务必在使用共享内在函数时验证相机参数。 所有提取的数据将存储在数据库文档中，可以在数据库管理工具中查看/管理(see Database Management) 或使用SQLite(see Database Format).Feature Matching and Geometric Verification 特征匹配和几何验证会找到不同图像中特征点之间的对应关系。 选择Processing \u003e feature matching 并选择一种提供的匹配模式，用于不同的输入场景： Exha","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_5","order":5,"summary":" ... 2 1.2 2.3 1.1 0.3 3 2 3 2 ... 3请注意，按照惯例，图像的左上角坐标为 (0, 0)，最左上角像素的中心坐标为 (0.5, 0.5)。如果您必须为大型图像集合导入特征，使用您喜欢的脚本语言直接访问数据库会更有效(see Database Format) 如果您完成了所有选项的设置，请选择“Extract”并等待提取完成或取消。如果您在提取过程中取消，下次您开始为同一项目提取图像时，COLMAP 会自动从中断处继续。这也允许您将图像添加到现有项目/重建中。在这种情况下，请务必在使用共享内在函数时验证相机参数。 所有提取的数据将存储在数据库文档中，可以在数据库管理工具中查看/管理(see Database Management) 或使用SQLite(see Database Format).Feature Matching and Geometric Verification 特征匹配和几何验证会找到不同图像中特征点之间的对应关系。 选择Processing \u003e feature matching 并选择一种提供的匹配模式，用于不同的输入场景： Exha","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":"ustive Matching：如果你的数据集中的图片数量比较少（最多几百张），这种匹配模式应该足够快，重建结果最好。在这里，每个图像都与其他图像匹配，而参数block_size决定了同时从磁盘加载到内存中的图像数量。 Sequential Matching: 如果图像是按顺序获取的（例如，通过摄像机），则此模式很有用。在这种情况下，连续的帧有视觉重叠，没有必要穷尽地匹配所有图像对。相反，连续捕获的图像相互匹配。这种匹配模式具有基于vocabulary tree的内置循环检测，其中每第 N 个图像 (loop_detection_period) 与其视觉上最相似的图像 (loop_detection_num_images) 进行匹配。请注意，图像文件名必须按顺序排列（例如，image0001.jpg、image0002.jpg 等）。数据库中的顺序无关紧要，因为图像是根据其文件名明确排序的。请注意，顺序检测需要一个预训练的vocabulary tree，可以从 https://demuc.de/colmap/ 下载。 Vocabulary Tree Matching：在这种匹配模式中，","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_6","order":6,"summary":"ustive Matching：如果你的数据集中的图片数量比较少（最多几百张），这种匹配模式应该足够快，重建结果最好。在这里，每个图像都与其他图像匹配，而参数block_size决定了同时从磁盘加载到内存中的图像数量。 Sequential Matching: 如果图像是按顺序获取的（例如，通过摄像机），则此模式很有用。在这种情况下，连续的帧有视觉重叠，没有必要穷尽地匹配所有图像对。相反，连续捕获的图像相互匹配。这种匹配模式具有基于vocabulary tree的内置循环检测，其中每第 N 个图像 (loop_detection_period) 与其视觉上最相似的图像 (loop_detection_num_images) 进行匹配。请注意，图像文件名必须按顺序排列（例如，image0001.jpg、image0002.jpg 等）。数据库中的顺序无关紧要，因为图像是根据其文件名明确排序的。请注意，顺序检测需要一个预训练的vocabulary tree，可以从 https://demuc.de/colmap/ 下载。 Vocabulary Tree Matching：在这种匹配模式中，","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":"每个图像都使用a vocabulary tree with spatial re-ranking与其视觉上最近的邻居进行匹配。这是推荐的大型图像集合（数千个）的匹配模式。这需要一个预训练的词汇树，可以从 https://demuc.de/colmap/ 下载。 Spatial Matching：这种匹配模式将每个图像与其空间上最近的邻居进行匹配。空间位置可以在database management中手动设置。默认情况下，COLMAP 还从 EXIF 中提取 GPS 信息并将其用于空间最近邻搜索。如果有准确的先验位置信息，这是推荐的匹配方式。 Transitive Matching：这种匹配模式使用已经存在的特征匹配的传递关系来产生更完整的匹配图。如果图像 A 与图像 B 匹配并且 B 与 C 匹配，则此匹配器会尝试直接将 A 与 C 匹配。 Custom Matching：此模式允许指定单个图像对进行匹配或导入单个特征匹配。要指定图像对，您必须提供一个文本文档，每行包含一个图像对：image1.jpg image2.jpg image1.jpg image3.jpg ...其中 ima","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_7","order":7,"summary":"每个图像都使用a vocabulary tree with spatial re-ranking与其视觉上最近的邻居进行匹配。这是推荐的大型图像集合（数千个）的匹配模式。这需要一个预训练的词汇树，可以从 https://demuc.de/colmap/ 下载。 Spatial Matching：这种匹配模式将每个图像与其空间上最近的邻居进行匹配。空间位置可以在database management中手动设置。默认情况下，COLMAP 还从 EXIF 中提取 GPS 信息并将其用于空间最近邻搜索。如果有准确的先验位置信息，这是推荐的匹配方式。 Transitive Matching：这种匹配模式使用已经存在的特征匹配的传递关系来产生更完整的匹配图。如果图像 A 与图像 B 匹配并且 B 与 C 匹配，则此匹配器会尝试直接将 A 与 C 匹配。 Custom Matching：此模式允许指定单个图像对进行匹配或导入单个特征匹配。要指定图像对，您必须提供一个文本文档，每行包含一个图像对：image1.jpg image2.jpg image1.jpg image3.jpg ...其中 ima","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":"ge1.jpg 是图像文档夹中的相对路径。您有两个选项来导入单个特征匹配项：未经geometrically verified的原始特征匹配或已经geometrically verified的特征匹配。在这两种情况下，预期格式为： 其中 image1.jpg 是图像文档夹中的相对路径，数字对是各个图像中从零开始的特征索引。如果您必须为大型图像集导入许多匹配项，使用您选择的脚本语言直接访问数据库会更有效。 如果您完成了所有选项的设置，请选择\"Match\"/\"Run\"并等待匹配完成或在期间取消。请注意，此步骤可能会花费大量时间，具体取决于图像数量、每张图像的特征数量以及所选的匹配模式。exhaustive matching的预期时间从几十张图像的几分钟到数百张图像的几小时到数千张图像的几天或几周不等。如果在匹配后取消匹配过程或导入新图像，COLMAP 只会匹配以前没有匹配过的图像对。跳过已经匹配的图像对的开销很低。这还可以匹配初始匹配后导入的其他图像，并且可以为同一数据集组合不同的匹配模式。 所有提取的数据将存储在数据库文档中，可以在数据库管理工具中查看/管理(see Database Ma","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_8","order":8,"summary":"ge1.jpg 是图像文档夹中的相对路径。您有两个选项来导入单个特征匹配项：未经geometrically verified的原始特征匹配或已经geometrically verified的特征匹配。在这两种情况下，预期格式为： 其中 image1.jpg 是图像文档夹中的相对路径，数字对是各个图像中从零开始的特征索引。如果您必须为大型图像集导入许多匹配项，使用您选择的脚本语言直接访问数据库会更有效。 如果您完成了所有选项的设置，请选择\"Match\"/\"Run\"并等待匹配完成或在期间取消。请注意，此步骤可能会花费大量时间，具体取决于图像数量、每张图像的特征数量以及所选的匹配模式。exhaustive matching的预期时间从几十张图像的几分钟到数百张图像的几小时到数千张图像的几天或几周不等。如果在匹配后取消匹配过程或导入新图像，COLMAP 只会匹配以前没有匹配过的图像对。跳过已经匹配的图像对的开销很低。这还可以匹配初始匹配后导入的其他图像，并且可以为同一数据集组合不同的匹配模式。 所有提取的数据将存储在数据库文档中，可以在数据库管理工具中查看/管理(see Database Ma","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":"nagement) 或使用SQLite(see Database Format). 注意，特征匹配需要 GPU，并且在匹配过程中您的计算机的显示性能可能会显著下降。如果您的系统有多个支持 CUDA 的 GPU，您可以使用 **gpu_index **选项选择特定的 GPU。Sparse Reconstruction Reconstruction \u003e start/resume reconstruction进行 incremental reconstruction COLMAP 首先将所有数据库中提取的数据加载到内存中，并从初始的image pair开始重建。然后，通过记录新图像和triangulating new points来逐步扩展场景。在此重建过程中，结果实时可视化。有关可用控件的更多详细信息，请参阅Graphical User Interface。如果不是所有图像都记录到同一模型中，COLMAP 会尝试重建多个模型。可以从工具栏的下拉菜单中选择不同的模型（应该如图所示的下拉栏）。 如果不同的模型有共同的记录过图像，您可以使用 model_converter executable将","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_9","order":9,"summary":"nagement) 或使用SQLite(see Database Format). 注意，特征匹配需要 GPU，并且在匹配过程中您的计算机的显示性能可能会显著下降。如果您的系统有多个支持 CUDA 的 GPU，您可以使用 **gpu_index **选项选择特定的 GPU。Sparse Reconstruction Reconstruction \u003e start/resume reconstruction进行 incremental reconstruction COLMAP 首先将所有数据库中提取的数据加载到内存中，并从初始的image pair开始重建。然后，通过记录新图像和triangulating new points来逐步扩展场景。在此重建过程中，结果实时可视化。有关可用控件的更多详细信息，请参阅Graphical User Interface。如果不是所有图像都记录到同一模型中，COLMAP 会尝试重建多个模型。可以从工具栏的下拉菜单中选择不同的模型（应该如图所示的下拉栏）。 如果不同的模型有共同的记录过图像，您可以使用 model_converter executable将","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":"它们合并到一个重建中（有关详细信息，see FAQ）。如果您的所有图像都使用没有共享内在函数的 SIMPLE_RADIAL 相机模型（默认），您可以使用 PBA而不是 Ceres Solver进行快速bundle调整，它可以在“reconstruction options”下的\"Bundle\"中激活（use_pba = true）。 理想情况下，重建工作正常并且所有图像都已记录。如果不是这种情况，建议：执行额外的匹配。为获得最佳结果，请使用exhaustive matching、enable guided matching、增加词汇树匹配中的最近邻数量或增加sequential matching中的重叠等。 如果 COLMAP 初始化失败，请手动选择初始图像对。选择Reconstruction \u003e Reconstruction options \u003e Init并从数据库管理工具中设置从不同视点具有足够匹配度的图像。 并从数据库管理工具中设置从不同视点具有足够匹配度的图像。Importing and Exporting COLMAP 为进一步处理提供了几个导出选项。为了充分的灵活性，建议导出","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_10","order":10,"summary":"它们合并到一个重建中（有关详细信息，see FAQ）。如果您的所有图像都使用没有共享内在函数的 SIMPLE_RADIAL 相机模型（默认），您可以使用 PBA而不是 Ceres Solver进行快速bundle调整，它可以在“reconstruction options”下的\"Bundle\"中激活（use_pba = true）。 理想情况下，重建工作正常并且所有图像都已记录。如果不是这种情况，建议：执行额外的匹配。为获得最佳结果，请使用exhaustive matching、enable guided matching、增加词汇树匹配中的最近邻数量或增加sequential matching中的重叠等。 如果 COLMAP 初始化失败，请手动选择初始图像对。选择Reconstruction \u003e Reconstruction options \u003e Init并从数据库管理工具中设置从不同视点具有足够匹配度的图像。 并从数据库管理工具中设置从不同视点具有足够匹配度的图像。Importing and Exporting COLMAP 为进一步处理提供了几个导出选项。为了充分的灵活性，建议导出","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["tech"],"content":"以 COLMAP 的数据格式的reconstruction。通过选择 File \u003e Export 导出当前查看的模型或 File \u003e Export all 导出所有重建的模型。使用用于重建相机、图像和点的单独文本文件将模型导出到所选文件夹中。当以 COLMAP 的数据格式导出时，您可以重新导入重建以用于以后的可视化、图像去失真，或从中断的地方继续现有的重建（例如，在导入和匹配新图像之后）。要导入模型，请选择 File \u003e Import 并选择导出文件夹路径。或者，您也可以通过 File \u003e Export as... 选择以各种其他格式导出模型，例如 Bundler、VisualSfM 、PLY 或 VRML。COLMAP 可以通过 File \u003e Import From... 可视化具有 RGB 信息的plain PLY 点云文件。有关导出模型格式的更多信息，请参见此处。 Dense Reconstruction 在重建场景的稀疏表示和输入图像的相机姿势后，MVS 现在可以恢复更密集的场景几何。 COLMAP 具有集成的密集重建流程，可以为所有配准图像生成深度图和法线图，将深度图和法线图","date":"2023-03-11T20:17:43.837Z","objectID":"507c07a9271b805debc722089cc9fd74_11","order":11,"summary":"以 COLMAP 的数据格式的reconstruction。通过选择 File \u003e Export 导出当前查看的模型或 File \u003e Export all 导出所有重建的模型。使用用于重建相机、图像和点的单独文本文件将模型导出到所选文件夹中。当以 COLMAP 的数据格式导出时，您可以重新导入重建以用于以后的可视化、图像去失真，或从中断的地方继续现有的重建（例如，在导入和匹配新图像之后）。要导入模型，请选择 File \u003e Import 并选择导出文件夹路径。或者，您也可以通过 File \u003e Export as... 选择以各种其他格式导出模型，例如 Bundler、VisualSfM 、PLY 或 VRML。COLMAP 可以通过 File \u003e Import From... 可视化具有 RGB 信息的plain PLY 点云文件。有关导出模型格式的更多信息，请参见此处。 Dense Reconstruction 在重建场景的稀疏表示和输入图像的相机姿势后，MVS 现在可以恢复更密集的场景几何。 COLMAP 具有集成的密集重建流程，可以为所有配准图像生成深度图和法线图，将深度图和法线图","tags":["ComputerVision"],"title":"ColMap使用","url":"http://localhost:1313/archives/colmap-use/"},{"categories":["create"],"content":"项目需求 python 客户端将opencv读取到的图片发送给python服务端，然后python服务端将opencv图发送给Linux设备，将处理结果通过C++ 传给服务端，然后服务端再传给客户端。 这里服务端可以改成C++ 写的，就不用这么麻烦了，但是需要将python的pickle包解码成C++ 的pickle包，还未尝试。 以下所给代码，并不一定能跑通，思路在哪里，结合自己的代码第一步，python间通信 这种方式能一次性全部发送，一次性全部接受（如发一张图片，接受一张，发两张，接受两张）方法一 Python Client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import datetime import pickle import time import cv2 from multiprocessing.connection impor","date":"2023-01-08T11:17:34.624Z","objectID":"70589f09cf86af656cea2b8392fc9d59_0","order":0,"summary":"项目需求 python 客户端将opencv读取到的图片发送给python服务端，然后python服务端将opencv图发送给Linux设备，将处理结果通过C++ 传给服务端，然后服务端再传给客户端。 这里服务端可以改成C++ 写的，就不用这么麻烦了，但是需要将python的pickle包解码成C++ 的pickle包，还未尝试。 以下所给代码，并不一定能跑通，思路在哪里，结合自己的代码第一步，python间通信 这种方式能一次性全部发送，一次性全部接受（如发一张图片，接受一张，发两张，接受两张）方法一 Python Client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import datetime import pickle import time import cv2 from multiprocessing.connection impor","tags":["Python","TCP","Ctype"],"title":"python 与python通信、python调用c++ 动态库返回检测结果","url":"http://localhost:1313/archives/python-and-ctypes/"},{"categories":["create"],"content":"t Client import os host = 'localhost' port = 9006 frame_num = 0 def connect_and_send(path, mode='file'): global frame_num client = Client((host, port)) while 1: img_dict_list = [] # 从文件夹读取图片 if mode == 'file': img_list = [] img_path = './data' for filename in os.listdir(img_path): read_img = cv2.imread(img_path + '/' + filename) img_list.append(read_img) # 存入dict for i in range(len(img_list)): img_obj = {'frame_num': i + 1, 'image': img_list[i], 'time': time.strftime('%Y%m%d%H%M%S', time.localti","date":"2023-01-08T11:17:34.624Z","objectID":"70589f09cf86af656cea2b8392fc9d59_1","order":1,"summary":"t Client import os host = 'localhost' port = 9006 frame_num = 0 def connect_and_send(path, mode='file'): global frame_num client = Client((host, port)) while 1: img_dict_list = [] # 从文件夹读取图片 if mode == 'file': img_list = [] img_path = './data' for filename in os.listdir(img_path): read_img = cv2.imread(img_path + '/' + filename) img_list.append(read_img) # 存入dict for i in range(len(img_list)): img_obj = {'frame_num': i + 1, 'image': img_list[i], 'time': time.strftime('%Y%m%d%H%M%S', time.localti","tags":["Python","TCP","Ctype"],"title":"python 与python通信、python调用c++ 动态库返回检测结果","url":"http://localhost:1313/archives/python-and-ctypes/"},{"categories":["create"],"content":"me())} img_dict_list.append(img_obj) else: read_img = cv2.imread(path) img_obj = {'frame_num': frame_num + 1, 'image': read_img, 'time': datetime.datetime.now().strftime('%M%S.%f')} img_dict_list.append(img_obj) frame_num += 1 # 1. obj to pickle 用json的话会慢，因为read_img需要to_list() data_bytes = pickle.dumps(img_dict_list) # 2. 发送文件 print('client send: ', datetime.datetime.now().strftime('%M%S.%f')) client.send(data_bytes) det_result = client.recv() print('client receive: ', datetime.datetime.now().st","date":"2023-01-08T11:17:34.624Z","objectID":"70589f09cf86af656cea2b8392fc9d59_2","order":2,"summary":"me())} img_dict_list.append(img_obj) else: read_img = cv2.imread(path) img_obj = {'frame_num': frame_num + 1, 'image': read_img, 'time': datetime.datetime.now().strftime('%M%S.%f')} img_dict_list.append(img_obj) frame_num += 1 # 1. obj to pickle 用json的话会慢，因为read_img需要to_list() data_bytes = pickle.dumps(img_dict_list) # 2. 发送文件 print('client send: ', datetime.datetime.now().strftime('%M%S.%f')) client.send(data_bytes) det_result = client.recv() print('client receive: ', datetime.datetime.now().st","tags":["Python","TCP","Ctype"],"title":"python 与python通信、python调用c++ 动态库返回检测结果","url":"http://localhost:1313/archives/python-and-ctypes/"},{"categories":["create"],"content":"rftime('%M%S.%f')) det_result = pickle.loads(det_result) print(det_result) break if __name__ == '__main__': connect_and_send('data/ship.jpg', mode='1') Python Server端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import datetime import pickle import cv2 import numpy as np from multiprocessing.connection import Listener host = '192.168.0.2' port = 9006 server_sock = Listener((host, port)) print(\"Connecting... ...\") sock = s","date":"2023-01-08T11:17:34.624Z","objectID":"70589f09cf86af656cea2b8392fc9d59_3","order":3,"summary":"rftime('%M%S.%f')) det_result = pickle.loads(det_result) print(det_result) break if __name__ == '__main__': connect_and_send('data/ship.jpg', mode='1') Python Server端 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import datetime import pickle import cv2 import numpy as np from multiprocessing.connection import Listener host = '192.168.0.2' port = 9006 server_sock = Listener((host, port)) print(\"Connecting... ...\") sock = s","tags":["Python","TCP","Ctype"],"title":"python 与python通信、python调用c++ 动态库返回检测结果","url":"http://localhost:1313/archives/python-and-ctypes/"},{"categories":["create"],"content":"erver_sock.accept() while 1: try: received_bytes = sock.recv() print('server receive: ', datetime.datetime.now().strftime('%M%S.%f')) except Exception as e: received_bytes = None print(e) if not received_bytes: # 当客户端下线，不让服务端下线 server_sock.close() sock.close() print(\"Client's data is empty !!!\") server_sock = Listener((host, port)) print(\"Reset Sever\") sock = server_sock.accept() continue else: # bytes to list img_dict_list = pickle.loads(received_bytes) # detect det_dict_list = [] img_num = len","date":"2023-01-08T11:17:34.624Z","objectID":"70589f09cf86af656cea2b8392fc9d59_4","order":4,"summary":"erver_sock.accept() while 1: try: received_bytes = sock.recv() print('server receive: ', datetime.datetime.now().strftime('%M%S.%f')) except Exception as e: received_bytes = None print(e) if not received_bytes: # 当客户端下线，不让服务端下线 server_sock.close() sock.close() print(\"Client's data is empty !!!\") server_sock = Listener((host, port)) print(\"Reset Sever\") sock = server_sock.accept() continue else: # bytes to list img_dict_list = pickle.loads(received_bytes) # detect det_dict_list = [] img_num = len","tags":["Python","TCP","Ctype"],"title":"python 与python通信、python调用c++ 动态库返回检测结果","url":"http://localhost:1313/archives/python-and-ctypes/"},{"categories":["create"],"content":"(img_dict_list) img = img_dict_list[0]['image'] # img send to server det_obj = {'frame_num': 1, 'det_output': getCResult(lib, det, img, img_num), # getCResult获取检测结果 'time': datetime.datetime.now().strftime('%Y%m%d%H%M%S.%f')} det_dict_list.append(det_obj) # send result to client content = pickle.dumps(det_dict_list) print('server send: ', datetime.datetime.now().strftime('%M%S.%f')) sock.send(content) 参考链接：Python，用简单代码上传内存中的图片到远程服务器进行处理、Python传输图片（同一局域网下版本）第二步，python调用C++ 动态库（opencv）返回检测结果 一共有cy","date":"2023-01-08T11:17:34.624Z","objectID":"70589f09cf86af656cea2b8392fc9d59_5","order":5,"summary":"(img_dict_list) img = img_dict_list[0]['image'] # img send to server det_obj = {'frame_num': 1, 'det_output': getCResult(lib, det, img, img_num), # getCResult获取检测结果 'time': datetime.datetime.now().strftime('%Y%m%d%H%M%S.%f')} det_dict_list.append(det_obj) # send result to client content = pickle.dumps(det_dict_list) print('server send: ', datetime.datetime.now().strftime('%M%S.%f')) sock.send(content) 参考链接：Python，用简单代码上传内存中的图片到远程服务器进行处理、Python传输图片（同一局域网下版本）第二步，python调用C++ 动态库（opencv）返回检测结果 一共有cy","tags":["Python","TCP","Ctype"],"title":"python 与python通信、python调用c++ 动态库返回检测结果","url":"http://localhost:1313/archives/python-and-ctypes/"},{"categories":["create"],"content":"thon、pybind11、ctypes等包，这里用的是ctypes 首先你需要有个.so文件，可以用cmake生成，注意python中你要调的包的位置，用camke不改.so文件的路径的话自动在当前文件夹生成，所以会报 **undefined symbol: strTest，**Linux指令：cp 复制文件 cmake自行查阅吧，这里做个示范project(xxx)add_library(xxx SHARED xxx.cpp) //这里会将.cpp中的非类方法加入到.so文件中add_executable(yyy yyy.cpp)target_link_libraries(yyy xxx)link：https://www.cnblogs.com/blog-3123958139/p/5575360.html 难点一：传输字符串 string to std::string C++ 端：1 2 3 4 5 6 extern \"C\" { // 加了才能识别到括号内的方法，必须！用C格式写代码 int Detect_Init(Detect* det, char* config_path){ ","date":"2023-01-08T11:17:34.624Z","objectID":"70589f09cf86af656cea2b8392fc9d59_6","order":6,"summary":"thon、pybind11、ctypes等包，这里用的是ctypes 首先你需要有个.so文件，可以用cmake生成，注意python中你要调的包的位置，用camke不改.so文件的路径的话自动在当前文件夹生成，所以会报 **undefined symbol: strTest，**Linux指令：cp 复制文件 cmake自行查阅吧，这里做个示范project(xxx)add_library(xxx SHARED xxx.cpp) //这里会将.cpp中的非类方法加入到.so文件中add_executable(yyy yyy.cpp)target_link_libraries(yyy xxx)link：https://www.cnblogs.com/blog-3123958139/p/5575360.html 难点一：传输字符串 string to std::string C++ 端：1 2 3 4 5 6 extern \"C\" { // 加了才能识别到括号内的方法，必须！用C格式写代码 int Detect_Init(Detect* det, char* config_path){ ","tags":["Python","TCP","Ctype"],"title":"python 与python通信、python调用c++ 动态库返回检测结果","url":"http://localhost:1313/archives/python-and-ctypes/"},{"categories":["create"],"content":"问题来源 项目需求用Ubuntu和Debian互相通信，传输数据 参考链接：Ubuntu通过修改配置文件进行网络配置、linux 双机直连设置物理连接 首先当然是用网线将两台设备连接起来，用的是本地接口修改Ubuntu的ip地址 此处先在终端（Ubuntu快捷键ctrl+alt+t）ifconfig查看当前ip地址 此处如果没有配置enp4s0的话 就不会出现inet 192.168.0.1这些东西，如果配置过，则会显示，那么只需要配置另一台Linux设备处在统一网段下即可。 此外有些设备可能不叫enp4s0,只要看到e开头的就是本地网络，即插网线的地方，或者Google冒号前的意思。 然后终端输入sudo vim /etc/network/interfaces 摁i进入insert模式，新加内容：auto enp4s0iface enp4s0 inet staticaddress 192.168.0.1netmask 255.255.255.0gateway 192.168.0.1 其中enp4s0 换成你的设备名字，如eth0；其他部分懂网络的任意设置，跟我一样小白的直接复制粘贴 ","date":"2022-12-15T19:50:58.186Z","objectID":"67f2d6a8eac3894b9ef1b4102e3b948e_0","order":0,"summary":"问题来源 项目需求用Ubuntu和Debian互相通信，传输数据 参考链接：Ubuntu通过修改配置文件进行网络配置、linux 双机直连设置物理连接 首先当然是用网线将两台设备连接起来，用的是本地接口修改Ubuntu的ip地址 此处先在终端（Ubuntu快捷键ctrl+alt+t）ifconfig查看当前ip地址 此处如果没有配置enp4s0的话 就不会出现inet 192.168.0.1这些东西，如果配置过，则会显示，那么只需要配置另一台Linux设备处在统一网段下即可。 此外有些设备可能不叫enp4s0,只要看到e开头的就是本地网络，即插网线的地方，或者Google冒号前的意思。 然后终端输入sudo vim /etc/network/interfaces 摁i进入insert模式，新加内容：auto enp4s0iface enp4s0 inet staticaddress 192.168.0.1netmask 255.255.255.0gateway 192.168.0.1 其中enp4s0 换成你的设备名字，如eth0；其他部分懂网络的任意设置，跟我一样小白的直接复制粘贴 ","tags":["Linux"],"title":"Linux 两台设备用网线通信","url":"http://localhost:1313/archives/linux-two-device-directly-communicate/"},{"categories":["error"],"content":"前言 本文环境是win7，opencv-python，有两个摄像头设备 参考链接：万能的StackOverflow-1 万能的StackOverflow-2 遇到的问题 win7设备上需要调高摄像头分辨率，有两个摄像头，一个固定一个usb，但是只能控制在640 x 480，才能两个都能使用，否则调整随机调整摄像头分辨率两个都无法点亮。并且在win10使用单个摄像头，修改为3000 x 2000 输出的图片分辨率可以直接自适应为2048 x 1536，可以点亮摄像头。解决办法一 因为要对程序做迁移，但是在win10上可以直接任意设置分辨率来时opencv自适应摄像头最大分辨率，但是在win7无法实现，所以设定分辨率为固定值640 x 480 800 x 600 1024 x 768 1280 x 960 1920 x 1080 2048 x 1536 ..... 注意越大分辨率需求的算力越大，以及有些分辨率可能不是通用，可以多试试 或者在代码上多设置几个大整数，然后get CV_CAP_PROP_FRAME_WIDTH，输出看一下，摄像头的分辨率是多少 1 2 3 4 cap = cv2","date":"2022-11-16T16:40:52.665Z","objectID":"e3dd7193aec93438f46182aba1ff1736_0","order":0,"summary":"前言 本文环境是win7，opencv-python，有两个摄像头设备 参考链接：万能的StackOverflow-1 万能的StackOverflow-2 遇到的问题 win7设备上需要调高摄像头分辨率，有两个摄像头，一个固定一个usb，但是只能控制在640 x 480，才能两个都能使用，否则调整随机调整摄像头分辨率两个都无法点亮。并且在win10使用单个摄像头，修改为3000 x 2000 输出的图片分辨率可以直接自适应为2048 x 1536，可以点亮摄像头。解决办法一 因为要对程序做迁移，但是在win10上可以直接任意设置分辨率来时opencv自适应摄像头最大分辨率，但是在win7无法实现，所以设定分辨率为固定值640 x 480 800 x 600 1024 x 768 1280 x 960 1920 x 1080 2048 x 1536 ..... 注意越大分辨率需求的算力越大，以及有些分辨率可能不是通用，可以多试试 或者在代码上多设置几个大整数，然后get CV_CAP_PROP_FRAME_WIDTH，输出看一下，摄像头的分辨率是多少 1 2 3 4 cap = cv2","tags":["Python","Opencv"],"title":"opencv提高摄像头分辨率时，无法打开摄像头","url":"http://localhost:1313/archives/opencv-set-high-resolution-cant-open-camera/"},{"categories":["error"],"content":".VideoCapture(0) print(\"Frame default resolution: (\" + str(cap.get(cv.CV_CAP_PROP_FRAME_WIDTH)) + \"; \" + str(cap.get(cv.CV_CAP_PROP_FRAME_HEIGHT)) + \")\") cap.set(cv.CV_CAP_PROP_FRAME_WIDTH, 800) cap.set(cv.CV_CAP_PROP_FRAME_HEIGHT, 600) 解决办法二 未经测试，就是有多个摄像头设备的时候，占用一个总线，所以导致冲突了，多添加一个usb card（我也不知道是啥，可能是usb接口） https://stackoverflow.com/a/29702444","date":"2022-11-16T16:40:52.665Z","objectID":"e3dd7193aec93438f46182aba1ff1736_1","order":1,"summary":".VideoCapture(0) print(\"Frame default resolution: (\" + str(cap.get(cv.CV_CAP_PROP_FRAME_WIDTH)) + \"; \" + str(cap.get(cv.CV_CAP_PROP_FRAME_HEIGHT)) + \")\") cap.set(cv.CV_CAP_PROP_FRAME_WIDTH, 800) cap.set(cv.CV_CAP_PROP_FRAME_HEIGHT, 600) 解决办法二 未经测试，就是有多个摄像头设备的时候，占用一个总线，所以导致冲突了，多添加一个usb card（我也不知道是啥，可能是usb接口） https://stackoverflow.com/a/29702444","tags":["Python","Opencv"],"title":"opencv提高摄像头分辨率时，无法打开摄像头","url":"http://localhost:1313/archives/opencv-set-high-resolution-cant-open-camera/"},{"categories":["create"],"content":"仅做参考用，今年建模赛前做完这个代码后，自觉信心满满，比完赛后直接裂开，希望能拿个国三吧!o(╥﹏╥)o。 11/26 为什么还没公布成绩，哭死，貌似还有好几个星期。后续，谢谢参与奖捏😎👌😭数据查看 1 2 3 4 5 6 7 8 9 10 import os from pandas_profiling import ProfileReport import pandas as pd # 超慢 先运行这个 os.chdir(r'C:\\Users\\Desktop\\math') file_name = 'Molecular_Descriptor.xlsx' sheet_name = 'training' table = pd.read_excel(file_name, sheet_name, header=[0]) # 如果有多个列名 方便起见只取一个 profile = table.profile_report(title=\"data_profile\") profile.to_file(output_file=\"analysis.html\") 数据预处理 1 2 3 4 5 6 7 8 ","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_0","order":0,"summary":"仅做参考用，今年建模赛前做完这个代码后，自觉信心满满，比完赛后直接裂开，希望能拿个国三吧!o(╥﹏╥)o。 11/26 为什么还没公布成绩，哭死，貌似还有好几个星期。后续，谢谢参与奖捏😎👌😭数据查看 1 2 3 4 5 6 7 8 9 10 import os from pandas_profiling import ProfileReport import pandas as pd # 超慢 先运行这个 os.chdir(r'C:\\Users\\Desktop\\math') file_name = 'Molecular_Descriptor.xlsx' sheet_name = 'training' table = pd.read_excel(file_name, sheet_name, header=[0]) # 如果有多个列名 方便起见只取一个 profile = table.profile_report(title=\"data_profile\") profile.to_file(output_file=\"analysis.html\") 数据预处理 1 2 3 4 5 6 7 8 ","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 ","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_1","order":1,"summary":"9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 ","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 # 导包略过，自行github看 def describeData(data): print(data.dtypes) # 如果是object需要转换 # for col in data: # object to numeric if is numeric # if isinstance(data[col][0], int) or isinstance(data[col][0], float): # data[col] = pd.to_numeric(data[col], errors='coerce') # print('数据类型：', data.dtypes) print('前三行数据：', data.iloc[:3, :5]) # 看","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_2","order":2,"summary":"157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 # 导包略过，自行github看 def describeData(data): print(data.dtypes) # 如果是object需要转换 # for col in data: # object to numeric if is numeric # if isinstance(data[col][0], int) or isinstance(data[col][0], float): # data[col] = pd.to_numeric(data[col], errors='coerce') # print('数据类型：', data.dtypes) print('前三行数据：', data.iloc[:3, :5]) # 看","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"看是否导入正确 print('样本情况', data.describe()) # 查看样本分布 sns.displot(data['土壤蒸发量(mm)'], kde=True) # 直方图折线图可视 !! 注意修改成某个列名 plt.savefig('picture/describe.jpg') data = pd.concat([data['10cm湿度(kg/m2)'], data['土壤蒸发量(mm)']], axis=1) # 1 !! 注意修改成某个列名 data.plot.scatter(x='10cm湿度(kg/m2)', y='土壤蒸发量(mm)', ylim=(0, 1666), c='c', cmap='coolwarm') # data = pd.concat([data['ALogp2'], data['AMR']], axis=1) # 1 !! 可选第二组对比 看它们之间的相关性 线性非线性 # data.plot.scatter(x='ALogp2', y='AMR', ylim=(0, 1666), c='c', cmap='coolwarm') plt","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_3","order":3,"summary":"看是否导入正确 print('样本情况', data.describe()) # 查看样本分布 sns.displot(data['土壤蒸发量(mm)'], kde=True) # 直方图折线图可视 !! 注意修改成某个列名 plt.savefig('picture/describe.jpg') data = pd.concat([data['10cm湿度(kg/m2)'], data['土壤蒸发量(mm)']], axis=1) # 1 !! 注意修改成某个列名 data.plot.scatter(x='10cm湿度(kg/m2)', y='土壤蒸发量(mm)', ylim=(0, 1666), c='c', cmap='coolwarm') # data = pd.concat([data['ALogp2'], data['AMR']], axis=1) # 1 !! 可选第二组对比 看它们之间的相关性 线性非线性 # data.plot.scatter(x='ALogp2', y='AMR', ylim=(0, 1666), c='c', cmap='coolwarm') plt","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":".show() def processNull(data): # https://blog.51cto.com/liguodong/3702149 # 1. 输出缺失率表格 建议结果放到excel，图好看 missing = data.isnull().sum().reset_index().rename(columns={0: 'missNum'})[1:] missing['missRate'] = missing['missNum'] / data.shape[0] # 计算缺失比例 miss_analogy = missing.sort_values(by='missRate', ascending=False) # 升序 miss_analogy.index = range(1, len(miss_analogy) + 1) # 排序后重新修改index print('前八变量的缺失率', miss_analogy[:5]) # 输出前8个 ！！ 解除注释 # 2. 输出缺失率图 取前8个遍历 plt.figure() plt.bar(np.arange(5), list(m","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_4","order":4,"summary":".show() def processNull(data): # https://blog.51cto.com/liguodong/3702149 # 1. 输出缺失率表格 建议结果放到excel，图好看 missing = data.isnull().sum().reset_index().rename(columns={0: 'missNum'})[1:] missing['missRate'] = missing['missNum'] / data.shape[0] # 计算缺失比例 miss_analogy = missing.sort_values(by='missRate', ascending=False) # 升序 miss_analogy.index = range(1, len(miss_analogy) + 1) # 排序后重新修改index print('前八变量的缺失率', miss_analogy[:5]) # 输出前8个 ！！ 解除注释 # 2. 输出缺失率图 取前8个遍历 plt.figure() plt.bar(np.arange(5), list(m","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"iss_analogy['missRate'].values)[:5], color=['red', 'steelblue', 'yellow']) plt.title('变量缺失率直方图') plt.xlabel('变量名') plt.ylabel('缺失率') plt.xticks(np.arange(5), list(miss_analogy['index'][:5])) # plt.xticks(rotation=90) for x, y in enumerate(list(miss_analogy['missRate'].values[:5])): plt.text(x, y + 0.02, '{:.2%}'.format(y), ha='center') #图片加text plt.ylim([0, 1]) # 3. 处理缺失值 删除缺失量大于阈值0.8 orig_col = data.columns # 设计删除列的操作时可以发现删除了什么列 del_col = [] data = data.dropna(axis=1, how='any', thresh=data.sha","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_5","order":5,"summary":"iss_analogy['missRate'].values)[:5], color=['red', 'steelblue', 'yellow']) plt.title('变量缺失率直方图') plt.xlabel('变量名') plt.ylabel('缺失率') plt.xticks(np.arange(5), list(miss_analogy['index'][:5])) # plt.xticks(rotation=90) for x, y in enumerate(list(miss_analogy['missRate'].values[:5])): plt.text(x, y + 0.02, '{:.2%}'.format(y), ha='center') #图片加text plt.ylim([0, 1]) # 3. 处理缺失值 删除缺失量大于阈值0.8 orig_col = data.columns # 设计删除列的操作时可以发现删除了什么列 del_col = [] data = data.dropna(axis=1, how='any', thresh=data.sha","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"pe[0] * 0.8) # 删除列 ！！ 解除注释 # data = data.dropna(axis=0, how='any', thresh=data.shape[1]*0.8) # 删除行 data.reset_index(drop=True, inplace=True) after_col = data.columns del_col.append(list(set(orig_col).difference(set(after_col)))) # https://cloud.tencent.com/developer/article/1705131 print('删除缺失量大于阈值0.8的变量：', del_col) plt.savefig('picture/nullV.jpg') plt.show() return data def interpolateData(data): # 填充缺失值 fig, axes = plt.subplots(figsize=(8, 4), sharex='all') axes.plot(data['积雪深度(mm)'], label='O","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_6","order":6,"summary":"pe[0] * 0.8) # 删除列 ！！ 解除注释 # data = data.dropna(axis=0, how='any', thresh=data.shape[1]*0.8) # 删除行 data.reset_index(drop=True, inplace=True) after_col = data.columns del_col.append(list(set(orig_col).difference(set(after_col)))) # https://cloud.tencent.com/developer/article/1705131 print('删除缺失量大于阈值0.8的变量：', del_col) plt.savefig('picture/nullV.jpg') plt.show() return data def interpolateData(data): # 填充缺失值 fig, axes = plt.subplots(figsize=(8, 4), sharex='all') axes.plot(data['积雪深度(mm)'], label='O","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"riginal Data', marker='*', markerfacecolor='blue') # 1 直接填充 \"\"\" 均值适用于定量数据 身高 年龄 mean() 中位数 正态分布 median() 众数适用于定性数据 性别 文化程度 data['S-ZORB.CAL_H2.PV'].mode()[0] method='pad/bfill' 取前/后数据填充 \"\"\" # data.fillna({'S-ZORB.CAL_H2.PV': data['S-ZORB.CAL_H2.PV'].mean()}, inplace=True) # 只修改一列 # data.fillna(data.mean(), inplace=True) # ！！ 选 直接填充 解除注释 # 2 插值法 \"\"\" ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’ 1.如果你的数据增长速率越来越快，可以选择 method='quadratic'二次插值。 2.如果数据集呈现出累计分布的样子，推荐选择 method='pchip'。 3.如果需要填补缺省值，以","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_7","order":7,"summary":"riginal Data', marker='*', markerfacecolor='blue') # 1 直接填充 \"\"\" 均值适用于定量数据 身高 年龄 mean() 中位数 正态分布 median() 众数适用于定性数据 性别 文化程度 data['S-ZORB.CAL_H2.PV'].mode()[0] method='pad/bfill' 取前/后数据填充 \"\"\" # data.fillna({'S-ZORB.CAL_H2.PV': data['S-ZORB.CAL_H2.PV'].mean()}, inplace=True) # 只修改一列 # data.fillna(data.mean(), inplace=True) # ！！ 选 直接填充 解除注释 # 2 插值法 \"\"\" ‘nearest’, ‘zero’, ‘slinear’, ‘quadratic’, ‘cubic’ 1.如果你的数据增长速率越来越快，可以选择 method='quadratic'二次插值。 2.如果数据集呈现出累计分布的样子，推荐选择 method='pchip'。 3.如果需要填补缺省值，以","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"平滑绘图为目标，推荐选择 method='akima'。 \"\"\" data.interpolate(method='quadratic', inplace=True) # ................！！ 解除注释 axes.plot(data['积雪深度(mm)'], 'r--', label='Filled Data', marker='h', markerfacecolor='red') axes.legend(['初始值', '拟合值'], loc=\"upper right\") plt.show() # ........................！！ 解除注释 return data def processZero(data): # 删除0值大于80%的列/行 Bijlsma 提出的 80%准则 zeros = [] for c in data: flat = data[c].to_numpy() cnt = np.where(flat, 0, True) if np.sum(cnt) \u003e 0.2 * data.shape[0]: # 获取0值过多的 列 zeros.","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_8","order":8,"summary":"平滑绘图为目标，推荐选择 method='akima'。 \"\"\" data.interpolate(method='quadratic', inplace=True) # ................！！ 解除注释 axes.plot(data['积雪深度(mm)'], 'r--', label='Filled Data', marker='h', markerfacecolor='red') axes.legend(['初始值', '拟合值'], loc=\"upper right\") plt.show() # ........................！！ 解除注释 return data def processZero(data): # 删除0值大于80%的列/行 Bijlsma 提出的 80%准则 zeros = [] for c in data: flat = data[c].to_numpy() cnt = np.where(flat, 0, True) if np.sum(cnt) \u003e 0.2 * data.shape[0]: # 获取0值过多的 列 zeros.","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"append(c) print('zeros error({}): '.format(len(zeros)), zeros) error = data[zeros[0]][data[zeros[0]] == 0] data_c = data[zeros[0]][data[zeros[0]] != 0] fig, ax2 = plt.subplots(figsize=(15, 9)) plt.scatter(data_c.index, data_c.values, color='g', alpha=0.6, label='正常值') plt.scatter(error.index, error.values, color='r', alpha=0.8, label='0值') ax2.set_xlabel('下标') ax2.set_ylabel('值') ax2.legend() plt.show() data.drop(columns=zeros, inplace=True) plt.savefig('picture/zeroV.jpg') return data def proce","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_9","order":9,"summary":"append(c) print('zeros error({}): '.format(len(zeros)), zeros) error = data[zeros[0]][data[zeros[0]] == 0] data_c = data[zeros[0]][data[zeros[0]] != 0] fig, ax2 = plt.subplots(figsize=(15, 9)) plt.scatter(data_c.index, data_c.values, color='g', alpha=0.6, label='正常值') plt.scatter(error.index, error.values, color='r', alpha=0.8, label='0值') ax2.set_xlabel('下标') ax2.set_ylabel('值') ax2.legend() plt.show() data.drop(columns=zeros, inplace=True) plt.savefig('picture/zeroV.jpg') return data def proce","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"ss3sigma(data): # 删除异常值 3sigma法 \"\"\" 需满足高斯分布，可假设为高斯分布强行用 1. 可以删除每列异常值大于阈值并且超过3sigma范围，对少于阈值但超过范围的进行赋值 没实现 2. 可以直接删除超过3sigma范围 \"\"\" sigma, sigma_cnt = [], [0] * data.shape[0] delrow_thres = 1 # 行异常值阈值 delcol_thres = 100 # 列异常值阈值 idx = [] sig = 0 for c in data: flat = data[c].to_numpy() try: mean = np.mean(flat) s = np.std(flat, ddof=1) except TypeError: continue flag = 0 for r in range(data.shape[0]): # 检查当前列的3sigma if abs(flat[r] - mean) \u003e s * 3: sigma_cnt[r] += 1 flag += 1 else: idx.append(r) if ","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_10","order":10,"summary":"ss3sigma(data): # 删除异常值 3sigma法 \"\"\" 需满足高斯分布，可假设为高斯分布强行用 1. 可以删除每列异常值大于阈值并且超过3sigma范围，对少于阈值但超过范围的进行赋值 没实现 2. 可以直接删除超过3sigma范围 \"\"\" sigma, sigma_cnt = [], [0] * data.shape[0] delrow_thres = 1 # 行异常值阈值 delcol_thres = 100 # 列异常值阈值 idx = [] sig = 0 for c in data: flat = data[c].to_numpy() try: mean = np.mean(flat) s = np.std(flat, ddof=1) except TypeError: continue flag = 0 for r in range(data.shape[0]): # 检查当前列的3sigma if abs(flat[r] - mean) \u003e s * 3: sigma_cnt[r] += 1 flag += 1 else: idx.append(r) if ","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"flag \u003e delrow_thres: # sig = 3 * s sigma.append(c) # print('del 3sigma({0}) column({1}): '.format(round(sig, 3), len(sigma)), sigma) # if len(sigma) \u003e 0: # draw_3sigma(data[sigma[0]]) # draw_3sigma(data['干重']) # data.drop(columns=sigma, inplace=True) # data.reset_index(drop=True) # 删除行 sigma_cntnp = np.array(sigma_cnt) where = np.where(sigma_cntnp \u003e 0) a = np.array(list(where)) a = a[0] # necessary？ print('del 3sigma row: ', len(a)) data.drop(index=a, inplace=True) data.reset_index(drop=True, in","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_11","order":11,"summary":"flag \u003e delrow_thres: # sig = 3 * s sigma.append(c) # print('del 3sigma({0}) column({1}): '.format(round(sig, 3), len(sigma)), sigma) # if len(sigma) \u003e 0: # draw_3sigma(data[sigma[0]]) # draw_3sigma(data['干重']) # data.drop(columns=sigma, inplace=True) # data.reset_index(drop=True) # 删除行 sigma_cntnp = np.array(sigma_cnt) where = np.where(sigma_cntnp \u003e 0) a = np.array(list(where)) a = a[0] # necessary？ print('del 3sigma row: ', len(a)) data.drop(index=a, inplace=True) data.reset_index(drop=True, in","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"place=True) return data, idx def processMaxMin(data): scope = pd.read_excel('附件四：354个操作变量信息.xlsx', usecols=[1, 3]) # 注意修改 scope = scope.to_numpy() scope = {n[0]: n[1].split('-') for n in scope} for k, v in scope.items(): mm = [] flag = 1 for value in v: if value == '' or value == '（' or value == '(': flag = 0 continue try: mm.append(float(value) if flag else -float(value)) except ValueError: value = re.findall(r'\\d+\\.?\\d*', value)[0] # 找浮点数 mm.append(float(value) if flag else -float(value)) flag","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_12","order":12,"summary":"place=True) return data, idx def processMaxMin(data): scope = pd.read_excel('附件四：354个操作变量信息.xlsx', usecols=[1, 3]) # 注意修改 scope = scope.to_numpy() scope = {n[0]: n[1].split('-') for n in scope} for k, v in scope.items(): mm = [] flag = 1 for value in v: if value == '' or value == '（' or value == '(': flag = 0 continue try: mm.append(float(value) if flag else -float(value)) except ValueError: value = re.findall(r'\\d+\\.?\\d*', value)[0] # 找浮点数 mm.append(float(value) if flag else -float(value)) flag","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":" = 1 if mm[0] \u003e mm[1]: print('数据error') scope[k] = mm for col in scope.keys(): for i in data[col].index: if scope[col][0] \u003e data[col][i] or data[col][i] \u003e scope[col][1]: # 删除最大最小不对的 行/样本 print('minmax error', i, data[col][i], scope[col], col) data.drop(index=i, inplace=True) data.reset_index(drop=True, inplace=True) return data if __name__ == '__main__': # 1. 读取数据 # file_name = r'C:\\Users\\Desktop\\2022年E题\\数据集\\监测点数据\\附件15：草原轮牧放牧样地群落结构监测数据集（2016年6月-2020年9' \\ # r'月）。/内蒙古自治区锡林郭勒盟典型草原轮牧放牧样地群落结构监测数据集（20","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_13","order":13,"summary":" = 1 if mm[0] \u003e mm[1]: print('数据error') scope[k] = mm for col in scope.keys(): for i in data[col].index: if scope[col][0] \u003e data[col][i] or data[col][i] \u003e scope[col][1]: # 删除最大最小不对的 行/样本 print('minmax error', i, data[col][i], scope[col], col) data.drop(index=i, inplace=True) data.reset_index(drop=True, inplace=True) return data if __name__ == '__main__': # 1. 读取数据 # file_name = r'C:\\Users\\Desktop\\2022年E题\\数据集\\监测点数据\\附件15：草原轮牧放牧样地群落结构监测数据集（2016年6月-2020年9' \\ # r'月）。/内蒙古自治区锡林郭勒盟典型草原轮牧放牧样地群落结构监测数据集（20","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"1.xlsx ' file_name = 'data/result.xlsx' sheet_name = 'Sheet1' # 注意修改 table = pd.read_excel(file_name, sheet_name, header=[0]) # 如果有多个列名 方便起见只取一个 # 2. 划分数据 if need # 注意索引还是原数据的索引 https://stackoverflow.com/questions/71679582/0-is-not-in-range-in-pandas sample285 = table[1:41] sample285.reset_index(drop=True, inplace=True) sample285 = sample285.copy() # 防止SettingWithCopyWarning sample310 = table[42:] sample310.reset_index(drop=True, inplace=True) data = table.iloc[:, 2:] # 排除年月 # 3. 查看数据情况 # descri","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_14","order":14,"summary":"1.xlsx ' file_name = 'data/result.xlsx' sheet_name = 'Sheet1' # 注意修改 table = pd.read_excel(file_name, sheet_name, header=[0]) # 如果有多个列名 方便起见只取一个 # 2. 划分数据 if need # 注意索引还是原数据的索引 https://stackoverflow.com/questions/71679582/0-is-not-in-range-in-pandas sample285 = table[1:41] sample285.reset_index(drop=True, inplace=True) sample285 = sample285.copy() # 防止SettingWithCopyWarning sample310 = table[42:] sample310.reset_index(drop=True, inplace=True) data = table.iloc[:, 2:] # 排除年月 # 3. 查看数据情况 # descri","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"beData(data) # 4. 处理缺失值 data = processNull(data) data = processZero(data) data, idx = process3sigma(data) # table = table.iloc[idx, 0] # data = processMaxMin(data) data = interpolateData(data) # print('删除前变量个数', len(table.columns)) # data.index = table.iloc[:, 0] # 将string列重新放回 # print('删除后变量个数', len(data.columns)) data.to_excel('Preprocess/pre_data.xlsx') 特征选择 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 4","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_15","order":15,"summary":"beData(data) # 4. 处理缺失值 data = processNull(data) data = processZero(data) data, idx = process3sigma(data) # table = table.iloc[idx, 0] # data = processMaxMin(data) data = interpolateData(data) # print('删除前变量个数', len(table.columns)) # data.index = table.iloc[:, 0] # 将string列重新放回 # print('删除后变量个数', len(data.columns)) data.to_excel('Preprocess/pre_data.xlsx') 特征选择 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 4","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"9 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 ","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_16","order":16,"summary":"9 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 ","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 ","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_17","order":17,"summary":"187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 ","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 ","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_18","order":18,"summary":"312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 ","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 def low_var_filter(data, names): # 低方差滤波 # 人","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_19","order":19,"summary":"437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 def low_var_filter(data, names): # 低方差滤波 # 人","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"工版 # var = data.var() # col = var.index # variable = [] # for i in range(len(var)): # if var[col[i]] \u0026lt; 1: # variable.append(col[[i]].format()[0]) # print(list(variable), var[variable[0]]) # data.drop(columns=variable, axis=1, inplace=True) data = data[:, 1:] # 排除time列 data = pd.DataFrame(data, columns=names[1:]) # 智能版 orig_col = data.columns selector = VarianceThreshold(threshold=1) # 阈值为\u0026lt;1 selector.fit(data) after_col = np.array(data.columns.format())[selector.get_support()] # 获得删除后列 del_","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_20","order":20,"summary":"工版 # var = data.var() # col = var.index # variable = [] # for i in range(len(var)): # if var[col[i]] \u0026lt; 1: # variable.append(col[[i]].format()[0]) # print(list(variable), var[variable[0]]) # data.drop(columns=variable, axis=1, inplace=True) data = data[:, 1:] # 排除time列 data = pd.DataFrame(data, columns=names[1:]) # 智能版 orig_col = data.columns selector = VarianceThreshold(threshold=1) # 阈值为\u0026lt;1 selector.fit(data) after_col = np.array(data.columns.format())[selector.get_support()] # 获得删除后列 del_","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["create"],"content":"col = list(set(orig_col).difference(set(after_col))) # 获得删除列 data = selector.fit_transform(data) print('低方差滤波删除列：', del_col) print('低方差删除后的矩阵shape：', data.shape) # data = pd.DataFrame(data, columns=after_col) # print(data[:5]) return data, after_col # data.to_excel('new_data.xlsx') def MICSelect(data, target, feature_name, k): def mic(x, y): m = MINE() m.compute_score(x, y) return m.mic(), 0.5 # n = data.shape[1] # 两两比较 https://zhuanlan.zhihu.com/p/53092905 # result = np.zeros([n, n]) # mine = M","date":"2022-10-16T20:58:19.149Z","objectID":"990aab6b1becce36b9f09d8faafd627a_21","order":21,"summary":"col = list(set(orig_col).difference(set(after_col))) # 获得删除列 data = selector.fit_transform(data) print('低方差滤波删除列：', del_col) print('低方差删除后的矩阵shape：', data.shape) # data = pd.DataFrame(data, columns=after_col) # print(data[:5]) return data, after_col # data.to_excel('new_data.xlsx') def MICSelect(data, target, feature_name, k): def mic(x, y): m = MINE() m.compute_score(x, y) return m.mic(), 0.5 # n = data.shape[1] # 两两比较 https://zhuanlan.zhihu.com/p/53092905 # result = np.zeros([n, n]) # mine = M","tags":["Python"],"title":"数学建模-数据分析题","url":"http://localhost:1313/archives/data-analysis/"},{"categories":["life"],"content":"原文网址 、 英文版磁链基本都是高清或4k版本，如有更清晰的版本，务必留言、 如需要磁力链可以鼠标移到链接上，右键复制链接地址1978老版本 注: 本指南对应从2003年开始上映的新版太空堡垒卡拉狄加系列， 为系列的重制版，有始有终，不需要从1978年原版开始看起。The Miniseries (迷你剧) Battlestar.Galactica.Miniseries.Part1 Battlestar.Galactica.Miniseries.Part2 Season 1 (第一季) Battlestar Galactica Season 1Season 2 (第二季) Battlestar Galactica Season 2 其中在第17集后看Battlestar Galactica Razor(Extended Version)这部电影的最后10分钟有几句台词是为第四季做的准备，如果在这里听到了那几句台词, 虽然算不上剧透，但是会影响这之后的感受，特别是第三季。 方法： 在那几句台词出现之前关闭声音和字幕，你只会看见画面上的人物在说话，但是你不会知道他们说的是什么。这几句台词过了","date":"2022-08-25T14:00:18.473Z","objectID":"932e14ba9f9a6a02072482279dbec07c_0","order":0,"summary":"原文网址 、 英文版磁链基本都是高清或4k版本，如有更清晰的版本，务必留言、 如需要磁力链可以鼠标移到链接上，右键复制链接地址1978老版本 注: 本指南对应从2003年开始上映的新版太空堡垒卡拉狄加系列， 为系列的重制版，有始有终，不需要从1978年原版开始看起。The Miniseries (迷你剧) Battlestar.Galactica.Miniseries.Part1 Battlestar.Galactica.Miniseries.Part2 Season 1 (第一季) Battlestar Galactica Season 1Season 2 (第二季) Battlestar Galactica Season 2 其中在第17集后看Battlestar Galactica Razor(Extended Version)这部电影的最后10分钟有几句台词是为第四季做的准备，如果在这里听到了那几句台词, 虽然算不上剧透，但是会影响这之后的感受，特别是第三季。 方法： 在那几句台词出现之前关闭声音和字幕，你只会看见画面上的人物在说话，但是你不会知道他们说的是什么。这几句台词过了","tags":["Movie"],"title":"《太空堡垒卡拉狄加》终极无剧透观影顺序指南+下载链接","url":"http://localhost:1313/archives/the-ultimate-battlestar-galactica-spoiler-free-viewing-order/"},{"categories":["life"],"content":"之后再把声音和字幕打开即可。 这样你会完整的享受完整个电影的故事，直到看完第三季后再回来听这几句台词即可，这几句台词发生在最后的10分钟里面（不算制作人员名单），所以你可以安心放心的看前90分钟。总共只有两处需要关闭声音和字幕，会在不剧透的前提下给予提示。 第一处：当Hybrid用手抓住Shaw的时候立即关闭声音和字幕（Hybrid可能翻译为混合体, Shaw可能翻译为肖），当Hybrid放手后即可打开声音和字幕。 第二处: 在第一处后不久, 当Red One开始与总部联系的时候(Red One可能翻译为红一号), 你会听见Red One说\"Actual, This is Red One, Come in\", 在这里即可关闭声音和字幕. 在红一号再次出现在画面上时即可打开声音和字幕. (其实在这之前就可以了, 不过实在是没有其他的线索可提供)可选项：Battlestar Galactica Razor Flashbacks(利刃 闪回, 网络剧, 共7集, 7集总时长18分钟左右) 之所以是可选项是因为这部所谓网络剧其实就是Razor电影的删减片段，有1到7的合集版。其中4个部分已经添","date":"2022-08-25T14:00:18.473Z","objectID":"932e14ba9f9a6a02072482279dbec07c_1","order":1,"summary":"之后再把声音和字幕打开即可。 这样你会完整的享受完整个电影的故事，直到看完第三季后再回来听这几句台词即可，这几句台词发生在最后的10分钟里面（不算制作人员名单），所以你可以安心放心的看前90分钟。总共只有两处需要关闭声音和字幕，会在不剧透的前提下给予提示。 第一处：当Hybrid用手抓住Shaw的时候立即关闭声音和字幕（Hybrid可能翻译为混合体, Shaw可能翻译为肖），当Hybrid放手后即可打开声音和字幕。 第二处: 在第一处后不久, 当Red One开始与总部联系的时候(Red One可能翻译为红一号), 你会听见Red One说\"Actual, This is Red One, Come in\", 在这里即可关闭声音和字幕. 在红一号再次出现在画面上时即可打开声音和字幕. (其实在这之前就可以了, 不过实在是没有其他的线索可提供)可选项：Battlestar Galactica Razor Flashbacks(利刃 闪回, 网络剧, 共7集, 7集总时长18分钟左右) 之所以是可选项是因为这部所谓网络剧其实就是Razor电影的删减片段，有1到7的合集版。其中4个部分已经添","tags":["Movie"],"title":"《太空堡垒卡拉狄加》终极无剧透观影顺序指南+下载链接","url":"http://localhost:1313/archives/the-ultimate-battlestar-galactica-spoiler-free-viewing-order/"},{"categories":["life"],"content":"加到加长版中，剩下的3个未加入电影的片段为1、2、7，这7集连起来是一个完整的故事，有兴趣的话可以完整看一遍。然后继续看完第二季。The Resistance (抵抗, 网络剧, 共10集, 10集总时长25分钟左右) Battlestar Galactica: The Resistance or youtobe 这部网络剧的作用是连接第二季和第三季，有1到10的合集版，十分推荐。Season 3 (第三季) Battlestar Galactica Season 3 上一季的Razor（静音部分） 是的，你现在可以去看那最后十分钟里面静音掉的台词了。这里也是本来这部电影上映的时期，如果可以的话可以看看这十分钟之前的一些内容，重新听听Hybrid之前说的那些话，你会十分惊讶你现在居然能够明白这些话的意思了。Season 4 (第四季) Battlestar Galactica Season 4He That Believeth In Me Six of One The Ties That Bind Escape Velocity The Road Less Traveled Faith","date":"2022-08-25T14:00:18.473Z","objectID":"932e14ba9f9a6a02072482279dbec07c_2","order":2,"summary":"加到加长版中，剩下的3个未加入电影的片段为1、2、7，这7集连起来是一个完整的故事，有兴趣的话可以完整看一遍。然后继续看完第二季。The Resistance (抵抗, 网络剧, 共10集, 10集总时长25分钟左右) Battlestar Galactica: The Resistance or youtobe 这部网络剧的作用是连接第二季和第三季，有1到10的合集版，十分推荐。Season 3 (第三季) Battlestar Galactica Season 3 上一季的Razor（静音部分） 是的，你现在可以去看那最后十分钟里面静音掉的台词了。这里也是本来这部电影上映的时期，如果可以的话可以看看这十分钟之前的一些内容，重新听听Hybrid之前说的那些话，你会十分惊讶你现在居然能够明白这些话的意思了。Season 4 (第四季) Battlestar Galactica Season 4He That Believeth In Me Six of One The Ties That Bind Escape Velocity The Road Less Traveled Faith","tags":["Movie"],"title":"《太空堡垒卡拉狄加》终极无剧透观影顺序指南+下载链接","url":"http://localhost:1313/archives/the-ultimate-battlestar-galactica-spoiler-free-viewing-order/"},{"categories":["life"],"content":" Guess What's Coming to Dinner Sine Qua Non The Hub Revelations Sometimes a Great Notion 11b. The Face of the Enemy、在线 这部网络剧十分推荐， 为之后发生的事情做了十分详细的铺垫，有1-10集的合集版。 A Disquite Follows My Soul (Extended Version) 53分钟左右加长版 The Oath Blood on the Scales No Exit 15b. The Plan (计划, 电影)\t这部电影本来是在全剧终后上映的，不过放在这里看效果最好。它将前两季用Cylon人的视角演绎了一遍，解答了很多问题(比如那个计划到底是什么!)，让你安心的通向结局。 16-19. 一直看到最后一集即可BSG之后的衍生作品 Caprica (全一季共18集) 这部剧的时间线是在BSG的前58年，很多人把这个剧当做前传放在BSG之前看，不过个人不推荐这么做：并不是这部剧不好，其原因是Caprica跟BSG太不一样了，导致很多人对BSG的内容产生了误解","date":"2022-08-25T14:00:18.473Z","objectID":"932e14ba9f9a6a02072482279dbec07c_3","order":3,"summary":" Guess What's Coming to Dinner Sine Qua Non The Hub Revelations Sometimes a Great Notion 11b. The Face of the Enemy、在线 这部网络剧十分推荐， 为之后发生的事情做了十分详细的铺垫，有1-10集的合集版。 A Disquite Follows My Soul (Extended Version) 53分钟左右加长版 The Oath Blood on the Scales No Exit 15b. The Plan (计划, 电影)\t这部电影本来是在全剧终后上映的，不过放在这里看效果最好。它将前两季用Cylon人的视角演绎了一遍，解答了很多问题(比如那个计划到底是什么!)，让你安心的通向结局。 16-19. 一直看到最后一集即可BSG之后的衍生作品 Caprica (全一季共18集) 这部剧的时间线是在BSG的前58年，很多人把这个剧当做前传放在BSG之前看，不过个人不推荐这么做：并不是这部剧不好，其原因是Caprica跟BSG太不一样了，导致很多人对BSG的内容产生了误解","tags":["Movie"],"title":"《太空堡垒卡拉狄加》终极无剧透观影顺序指南+下载链接","url":"http://localhost:1313/archives/the-ultimate-battlestar-galactica-spoiler-free-viewing-order/"},{"categories":["learn"],"content":"DIR难点： 现实中，数据不平衡随处可见，通常是带长尾的偏态分布，其中某些标签的值很少。解决不平衡的分类任务的方法具有局限性，它们只适合分类任务，主要关注于类别的不平衡，直接用于连续数据会产生歧义以及忽略了连续数据中每个数据周围的信息。解决不平衡的回归任务没有很好的探索过，没有考虑目标间的信息，同时对于极高维度的数据来说，线性插值不会产生有意义的样本解决方法： 提出了LDS由“Figure 2.” [Yang 等。, 2021, p. 3] 可以看出分类和连续的区别原因是所有不平衡学习方法是通过改善经验标签密度分布的不平衡来进行的，没有学习到临近标签的数据样本间的依赖性因此提出LDS，它提倡使用核密度估计来学习连续标签的不平衡区域由“Figure 3.” [Yang 等。, 2021, p. 3] 可以看出连续问题可能转化成分类问题，因此可以使用不平衡的分类方法，如重加权、重采样提出了FDS作者认为有目标空间的连续性，应该也有特征空间的连续性首先从“Figure 4.” [Yang 等。, 2021, p. 4] 可以看出在样本很多的区域，它们的均值和方差的余弦相似度相似且高，但是在少","date":"2022-08-17T21:59:05.186Z","objectID":"ec2fb3c5267bb437f778ae341fab7f99_0","order":0,"summary":"DIR难点： 现实中，数据不平衡随处可见，通常是带长尾的偏态分布，其中某些标签的值很少。解决不平衡的分类任务的方法具有局限性，它们只适合分类任务，主要关注于类别的不平衡，直接用于连续数据会产生歧义以及忽略了连续数据中每个数据周围的信息。解决不平衡的回归任务没有很好的探索过，没有考虑目标间的信息，同时对于极高维度的数据来说，线性插值不会产生有意义的样本解决方法： 提出了LDS由“Figure 2.” [Yang 等。, 2021, p. 3] 可以看出分类和连续的区别原因是所有不平衡学习方法是通过改善经验标签密度分布的不平衡来进行的，没有学习到临近标签的数据样本间的依赖性因此提出LDS，它提倡使用核密度估计来学习连续标签的不平衡区域由“Figure 3.” [Yang 等。, 2021, p. 3] 可以看出连续问题可能转化成分类问题，因此可以使用不平衡的分类方法，如重加权、重采样提出了FDS作者认为有目标空间的连续性，应该也有特征空间的连续性首先从“Figure 4.” [Yang 等。, 2021, p. 4] 可以看出在样本很多的区域，它们的均值和方差的余弦相似度相似且高，但是在少","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression笔记","url":"http://localhost:1313/archives/dir-note/"},{"categories":["learn"],"content":"样本区域也表现得很高（因为数据不平衡，它们从数据量大的区域学习它们学习到的值）因此提出FDS，它通过对称核来平衡目标的均值和协方差，进行特征空间分布平滑它可以整合到任何神经网络和改善标签不平衡的工作中来提升性能。整理出五个DIR基准数据集。实验及结果 应用不平衡回归任务的方法在高维数据上时性能不好，vanilla模型在manyshot区域易过拟合添加了LDS+FDS取得最好结果，并且提高了all-, many-, medium-, few-shot区域的性能LDS和FDS在有数据区域和无数据区域都取得收益，具体来说，内插和外插都有提升，内插最多。“Figure 8” [Yang 等。, 2021, p. 8] 表明了FDS可以很好的校准统计数据，使得尽在其周围具有高相似度，并随着目标值变大，相似度下降。此外运行统计数据和平滑统计数据的L1距离随训练进行而减少。Gaussian核带来最优结果LDS和FDS对不同的损失函数具有鲁棒性核大小最好为5，标准差最好为2，且都不同的超参数大小都有鲁棒性LDS和FDS对不同偏态标签密度的鲁棒性好另外发现了不平衡的分类方法在回归上应用不好的原因：首先，","date":"2022-08-17T21:59:05.186Z","objectID":"ec2fb3c5267bb437f778ae341fab7f99_1","order":1,"summary":"样本区域也表现得很高（因为数据不平衡，它们从数据量大的区域学习它们学习到的值）因此提出FDS，它通过对称核来平衡目标的均值和协方差，进行特征空间分布平滑它可以整合到任何神经网络和改善标签不平衡的工作中来提升性能。整理出五个DIR基准数据集。实验及结果 应用不平衡回归任务的方法在高维数据上时性能不好，vanilla模型在manyshot区域易过拟合添加了LDS+FDS取得最好结果，并且提高了all-, many-, medium-, few-shot区域的性能LDS和FDS在有数据区域和无数据区域都取得收益，具体来说，内插和外插都有提升，内插最多。“Figure 8” [Yang 等。, 2021, p. 8] 表明了FDS可以很好的校准统计数据，使得尽在其周围具有高相似度，并随着目标值变大，相似度下降。此外运行统计数据和平滑统计数据的L1距离随训练进行而减少。Gaussian核带来最优结果LDS和FDS对不同的损失函数具有鲁棒性核大小最好为5，标准差最好为2，且都不同的超参数大小都有鲁棒性LDS和FDS对不同偏态标签密度的鲁棒性好另外发现了不平衡的分类方法在回归上应用不好的原因：首先，","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression笔记","url":"http://localhost:1313/archives/dir-note/"},{"categories":["learn"],"content":"忽略了连续目标周围数据的相似性；其次，分类无法在连续空间内进行外插和内插，因此无法处理缺失数据其他博客介绍https://blog.csdn.net/qq_43310834/article/details/119969513https://blog.csdn.net/qq_43349542/article/details/120370049","date":"2022-08-17T21:59:05.186Z","objectID":"ec2fb3c5267bb437f778ae341fab7f99_2","order":2,"summary":"忽略了连续目标周围数据的相似性；其次，分类无法在连续空间内进行外插和内插，因此无法处理缺失数据其他博客介绍https://blog.csdn.net/qq_43310834/article/details/119969513https://blog.csdn.net/qq_43349542/article/details/120370049","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression笔记","url":"http://localhost:1313/archives/dir-note/"},{"categories":["learn"],"content":"非对照翻译，有所简略。翻译不对，尽情谅解，可留言 因为halo渲染的原因，有些地方可能不对，请留言 作者解释 and paper自己做的笔记 Abstract Real-world data often exhibit imbalanced distributions, where certain target values have significantly fewer observations. Existing techniques for dealing with imbalanced data focus on targets with categorical indices, i.e., different classes. However, many tasks involve continuous targets, where hard boundaries between classes do not exist. We define Deep Imbalanced Regression (DIR) as learning from such imbalanced ","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_0","order":0,"summary":"非对照翻译，有所简略。翻译不对，尽情谅解，可留言 因为halo渲染的原因，有些地方可能不对，请留言 作者解释 and paper自己做的笔记 Abstract Real-world data often exhibit imbalanced distributions, where certain target values have significantly fewer observations. Existing techniques for dealing with imbalanced data focus on targets with categorical indices, i.e., different classes. However, many tasks involve continuous targets, where hard boundaries between classes do not exist. We define Deep Imbalanced Regression (DIR) as learning from such imbalanced ","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"data with continuous targets, dealing with potential missing data for certain target values, and generalizing to the entire target range. Motivated by the intrinsic difference between categorical and continuous label space, we propose distribution smoothing for both labels and features, which explicitly acknowledges the effects of nearby targets, and calibrates both label and learned feature distributions. We curate and benchmark large-scale DIR datasets from common real-world tasks in computer ","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_1","order":1,"summary":"data with continuous targets, dealing with potential missing data for certain target values, and generalizing to the entire target range. Motivated by the intrinsic difference between categorical and continuous label space, we propose distribution smoothing for both labels and features, which explicitly acknowledges the effects of nearby targets, and calibrates both label and learned feature distributions. We curate and benchmark large-scale DIR datasets from common real-world tasks in computer ","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"vision, natural language processing, and healthcare domains. Extensive experiments verify the superior performance of our strategies. Our work fills the gap in benchmarks and techniques for practical imbalanced regression problems. Code and data are available at: https://github.com/YyzHarry/imbalanced-regression.现实世界的数据往往是不平衡分布，其中某些target值的观测数据很少。处理不平衡数据的现存方法都侧重于具有分类索引的target（已经标好数据的数据集？数据都标出了类别），如不同的类别。然而，很多任务涉及到连续目标，其中类之间不存在清晰边界。我们称深度不平衡回归（DIR）为从此类含连续目标的不平衡数据中学习，处理某些target值的潜在缺失值，并泛化到整个target范","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_2","order":2,"summary":"vision, natural language processing, and healthcare domains. Extensive experiments verify the superior performance of our strategies. Our work fills the gap in benchmarks and techniques for practical imbalanced regression problems. Code and data are available at: https://github.com/YyzHarry/imbalanced-regression.现实世界的数据往往是不平衡分布，其中某些target值的观测数据很少。处理不平衡数据的现存方法都侧重于具有分类索引的target（已经标好数据的数据集？数据都标出了类别），如不同的类别。然而，很多任务涉及到连续目标，其中类之间不存在清晰边界。我们称深度不平衡回归（DIR）为从此类含连续目标的不平衡数据中学习，处理某些target值的潜在缺失值，并泛化到整个target范","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"围。受分类和连续标签空间之间固有差异的激发，我们建议对标签和特征的进行平滑分布，这承认了临近目标的影响，并校准标签和学习到的特征分布。我们从计算机视觉、自然语言处理和医疗领域的常见现实世界任务中评估该大型 DIR 数据集。大量实验验证了我们策略的卓越性能。我们的工作填补了实际中的不平衡回归问题的基准数据集和技术方面的空白。Introduction Data imbalance is ubiquitous and inherent in the real world. Rather than preserving an ideal uniform distribution over each category, the data often exhibit skewed distributions with a long tail (Buda et al., 2018; Liu et al., 2019), where certain target values have significantly fewer observations. This phenomenon poses gr","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_3","order":3,"summary":"围。受分类和连续标签空间之间固有差异的激发，我们建议对标签和特征的进行平滑分布，这承认了临近目标的影响，并校准标签和学习到的特征分布。我们从计算机视觉、自然语言处理和医疗领域的常见现实世界任务中评估该大型 DIR 数据集。大量实验验证了我们策略的卓越性能。我们的工作填补了实际中的不平衡回归问题的基准数据集和技术方面的空白。Introduction Data imbalance is ubiquitous and inherent in the real world. Rather than preserving an ideal uniform distribution over each category, the data often exhibit skewed distributions with a long tail (Buda et al., 2018; Liu et al., 2019), where certain target values have significantly fewer observations. This phenomenon poses gr","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"eat challenges for deep recognition models, and has motivated many prior techniques for addressing data imbalance (Cao et al., 2019; Cui et al., 2019; Huang et al., 2019; Liu et al., 2019; Tang et al., 2020).在现实中，数据的不平衡是常见且固有的。与在每个类别上保持理想的均匀分布不同，数据经常表现出带有长尾的偏态分布，其中某些目标值的观测值十分少。该现象对深度识别模型提出了巨大的挑战，并激发许多现有技术去处理数据不平衡。Existing solutions for learning from imbalanced data, however, focus on targets with categorical indices, i.e., the targets are different classes. However, many real-world tasks involve","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_4","order":4,"summary":"eat challenges for deep recognition models, and has motivated many prior techniques for addressing data imbalance (Cao et al., 2019; Cui et al., 2019; Huang et al., 2019; Liu et al., 2019; Tang et al., 2020).在现实中，数据的不平衡是常见且固有的。与在每个类别上保持理想的均匀分布不同，数据经常表现出带有长尾的偏态分布，其中某些目标值的观测值十分少。该现象对深度识别模型提出了巨大的挑战，并激发许多现有技术去处理数据不平衡。Existing solutions for learning from imbalanced data, however, focus on targets with categorical indices, i.e., the targets are different classes. However, many real-world tasks involve","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":" continuous and even infinite target values. For example, in vision applications, one needs to infer the age of different people based on their visual appearances, where age is a continuous target and can be highly imbalanced. Treating different ages as distinct classes is unlikely to yield the best results because it does not take advantage of the similarity between people with nearby ages. Similar issues happen in medical applications since many health metrics including heart rate, blood press","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_5","order":5,"summary":" continuous and even infinite target values. For example, in vision applications, one needs to infer the age of different people based on their visual appearances, where age is a continuous target and can be highly imbalanced. Treating different ages as distinct classes is unlikely to yield the best results because it does not take advantage of the similarity between people with nearby ages. Similar issues happen in medical applications since many health metrics including heart rate, blood press","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"ure, and oxygen saturation, are continuous and often have skewed distributions across patient populations.然而，现有从不平衡数据中学习的方案侧重于带分类索引的目标，如目标是不同的类别（有多个目标还是目标有多个label值？应该是每个目标都标出了独立类别）。但，许多现实任务涉及连续且无限的目标值。如，在视觉应用中，需要根据他们的外貌来推断他们的年龄，其中年龄是连续值并且可能高度不平衡。把不同年龄视为独立类别不太可能产生最佳结果，因为它没有利用年龄相近的人的相似性。类似的问题也发生在医疗应用中，因为包括心率、血压和血氧饱和度在内的许多健康指标是连续的，并且在患者群体中通常是偏态分布。Figure 1. Deep Imbalanced Regression (DIR) aims to learn from imbalanced data with continuous targets, tackle potential missing data for certain regions, ","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_6","order":6,"summary":"ure, and oxygen saturation, are continuous and often have skewed distributions across patient populations.然而，现有从不平衡数据中学习的方案侧重于带分类索引的目标，如目标是不同的类别（有多个目标还是目标有多个label值？应该是每个目标都标出了独立类别）。但，许多现实任务涉及连续且无限的目标值。如，在视觉应用中，需要根据他们的外貌来推断他们的年龄，其中年龄是连续值并且可能高度不平衡。把不同年龄视为独立类别不太可能产生最佳结果，因为它没有利用年龄相近的人的相似性。类似的问题也发生在医疗应用中，因为包括心率、血压和血氧饱和度在内的许多健康指标是连续的，并且在患者群体中通常是偏态分布。Figure 1. Deep Imbalanced Regression (DIR) aims to learn from imbalanced data with continuous targets, tackle potential missing data for certain regions, ","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"and generalize to the entire target range.图一 DIR旨在从带连续目标的不平衡数据中学习，解决某些区域的潜在缺失数据并泛化到整个目标范围In this work, we systematically investigate Deep Imbalanced Regression (DIR) arising in real-world settings (see Fig. 1). We define DIR as learning continuous targets from natural imbalanced data, dealing with potentially missing data for certain target values, and generalizing to a test set that is balanced over the entire range of continuous target values. This definition is analogous to the class imbalanc","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_7","order":7,"summary":"and generalize to the entire target range.图一 DIR旨在从带连续目标的不平衡数据中学习，解决某些区域的潜在缺失数据并泛化到整个目标范围In this work, we systematically investigate Deep Imbalanced Regression (DIR) arising in real-world settings (see Fig. 1). We define DIR as learning continuous targets from natural imbalanced data, dealing with potentially missing data for certain target values, and generalizing to a test set that is balanced over the entire range of continuous target values. This definition is analogous to the class imbalanc","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"e problem (Liu et al., 2019), but focuses on the continuous setting.在这项工作中，我们系统地研究了在现实中出现的DIR。我们把DIR定义为从自然的不平衡数据中学习到连续的目标，然后处理某些目标值潜在缺失数据，并泛化到整个连续目标值范围内是平衡的测试集。这个定义类似于类不平衡问题，但侧重于连续。DIR brings new challenges distinct from its classification counterpart. First, given continuous (potentially infinite) target values, the hard boundaries between classes no longer exist, causing ambiguity when directly applying traditional imbalanced classification methods such as re-sampling and re-weighting. Moreove","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_8","order":8,"summary":"e problem (Liu et al., 2019), but focuses on the continuous setting.在这项工作中，我们系统地研究了在现实中出现的DIR。我们把DIR定义为从自然的不平衡数据中学习到连续的目标，然后处理某些目标值潜在缺失数据，并泛化到整个连续目标值范围内是平衡的测试集。这个定义类似于类不平衡问题，但侧重于连续。DIR brings new challenges distinct from its classification counterpart. First, given continuous (potentially infinite) target values, the hard boundaries between classes no longer exist, causing ambiguity when directly applying traditional imbalanced classification methods such as re-sampling and re-weighting. Moreove","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"r, continuous labels inherently possess a meaningful distance between targets, which has implication for how we should interpret data imbalance. For example, say two target labels $t1$ and $t2$ have a small number of observations in training data. However, $t1$ is in a highly represented neighborhood (i.e., there are many samples in the range $\\left [ t1- \\bigtriangleup , t1+ \\bigtriangleup \\right ]$), while $t2$ is in a weakly represented neighborhood. In this case,$t1$ does not suffer from the","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_9","order":9,"summary":"r, continuous labels inherently possess a meaningful distance between targets, which has implication for how we should interpret data imbalance. For example, say two target labels $t1$ and $t2$ have a small number of observations in training data. However, $t1$ is in a highly represented neighborhood (i.e., there are many samples in the range $\\left [ t1- \\bigtriangleup , t1+ \\bigtriangleup \\right ]$), while $t2$ is in a weakly represented neighborhood. In this case,$t1$ does not suffer from the","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":" same level of imbalance as $t2$. Finally, unlike classification, certain target values may have no data at all, which motivates the need for target extrapolation \u0026 interpolation. DIR带来了不同于其它分类任务的新挑战。首先，给定了连续（可能无限的）目标值，类间的边界不再存在，从而直接使用传统的不平衡分类方法（如重采样和重加权）时会导致歧义。此外，连续标签在目标之间本身具有有意义的distance，这对我们如何解释数据不平衡有影响。如，假设两个目标标签$t1$和$t2$在训练集中只有小部分的观测值。然而$t1$在一个相当高的表示域内（即，在$\\left [ t1- \\bigtriangleup , t1+ \\bigtriangleup \\right ]$ 内有许多样本，而$t2$在一个低的表示域内）在这种例子下，$t1$不会遭受与$t2$相同程度的不平衡。最后，不同于分类任务，某些目标值可能根本没有数据，这激","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_10","order":10,"summary":" same level of imbalance as $t2$. Finally, unlike classification, certain target values may have no data at all, which motivates the need for target extrapolation \u0026 interpolation. DIR带来了不同于其它分类任务的新挑战。首先，给定了连续（可能无限的）目标值，类间的边界不再存在，从而直接使用传统的不平衡分类方法（如重采样和重加权）时会导致歧义。此外，连续标签在目标之间本身具有有意义的distance，这对我们如何解释数据不平衡有影响。如，假设两个目标标签$t1$和$t2$在训练集中只有小部分的观测值。然而$t1$在一个相当高的表示域内（即，在$\\left [ t1- \\bigtriangleup , t1+ \\bigtriangleup \\right ]$ 内有许多样本，而$t2$在一个低的表示域内）在这种例子下，$t1$不会遭受与$t2$相同程度的不平衡。最后，不同于分类任务，某些目标值可能根本没有数据，这激","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"发了对目标extrapolation 和 interpolation的需求。In this paper, we propose two simple yet effective methods for addressing DIR: label distribution smoothing (LDS) and feature distribution smoothing (FDS). A key idea underlying both approaches is to leverage the similarity between nearby targets by employing a kernel distribution to perform explicit distribution smoothing in the label and feature spaces. Both techniques can be easily embedded into existing deep networks and allow optimization in an end-to-e","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_11","order":11,"summary":"发了对目标extrapolation 和 interpolation的需求。In this paper, we propose two simple yet effective methods for addressing DIR: label distribution smoothing (LDS) and feature distribution smoothing (FDS). A key idea underlying both approaches is to leverage the similarity between nearby targets by employing a kernel distribution to perform explicit distribution smoothing in the label and feature spaces. Both techniques can be easily embedded into existing deep networks and allow optimization in an end-to-e","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"nd fashion. We verify that our techniques not only successfully calibrate for the intrinsic underlying imbalance, but also provide large and consistent gains when combined with other methods. To support practical evaluation of imbalanced regression, we curate and benchmark large-scale DIR datasets for common real-world tasks in computer vision, natural language processing, and healthcare. They range from single-value prediction such as age, text similarity score, health condition score, to dense","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_12","order":12,"summary":"nd fashion. We verify that our techniques not only successfully calibrate for the intrinsic underlying imbalance, but also provide large and consistent gains when combined with other methods. To support practical evaluation of imbalanced regression, we curate and benchmark large-scale DIR datasets for common real-world tasks in computer vision, natural language processing, and healthcare. They range from single-value prediction such as age, text similarity score, health condition score, to dense","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"-value prediction such as depth. We further set up benchmarks for proper DIR performance evaluation.在本文中，我们提出两个简单高效的方法来解决DIR：标签分布平滑和特征分布平滑。两个方法的关键思想是通过使用核分布在标签和特征空间中执行显式的分布平滑来利用临近目标间的相似性。每个方法都能轻易嵌入到现在的深度网络中并允许以端到端的方式进行优化。我们验证了我们的方法不仅成功地校准了固有的潜在不平衡，而且与其他方法结合时提供了巨大而一致的收益。为了支持不平衡回归的实际评估，我们为计算机视觉、自然语言处理和医疗中的常见现实任务中整理了和基准测试了大规模 DIR 数据集。这些数据集从单值预测（如年龄，文本相似度得分和健康状况得分）到密集值的预测（如深度）。我们进一步为合适的DIR性能评估建立了基准。Our contributions are as follows:We formally define the DIR task as learning from imbalanced data with","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_13","order":13,"summary":"-value prediction such as depth. We further set up benchmarks for proper DIR performance evaluation.在本文中，我们提出两个简单高效的方法来解决DIR：标签分布平滑和特征分布平滑。两个方法的关键思想是通过使用核分布在标签和特征空间中执行显式的分布平滑来利用临近目标间的相似性。每个方法都能轻易嵌入到现在的深度网络中并允许以端到端的方式进行优化。我们验证了我们的方法不仅成功地校准了固有的潜在不平衡，而且与其他方法结合时提供了巨大而一致的收益。为了支持不平衡回归的实际评估，我们为计算机视觉、自然语言处理和医疗中的常见现实任务中整理了和基准测试了大规模 DIR 数据集。这些数据集从单值预测（如年龄，文本相似度得分和健康状况得分）到密集值的预测（如深度）。我们进一步为合适的DIR性能评估建立了基准。Our contributions are as follows:We formally define the DIR task as learning from imbalanced data with","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":" continuous targets, and generalizing to the entire target range. DIR provides thorough and unbiased evaluation of learning algorithms in practical settings. We develop two simple, effective, and interpretable algorithms for DIR, LDS and FDS, which exploit the similarity between nearby targets in both label and feature space. We curate benchmark DIR datasets in different domains: computer vision, natural language processing, and healthcare. We set up strong baselines as well as benchmarks for pr","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_14","order":14,"summary":" continuous targets, and generalizing to the entire target range. DIR provides thorough and unbiased evaluation of learning algorithms in practical settings. We develop two simple, effective, and interpretable algorithms for DIR, LDS and FDS, which exploit the similarity between nearby targets in both label and feature space. We curate benchmark DIR datasets in different domains: computer vision, natural language processing, and healthcare. We set up strong baselines as well as benchmarks for pr","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"oper DIR performance evaluation. Extensive experiments on large-scale DIR datasets verify the consistent and superior performance of our strategies. 我们的贡献如下：我们将DIR任务定义为从带连续目标的不平衡数据中学习，并泛化到整个目标范围内。DIR在实际环境中对学习算法进行完全的公正的评估。 我们为DIR、LDS和FDS设计了两个简单高效且可解释的算法，算法利用了标签和特征空间中临近目标的相似性 我们在不同领域管理DIR基准数据集。我们为DIR性能评估建立了强大的基线和基准。 在大规模DIR数据集上进行的大量实验验证了我们方法的一致性和卓越的性能。 Related Work Imbalanced Classification. Much prior work has focused on the imbalanced classification problem (also referred to as long-tailed recog","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_15","order":15,"summary":"oper DIR performance evaluation. Extensive experiments on large-scale DIR datasets verify the consistent and superior performance of our strategies. 我们的贡献如下：我们将DIR任务定义为从带连续目标的不平衡数据中学习，并泛化到整个目标范围内。DIR在实际环境中对学习算法进行完全的公正的评估。 我们为DIR、LDS和FDS设计了两个简单高效且可解释的算法，算法利用了标签和特征空间中临近目标的相似性 我们在不同领域管理DIR基准数据集。我们为DIR性能评估建立了强大的基线和基准。 在大规模DIR数据集上进行的大量实验验证了我们方法的一致性和卓越的性能。 Related Work Imbalanced Classification. Much prior work has focused on the imbalanced classification problem (also referred to as long-tailed recog","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"nition (Liu et al., 2019)). Past solutions can be divided into data-based and model-based solutions: Data-based solutions either over-sample the minority class or under-sample the majority (Chawla et al., 2002; Garc´ıa \u0026 Herrera, 2009; He et al., 2008). For example, SMOTE generates synthetic samples for minority classes by linearly interpolating samples in the same class (Chawla et al., 2002). Model-based solutions include re-weighting or adjusting the loss function to compensate for class imbal","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_16","order":16,"summary":"nition (Liu et al., 2019)). Past solutions can be divided into data-based and model-based solutions: Data-based solutions either over-sample the minority class or under-sample the majority (Chawla et al., 2002; Garc´ıa \u0026 Herrera, 2009; He et al., 2008). For example, SMOTE generates synthetic samples for minority classes by linearly interpolating samples in the same class (Chawla et al., 2002). Model-based solutions include re-weighting or adjusting the loss function to compensate for class imbal","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"ance (Cao et al., 2019; Cui et al., 2019; Dong et al., 2019; Huang et al., 2016; 2019), and leveraging relevant learning paradigms, including transfer learning (Yin et al., 2019), metric learning (Zhang et al., 2017), meta-learning (Shu et al., 2019), and two-stage training (Kang et al., 2020). Recent studies have also discovered that semi-supervised learning and selfsupervised learning lead to better imbalanced classification results (Yang \u0026 Xu, 2020). In contrast to these past work, we identif","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_17","order":17,"summary":"ance (Cao et al., 2019; Cui et al., 2019; Dong et al., 2019; Huang et al., 2016; 2019), and leveraging relevant learning paradigms, including transfer learning (Yin et al., 2019), metric learning (Zhang et al., 2017), meta-learning (Shu et al., 2019), and two-stage training (Kang et al., 2020). Recent studies have also discovered that semi-supervised learning and selfsupervised learning lead to better imbalanced classification results (Yang \u0026 Xu, 2020). In contrast to these past work, we identif","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"y the limitations of applying class imbalance methods to regression problems, and introduce new techniques particularly suitable for learning continuous target values. 不平衡分类。大量的先前工作都集中于不平衡分类问题（也称为长尾识别问题）上。过去的解决方案可以分为基于数据和基于模型：基于数据的方案要么在少数类上过采样或在大多数上缺采样。如，SMOTE为少数类别生成人造样本通过在相同类别的样本中线性插值。基于模型的方案包括重加权或调整损失函数来弥补类别不平衡（yolo的大小目标的超参数），并利用相关的学习范式，包括迁移学习、度量学习、元学习和二阶段训练。最近研究也发现半监督学习和自监督学习会产生不平衡分类问题的好结果。与过去工作相比，我们发现在回归问题上应用类别不平衡方法的局限性，并引入特别适合学习连续目标值的新方法。Imbalanced Regression. Regression over imbalanced dat","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_18","order":18,"summary":"y the limitations of applying class imbalance methods to regression problems, and introduce new techniques particularly suitable for learning continuous target values. 不平衡分类。大量的先前工作都集中于不平衡分类问题（也称为长尾识别问题）上。过去的解决方案可以分为基于数据和基于模型：基于数据的方案要么在少数类上过采样或在大多数上缺采样。如，SMOTE为少数类别生成人造样本通过在相同类别的样本中线性插值。基于模型的方案包括重加权或调整损失函数来弥补类别不平衡（yolo的大小目标的超参数），并利用相关的学习范式，包括迁移学习、度量学习、元学习和二阶段训练。最近研究也发现半监督学习和自监督学习会产生不平衡分类问题的好结果。与过去工作相比，我们发现在回归问题上应用类别不平衡方法的局限性，并引入特别适合学习连续目标值的新方法。Imbalanced Regression. Regression over imbalanced dat","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"a is not as well explored. Most of the work on this topic is a direct adaptation of the SMOTE algorithm to regression scenarios (Branco et al., 2017; 2018; Torgo et al., 2013). Synthetic samples are created for pre-defined rare target regions by either directly interpolating both inputs and targets (Torgo et al., 2013), or using Gaussian noise augmentation (Branco et al., 2017). A bagging-based ensemble method that incorporates multiple data pre-processing steps has also been introduced (Branco ","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_19","order":19,"summary":"a is not as well explored. Most of the work on this topic is a direct adaptation of the SMOTE algorithm to regression scenarios (Branco et al., 2017; 2018; Torgo et al., 2013). Synthetic samples are created for pre-defined rare target regions by either directly interpolating both inputs and targets (Torgo et al., 2013), or using Gaussian noise augmentation (Branco et al., 2017). A bagging-based ensemble method that incorporates multiple data pre-processing steps has also been introduced (Branco ","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"et al., 2018). However, there exist several intrinsic drawbacks for these methods. First, they fail to take the distance between targets into account, and rather heuristically divide the dataset into rare and frequent sets, then plug in classification-based methods. Moreover, modern data is of extremely high dimension (e.g., images and physiological signals); linear interpolation of two samples of such data does not lead to meaningful new synthetic samples. Our methods are intrinsically differen","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_20","order":20,"summary":"et al., 2018). However, there exist several intrinsic drawbacks for these methods. First, they fail to take the distance between targets into account, and rather heuristically divide the dataset into rare and frequent sets, then plug in classification-based methods. Moreover, modern data is of extremely high dimension (e.g., images and physiological signals); linear interpolation of two samples of such data does not lead to meaningful new synthetic samples. Our methods are intrinsically differen","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"t from past work in their approach. They can be combined with existing methods to improve their performance, as we show in Sec. 4. Further, our approaches are tested on large-scale real-world datasets in computer vision, NLP, and healthcare.不平衡回归。在不平衡数据上回归也没有很好的探索过。大多数的工作是SMOTE算法的直接调整到回归场景。通过直接在输入和目标上插值或使用高斯噪声增强技术，来为预定义的稀少目标区域（样本很少的地方）创造人造样本。还引入一个基于bagging的集成方法，它包含多个数据预处理步骤。但是，这些方法存在几个固有的缺陷。首先，它们没有考虑目标间的distance，而是启发式地把数据集分成rare集和frequent集，然后插入基于分类的方法。此外，极高维度的现代数据（如，图片和生理信号）对此类数据的两个样本进行线性插值不会产生有","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_21","order":21,"summary":"t from past work in their approach. They can be combined with existing methods to improve their performance, as we show in Sec. 4. Further, our approaches are tested on large-scale real-world datasets in computer vision, NLP, and healthcare.不平衡回归。在不平衡数据上回归也没有很好的探索过。大多数的工作是SMOTE算法的直接调整到回归场景。通过直接在输入和目标上插值或使用高斯噪声增强技术，来为预定义的稀少目标区域（样本很少的地方）创造人造样本。还引入一个基于bagging的集成方法，它包含多个数据预处理步骤。但是，这些方法存在几个固有的缺陷。首先，它们没有考虑目标间的distance，而是启发式地把数据集分成rare集和frequent集，然后插入基于分类的方法。此外，极高维度的现代数据（如，图片和生理信号）对此类数据的两个样本进行线性插值不会产生有","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"意义的新合成样本。我们的方法本质上同先前方法不同。它们可以结合现有方法来提高性能，如Sec.4所示。此外，我们的方法在视觉、NLP和医疗的大规模数据集上测试过。 Methods Problem Setting. $ \\left\\{\\left(x_i,y_i\\right)\\right\\}_{i=1}^N$ be a training set, where$x_i\\in \\mathbb{R} ^d $ denotes the input and$y_i\\in \\mathbb{R}$ is the label, which is a continuous target. We introduce an additional structure for the label space $\\mathcal{Y}$ , where we divide $\\mathcal{Y}$ into $B$ groups (bins) with equal intervals, i.e., $\\left [ y_0, y_1\\right ), \\left [ y_1, y_2\\right ), \\cdots ","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_22","order":22,"summary":"意义的新合成样本。我们的方法本质上同先前方法不同。它们可以结合现有方法来提高性能，如Sec.4所示。此外，我们的方法在视觉、NLP和医疗的大规模数据集上测试过。 Methods Problem Setting. $ \\left\\{\\left(x_i,y_i\\right)\\right\\}_{i=1}^N$ be a training set, where$x_i\\in \\mathbb{R} ^d $ denotes the input and$y_i\\in \\mathbb{R}$ is the label, which is a continuous target. We introduce an additional structure for the label space $\\mathcal{Y}$ , where we divide $\\mathcal{Y}$ into $B$ groups (bins) with equal intervals, i.e., $\\left [ y_0, y_1\\right ), \\left [ y_1, y_2\\right ), \\cdots ","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":", \\left [ y_{B-1}, y_B\\right )$. Throughout the paper, we use $b \\in \\mathcal{B}$ to denote the group index of the target value, where $\\mathcal{B} = \\left { 1, \\dots , B\\right } \\subset \\mathbb{Z}^+$ is the index space. In practice, the defined bins reflect a minimum resolution we care for grouping data in a regression task. For instance, in age estimation, we could define $\\delta y \\triangleq y_{b+1}-y_{b}=1$, showing a minimum age difference of 1 is of interest. Finally, we denote $\\mathrm {z","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_23","order":23,"summary":", \\left [ y_{B-1}, y_B\\right )$. Throughout the paper, we use $b \\in \\mathcal{B}$ to denote the group index of the target value, where $\\mathcal{B} = \\left { 1, \\dots , B\\right } \\subset \\mathbb{Z}^+$ is the index space. In practice, the defined bins reflect a minimum resolution we care for grouping data in a regression task. For instance, in age estimation, we could define $\\delta y \\triangleq y_{b+1}-y_{b}=1$, showing a minimum age difference of 1 is of interest. Finally, we denote $\\mathrm {z","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"} =f\\left ( x;\\theta \\right )$as the feature for $\\mathrm {x}$, where $f\\left ( x;\\theta \\right )$ is parameterized by a deep neural network model with parameter $\\theta$. The final prediction $\\hat{y}$ is given by a regression function $g(\\cdot)$ that operates over $\\mathbf{ \\mathrm {z}}$.问题设置。让 $\\left { \\left ( x_i, y_i \\right ) \\right }^N_{i=1}$作为训练集，其中$x_i\\in \\mathbb{R} ^d$表示输入，$y_i\\in \\mathbb{R}$表示标签，是连续目标值。我们为标签空间$\\mathcal{Y}$引入额外的结构，其中我们把$\\mathcal{Y}$分成等间隔的B组（箱），即$\\left [ y_0, y_1\\right )","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_24","order":24,"summary":"} =f\\left ( x;\\theta \\right )$as the feature for $\\mathrm {x}$, where $f\\left ( x;\\theta \\right )$ is parameterized by a deep neural network model with parameter $\\theta$. The final prediction $\\hat{y}$ is given by a regression function $g(\\cdot)$ that operates over $\\mathbf{ \\mathrm {z}}$.问题设置。让 $\\left { \\left ( x_i, y_i \\right ) \\right }^N_{i=1}$作为训练集，其中$x_i\\in \\mathbb{R} ^d$表示输入，$y_i\\in \\mathbb{R}$表示标签，是连续目标值。我们为标签空间$\\mathcal{Y}$引入额外的结构，其中我们把$\\mathcal{Y}$分成等间隔的B组（箱），即$\\left [ y_0, y_1\\right )","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":", \\left [ y_1, y_2\\right ), \\cdots , \\left [ y_{B-1}, y_B\\right )$。在整个文章中，我们使用$b \\in \\mathcal{B}$表示目标值的组索引，其中 $\\mathcal{B} = \\left { 1, \\dots , B\\right } \\subset \\mathbb{Z}^+$是索引空间。实际上，定义的bins反应了我们在回归任务中对数据分组时关心的最小分辨率。例如，在年龄评估上，我们可以定义$\\delta y \\triangleq y_{b+1}-y_{b}=1$，表明最小年龄差为1是有用的。最终，我们把 $\\mathrm {z} =f\\left ( x;\\theta \\right )$表示x的特征，其中$f\\left ( x;\\theta \\right )$是通过具有参数$\\theta$的深度神经网络参数化的。最终的预测 $\\hat{y}$是通过 一个在$\\mathbf{ \\mathrm {z}}$上运行的回归函数$g(\\cdot)$给出。 Label Distribution Smoothing We sta","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_25","order":25,"summary":", \\left [ y_1, y_2\\right ), \\cdots , \\left [ y_{B-1}, y_B\\right )$。在整个文章中，我们使用$b \\in \\mathcal{B}$表示目标值的组索引，其中 $\\mathcal{B} = \\left { 1, \\dots , B\\right } \\subset \\mathbb{Z}^+$是索引空间。实际上，定义的bins反应了我们在回归任务中对数据分组时关心的最小分辨率。例如，在年龄评估上，我们可以定义$\\delta y \\triangleq y_{b+1}-y_{b}=1$，表明最小年龄差为1是有用的。最终，我们把 $\\mathrm {z} =f\\left ( x;\\theta \\right )$表示x的特征，其中$f\\left ( x;\\theta \\right )$是通过具有参数$\\theta$的深度神经网络参数化的。最终的预测 $\\hat{y}$是通过 一个在$\\mathbf{ \\mathrm {z}}$上运行的回归函数$g(\\cdot)$给出。 Label Distribution Smoothing We sta","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"rt by showing an example to demonstrate the difference between classification and regression when imbalance comes into the picture.Figure 2. Comparison on the test error distribution (bottom) using same training label distribution (top) on two different datasets: (a) CIFAR-100, a classification task with categorical label space. (b) IMDB-WIKI, a regression task with continuous label space.图二。在两个不同的数据集上使用相同的训练标签分布来比较测试error分布(bottom)：(a)CIFAR-100，具有分类的标签空间的分类任务。(b)IMDB-WIKI，具有连续标签空间的回归任务Motivatin","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_26","order":26,"summary":"rt by showing an example to demonstrate the difference between classification and regression when imbalance comes into the picture.Figure 2. Comparison on the test error distribution (bottom) using same training label distribution (top) on two different datasets: (a) CIFAR-100, a classification task with categorical label space. (b) IMDB-WIKI, a regression task with continuous label space.图二。在两个不同的数据集上使用相同的训练标签分布来比较测试error分布(bottom)：(a)CIFAR-100，具有分类的标签空间的分类任务。(b)IMDB-WIKI，具有连续标签空间的回归任务Motivatin","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"g Example. We employ two datasets: (1) CIFAR100 (Krizhevsky et al., 2009), which is a 100-class classification dataset, and (2) the IMDB-WIKI dataset (Rothe et al., 2018), which is a large-scale image dataset for age estimation from visual appearance. The two datasets have intrinsically different label space: CIFAR-100 exhibits categorical label space where the target is class index, while IMDB-WIKI has a continuous label space where the target is age. We limit the age range to $0 \\sim 99$ so th","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_27","order":27,"summary":"g Example. We employ two datasets: (1) CIFAR100 (Krizhevsky et al., 2009), which is a 100-class classification dataset, and (2) the IMDB-WIKI dataset (Rothe et al., 2018), which is a large-scale image dataset for age estimation from visual appearance. The two datasets have intrinsically different label space: CIFAR-100 exhibits categorical label space where the target is class index, while IMDB-WIKI has a continuous label space where the target is age. We limit the age range to $0 \\sim 99$ so th","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"at the two datasets have the same label range, and subsample them to simulate data imbalance, while ensuring they have exactly the same label density distribution (Fig. 2). We make both test sets balanced. We then train a plain ResNet-50 model on the two datasets, and plot their test error distributions.我们使用两个数据集：CIFAR100，它是一个100类的分类数据集；IMDB-WIKI，它是从外貌来估计年龄的大规模图片数据集。这两个数据集具有完全不同的标签空间：CIFAR100的类别标签空间中目标值是类别索引，而IMDB-WIKI是目标值是年龄的连续样本空间我们限制年龄到0~99使得两个数据集有相同的标签范围，并且下采样来模拟数据不平衡，同时保持它们具有相同的标签密度分布（图2）。我","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_28","order":28,"summary":"at the two datasets have the same label range, and subsample them to simulate data imbalance, while ensuring they have exactly the same label density distribution (Fig. 2). We make both test sets balanced. We then train a plain ResNet-50 model on the two datasets, and plot their test error distributions.我们使用两个数据集：CIFAR100，它是一个100类的分类数据集；IMDB-WIKI，它是从外貌来估计年龄的大规模图片数据集。这两个数据集具有完全不同的标签空间：CIFAR100的类别标签空间中目标值是类别索引，而IMDB-WIKI是目标值是年龄的连续样本空间我们限制年龄到0~99使得两个数据集有相同的标签范围，并且下采样来模拟数据不平衡，同时保持它们具有相同的标签密度分布（图2）。我","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"们保持两个测试集平滑。然后在两个数据集上训练plain ResNet-50，并绘制出它们的测试误差分布。We observe from Fig. 2(a) that the error distribution correlates with label density distribution. Specifically, the test error as a function of class index has a high negative Pearson correlation with the label density distribution (i.e., -0.76) in the categorical label space. The phenomenon is expected, as majority classes with more samples are better learned than minority classes. Interestingly however, as Fig. 2(b) shows, the error distribut","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_29","order":29,"summary":"们保持两个测试集平滑。然后在两个数据集上训练plain ResNet-50，并绘制出它们的测试误差分布。We observe from Fig. 2(a) that the error distribution correlates with label density distribution. Specifically, the test error as a function of class index has a high negative Pearson correlation with the label density distribution (i.e., -0.76) in the categorical label space. The phenomenon is expected, as majority classes with more samples are better learned than minority classes. Interestingly however, as Fig. 2(b) shows, the error distribut","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"ion is very different for IMDB-WIKI with continuous label space, even when the label density distribution is the same as CIFAR-100. In particular, the error distribution is much smoother and no longer correlates well with the label density distribution (-0.47). 在图2，我们观察到误差分布与标签密度分布相关。特别的，作为一个类别索引的函数，测试误差与分类标签空间的标签密度分布中有特别高的负Pearson相关性（即-0.76）。这种现象是预期的，因为多数类有更多的样本比少数类更易训练。但有趣的是，如图2(b)所示，误差分布在IMDB-WIKI十分不同，即使当标签密度空间与CIFAR-100相同。特别是误差分布更平滑并且不再跟标签密度分布相关（-0.47）。The reason why this example is interest","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_30","order":30,"summary":"ion is very different for IMDB-WIKI with continuous label space, even when the label density distribution is the same as CIFAR-100. In particular, the error distribution is much smoother and no longer correlates well with the label density distribution (-0.47). 在图2，我们观察到误差分布与标签密度分布相关。特别的，作为一个类别索引的函数，测试误差与分类标签空间的标签密度分布中有特别高的负Pearson相关性（即-0.76）。这种现象是预期的，因为多数类有更多的样本比少数类更易训练。但有趣的是，如图2(b)所示，误差分布在IMDB-WIKI十分不同，即使当标签密度空间与CIFAR-100相同。特别是误差分布更平滑并且不再跟标签密度分布相关（-0.47）。The reason why this example is interest","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"ing is that all imbalanced learning methods, directly or indirectly, operate by compensating for the imbalance in the empirical label density distribution. This works well for class imbalance, but for continuous labels the empirical density does not accurately reflect the imbalance as seen by the neural network. Hence, compensating for data imbalance based on empirical label density is inaccurate for the continuous label space. 这个例子的原因是所有不平衡学习方法都直接或间接的通过改善经验标签密度分布的不平衡来操作。这对于类不平衡有效，但对于连续标签，经验密度不能","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_31","order":31,"summary":"ing is that all imbalanced learning methods, directly or indirectly, operate by compensating for the imbalance in the empirical label density distribution. This works well for class imbalance, but for continuous labels the empirical density does not accurately reflect the imbalance as seen by the neural network. Hence, compensating for data imbalance based on empirical label density is inaccurate for the continuous label space. 这个例子的原因是所有不平衡学习方法都直接或间接的通过改善经验标签密度分布的不平衡来操作。这对于类不平衡有效，但对于连续标签，经验密度不能","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"准确反应通过神经网络看到的不平衡。因此，对于连续标签空间，基于经验标签密度来改善数据不平衡是不正确的An empirical distribution is one for which each possible event is assigned a probability derived from experimental observation. It is assumed that the events are independent and the sum of the probabilities is 1.也就是直接观测到的标签密度。LDS for Imbalanced Data Density Estimation. The above example shows that, in the continuous case, the empirical label distribution does not reflect the real label density distribution. This is because of the dependence betwe","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_32","order":32,"summary":"准确反应通过神经网络看到的不平衡。因此，对于连续标签空间，基于经验标签密度来改善数据不平衡是不正确的An empirical distribution is one for which each possible event is assigned a probability derived from experimental observation. It is assumed that the events are independent and the sum of the probabilities is 1.也就是直接观测到的标签密度。LDS for Imbalanced Data Density Estimation. The above example shows that, in the continuous case, the empirical label distribution does not reflect the real label density distribution. This is because of the dependence betwe","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["learn"],"content":"en data samples at nearby labels (e.g., images of close ages). In fact, there is a significant literature in statistics on how to estimate the expected density in such cases (Parzen, 1962). Thus, Label Distribution Smoothing (LDS) advocates the use of kernel density estimation to learn the effective imbalance in datasets that corresponds to continuous targets. 用于不平衡数据密度估计的LDS。上述例子表明，在连续情况下，经验标签密度不能反映真实标签密度分布。这是因为相近标签的数据样本之间存在依赖性（如年龄相近的图片）。事实上，关于如何估计在这种情况下的预期密度，统计学有大量的统计文献。因此，LDS提倡使用核密度估计来学习数据集对应","date":"2022-08-16T20:19:04.481Z","objectID":"7fdb531f64dc0731034778333148e0ae_33","order":33,"summary":"en data samples at nearby labels (e.g., images of close ages). In fact, there is a significant literature in statistics on how to estimate the expected density in such cases (Parzen, 1962). Thus, Label Distribution Smoothing (LDS) advocates the use of kernel density estimation to learn the effective imbalance in datasets that corresponds to continuous targets. 用于不平衡数据密度估计的LDS。上述例子表明，在连续情况下，经验标签密度不能反映真实标签密度分布。这是因为相近标签的数据样本之间存在依赖性（如年龄相近的图片）。事实上，关于如何估计在这种情况下的预期密度，统计学有大量的统计文献。因此，LDS提倡使用核密度估计来学习数据集对应","tags":["ComputerVision"],"title":"Delving into Deep Imbalanced Regression翻译","url":"http://localhost:1313/archives/delving-into-dir-translation/"},{"categories":["other"],"content":"深度学习 吴恩达课后作业目录 深度学习作业 习题无答案 深度学习作业 编程 《深度学习》笔记 作业 深度学习代码 深度学习 习题 有答案 李沐动手学深度学习 李沐深度学习 如何自学机器学习 前端 图床 在线api markdown转义 资源下载 csdn下载 b站下载 ","date":"2022-07-31T19:01:58.277Z","objectID":"941b374ecc2e1a84f0e7b785611e43b6_0","order":0,"summary":"深度学习 吴恩达课后作业目录 深度学习作业 习题无答案 深度学习作业 编程 《深度学习》笔记 作业 深度学习代码 深度学习 习题 有答案 李沐动手学深度学习 李沐深度学习 如何自学机器学习 前端 图床 在线api markdown转义 资源下载 csdn下载 b站下载 ","tags":["Collection"],"title":"清收藏用","url":"http://localhost:1313/archives/clean-collection/"},{"categories":["error"],"content":"参考链接：借助数据万象（原万象优图），让 hexo 也用上 webp Base64编码解码 自定义链接格式 添加盲水印 阿里云+picgo+自定义链接 盲水印价格 数据万象常见问题 因为想着今晚已经浪费好长时间了，索性把picgo上传图片优化一下。无法上传图片 TypeError: Cannot create property ‘xxx’ on string启用兼容模式打开软件，我选的是Windows8上传图片为webp格式并加盲水印 在图床设置下选择腾讯云cos，设定网址后缀如下：?imageMogr2/format/webp|?watermark/3/type/3/text/XXXX|?watermark/3/type/3/text/XXXX：生成盲水印，另外盲水印目前的价格是添加盲水印：1元/千次 提取盲水印：1元/千次 XXXX记得通过上述的Base64编码解码生成你的base64字符串 官方文档好像不可以https开头，目前用$url没有什么问题 微信小程序的多处理规则无效应该怎么办？ 解决方案如下： 使用样式。 把操作符 “|” 替换成 “%7C”。 提取盲水印 因为需要别","date":"2022-05-31T22:36:39.402Z","objectID":"3e638a84fc82d483ce7860cd55d3304b_0","order":0,"summary":"参考链接：借助数据万象（原万象优图），让 hexo 也用上 webp Base64编码解码 自定义链接格式 添加盲水印 阿里云+picgo+自定义链接 盲水印价格 数据万象常见问题 因为想着今晚已经浪费好长时间了，索性把picgo上传图片优化一下。无法上传图片 TypeError: Cannot create property ‘xxx’ on string启用兼容模式打开软件，我选的是Windows8上传图片为webp格式并加盲水印 在图床设置下选择腾讯云cos，设定网址后缀如下：?imageMogr2/format/webp|?watermark/3/type/3/text/XXXX|?watermark/3/type/3/text/XXXX：生成盲水印，另外盲水印目前的价格是添加盲水印：1元/千次 提取盲水印：1元/千次 XXXX记得通过上述的Base64编码解码生成你的base64字符串 官方文档好像不可以https开头，目前用$url没有什么问题 微信小程序的多处理规则无效应该怎么办？ 解决方案如下： 使用样式。 把操作符 “|” 替换成 “%7C”。 提取盲水印 因为需要别","tags":["Blog","Picgo"],"title":"picgo进阶玩法+腾讯云","url":"http://localhost:1313/archives/picgo-jin-jie-wan-fa--teng-xun-yun/"},{"categories":["error"],"content":"安装picgo 一开始发现picgo-plugin-super-prefix-master这个插件，故安装，因为从github上下下来，所以采取了本地上传插件进行安装，这一步坑死我了。 super-prefix安装 在插件设置里输入super-prefix，搜索后即可安装成功，注意作者是gclove 遇到的坑 我是直接在GitHub上download下来，然后本地上传，非常不建议本地上传，有bug 修改package.json 在这个路径C:\\Users\\xxxx\\AppData\\Roaming\\picgo下找到package.json，首先将里面的本地上传的super-prefix删除(ctrl+f 查找即可)，如果没有也没事 删除node_modules中的.package-lock.json的字段值 1.先从第一步从搜索栏安装后 2.错误复现不了了，总之在文件最上面会有个../.../destop/picgo-plugin-super-prefix的一串代码，一直删除**{ xxxxx},**为止,然后重启软件即可 pic-migrate安装 安装照上面来即可，但是安装完成后记得","date":"2022-05-31T21:39:04.656Z","objectID":"28f66ba895da33534f41120b447c45d5_0","order":0,"summary":"安装picgo 一开始发现picgo-plugin-super-prefix-master这个插件，故安装，因为从github上下下来，所以采取了本地上传插件进行安装，这一步坑死我了。 super-prefix安装 在插件设置里输入super-prefix，搜索后即可安装成功，注意作者是gclove 遇到的坑 我是直接在GitHub上download下来，然后本地上传，非常不建议本地上传，有bug 修改package.json 在这个路径C:\\Users\\xxxx\\AppData\\Roaming\\picgo下找到package.json，首先将里面的本地上传的super-prefix删除(ctrl+f 查找即可)，如果没有也没事 删除node_modules中的.package-lock.json的字段值 1.先从第一步从搜索栏安装后 2.错误复现不了了，总之在文件最上面会有个../.../destop/picgo-plugin-super-prefix的一串代码，一直删除**{ xxxxx},**为止,然后重启软件即可 pic-migrate安装 安装照上面来即可，但是安装完成后记得","tags":["Blog"],"title":"picgo安装插件不成功","url":"http://localhost:1313/archives/picgo-install-plugin/"},{"categories":["learn"],"content":"下载VOC2012数据集，这里用的是镜像：镜像网址、Train/Validation dataset、test dataset 注意直接复制链接，浏览器不会接管下载，需要打开迅雷（最好有超级会员） 原本想复现的，师兄告诉我还是直接看v3好，故溜~ 参考链接：目标检测：YOLOV1 YOLOv1损失函数 YOLO v1深入理解 可以看看评论区 YOLO：实时快速目标检测 可以看看评论区 【目标检测】单阶段算法--YOLOv1详解 【论文解读】Yolo三部曲解读——Yolov1 可以看看评论区 YOLOv1简介 相比于 R-CNN 系列的方法，YOLO提供了另外一种思路，将 Object Detection 的问题转化成一个 Regression 问题。给定输入图像，直接在图像的多个位置上回归出目标的bounding box以及其分类类别。YOLO是一个可以一次性预测多个Box位置和类别的卷积神经网络，能够实现端到端的目标检测和识别，其最大的优势就是速度快。YOLO没有选择滑动窗口（silding window）或提取proposal的方式训练网络，而是直接选用整图训练模型。这样做的好处在","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_0","order":0,"summary":"下载VOC2012数据集，这里用的是镜像：镜像网址、Train/Validation dataset、test dataset 注意直接复制链接，浏览器不会接管下载，需要打开迅雷（最好有超级会员） 原本想复现的，师兄告诉我还是直接看v3好，故溜~ 参考链接：目标检测：YOLOV1 YOLOv1损失函数 YOLO v1深入理解 可以看看评论区 YOLO：实时快速目标检测 可以看看评论区 【目标检测】单阶段算法--YOLOv1详解 【论文解读】Yolo三部曲解读——Yolov1 可以看看评论区 YOLOv1简介 相比于 R-CNN 系列的方法，YOLO提供了另外一种思路，将 Object Detection 的问题转化成一个 Regression 问题。给定输入图像，直接在图像的多个位置上回归出目标的bounding box以及其分类类别。YOLO是一个可以一次性预测多个Box位置和类别的卷积神经网络，能够实现端到端的目标检测和识别，其最大的优势就是速度快。YOLO没有选择滑动窗口（silding window）或提取proposal的方式训练网络，而是直接选用整图训练模型。这样做的好处在","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"于可以更好的区分目标和背景区域，相比之下，采用proposal训练方式的Fast-R-CNN常常把背景区域误检为特定目标。但是YOLO目标区域定位误差更大（特别是小目标）。 优点：First, YOLO is extremely fast. Since we frame detection as a regression problem we don't need a complex pipeline.（这里的回归问题不是特别理解。回归的目的是预测数值型的目标值，输入图像经过一次网络，便能得到图像中所有物体的位置和其所属类别及相应的置信概率） Second, YOLO reasons globally about the image when making predictions. Unlike sliding window and region proposal-based techniques, YOLO sees the entire image. Third, YOLO learns generalizable representations of objects. When ","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_1","order":1,"summary":"于可以更好的区分目标和背景区域，相比之下，采用proposal训练方式的Fast-R-CNN常常把背景区域误检为特定目标。但是YOLO目标区域定位误差更大（特别是小目标）。 优点：First, YOLO is extremely fast. Since we frame detection as a regression problem we don't need a complex pipeline.（这里的回归问题不是特别理解。回归的目的是预测数值型的目标值，输入图像经过一次网络，便能得到图像中所有物体的位置和其所属类别及相应的置信概率） Second, YOLO reasons globally about the image when making predictions. Unlike sliding window and region proposal-based techniques, YOLO sees the entire image. Third, YOLO learns generalizable representations of objects. When ","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"trained on natural images and tested on art- work, YOLO outperforms top detection methods like DPM and R-CNN by a wide margin.Our system models detection as a regression problem. It divides the image into an S × S grid and for each grid cell predicts B bounding boxes, confidence for those boxes, and C class probabilities. These predictions are encoded as an S × S × (B ∗ 5 + C) tensor.实现方案：Link，大致下面这个区域，因为都是原文摘抄，所以不全部复制了。1）结构 去掉候选区这个步骤以后，YOLO的结构非常简单，就是单纯的卷积、池化最后加了两层全连接。单看网络结构的话，和普通的CNN对象分类网络几乎没有本","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_2","order":2,"summary":"trained on natural images and tested on art- work, YOLO outperforms top detection methods like DPM and R-CNN by a wide margin.Our system models detection as a regression problem. It divides the image into an S × S grid and for each grid cell predicts B bounding boxes, confidence for those boxes, and C class probabilities. These predictions are encoded as an S × S × (B ∗ 5 + C) tensor.实现方案：Link，大致下面这个区域，因为都是原文摘抄，所以不全部复制了。1）结构 去掉候选区这个步骤以后，YOLO的结构非常简单，就是单纯的卷积、池化最后加了两层全连接。单看网络结构的话，和普通的CNN对象分类网络几乎没有本","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"质的区别，最大的差异是最后输出层用线性函数做激活函数，因为需要预测bounding box的位置（数值型），而不仅仅是对象的概率。所以粗略来说，YOLO的整个结构就是输入图片经过神经网络的变换得到一个输出的张量，如下图所示。另外文中将图片resize为448*448，一些图片会发生很大的变形，所以尽量训练数据和测试数据分布保持一致。 YOLO并没有预先设置2个bounding box的大小和形状，也没有对每个bounding box分别输出一个对象的预测。它的意思仅仅是对一个对象预测出2个bounding box，选择预测得相对比较准的那个。这里采用2个bounding box，有点不完全算监督算法，而是像进化算法。如果是监督算法，我们需要事先根据样本就能给出一个正确的bounding box作为回归的目标。但YOLO的2个bounding box事先并不知道会在什么位置，只有经过前向计算，网络会输出2个bounding box，这两个bounding box与样本中对象实际的bounding box计算IOU。这时才能确定，IOU值大的那个bounding box，作为负责预测该对象","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_3","order":3,"summary":"质的区别，最大的差异是最后输出层用线性函数做激活函数，因为需要预测bounding box的位置（数值型），而不仅仅是对象的概率。所以粗略来说，YOLO的整个结构就是输入图片经过神经网络的变换得到一个输出的张量，如下图所示。另外文中将图片resize为448*448，一些图片会发生很大的变形，所以尽量训练数据和测试数据分布保持一致。 YOLO并没有预先设置2个bounding box的大小和形状，也没有对每个bounding box分别输出一个对象的预测。它的意思仅仅是对一个对象预测出2个bounding box，选择预测得相对比较准的那个。这里采用2个bounding box，有点不完全算监督算法，而是像进化算法。如果是监督算法，我们需要事先根据样本就能给出一个正确的bounding box作为回归的目标。但YOLO的2个bounding box事先并不知道会在什么位置，只有经过前向计算，网络会输出2个bounding box，这两个bounding box与样本中对象实际的bounding box计算IOU。这时才能确定，IOU值大的那个bounding box，作为负责预测该对象","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"的bounding box。 训练开始阶段，网络预测的bounding box可能都是乱来的，但总是选择IOU相对好一些的那个，随着训练的进行，每个bounding box会逐渐擅长对某些情况的预测（可能是对象大小、宽高比、不同类型的对象等）。所以，这是一种进化或者非监督学习的思想。 responsible： We assign one predictor to be “responsible” for predicting an object based on which prediction has the highest current IOU with the ground truth. This leads to specialization between the bounding box predictors. Each predictor gets better at predicting certain sizes, aspect ratios, or classes of object, improving overall recall. 设网格数量为 SS，每个网","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_4","order":4,"summary":"的bounding box。 训练开始阶段，网络预测的bounding box可能都是乱来的，但总是选择IOU相对好一些的那个，随着训练的进行，每个bounding box会逐渐擅长对某些情况的预测（可能是对象大小、宽高比、不同类型的对象等）。所以，这是一种进化或者非监督学习的思想。 responsible： We assign one predictor to be “responsible” for predicting an object based on which prediction has the highest current IOU with the ground truth. This leads to specialization between the bounding box predictors. Each predictor gets better at predicting certain sizes, aspect ratios, or classes of object, improving overall recall. 设网格数量为 SS，每个网","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"格产生B个边框，数据集包含C个不同的对象。这时，输出的长度为：$(C+B(4+1))SS$ 论文关键部分翻译：Unified Detection We unify the separate components of object detection into a single neural network. Our network uses features from the entire image to predict each bounding box. It also predicts all bounding boxes across all classes for an image simultaneously. This means our network reasons globally about the full image and all the objects in the image. The YOLO design enables end-to-end training and realtime speeds while maintaining high ","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_5","order":5,"summary":"格产生B个边框，数据集包含C个不同的对象。这时，输出的长度为：$(C+B(4+1))SS$ 论文关键部分翻译：Unified Detection We unify the separate components of object detection into a single neural network. Our network uses features from the entire image to predict each bounding box. It also predicts all bounding boxes across all classes for an image simultaneously. This means our network reasons globally about the full image and all the objects in the image. The YOLO design enables end-to-end training and realtime speeds while maintaining high ","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"average precision.我们将目标检测的不同组件整合到一个神经网络中。我们的网络使用整张图片的特征来预测每一个边界框。它还同时预测图像的所有类中的每一个边界框。这表示我们的网络全局推理整张图片和图片上的所有对象。YOLO的设计可以进行端到端训练和达到实时的速度并且保持相对高的准确度。 Our system divides the input image into an_ S _× S grid. If the center of an object falls into a grid cell, that grid cell is responsible for detecting that object.我们的系统将输入图片分成S×S的网格。如果一个对象的中心点落在某个网格内，则这个网格负责预测这个对象。（计算出该Object的bounding box的中心位置，这个中心位置落在哪个grid，该grid对应的输出向量中该对象的类别概率是1（该gird负责预测该对象），所有其它grid对该Object的预测概率设为0（不负责预测该对象）参考网址。另外最多能检测出S*S个物体","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_6","order":6,"summary":"average precision.我们将目标检测的不同组件整合到一个神经网络中。我们的网络使用整张图片的特征来预测每一个边界框。它还同时预测图像的所有类中的每一个边界框。这表示我们的网络全局推理整张图片和图片上的所有对象。YOLO的设计可以进行端到端训练和达到实时的速度并且保持相对高的准确度。 Our system divides the input image into an_ S _× S grid. If the center of an object falls into a grid cell, that grid cell is responsible for detecting that object.我们的系统将输入图片分成S×S的网格。如果一个对象的中心点落在某个网格内，则这个网格负责预测这个对象。（计算出该Object的bounding box的中心位置，这个中心位置落在哪个grid，该grid对应的输出向量中该对象的类别概率是1（该gird负责预测该对象），所有其它grid对该Object的预测概率设为0（不负责预测该对象）参考网址。另外最多能检测出S*S个物体","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"，如果每个物体的中心点在每个网格内） Each grid cell predicts B bounding boxes and confidence scores for those boxes. These confidence scores reflect how confident the model is that the box contains an object and also how accurate it thinks the box is that it predicts. Formally we define confidence as $\\operatorname{Pr}(\\text { Object }) * \\mathrm{IOU}_{\\text {pred }}^{\\text {truth }}$. If no object exists in that cell, the confidence scores should be zero. Otherwise we want the confidence score to equal the inter","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_7","order":7,"summary":"，如果每个物体的中心点在每个网格内） Each grid cell predicts B bounding boxes and confidence scores for those boxes. These confidence scores reflect how confident the model is that the box contains an object and also how accurate it thinks the box is that it predicts. Formally we define confidence as $\\operatorname{Pr}(\\text { Object }) * \\mathrm{IOU}_{\\text {pred }}^{\\text {truth }}$. If no object exists in that cell, the confidence scores should be zero. Otherwise we want the confidence score to equal the inter","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"section over union (IOU) between the predicted box and the ground truth.每个网格预测B个bboxes和这些boxes的置信度。其中置信度反映了模型对这个box包含对象的信任度和模型认为这个box预测有无对象的准确度。我们定义置信度为有无对象的预测值（非0即1）* truth box和pred box的交并比。如果没有object在网格内，则置信度应为0. 否则我们将置信度等于预测框和真实框的交并比。Each bounding box consists of 5 predictions: x, y, w, h,_ _and confidence. The (x, y) coordinates represent the center of the box relative to the bounds of the grid cell. The width and height are predicted relative to the whole image. Finally the confidence predi","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_8","order":8,"summary":"section over union (IOU) between the predicted box and the ground truth.每个网格预测B个bboxes和这些boxes的置信度。其中置信度反映了模型对这个box包含对象的信任度和模型认为这个box预测有无对象的准确度。我们定义置信度为有无对象的预测值（非0即1）* truth box和pred box的交并比。如果没有object在网格内，则置信度应为0. 否则我们将置信度等于预测框和真实框的交并比。Each bounding box consists of 5 predictions: x, y, w, h,_ _and confidence. The (x, y) coordinates represent the center of the box relative to the bounds of the grid cell. The width and height are predicted relative to the whole image. Finally the confidence predi","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"ction represents the IOU between the predicted box and any ground truth box.每个bbox包含5个预测值：x, y, w, h and 置信度。(x, y)表示bbox相对于网格单元格边界的中心坐标。预测的高宽相对于整张图片的高宽。最后，置信度预测表示pred and truth 的交并比Each grid cell also predicts C conditional class probabilities, $\\operatorname{Pr}\\left(\\text { Class }{i} \\mid \\text { Object }\\right)$. These probabilities are conditioned on the grid cell containing an object. We only predict one set of class probabilities per grid cell, regardless of the number of boxes B_.每个网格也预","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_9","order":9,"summary":"ction represents the IOU between the predicted box and any ground truth box.每个bbox包含5个预测值：x, y, w, h and 置信度。(x, y)表示bbox相对于网格单元格边界的中心坐标。预测的高宽相对于整张图片的高宽。最后，置信度预测表示pred and truth 的交并比Each grid cell also predicts C conditional class probabilities, $\\operatorname{Pr}\\left(\\text { Class }{i} \\mid \\text { Object }\\right)$. These probabilities are conditioned on the grid cell containing an object. We only predict one set of class probabilities per grid cell, regardless of the number of boxes B_.每个网格也预","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"测C个条件类型概率，即存在对象时，属于某类别的概率。这些概率以网格内包含对象为条件。我们仅预测每个网格的一系列的类别概率，不管bbox的个数。（相当于每个网格只输出一个类型概率，而不会输出bbox的类别概率，bbox输出置信度） At test time we multiply the conditional class probabilities and the individual box confidence predictions, $\\begin{equation*} \\operatorname{Pr}\\left(\\text { Class }{i} \\mid \\text { Object }\\right) * \\operatorname{Pr}(\\text { Object }) * \\mathrm{IOU}{\\text {pred }}^{\\text {truth }}=\\operatorname{Pr}\\left(\\text { Class }{i}\\right) * \\mathrm{IOU}{\\text {pred }}^{\\text {truth }} \\end{e","date":"2022-05-27T16:14:59.488Z","objectID":"51f381ba7e1b92559ac8ec6f3590533f_10","order":10,"summary":"测C个条件类型概率，即存在对象时，属于某类别的概率。这些概率以网格内包含对象为条件。我们仅预测每个网格的一系列的类别概率，不管bbox的个数。（相当于每个网格只输出一个类型概率，而不会输出bbox的类别概率，bbox输出置信度） At test time we multiply the conditional class probabilities and the individual box confidence predictions, $\\begin{equation*} \\operatorname{Pr}\\left(\\text { Class }{i} \\mid \\text { Object }\\right) * \\operatorname{Pr}(\\text { Object }) * \\mathrm{IOU}{\\text {pred }}^{\\text {truth }}=\\operatorname{Pr}\\left(\\text { Class }{i}\\right) * \\mathrm{IOU}{\\text {pred }}^{\\text {truth }} \\end{e","tags":["ComputerVision"],"title":"YOLOv1初体验","url":"http://localhost:1313/archives/yolov1-first-try/"},{"categories":["learn"],"content":"在网上翻看许多，都是只讲定义，不讲过程，故我根据一道题目来详细介绍如何进行腐蚀运算，膨胀运算与腐蚀运算差不多就不多加赘述了。 题目如下： 程序如下：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import numpy as np import cv2 A = np.array( [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], np.uint8) Ac = 1 - A print(","date":"2022-05-10T20:04:00.648Z","objectID":"d8c717184d86a3701eeb4b4dc1a10179_0","order":0,"summary":"在网上翻看许多，都是只讲定义，不讲过程，故我根据一道题目来详细介绍如何进行腐蚀运算，膨胀运算与腐蚀运算差不多就不多加赘述了。 题目如下： 程序如下：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import numpy as np import cv2 A = np.array( [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], np.uint8) Ac = 1 - A print(","tags":["Python","ComputerVision"],"title":"形态学--腐蚀运算详细过程","url":"http://localhost:1313/archives/morphology-erosion/"},{"categories":["learn"],"content":"A) print(Ac) # print(np.pad(Ac, (1, 1), mode='constant', constant_values=(1, 1))) print() T1 = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], np.uint8) T2 = np.array([[1, 0, 1], [0, 0, 0], [1, 0, 1]], np.uint8) img1 = cv2.erode(A, T1) # 事实上这里是cv2.erode(Ac, T2, borderValue=1) img2 = cv2.erode(Ac, T2) print(img1) print(img2) print() print(img1 \u0026 img2) 产生img1 首先讲img1是如何出来的。（安利一个截图神器，snipaste） 图片我个人感觉很清晰了，除了有点乱。顺序从红色字→绿色字→蓝色字→紫色字→白色字疑问解决： Eroding and Dilating cv2.erode参数解释 如果无指定，默认为结构元素中点产生img2 接下来是img","date":"2022-05-10T20:04:00.648Z","objectID":"d8c717184d86a3701eeb4b4dc1a10179_1","order":1,"summary":"A) print(Ac) # print(np.pad(Ac, (1, 1), mode='constant', constant_values=(1, 1))) print() T1 = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], np.uint8) T2 = np.array([[1, 0, 1], [0, 0, 0], [1, 0, 1]], np.uint8) img1 = cv2.erode(A, T1) # 事实上这里是cv2.erode(Ac, T2, borderValue=1) img2 = cv2.erode(Ac, T2) print(img1) print(img2) print() print(img1 \u0026 img2) 产生img1 首先讲img1是如何出来的。（安利一个截图神器，snipaste） 图片我个人感觉很清晰了，除了有点乱。顺序从红色字→绿色字→蓝色字→紫色字→白色字疑问解决： Eroding and Dilating cv2.erode参数解释 如果无指定，默认为结构元素中点产生img2 接下来是img","tags":["Python","ComputerVision"],"title":"形态学--腐蚀运算详细过程","url":"http://localhost:1313/archives/morphology-erosion/"},{"categories":["other"],"content":"至此一个月全部打卡，之后按专题来进行提高随机数索引 随机数索引1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # 暴力 class Solution: def __init__(self, nums: List[int]): self.nums = nums def pick(self, target: int) -\u003e int: dic = {} # 新建字典 key:int value:list for i, num in enumerate(self.nums): if num in dic: dic[num].append(i) continue dic[num] = [i] return random.choice(dic[target]) # 水塘抽样 # https://zhuanlan.zhihu.com/p/29178293 class Solu","date":"2022-04-30T14:50:31.527Z","objectID":"0c3ce1219cfcd59c6c2633ea6e624479_0","order":0,"summary":"至此一个月全部打卡，之后按专题来进行提高随机数索引 随机数索引1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # 暴力 class Solution: def __init__(self, nums: List[int]): self.nums = nums def pick(self, target: int) -\u003e int: dic = {} # 新建字典 key:int value:list for i, num in enumerate(self.nums): if num in dic: dic[num].append(i) continue dic[num] = [i] return random.choice(dic[target]) # 水塘抽样 # https://zhuanlan.zhihu.com/p/29178293 class Solu","tags":["LeetCode"],"title":"(leetcode) 一周六题","url":"http://localhost:1313/archives/leetcode-one-week-six-ans/"},{"categories":["other"],"content":"tion: def __init__(self, nums: List[int]): self.nums = nums def pick(self, target: int) -\u003e int: cnt, ans = 0, 0 for i, num in enumerate(self.nums): if num == target: cnt += 1 if random.randrange(cnt) == 0: ans = i return ans # 随机抽k个 # 仅供参考 def ReservoirSampling(nums, target, k): res = [0]*k idx = 0 for i, num in enumerate(nums): if target == num: res[idx] = i idx += 1 if idx == k: break cnt = k for i in range(res[idx-1], len(nums)): if nums[i] == target: cnt += 1 ran = random.randrange(cnt) if r","date":"2022-04-30T14:50:31.527Z","objectID":"0c3ce1219cfcd59c6c2633ea6e624479_1","order":1,"summary":"tion: def __init__(self, nums: List[int]): self.nums = nums def pick(self, target: int) -\u003e int: cnt, ans = 0, 0 for i, num in enumerate(self.nums): if num == target: cnt += 1 if random.randrange(cnt) == 0: ans = i return ans # 随机抽k个 # 仅供参考 def ReservoirSampling(nums, target, k): res = [0]*k idx = 0 for i, num in enumerate(nums): if target == num: res[idx] = i idx += 1 if idx == k: break cnt = k for i in range(res[idx-1], len(nums)): if nums[i] == target: cnt += 1 ran = random.randrange(cnt) if r","tags":["LeetCode"],"title":"(leetcode) 一周六题","url":"http://localhost:1313/archives/leetcode-one-week-six-ans/"},{"categories":["other"],"content":"最常见的单词 最常见的单词1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # 自己写的水代码 def mostCommonWord(paragraph, banned): s, ss = '', [] # 将字符串转成小写字母 paragraph = paragraph.lower() for i in range(len(banned)): banned[i] = banned[i].lower() # 判断是否是最后一个字符，最后一个字符没有空格或其他符号 flag = 1 for i in paragraph: if 'a' \u0026lt;= i \u0026lt;= 'z': flag = 1 s += i continue flag = 0 # 将bob,中','造成的''删除 if s: ss.append(s) s = '' # 最后一个字符串加入数组","date":"2022-04-24T14:27:55.812Z","objectID":"7d08896ed65531463fa037b23ef8aa10_0","order":0,"summary":"最常见的单词 最常见的单词1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # 自己写的水代码 def mostCommonWord(paragraph, banned): s, ss = '', [] # 将字符串转成小写字母 paragraph = paragraph.lower() for i in range(len(banned)): banned[i] = banned[i].lower() # 判断是否是最后一个字符，最后一个字符没有空格或其他符号 flag = 1 for i in paragraph: if 'a' \u0026lt;= i \u0026lt;= 'z': flag = 1 s += i continue flag = 0 # 将bob,中','造成的''删除 if s: ss.append(s) s = '' # 最后一个字符串加入数组","tags":["Python","LeetCode"],"title":"(leetcode) 一周七题","url":"http://localhost:1313/archives/leetcode-week-1/"},{"categories":["other"],"content":" if flag: ss.append(s) c = Counter(ss) for i in range(len(banned) + 1): # 获取最大值 ans = max(c.keys(), key=c.get) if ans in banned: del c[ans] else: return ans # 官解 def mostCommonWord(paragraph, banned): ban = set(banned) freq = Counter() word, n = \"\", len(paragraph) # 获取字符串模板，'Bob like Joe'=\u003e[Bob, like, Joe] # n+1 排除了单词结尾的情况 for i in range(n + 1): # i\u0026lt;n 使得paragraph[i]不会越界 if i \u0026lt; n and paragraph[i].isalpha(): word += paragraph[i].lower() elif word: if word not in ban: freq[word] += 1 word = \"","date":"2022-04-24T14:27:55.812Z","objectID":"7d08896ed65531463fa037b23ef8aa10_1","order":1,"summary":" if flag: ss.append(s) c = Counter(ss) for i in range(len(banned) + 1): # 获取最大值 ans = max(c.keys(), key=c.get) if ans in banned: del c[ans] else: return ans # 官解 def mostCommonWord(paragraph, banned): ban = set(banned) freq = Counter() word, n = \"\", len(paragraph) # 获取字符串模板，'Bob like Joe'=\u003e[Bob, like, Joe] # n+1 排除了单词结尾的情况 for i in range(n + 1): # i\u0026lt;n 使得paragraph[i]不会越界 if i \u0026lt; n and paragraph[i].isalpha(): word += paragraph[i].lower() elif word: if word not in ban: freq[word] += 1 word = \"","tags":["Python","LeetCode"],"title":"(leetcode) 一周七题","url":"http://localhost:1313/archives/leetcode-week-1/"},{"categories":["other"],"content":"\" maxFreq = max(freq.values()) return next(word for word, f in freq.items() if f == maxFreq) # 一行 # https://leetcode-cn.com/problems/most-common-word/solution/by-jam007-3la9/ def mostCommonWord(self, paragraph: str, banned: List[str]) -\u003e str: return Counter(w for w in re.findall(r'\\w+', paragraph.lower()) if w not in set(banned)).most_common(1)[0][0] 字典序排数 字典序排数1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 官解 def lexicalOrder(n: int) -\u003e List[int]: ans = [0","date":"2022-04-24T14:27:55.812Z","objectID":"7d08896ed65531463fa037b23ef8aa10_2","order":2,"summary":"\" maxFreq = max(freq.values()) return next(word for word, f in freq.items() if f == maxFreq) # 一行 # https://leetcode-cn.com/problems/most-common-word/solution/by-jam007-3la9/ def mostCommonWord(self, paragraph: str, banned: List[str]) -\u003e str: return Counter(w for w in re.findall(r'\\w+', paragraph.lower()) if w not in set(banned)).most_common(1)[0][0] 字典序排数 字典序排数1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 官解 def lexicalOrder(n: int) -\u003e List[int]: ans = [0","tags":["Python","LeetCode"],"title":"(leetcode) 一周七题","url":"http://localhost:1313/archives/leetcode-week-1/"},{"categories":["other"],"content":"] * n num = 1 for i in range(n): ans[i] = num if num * 10 \u0026lt;= n: # 保存1 100 1000 num *= 10 else: # num % 10 = 9是判断尾数是否到头，因为再加1则变为10，到头则使num变为9 # num + 1 \u003e n：+1是为了后面的num+=1，并且判断num是不是超过了n，超过则使num//10 while num % 10 == 9 or num + 1 \u003e n: num //= 10 # 使num复原 num += 1 return ans # dfs # https://leetcode-cn.com/problems/lexicographical-numbers/solution/by-ac_oier-ktn7/ def lexicalOrder(n: int) -\u003e List[int]: ans = [] def dfs(num, limit): if num \u003e limit: return ans.append(num) for i in range(10): dfs(n","date":"2022-04-24T14:27:55.812Z","objectID":"7d08896ed65531463fa037b23ef8aa10_3","order":3,"summary":"] * n num = 1 for i in range(n): ans[i] = num if num * 10 \u0026lt;= n: # 保存1 100 1000 num *= 10 else: # num % 10 = 9是判断尾数是否到头，因为再加1则变为10，到头则使num变为9 # num + 1 \u003e n：+1是为了后面的num+=1，并且判断num是不是超过了n，超过则使num//10 while num % 10 == 9 or num + 1 \u003e n: num //= 10 # 使num复原 num += 1 return ans # dfs # https://leetcode-cn.com/problems/lexicographical-numbers/solution/by-ac_oier-ktn7/ def lexicalOrder(n: int) -\u003e List[int]: ans = [] def dfs(num, limit): if num \u003e limit: return ans.append(num) for i in range(10): dfs(n","tags":["Python","LeetCode"],"title":"(leetcode) 一周七题","url":"http://localhost:1313/archives/leetcode-week-1/"},{"categories":["other"],"content":"um * 10 + i, limit) for i in range(1, 10): dfs(i, n) return ans # 库函数 def lexicalOrder(self, n: int) -\u003e List[int]: return sorted(range(1,n+1),key=str) 字符的最短距离 字符的最短距离1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # 官解的-n、2*n 秒啊 def shortestToChar(s: str, c: str) -\u003e List[int]: ans = [0] * len(s) idx = -1 for i in range(len(s)): if s[i] == c: idx = i if idx \u003e= 0: ans[i] = abs(i-idx","date":"2022-04-24T14:27:55.812Z","objectID":"7d08896ed65531463fa037b23ef8aa10_4","order":4,"summary":"um * 10 + i, limit) for i in range(1, 10): dfs(i, n) return ans # 库函数 def lexicalOrder(self, n: int) -\u003e List[int]: return sorted(range(1,n+1),key=str) 字符的最短距离 字符的最短距离1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # 官解的-n、2*n 秒啊 def shortestToChar(s: str, c: str) -\u003e List[int]: ans = [0] * len(s) idx = -1 for i in range(len(s)): if s[i] == c: idx = i if idx \u003e= 0: ans[i] = abs(i-idx","tags":["Python","LeetCode"],"title":"(leetcode) 一周七题","url":"http://localhost:1313/archives/leetcode-week-1/"},{"categories":["tech"],"content":"下载软件 准备工作：下载夜神模拟器、下载“安卓终端模拟器”apk文件、下载“豌豆荚”apk文件 将透明图片或者半透明图片移入夜神模拟器，（途中可能需要文件管理器的权限，直接允许即可）安装apk文件 将apk文件拖入夜神模拟器中，安装安卓终端模拟器、豌豆荚。注意，夜神模拟器需要安卓5.0版本的，7.0没试过，可以尝试一下下载微信 豌豆荚的历史版本在微信的下载页面最下面，如果是mumu模拟器可能无法显示，需要点击安装/下载才会显示在豌豆荚中下载8.06版本的微信，（只要能安装并且登录的就行，如果你是安卓5.0版本的，不能安装最新版微信）安装好微信后，登录并且新设备需要接受短信（登陆的时候用鼠标点击输入框，不要用tab键或其他，可能输入没反应）进行移花接木 打开安卓终端模拟器 输入“su”回车，再输入“pm uninstall -k com.tencent.mm”回车，如果无响应，新建一个窗口，或者点击那个灰色竖条 在win+r后输入adb shell pm uninstall -k com.tencent.mm.点击确定 此时微信已经卸载，并且已经保存登录状态下载旧版本微信 在豌豆荚下载7","date":"2022-04-16T21:34:50.282Z","objectID":"c6125831a182b8df6e85c381a34685e1_0","order":0,"summary":"下载软件 准备工作：下载夜神模拟器、下载“安卓终端模拟器”apk文件、下载“豌豆荚”apk文件 将透明图片或者半透明图片移入夜神模拟器，（途中可能需要文件管理器的权限，直接允许即可）安装apk文件 将apk文件拖入夜神模拟器中，安装安卓终端模拟器、豌豆荚。注意，夜神模拟器需要安卓5.0版本的，7.0没试过，可以尝试一下下载微信 豌豆荚的历史版本在微信的下载页面最下面，如果是mumu模拟器可能无法显示，需要点击安装/下载才会显示在豌豆荚中下载8.06版本的微信，（只要能安装并且登录的就行，如果你是安卓5.0版本的，不能安装最新版微信）安装好微信后，登录并且新设备需要接受短信（登陆的时候用鼠标点击输入框，不要用tab键或其他，可能输入没反应）进行移花接木 打开安卓终端模拟器 输入“su”回车，再输入“pm uninstall -k com.tencent.mm”回车，如果无响应，新建一个窗口，或者点击那个灰色竖条 在win+r后输入adb shell pm uninstall -k com.tencent.mm.点击确定 此时微信已经卸载，并且已经保存登录状态下载旧版本微信 在豌豆荚下载7","tags":[null],"title":"微信头像透明or半透明","url":"http://localhost:1313/archives/wei-xin-tou-xiang-tou-ming-or-ban-tou-ming/"},{"categories":["tech"],"content":".0.9版本的微信，安装完后点击打开即可进行切换头像，将你放入的头像用触摸板两指放大或者ctrl+鼠标滚轮放大，放着上下移动都可以，多试试就能出来透明头像 tips：如果是黑字透明底，更换头像的时候无法显示。 非透明建议改成其他颜色，并且区域小一点，否则放大容易超出头像框 iphone手机免疫一切透明 参考链接： https://zhuanlan.zhihu.com/p/473839446 另一个办法，比较繁琐，成功率较低：https://zhuanlan.zhihu.com/p/445720417","date":"2022-04-16T21:34:50.282Z","objectID":"c6125831a182b8df6e85c381a34685e1_1","order":1,"summary":".0.9版本的微信，安装完后点击打开即可进行切换头像，将你放入的头像用触摸板两指放大或者ctrl+鼠标滚轮放大，放着上下移动都可以，多试试就能出来透明头像 tips：如果是黑字透明底，更换头像的时候无法显示。 非透明建议改成其他颜色，并且区域小一点，否则放大容易超出头像框 iphone手机免疫一切透明 参考链接： https://zhuanlan.zhihu.com/p/473839446 另一个办法，比较繁琐，成功率较低：https://zhuanlan.zhihu.com/p/445720417","tags":[null],"title":"微信头像透明or半透明","url":"http://localhost:1313/archives/wei-xin-tou-xiang-tou-ming-or-ban-tou-ming/"},{"categories":["other"],"content":"O(1) 时间插入、删除和获取随机元素 O(1) 时间插入、删除和获取随机元素1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # 暴力 class RandomizedSet(object): def __init__(self): self.list = [] def insert(self, val): if val not in self.list: self.list.append(val) return True return False def remove(self, val): if val not in self.list: return False self.list.remove(val) return True def ","date":"2022-04-16T16:41:20.711Z","objectID":"0a081fc8034d8f678f97451df2bb5421_0","order":0,"summary":"O(1) 时间插入、删除和获取随机元素 O(1) 时间插入、删除和获取随机元素1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 # 暴力 class RandomizedSet(object): def __init__(self): self.list = [] def insert(self, val): if val not in self.list: self.list.append(val) return True return False def remove(self, val): if val not in self.list: return False self.list.remove(val) return True def ","tags":["Python","LeetCode"],"title":"(leetcode) 四日四题","url":"http://localhost:1313/archives/leetcode-four-day-four-ans/"},{"categories":["other"],"content":"getRandom(self): return choice(self.list) # list + 哈希表 # 执行用时：620 ms # 内存消耗：49.4 MB class RandomizedSet: def __init__(self): self.nums = [] self.indices = {} def insert(self, val: int) -\u003e bool: if val in self.nums: return False # len(nums) 下标从0开始 self.indices[val] = len(self.nums) self.nums.append(val) return True def remove(self, val: int) -\u003e bool: if val not in self.nums: return False # 将val放在list末尾后，防止移动 idx = self.indices[val] self.nums[idx] = self.nums[-1] # 先修改indices再删除nums的元素，防止index out","date":"2022-04-16T16:41:20.711Z","objectID":"0a081fc8034d8f678f97451df2bb5421_1","order":1,"summary":"getRandom(self): return choice(self.list) # list + 哈希表 # 执行用时：620 ms # 内存消耗：49.4 MB class RandomizedSet: def __init__(self): self.nums = [] self.indices = {} def insert(self, val: int) -\u003e bool: if val in self.nums: return False # len(nums) 下标从0开始 self.indices[val] = len(self.nums) self.nums.append(val) return True def remove(self, val: int) -\u003e bool: if val not in self.nums: return False # 将val放在list末尾后，防止移动 idx = self.indices[val] self.nums[idx] = self.nums[-1] # 先修改indices再删除nums的元素，防止index out","tags":["Python","LeetCode"],"title":"(leetcode) 四日四题","url":"http://localhost:1313/archives/leetcode-four-day-four-ans/"},{"categories":["other"],"content":" of range self.indices[self.nums[idx]] = idx self.nums.pop() return True def getRandom(self) -\u003e int: return choice(self.nums) # 使用set 效率与上面差不多 # 执行用时: 532 ms # 内存消耗: 49.5 MB class RandomizedSet: def __init__(self): self.nums = set() def insert(self, val: int) -\u003e bool: if val in self.nums: return False self.nums.add(val) return True def remove(self, val: int) -\u003e bool: if val not in self.nums: return False self.nums.remove(val) return True def getRandom(self) -\u003e int: return choice(list(self.nums))","date":"2022-04-16T16:41:20.711Z","objectID":"0a081fc8034d8f678f97451df2bb5421_2","order":2,"summary":" of range self.indices[self.nums[idx]] = idx self.nums.pop() return True def getRandom(self) -\u003e int: return choice(self.nums) # 使用set 效率与上面差不多 # 执行用时: 532 ms # 内存消耗: 49.5 MB class RandomizedSet: def __init__(self): self.nums = set() def insert(self, val: int) -\u003e bool: if val in self.nums: return False self.nums.add(val) return True def remove(self, val: int) -\u003e bool: if val not in self.nums: return False self.nums.remove(val) return True def getRandom(self) -\u003e int: return choice(list(self.nums))","tags":["Python","LeetCode"],"title":"(leetcode) 四日四题","url":"http://localhost:1313/archives/leetcode-four-day-four-ans/"},{"categories":["other"],"content":"到达终点 到达终点1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 摘自评论 # https://leetcode-cn.com/problems/reaching-points/comments/85185 def reachingPoints(self, sx, sy, tx, ty): while tx \u003e 0 and ty \u003e 0: if tx == sx and ty == sy: return True if tx \u003e ty: # tx - sx是目标与起始值在x的差距，我们需要一次减去n * ty达到快速逼近sx的目的 # 差距除于ty可以得到差距里包含多少个ty即n*ty # 我太笨了 tx -= ty * max((tx-sx)/ty, 1) else: ty -= tx * max((ty-sy)/tx, 1) return False 唯一摩尔斯密码词 唯一摩尔斯密码词1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def uniqueMorseRepresen","date":"2022-04-13T13:04:48.387Z","objectID":"1e4e49bf4f0d46c7609650c99d1329c0_0","order":0,"summary":"到达终点 到达终点1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 摘自评论 # https://leetcode-cn.com/problems/reaching-points/comments/85185 def reachingPoints(self, sx, sy, tx, ty): while tx \u003e 0 and ty \u003e 0: if tx == sx and ty == sy: return True if tx \u003e ty: # tx - sx是目标与起始值在x的差距，我们需要一次减去n * ty达到快速逼近sx的目的 # 差距除于ty可以得到差距里包含多少个ty即n*ty # 我太笨了 tx -= ty * max((tx-sx)/ty, 1) else: ty -= tx * max((ty-sy)/tx, 1) return False 唯一摩尔斯密码词 唯一摩尔斯密码词1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def uniqueMorseRepresen","tags":null,"title":"(leetcode) 四日四题","url":"http://localhost:1313/archives/leetcode-si-ri-si-ti/"},{"categories":["other"],"content":"tations(self, words): Mose =[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\", \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\", \"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] translate = [] for word in words: strs = '' for c in word: idx = ord(c) - ord('a') strs += Mose[idx] translate.append(strs) count = Counter(translate) return len(count) # 利用set元素不重复 class Solution(object): def uniqueMorseRepresentations(self, words): mos =[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\".","date":"2022-04-13T13:04:48.387Z","objectID":"1e4e49bf4f0d46c7609650c99d1329c0_1","order":1,"summary":"tations(self, words): Mose =[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\", \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\", \"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] translate = [] for word in words: strs = '' for c in word: idx = ord(c) - ord('a') strs += Mose[idx] translate.append(strs) count = Counter(translate) return len(count) # 利用set元素不重复 class Solution(object): def uniqueMorseRepresentations(self, words): mos =[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\".","tags":null,"title":"(leetcode) 四日四题","url":"http://localhost:1313/archives/leetcode-si-ri-si-ti/"},{"categories":["other"],"content":".\", \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\", \"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] ans = set() for w in words: t = \"\".join([mos[ord(letter)-ord('a')] for letter in w]) ans.add(t) return len(ans) 统计各位数字都不同的数字个数 统计各位数字都不同的数字个数 Linkn=0，数字有{0} 1个。n=1，数字有{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 10个。n=2，数字包括两部分之和，一部分为n=1的所有10个答案，另一部分为长度为2的新增数字。长度为2的新增数字可以在n=1的所有9个数字基础上进行拼接（0不能算）。例如：从n=1的数字列表{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}中随便取出一个除0以外的数字（因为0不能作为起始数字！），我们取2好了。通过在2的尾巴处拼接一位数字可以得到新的合法数字有：{","date":"2022-04-13T13:04:48.387Z","objectID":"1e4e49bf4f0d46c7609650c99d1329c0_2","order":2,"summary":".\", \".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\", \"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] ans = set() for w in words: t = \"\".join([mos[ord(letter)-ord('a')] for letter in w]) ans.add(t) return len(ans) 统计各位数字都不同的数字个数 统计各位数字都不同的数字个数 Linkn=0，数字有{0} 1个。n=1，数字有{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} 10个。n=2，数字包括两部分之和，一部分为n=1的所有10个答案，另一部分为长度为2的新增数字。长度为2的新增数字可以在n=1的所有9个数字基础上进行拼接（0不能算）。例如：从n=1的数字列表{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}中随便取出一个除0以外的数字（因为0不能作为起始数字！），我们取2好了。通过在2的尾巴处拼接一位数字可以得到新的合法数字有：{","tags":null,"title":"(leetcode) 四日四题","url":"http://localhost:1313/archives/leetcode-si-ri-si-ti/"},{"categories":["other"],"content":"二进制表示中质数个计算置位 二进制表示中质数个计算置位 [Link](https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/solution/ Link 1，计算整数x的二进制表示有多少个1： x\u0026=x-1可以消除x最低位的1，while循环计数，直到x=0即可。 2，只保留整数x最低位的1： x\u0026-x ，暨鼎鼎大名的lowbit \u003e\u003e1 相当于除2，\u0026lt;\u0026lt;1相当与乘2，因为一位相当于2^11 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 暴力，但忘记素数怎么求 def check(x): cnt = 0 while x != 0: x -= x \u0026 -x # x \u0026 -x cnt += 1 return isPrime(cnt) def isPrime(x): if x \u0026lt; 2: return False for i in range(2","date":"2022-04-12T10:45:54.126Z","objectID":"67566ca244d153b4d65836ff9dc6c262_0","order":0,"summary":"二进制表示中质数个计算置位 二进制表示中质数个计算置位 [Link](https://leetcode-cn.com/problems/prime-number-of-set-bits-in-binary-representation/solution/ Link 1，计算整数x的二进制表示有多少个1： x\u0026=x-1可以消除x最低位的1，while循环计数，直到x=0即可。 2，只保留整数x最低位的1： x\u0026-x ，暨鼎鼎大名的lowbit \u003e\u003e1 相当于除2，\u0026lt;\u0026lt;1相当与乘2，因为一位相当于2^11 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 暴力，但忘记素数怎么求 def check(x): cnt = 0 while x != 0: x -= x \u0026 -x # x \u0026 -x cnt += 1 return isPrime(cnt) def isPrime(x): if x \u0026lt; 2: return False for i in range(2","tags":["Python","LeetCode"],"title":"(leetcode) 四日四题","url":"http://localhost:1313/archives/leetcode-four-day-four-answer-1/"},{"categories":["other"],"content":", int(x**0.5)+1): # 优化循环次数 if x % i == 0: return False return True def countPrimeSetBits(left, right): ans = 0 for i in range(left, right + 1): if check(i): ans += 1 return ans # python库 def countPrimeSetBits(left, right): prime = (2, 3, 5, 7, 11, 13, 17, 19) # 因为right最大不超过20位 return sum(bin(i).count('1') in prime for i in range(left, right + 1)) # 10100010100010101100存储上述素数 # 当x中1的个数与该数求\u0026不为0，则说明1的个数在上述素数组合内 # python3 def countPrimeSetBits(left, right): return sum(((1 \u0026lt;\u0026lt; x.bit_count()) \u0026 6","date":"2022-04-12T10:45:54.126Z","objectID":"67566ca244d153b4d65836ff9dc6c262_1","order":1,"summary":", int(x**0.5)+1): # 优化循环次数 if x % i == 0: return False return True def countPrimeSetBits(left, right): ans = 0 for i in range(left, right + 1): if check(i): ans += 1 return ans # python库 def countPrimeSetBits(left, right): prime = (2, 3, 5, 7, 11, 13, 17, 19) # 因为right最大不超过20位 return sum(bin(i).count('1') in prime for i in range(left, right + 1)) # 10100010100010101100存储上述素数 # 当x中1的个数与该数求\u0026不为0，则说明1的个数在上述素数组合内 # python3 def countPrimeSetBits(left, right): return sum(((1 \u0026lt;\u0026lt; x.bit_count()) \u0026 6","tags":["Python","LeetCode"],"title":"(leetcode) 四日四题","url":"http://localhost:1313/archives/leetcode-four-day-four-answer-1/"},{"categories":["other"],"content":"二倍数对数组 二倍数对数组 思路就是 使得每一个奇数位置的值均是前一个位置的值的两倍，即凑成 n/2 对元素形如 (x, 2 * x) 的数对。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 利用python的Counter，计算每一个值的个数 # 只需要通过arr[2 * i + 1] = 2 * arr[2 * i] 是否符合即可 def canReorderDoubled(arr): cnt = Counter(arr) if cnt[0] % 2: # 如果0为奇数，则必不可能满足 return False print(sorted(cnt, key=abs)) for i in sorted(cnt, key=abs): if cnt[i] \u003e cnt[2 * i]: return False cnt[2*i] -= cnt[i] # 将(小，大)中的大数删除，防止cnt[2*大]没有值 return True # 用两个队列 # https://","date":"2022-04-10T10:41:59.589Z","objectID":"4b26147ab2603058ea620d57d2589303_0","order":0,"summary":"二倍数对数组 二倍数对数组 思路就是 使得每一个奇数位置的值均是前一个位置的值的两倍，即凑成 n/2 对元素形如 (x, 2 * x) 的数对。1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 利用python的Counter，计算每一个值的个数 # 只需要通过arr[2 * i + 1] = 2 * arr[2 * i] 是否符合即可 def canReorderDoubled(arr): cnt = Counter(arr) if cnt[0] % 2: # 如果0为奇数，则必不可能满足 return False print(sorted(cnt, key=abs)) for i in sorted(cnt, key=abs): if cnt[i] \u003e cnt[2 * i]: return False cnt[2*i] -= cnt[i] # 将(小，大)中的大数删除，防止cnt[2*大]没有值 return True # 用两个队列 # https://","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcode-three-day-three-code-1/"},{"categories":["other"],"content":"leetcode-cn.com/problems/array-of-doubled-pairs/solution/fen-jie-wei-liang-ge-dui-lie-by-mooc-3/ def canReorderDoubled(arr): q1 = [] q2 = [] arr = sorted(arr) for i in arr: if i \u0026lt; 0: if len(q1) and 2*i == q1[0]: q1.pop(0) else: q1.append(i) else: if len(q2) and i == 2*q2[0]: q2.pop(0) else: q2.append(i) if not len(q1) and not len(q2): return True return False 寻找比目标字母大的最小字母 寻找比目标字母大的最小字母 简单题重拳出击，二分法忘了😓1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def nextGreatestLetter(self, letters, t","date":"2022-04-10T10:41:59.589Z","objectID":"4b26147ab2603058ea620d57d2589303_1","order":1,"summary":"leetcode-cn.com/problems/array-of-doubled-pairs/solution/fen-jie-wei-liang-ge-dui-lie-by-mooc-3/ def canReorderDoubled(arr): q1 = [] q2 = [] arr = sorted(arr) for i in arr: if i \u0026lt; 0: if len(q1) and 2*i == q1[0]: q1.pop(0) else: q1.append(i) else: if len(q2) and i == 2*q2[0]: q2.pop(0) else: q2.append(i) if not len(q1) and not len(q2): return True return False 寻找比目标字母大的最小字母 寻找比目标字母大的最小字母 简单题重拳出击，二分法忘了😓1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def nextGreatestLetter(self, letters, t","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcode-three-day-three-code-1/"},{"categories":["other"],"content":"arget): for i in letters: if ord(i)-ord(target) \u003e 0: return i return letters[0] # 二分 def nextGreatestLetter(letters, target): n = len(letters) l, r = 0, n - 1 while l \u0026lt; r: print(l, r, l + r \u003e\u003e 1, (l + r) // 2, bin(l + r)) mid = l + r \u003e\u003e 1 # l + r \u003e\u003e 1 \u0026lt;=\u003e (l + r) // 2 运算符优先级 if letters[mid] \u003e target: r = mid else: l = mid + 1 return letters[r] if letters[r] \u003e target else letters[0] # 一行 # https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/comments/1482439 def nextGre","date":"2022-04-10T10:41:59.589Z","objectID":"4b26147ab2603058ea620d57d2589303_2","order":2,"summary":"arget): for i in letters: if ord(i)-ord(target) \u003e 0: return i return letters[0] # 二分 def nextGreatestLetter(letters, target): n = len(letters) l, r = 0, n - 1 while l \u0026lt; r: print(l, r, l + r \u003e\u003e 1, (l + r) // 2, bin(l + r)) mid = l + r \u003e\u003e 1 # l + r \u003e\u003e 1 \u0026lt;=\u003e (l + r) // 2 运算符优先级 if letters[mid] \u003e target: r = mid else: l = mid + 1 return letters[r] if letters[r] \u003e target else letters[0] # 一行 # https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/comments/1482439 def nextGre","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcode-three-day-three-code-1/"},{"categories":["other"],"content":"atestLetter(self, letters: List[str], target: str) -\u003e str: return letters[bisect.bisect(letters, target) % len(letters)] 区域和检索 - 数组可修改 区域和检索 - 数组可修改 前缀和概念：Link、Link2int n = nums.length; int[] preSum = new int[n + 1]; // 前缀和数组 preSum[0] = 0; for (int i = 0; i \u0026lt; n; i++) preSum[i + 1] = preSum[i] + nums[i];树形数组 先记住最精髓的一句话：树状数组本质是二进制规律的应用 假设现在有一个线性数组A,为了便于理解A的范围从1--8。 并构造一个数组C，范围也是1--8 接下来将C构造为那么一个树结构： 观察这棵树结构，可以发现叶子结点的二进制的最后一位为1。接下来的结点为倒数第二位为1.... 现在，我们对这棵树结构赋予其涵义：二进制 1=(001) C[1]=A[1]; 2=(010) ","date":"2022-04-10T10:41:59.589Z","objectID":"4b26147ab2603058ea620d57d2589303_3","order":3,"summary":"atestLetter(self, letters: List[str], target: str) -\u003e str: return letters[bisect.bisect(letters, target) % len(letters)] 区域和检索 - 数组可修改 区域和检索 - 数组可修改 前缀和概念：Link、Link2int n = nums.length; int[] preSum = new int[n + 1]; // 前缀和数组 preSum[0] = 0; for (int i = 0; i \u0026lt; n; i++) preSum[i + 1] = preSum[i] + nums[i];树形数组 先记住最精髓的一句话：树状数组本质是二进制规律的应用 假设现在有一个线性数组A,为了便于理解A的范围从1--8。 并构造一个数组C，范围也是1--8 接下来将C构造为那么一个树结构： 观察这棵树结构，可以发现叶子结点的二进制的最后一位为1。接下来的结点为倒数第二位为1.... 现在，我们对这棵树结构赋予其涵义：二进制 1=(001) C[1]=A[1]; 2=(010) ","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcode-three-day-three-code-1/"},{"categories":["other"],"content":"C[2]=A[1]+A[2]; 3=(011) C[3]=A[3]; 4=(100) C[4]=A[1]+A[2]+A[3]+A[4]; 5=(101) C[5]=A[5]; 6=(110) C[6]=A[5]+A[6]; 7=(111) C[7]=A[7]; 8=(1000) C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];这么说吧，这棵树的规律就是找出相应结点的二进制最后一位的1并该位后面的0也截出(后面会讲的lowBit函数)。 如5(101),最后一个1截出为1，那么它只有一个结点，那么他就是叶子结点。 如6(110),最后一个1截出为10，那么它这棵子树上有两个结点非常重要：而某元素的父结点为该结点6(110)加上此结点的二进制截出最后一位的1(即010)(后面会讲的lowBit函数)。 如6(110)+2(010)=8(1000)树形数组的单点元素修改和查询区间和规律 1.lowBit函数1 2 3 int lowBit(int x) { return x \u0026 -x; } 我们先需要知道lowBit函数的含义：可以用来获取某个二进制","date":"2022-04-10T10:41:59.589Z","objectID":"4b26147ab2603058ea620d57d2589303_4","order":4,"summary":"C[2]=A[1]+A[2]; 3=(011) C[3]=A[3]; 4=(100) C[4]=A[1]+A[2]+A[3]+A[4]; 5=(101) C[5]=A[5]; 6=(110) C[6]=A[5]+A[6]; 7=(111) C[7]=A[7]; 8=(1000) C[8]=A[1]+A[2]+A[3]+A[4]+A[5]+A[6]+A[7]+A[8];这么说吧，这棵树的规律就是找出相应结点的二进制最后一位的1并该位后面的0也截出(后面会讲的lowBit函数)。 如5(101),最后一个1截出为1，那么它只有一个结点，那么他就是叶子结点。 如6(110),最后一个1截出为10，那么它这棵子树上有两个结点非常重要：而某元素的父结点为该结点6(110)加上此结点的二进制截出最后一位的1(即010)(后面会讲的lowBit函数)。 如6(110)+2(010)=8(1000)树形数组的单点元素修改和查询区间和规律 1.lowBit函数1 2 3 int lowBit(int x) { return x \u0026 -x; } 我们先需要知道lowBit函数的含义：可以用来获取某个二进制","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcode-three-day-three-code-1/"},{"categories":["tech"],"content":"HEU KMS Activator 用于Windows激活 原文Link，纯粹为了记录，与原文一致 我常给自己或者亲朋好友的电脑重装系统，基于稳定性和系统运行速度等因素考量，一般都会选择安装Windows 10 Enterprise LTSC 2019。之前曾使用过国外网友s1ave77制作的Windows 10数字权利激活工具——HWIDGEN，遗憾的是该软件不支持以数字许可证永久激活LTSC 2019，仅能用KMS离线激活，让系统有效期延长到2038年。小知识： 数字许可证（在 Windows 10 版本 1511 中称为数字授权）是 Windows 10 的一种激活方法，该方法不需要输入产品密钥。激活后会自动把当前电脑硬件信息上传到微软服务器中，以后重装系统时会自动与微软服务器中存储的激活信息相比对，信息相符即自动激活该设备，免去了用户记忆和输入产品密钥的麻烦。 在同一台电脑上主要硬件（CPU和主板等）不变化的情况下，每次重新安装系统时无需再次输入密钥，系统会在自动连接到微软服务器进行激活。如果你在电脑登录了Microsoft帐户，那么数字许可证还会自动关联你的账户，即使你更换电","date":"2022-04-04T19:22:25.289Z","objectID":"df5b90c987aa3941249abaa0e25cd0ba_0","order":0,"summary":"HEU KMS Activator 用于Windows激活 原文Link，纯粹为了记录，与原文一致 我常给自己或者亲朋好友的电脑重装系统，基于稳定性和系统运行速度等因素考量，一般都会选择安装Windows 10 Enterprise LTSC 2019。之前曾使用过国外网友s1ave77制作的Windows 10数字权利激活工具——HWIDGEN，遗憾的是该软件不支持以数字许可证永久激活LTSC 2019，仅能用KMS离线激活，让系统有效期延长到2038年。小知识： 数字许可证（在 Windows 10 版本 1511 中称为数字授权）是 Windows 10 的一种激活方法，该方法不需要输入产品密钥。激活后会自动把当前电脑硬件信息上传到微软服务器中，以后重装系统时会自动与微软服务器中存储的激活信息相比对，信息相符即自动激活该设备，免去了用户记忆和输入产品密钥的麻烦。 在同一台电脑上主要硬件（CPU和主板等）不变化的情况下，每次重新安装系统时无需再次输入密钥，系统会在自动连接到微软服务器进行激活。如果你在电脑登录了Microsoft帐户，那么数字许可证还会自动关联你的账户，即使你更换电","tags":["Software"],"title":"Windows相关软件","url":"http://localhost:1313/archives/windows-software/"},{"categories":["tech"],"content":"脑，只要登录账户就可以激活相同版本的系统。那么，有没有一款能支持以数字许可证永久激活LTSC 2019，而且不捆绑恶意软件，不篡改浏览器主页或静默下载安装广告软件等不法行为的的系统激活工具？答案当然有，这款软件叫HEU KMS Activator！HEU KMS Activator的优势在于纯粹的本地搭建服务器几乎无需联网，同时不含有任何广告或后门程序不篡改系统设置等。该工具原理主要是在本地搭建KMS服务器通过GVLK密钥激活。 这款激活软件之前颇有名气，其作者“知彼而知己”近期已更新到v20版本，这次更新采用了全新的UI设计，告别繁琐的操作，主页面的“橘黄色按钮”为智能激活按钮，将根据当前的Windows系统和Office，智能判断最佳的激活方式。诸如以下的问题，根本无需担心，只需一键按照激活按钮，HEU KMS Activator将自动提供最佳的解决方案—— 已永久激活的Windows或Office会不会破坏？ 安装了多个版本的Office怎么激活？ Retail版Office会不会转化成VL版 会不会数字权利激活？ Windows7能不能激活？ 怎么安装KMS的自动续期功能？ .","date":"2022-04-04T19:22:25.289Z","objectID":"df5b90c987aa3941249abaa0e25cd0ba_1","order":1,"summary":"脑，只要登录账户就可以激活相同版本的系统。那么，有没有一款能支持以数字许可证永久激活LTSC 2019，而且不捆绑恶意软件，不篡改浏览器主页或静默下载安装广告软件等不法行为的的系统激活工具？答案当然有，这款软件叫HEU KMS Activator！HEU KMS Activator的优势在于纯粹的本地搭建服务器几乎无需联网，同时不含有任何广告或后门程序不篡改系统设置等。该工具原理主要是在本地搭建KMS服务器通过GVLK密钥激活。 这款激活软件之前颇有名气，其作者“知彼而知己”近期已更新到v20版本，这次更新采用了全新的UI设计，告别繁琐的操作，主页面的“橘黄色按钮”为智能激活按钮，将根据当前的Windows系统和Office，智能判断最佳的激活方式。诸如以下的问题，根本无需担心，只需一键按照激活按钮，HEU KMS Activator将自动提供最佳的解决方案—— 已永久激活的Windows或Office会不会破坏？ 安装了多个版本的Office怎么激活？ Retail版Office会不会转化成VL版 会不会数字权利激活？ Windows7能不能激活？ 怎么安装KMS的自动续期功能？ .","tags":["Software"],"title":"Windows相关软件","url":"http://localhost:1313/archives/windows-software/"},{"categories":["tech"],"content":"...... HEU KMS Activator支持激活Windows Vista/7/8/10/Server 2008/2008R2等微软系统，新增Windows 10 LTSC 2019数字激活。另外，也支持激活批量授权Office 2019及以下版本。亲测使用HEU KMS Activator，以数字许可证方式成功永久激活LTSC 2019HEU KMS Activator 当前最新版本下载： HEU KMS Activator最新版本下载地址** （访问密码：2278）** 文件: HEU_KMS_Activator_v24.6.1.exe SHA1: 6375D61442698AA57FFD56DA26CE09661504AC8C 本次更新，修复了一些已知的Bug。全面支持Office 2021以及Windows Server 2022和Win10 IoT Enterprise 2021 LTSC。并且如果Microsoft 365已订阅激活，则自动跳过。 [2022.01.17] v24.6.1 更新说明： 1.修复ARM64架构下激活失败的Bug。 2.修复Office ","date":"2022-04-04T19:22:25.289Z","objectID":"df5b90c987aa3941249abaa0e25cd0ba_2","order":2,"summary":"...... HEU KMS Activator支持激活Windows Vista/7/8/10/Server 2008/2008R2等微软系统，新增Windows 10 LTSC 2019数字激活。另外，也支持激活批量授权Office 2019及以下版本。亲测使用HEU KMS Activator，以数字许可证方式成功永久激活LTSC 2019HEU KMS Activator 当前最新版本下载： HEU KMS Activator最新版本下载地址** （访问密码：2278）** 文件: HEU_KMS_Activator_v24.6.1.exe SHA1: 6375D61442698AA57FFD56DA26CE09661504AC8C 本次更新，修复了一些已知的Bug。全面支持Office 2021以及Windows Server 2022和Win10 IoT Enterprise 2021 LTSC。并且如果Microsoft 365已订阅激活，则自动跳过。 [2022.01.17] v24.6.1 更新说明： 1.修复ARM64架构下激活失败的Bug。 2.修复Office ","tags":["Software"],"title":"Windows相关软件","url":"http://localhost:1313/archives/windows-software/"},{"categories":["tech"],"content":"UWP激活后仍有盗版提示的弹窗。根据2013年1月30日《计算机软件保护条例》的第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬。正版与盗版这两个说法为法律上的概念，凡是没有取得官方授权的均都属于盗版。本软件作为激活原理研究、交流使用，不得用于商业用途，且下载后请在24小时内删除。如需要使用Windows/Office等，请前往正规渠道，购买微软官方正版软件。 由于软件的特殊性，经常会被一些杀毒软件误报，本软件保证绝对纯净。使用前请检验软件SHA1值(见更新日志)，准确无误后请放心使用。使用HEU KMS Activator进行激活后和正版的功能没有任何区别。根据网友的建议和反馈进行不定期更新。","date":"2022-04-04T19:22:25.289Z","objectID":"df5b90c987aa3941249abaa0e25cd0ba_3","order":3,"summary":"UWP激活后仍有盗版提示的弹窗。根据2013年1月30日《计算机软件保护条例》的第十七条规定：为了学习和研究软件内含的设计思想和原理，通过安装、显示、传输或者存储软件等方式使用软件的，可以不经软件著作权人许可，不向其支付报酬。正版与盗版这两个说法为法律上的概念，凡是没有取得官方授权的均都属于盗版。本软件作为激活原理研究、交流使用，不得用于商业用途，且下载后请在24小时内删除。如需要使用Windows/Office等，请前往正规渠道，购买微软官方正版软件。 由于软件的特殊性，经常会被一些杀毒软件误报，本软件保证绝对纯净。使用前请检验软件SHA1值(见更新日志)，准确无误后请放心使用。使用HEU KMS Activator进行激活后和正版的功能没有任何区别。根据网友的建议和反馈进行不定期更新。","tags":["Software"],"title":"Windows相关软件","url":"http://localhost:1313/archives/windows-software/"},{"categories":["other"],"content":"找出缺失的观测数据 找出缺失的观测数据1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 我的题解 def missingRolls(rolls, mean, n): loss_sum = mean * (n + len(rolls)) - sum(rolls) loss_l = [] if not n \u0026lt;= loss_sum \u0026lt;= 6*n: return loss_l for i in range(n): # 没找出规律，瞎猫碰上死耗子 num = loss_sum // n loss_l.append(num) loss_sum -= num n -= 1 return loss_l # 官方题解 def missingRolls(rolls, mean, n): missingSum = mean * (n + len(rolls)) - sum(rolls) if not n \u0026lt;= missingSum \u0026lt;= n * 6: return [] # divmod(x, y) re","date":"2022-03-30T14:53:45.377Z","objectID":"e1586ae95d6c58f3ef5359f45365d922_0","order":0,"summary":"找出缺失的观测数据 找出缺失的观测数据1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 我的题解 def missingRolls(rolls, mean, n): loss_sum = mean * (n + len(rolls)) - sum(rolls) loss_l = [] if not n \u0026lt;= loss_sum \u0026lt;= 6*n: return loss_l for i in range(n): # 没找出规律，瞎猫碰上死耗子 num = loss_sum // n loss_l.append(num) loss_sum -= num n -= 1 return loss_l # 官方题解 def missingRolls(rolls, mean, n): missingSum = mean * (n + len(rolls)) - sum(rolls) if not n \u0026lt;= missingSum \u0026lt;= n * 6: return [] # divmod(x, y) re","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcodethree-day-three-code/"},{"categories":["other"],"content":"turn the tuple (x//y, x%y) quotient, remainder = divmod(missingSum, n) return [quotient + 1] * remainder + [quotient] * (n - remainder) # 作者：himymBen def missingRolls(rolls: List[int], mean: int, n: int) -\u003e List[int]: return [s // n + 1] * (s % n) + [s // n] * (n - s % n) if n \u0026lt;= (s := mean * (len(rolls) + n) - sum(rolls)) \u0026lt;= 6 * n else [] 交替位二进制数 交替位二进制数 原本以为超时，没想到直接ac了1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def hasAlternatingBits(n)","date":"2022-03-30T14:53:45.377Z","objectID":"e1586ae95d6c58f3ef5359f45365d922_1","order":1,"summary":"turn the tuple (x//y, x%y) quotient, remainder = divmod(missingSum, n) return [quotient + 1] * remainder + [quotient] * (n - remainder) # 作者：himymBen def missingRolls(rolls: List[int], mean: int, n: int) -\u003e List[int]: return [s // n + 1] * (s % n) + [s // n] * (n - s % n) if n \u0026lt;= (s := mean * (len(rolls) + n) - sum(rolls)) \u0026lt;= 6 * n else [] 交替位二进制数 交替位二进制数 原本以为超时，没想到直接ac了1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def hasAlternatingBits(n)","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcodethree-day-three-code/"},{"categories":["other"],"content":": while n: sam = n % 2 n //= 2 if sam == n %2: return False return True # 打表 def hasAlternatingBits(n): return n in { 1, 2, 5, 10, 21, 42, 85, 170, 341, 682, 1365, 2730, 5461, 10922, 21845, 43690, 87381, 174762, 349525, 699050, 1398101, 2796202, 5592405, 11184810, 22369621, 44739242, 89478485, 178956970, 357913941, 715827882, 1431655765 } # 异或 def hasAlternatingBits(self, n: int) -\u003e bool: a = n ^ (n \u003e\u003e 1) return a \u0026 (a + 1) == 0 # https://leetcode-cn.com/problems/binary-number-with-alternating-b","date":"2022-03-30T14:53:45.377Z","objectID":"e1586ae95d6c58f3ef5359f45365d922_2","order":2,"summary":": while n: sam = n % 2 n //= 2 if sam == n %2: return False return True # 打表 def hasAlternatingBits(n): return n in { 1, 2, 5, 10, 21, 42, 85, 170, 341, 682, 1365, 2730, 5461, 10922, 21845, 43690, 87381, 174762, 349525, 699050, 1398101, 2796202, 5592405, 11184810, 22369621, 44739242, 89478485, 178956970, 357913941, 715827882, 1431655765 } # 异或 def hasAlternatingBits(self, n: int) -\u003e bool: a = n ^ (n \u003e\u003e 1) return a \u0026 (a + 1) == 0 # https://leetcode-cn.com/problems/binary-number-with-alternating-b","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcodethree-day-three-code/"},{"categories":["other"],"content":"作为第一篇力扣每日一题，要好好坚持，广大网友给我监督！！(后记，没坚持下去😅)图片平滑器 图片平滑器1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # 速度有点拉跨 def imageSmoother(self, img): import numpy as np import copy # 利用pad填充原矩阵，并且防止原矩阵有0，故填充-1 padList = np.pad(img, ((1, 1), (1, 1)), 'constant', constant_values=-1) # 不用深拷贝会报错 # https://leetcode-cn.com/problems/image-smoother/comments/1461270 newImg = copy.deepcopy(img) # 获取img的行列 m, n = len(img), len(img[0]) for i in range(m): for j in ran","date":"2022-03-26T10:02:04.603Z","objectID":"bb1cad2b333105f9baf4cf22cd77286a_0","order":0,"summary":"作为第一篇力扣每日一题，要好好坚持，广大网友给我监督！！(后记，没坚持下去😅)图片平滑器 图片平滑器1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # 速度有点拉跨 def imageSmoother(self, img): import numpy as np import copy # 利用pad填充原矩阵，并且防止原矩阵有0，故填充-1 padList = np.pad(img, ((1, 1), (1, 1)), 'constant', constant_values=-1) # 不用深拷贝会报错 # https://leetcode-cn.com/problems/image-smoother/comments/1461270 newImg = copy.deepcopy(img) # 获取img的行列 m, n = len(img), len(img[0]) for i in range(m): for j in ran","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcode-one-question-per-day/"},{"categories":["other"],"content":"ge(n): # 深拷贝，防止后续修改padList zeroList = copy.deepcopy(padList[i: i + 3, j:j + 3]) # 计算9个元素中哪些元素是原数组，即非 -1 就是原元素 count = 9 - np.sum(zeroList == -1) # 遮罩层，重新置为0方便sum求和 # 或者得到-1的个数重新加回去，减小内存开销 mask = (zeroList == -1) zeroList[mask] = 0 # 计算值 newImg[i][j] = np.sum(zeroList) // count return newImg # 修改版 def imageSmoother(self, img): import numpy as np padList = np.pad(img, ((1, 1), (1, 1)), 'constant', constant_values=-1) newImg = img m, n = len(img), len(img[0]) for i in range(m): for j in range(n): z","date":"2022-03-26T10:02:04.603Z","objectID":"bb1cad2b333105f9baf4cf22cd77286a_1","order":1,"summary":"ge(n): # 深拷贝，防止后续修改padList zeroList = copy.deepcopy(padList[i: i + 3, j:j + 3]) # 计算9个元素中哪些元素是原数组，即非 -1 就是原元素 count = 9 - np.sum(zeroList == -1) # 遮罩层，重新置为0方便sum求和 # 或者得到-1的个数重新加回去，减小内存开销 mask = (zeroList == -1) zeroList[mask] = 0 # 计算值 newImg[i][j] = np.sum(zeroList) // count return newImg # 修改版 def imageSmoother(self, img): import numpy as np padList = np.pad(img, ((1, 1), (1, 1)), 'constant', constant_values=-1) newImg = img m, n = len(img), len(img[0]) for i in range(m): for j in range(n): z","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcode-one-question-per-day/"},{"categories":["other"],"content":"eroList = padList[i: i + 3, j:j + 3] count = np.sum(zeroList \u003e -1) mask = (zeroList \u003e -1) newImg[i][j] = np.sum(zeroList[mask])//count return newImg 大佬题解 Link1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 m, n = len(img), len(img[0]) newImg = [[0] * n for _ in range(m)] for idx in range(m * n): # 除以n非m cur_r = idx // n # r行 cur_c = idx % n # c列 x1, y1 = cur_r, cur_c x2, y2 = cur_r, cur_c sum1 = 0 if cur_r - 1 \u003e= 0: # 上限 (-1, 0) 往上走不行 x1 = cur_r - 1 if cur_r + 1 \u0026lt; m: # 下限 (m+1,","date":"2022-03-26T10:02:04.603Z","objectID":"bb1cad2b333105f9baf4cf22cd77286a_2","order":2,"summary":"eroList = padList[i: i + 3, j:j + 3] count = np.sum(zeroList \u003e -1) mask = (zeroList \u003e -1) newImg[i][j] = np.sum(zeroList[mask])//count return newImg 大佬题解 Link1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 m, n = len(img), len(img[0]) newImg = [[0] * n for _ in range(m)] for idx in range(m * n): # 除以n非m cur_r = idx // n # r行 cur_c = idx % n # c列 x1, y1 = cur_r, cur_c x2, y2 = cur_r, cur_c sum1 = 0 if cur_r - 1 \u003e= 0: # 上限 (-1, 0) 往上走不行 x1 = cur_r - 1 if cur_r + 1 \u0026lt; m: # 下限 (m+1,","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcode-one-question-per-day/"},{"categories":["other"],"content":" 0) 往下走不行 x2 = cur_r + 1 if cur_c - 1 \u003e= 0: # 左限 (0, -1) 往左走不行 y1 = cur_c - 1 if cur_c + 1 \u0026lt; n: # 右限 (0, n+1) 往右走不行 y2 = cur_c + 1 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): sum1 += img[i][j] count = (y2 - y1 + 1) * (x2 - x1 + 1) print(sum1) newImg[cur_r][cur_c] = sum1 // count return newImg python性能好版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # list版 占13.9mb def imageSmoother(self, img): res = [] l1, l2 = len(img), len(img[0]) expand = np.pad(img","date":"2022-03-26T10:02:04.603Z","objectID":"bb1cad2b333105f9baf4cf22cd77286a_3","order":3,"summary":" 0) 往下走不行 x2 = cur_r + 1 if cur_c - 1 \u003e= 0: # 左限 (0, -1) 往左走不行 y1 = cur_c - 1 if cur_c + 1 \u0026lt; n: # 右限 (0, n+1) 往右走不行 y2 = cur_c + 1 for i in range(x1, x2 + 1): for j in range(y1, y2 + 1): sum1 += img[i][j] count = (y2 - y1 + 1) * (x2 - x1 + 1) print(sum1) newImg[cur_r][cur_c] = sum1 // count return newImg python性能好版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # list版 占13.9mb def imageSmoother(self, img): res = [] l1, l2 = len(img), len(img[0]) expand = np.pad(img","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcode-one-question-per-day/"},{"categories":["other"],"content":", ((1, 1), (1, 1)), 'constant', constant_values=-1) expand = expand.tolist() res = [[0] * l2 for _ in range(l1)] for i in range(l1): for j in range(l2): nine = [expand[i][j], expand[i][j + 1], expand[i][j + 2], expand[i + 1][j], expand[i + 1][j + 1], expand[i + 1][j + 2], expand[i + 2][j], expand[i + 2][j + 1], expand[i + 2][j + 2]] num = nine.count(-1) res[i][j] = (sum(nine) + num) // (9 - num) return res # numpy版 占25.3mb def imageSmoother(self, img): import numpy as np l1, l2 = len(img), len(i","date":"2022-03-26T10:02:04.603Z","objectID":"bb1cad2b333105f9baf4cf22cd77286a_4","order":4,"summary":", ((1, 1), (1, 1)), 'constant', constant_values=-1) expand = expand.tolist() res = [[0] * l2 for _ in range(l1)] for i in range(l1): for j in range(l2): nine = [expand[i][j], expand[i][j + 1], expand[i][j + 2], expand[i + 1][j], expand[i + 1][j + 1], expand[i + 1][j + 2], expand[i + 2][j], expand[i + 2][j + 1], expand[i + 2][j + 2]] num = nine.count(-1) res[i][j] = (sum(nine) + num) // (9 - num) return res # numpy版 占25.3mb def imageSmoother(self, img): import numpy as np l1, l2 = len(img), len(i","tags":["Python","LeetCode"],"title":"(leetcode) 三日三题","url":"http://localhost:1313/archives/leetcode-one-question-per-day/"},{"categories":["tech"],"content":"概要：本博客使用Halo搭建，域名通过name.com进行购买，使用cloudflare进行cdn代理，服务器是阿里云的，对象存储用的是腾讯云的按量付费50g。购买域名 首先，当然是买个域名啦，可以选择国内网址，但是要备案，好处就是国内比较便宜，备案也较为轻松，也可以选国外网址，不需要备案，而且更加随心所欲一点。域名网址 我这里用的是name.com买的网址。这是我的分享链接，（购买会便宜36，当然我也有点小利润）先输入你心仪的域名，如keepjolly.com，他就会告诉你这个域名是否被购买，以及其他后缀的域名。.com后缀会稍微贵一些，其他域名会便宜点 点击加入购物车，然后点上面的购物车图标，（如果点击结账，就会跳转到下面的界面，然后点击购物车） 这是点击结账的页面。 选择你要购买几年，如果有信心运营下去的话，建议多买几年，首先买一年试试水吧 促销码可以Google一下，我当初便宜了一年的Advanced Security + Privacy促销码**：**PRIVACYPLEASE 减去那个附加项、RENEW 续费便宜15% 联合使用的话，先renew，然后在域名管理页再续费pr","date":"2022-03-19T20:11:01.786Z","objectID":"35f6a2c19f3287a885e4b630f2f6e620_0","order":0,"summary":"概要：本博客使用Halo搭建，域名通过name.com进行购买，使用cloudflare进行cdn代理，服务器是阿里云的，对象存储用的是腾讯云的按量付费50g。购买域名 首先，当然是买个域名啦，可以选择国内网址，但是要备案，好处就是国内比较便宜，备案也较为轻松，也可以选国外网址，不需要备案，而且更加随心所欲一点。域名网址 我这里用的是name.com买的网址。这是我的分享链接，（购买会便宜36，当然我也有点小利润）先输入你心仪的域名，如keepjolly.com，他就会告诉你这个域名是否被购买，以及其他后缀的域名。.com后缀会稍微贵一些，其他域名会便宜点 点击加入购物车，然后点上面的购物车图标，（如果点击结账，就会跳转到下面的界面，然后点击购物车） 这是点击结账的页面。 选择你要购买几年，如果有信心运营下去的话，建议多买几年，首先买一年试试水吧 促销码可以Google一下，我当初便宜了一年的Advanced Security + Privacy促销码**：**PRIVACYPLEASE 减去那个附加项、RENEW 续费便宜15% 联合使用的话，先renew，然后在域名管理页再续费pr","tags":["Blog","Server"],"title":"Halo博客搭建---一个属于自己的网站","url":"http://localhost:1313/archives/halo-blog-build-a-website-of-your-own/"},{"categories":["tech"],"content":"ivacy，（目前还没试过）然后就可以付款了。付款可以选择支付宝，然后就不截图了。 买后之后（因为我是买后再写博文，所以没有买后的跳转页面，我这里直接放上域名管理页面） 这是域名管理页面，一般都是自动勾选上的，自动续订需要绑信用卡，下面的域名服务器等下要替换成cloudflare。 域名购买就到这里结束了 给域名套上cdn 因为我的是国外域名，所以弄了个国外的cdn，如果是在国内购买域名，建议选国内的cdn（另外也有可能买服务器或者域名会送cdn服务）。（另外有大佬也说，套国外的cdn对国内会影响访问速度，而且也不需要ddos防御，毕竟小网站，但最后反正也免费，索性就配置一下）。注册cloudflare 这里就不说了，这都不会建议别套cdn了😂。这个cdn网站还有中文添加要加速的网站 就是添加站点把你的网址输入进去即可。 选择付费计划 白嫖怪当然选择免费计划啦，主要就是防止ddos攻击。 如果是国外的域名购买网站如namesilo、godaddy，Link here 这里展示一下name、和阿里云的。查看dns记录 建议也用上面那个链接，这里我因为点了返回，直接进入下一步了。完成名称服","date":"2022-03-19T20:11:01.786Z","objectID":"35f6a2c19f3287a885e4b630f2f6e620_1","order":1,"summary":"ivacy，（目前还没试过）然后就可以付款了。付款可以选择支付宝，然后就不截图了。 买后之后（因为我是买后再写博文，所以没有买后的跳转页面，我这里直接放上域名管理页面） 这是域名管理页面，一般都是自动勾选上的，自动续订需要绑信用卡，下面的域名服务器等下要替换成cloudflare。 域名购买就到这里结束了 给域名套上cdn 因为我的是国外域名，所以弄了个国外的cdn，如果是在国内购买域名，建议选国内的cdn（另外也有可能买服务器或者域名会送cdn服务）。（另外有大佬也说，套国外的cdn对国内会影响访问速度，而且也不需要ddos防御，毕竟小网站，但最后反正也免费，索性就配置一下）。注册cloudflare 这里就不说了，这都不会建议别套cdn了😂。这个cdn网站还有中文添加要加速的网站 就是添加站点把你的网址输入进去即可。 选择付费计划 白嫖怪当然选择免费计划啦，主要就是防止ddos攻击。 如果是国外的域名购买网站如namesilo、godaddy，Link here 这里展示一下name、和阿里云的。查看dns记录 建议也用上面那个链接，这里我因为点了返回，直接进入下一步了。完成名称服","tags":["Blog","Server"],"title":"Halo博客搭建---一个属于自己的网站","url":"http://localhost:1313/archives/halo-blog-build-a-website-of-your-own/"},{"categories":["tech"],"content":"务器设置 复制cloudflare的名称服务器，一共两条 name.com 选择最下面的管理域名服务器 添加刚刚复制的那两条，添加完成后，cloudflare就能托管你的网站了 aliyun.com 首先当然是登录啦，登陆成功后点击第一步的“我的阿里云”。然后如果你买了域名的话，在第二步应该能看见你的域名“控制台”，点进去。 然后在域名列表里，点击你的网址，（国内记得备案哦，备案就不介绍了，网上查一查吧） 点击“修改DNS” 复制cloudflare 的名称服务器，cv就完事了 cloudflare快速入门指南 全选是就行了，最后就是这样子。 其他设置 参考上面的link（快速入门指南以及包括了大部分了）。另外，如果需要进行端到端加密的话，官网是这样子介绍的，我因为有段时间没弄这篇博客，有点忘记怎么弄了。这里就给个本机生成SSL证书，（好像大概率用的是宝塔自动产生的SSL证书），但是具体怎么套入，看看官网，或者我帮你试试。另外自己的域名购买网站记得加上SSL证书，这里也不说了，应该把本机生成的放进去就好了，或者宝塔里的，（时间有点久，不知道怎么操作了，抱歉）。另外看到阿里云有付费的SS","date":"2022-03-19T20:11:01.786Z","objectID":"35f6a2c19f3287a885e4b630f2f6e620_2","order":2,"summary":"务器设置 复制cloudflare的名称服务器，一共两条 name.com 选择最下面的管理域名服务器 添加刚刚复制的那两条，添加完成后，cloudflare就能托管你的网站了 aliyun.com 首先当然是登录啦，登陆成功后点击第一步的“我的阿里云”。然后如果你买了域名的话，在第二步应该能看见你的域名“控制台”，点进去。 然后在域名列表里，点击你的网址，（国内记得备案哦，备案就不介绍了，网上查一查吧） 点击“修改DNS” 复制cloudflare 的名称服务器，cv就完事了 cloudflare快速入门指南 全选是就行了，最后就是这样子。 其他设置 参考上面的link（快速入门指南以及包括了大部分了）。另外，如果需要进行端到端加密的话，官网是这样子介绍的，我因为有段时间没弄这篇博客，有点忘记怎么弄了。这里就给个本机生成SSL证书，（好像大概率用的是宝塔自动产生的SSL证书），但是具体怎么套入，看看官网，或者我帮你试试。另外自己的域名购买网站记得加上SSL证书，这里也不说了，应该把本机生成的放进去就好了，或者宝塔里的，（时间有点久，不知道怎么操作了，抱歉）。另外看到阿里云有付费的SS","tags":["Blog","Server"],"title":"Halo博客搭建---一个属于自己的网站","url":"http://localhost:1313/archives/halo-blog-build-a-website-of-your-own/"},{"categories":["tech"],"content":"L证书，Google后，其实免费的对于个人博客来说就够了。阿里云的SSL证书签发 点击开启SSL证书 买免费的就行了 点证书申请，然后输入你的域名，然后下一步 然后在cloudflare的DNS记录里新建txt，对应cv就行了。 购买服务器 这里选的是阿里云的，如果需要国外的，点更多商品。下面的点开后，我选的是ECS突发性能型 t6 - 新加坡，下面是我的配置，因为没有新用户，很贵。 搭建博客 这里推荐一个up，BV1JN411Q7Na（文字版建议两者结合），我时隔已久，而且已经是装完的状态了，所以无法展示了。按照他的来可以搭建出来Halo的博客，但后来我记得部署完halo后，halo页面无法显示，可能按照清缓存，重启服务器，等待一会儿就行了。 啊啊啊，原本想从0开始搭建出自己的博客来着，属于是推着推着就忘了好多。如果有需要，我可以帮你尝试一下建博客（不保证行不行，因为我也是看网上教程来的）。对象存储 国外买国外的存储桶，记得开防盗链，然后用picgo管理，插件是picgo-plugin-pic-migrater它可以将语雀导出的markdown里的图片自动上传到存储桶，并新建一个.m","date":"2022-03-19T20:11:01.786Z","objectID":"35f6a2c19f3287a885e4b630f2f6e620_3","order":3,"summary":"L证书，Google后，其实免费的对于个人博客来说就够了。阿里云的SSL证书签发 点击开启SSL证书 买免费的就行了 点证书申请，然后输入你的域名，然后下一步 然后在cloudflare的DNS记录里新建txt，对应cv就行了。 购买服务器 这里选的是阿里云的，如果需要国外的，点更多商品。下面的点开后，我选的是ECS突发性能型 t6 - 新加坡，下面是我的配置，因为没有新用户，很贵。 搭建博客 这里推荐一个up，BV1JN411Q7Na（文字版建议两者结合），我时隔已久，而且已经是装完的状态了，所以无法展示了。按照他的来可以搭建出来Halo的博客，但后来我记得部署完halo后，halo页面无法显示，可能按照清缓存，重启服务器，等待一会儿就行了。 啊啊啊，原本想从0开始搭建出自己的博客来着，属于是推着推着就忘了好多。如果有需要，我可以帮你尝试一下建博客（不保证行不行，因为我也是看网上教程来的）。对象存储 国外买国外的存储桶，记得开防盗链，然后用picgo管理，插件是picgo-plugin-pic-migrater它可以将语雀导出的markdown里的图片自动上传到存储桶，并新建一个.m","tags":["Blog","Server"],"title":"Halo博客搭建---一个属于自己的网站","url":"http://localhost:1313/archives/halo-blog-build-a-website-of-your-own/"},{"categories":["tech"],"content":"d文件，如果导入图片不显示，可能是你的链接没有https://。博客主题 joe2.0搜索引擎检索 这里只在必应（可以直接从你的Google里导入，但还是得把你网站地图放进去https://www.你的域名/sitemap.xml ）、Google、百度上弄了， ","date":"2022-03-19T20:11:01.786Z","objectID":"35f6a2c19f3287a885e4b630f2f6e620_4","order":4,"summary":"d文件，如果导入图片不显示，可能是你的链接没有https://。博客主题 joe2.0搜索引擎检索 这里只在必应（可以直接从你的Google里导入，但还是得把你网站地图放进去https://www.你的域名/sitemap.xml ）、Google、百度上弄了， ","tags":["Blog","Server"],"title":"Halo博客搭建---一个属于自己的网站","url":"http://localhost:1313/archives/halo-blog-build-a-website-of-your-own/"},{"categories":["error"],"content":"如题，最近遇到b站的音频播放页不能播放音乐，一些音乐组件也不能播放，如Aplayer，然后发现谷歌浏览器加载了一个扩展程序 Disable HTML5 Autoplay，通过设置成特定模式解决了。不要用全局模式，否则容易出问题。 ","date":"2022-03-16T13:59:01.194Z","objectID":"8d06a2ee35018cb46931ab9ee6ab946a_0","order":0,"summary":"如题，最近遇到b站的音频播放页不能播放音乐，一些音乐组件也不能播放，如Aplayer，然后发现谷歌浏览器加载了一个扩展程序 Disable HTML5 Autoplay，通过设置成特定模式解决了。不要用全局模式，否则容易出问题。 ","tags":["Error"],"title":"谷歌浏览器无法播放音乐","url":"http://localhost:1313/archives/gu-ge-liu-lan-qi-wu-fa-bo-fang-yin-le/"},{"categories":["tech"],"content":"JAVA安装 首推 JAVA安装 不知道你们注意到安装完java后会出现两个jre文件，特地去Google一下：网址 放在jdk文件里的jre文件夹是专用jre，它是用于开发java程序用 而与jdk同文件夹下的jre文件是公用jre，它是为了运行操作系统中的程序。注意平时所说的“java自动更新”不是所安装的JDK版本的更新，它指的是这个公用JRE运行时环境的更新，这个更新让你的计算机能够使用最新版本正常的运行一些网站或则Web应用等等当中的java程序安装教程随处可见，这里重点讲一下java的版本号的区别（虽说也是能Google到，但还是留个档） 参考博客1、参考博客2、参考博客3(1) Java与JDK的区别与关系 Java等价于JDK。(2) JDK8与JDK1.8的区别与关系 JDK8或者JDK1.8也是同一个东西。(3) JDK与J2SE的区别与关系 Java（即JDK）有3个版本：J2SE(Java Platform，Standard Edition)、J2EE(Java Platform，Enterprise Edition)、J2ME(Java Platform，Mi","date":"2022-03-13T18:16:11.921Z","objectID":"6107f150ec433fb53c1fb147e38785d2_0","order":0,"summary":"JAVA安装 首推 JAVA安装 不知道你们注意到安装完java后会出现两个jre文件，特地去Google一下：网址 放在jdk文件里的jre文件夹是专用jre，它是用于开发java程序用 而与jdk同文件夹下的jre文件是公用jre，它是为了运行操作系统中的程序。注意平时所说的“java自动更新”不是所安装的JDK版本的更新，它指的是这个公用JRE运行时环境的更新，这个更新让你的计算机能够使用最新版本正常的运行一些网站或则Web应用等等当中的java程序安装教程随处可见，这里重点讲一下java的版本号的区别（虽说也是能Google到，但还是留个档） 参考博客1、参考博客2、参考博客3(1) Java与JDK的区别与关系 Java等价于JDK。(2) JDK8与JDK1.8的区别与关系 JDK8或者JDK1.8也是同一个东西。(3) JDK与J2SE的区别与关系 Java（即JDK）有3个版本：J2SE(Java Platform，Standard Edition)、J2EE(Java Platform，Enterprise Edition)、J2ME(Java Platform，Mi","tags":["Java","Install"],"title":"安装Java(jdk)及jdk版本探讨","url":"http://localhost:1313/archives/java-install-and-version-talk/"},{"categories":["tech"],"content":"cro Edition)，所以J2SE是3个版本中的其中一个，即标准版本。(4) java jdk-XXXX-i586与jdk-XXXX-x64区别? i586是32位系统、x64是64位系统(5) java jdk-XXXX-aarch64与jdk-XXXX-x64区别?(Linux) x86_64就是我们常用的台式机的体系架构，是基于冯诺依曼体系架构的。x86_64 Linux可以理解为在普通台式机上安装的Linux操作系统。 AArch64是一种ARMv8架构，也是一种计算机的体系架构。AArch64 Linux可以理解为在ARMv8架构的计算机上安装的Linux操作系统。 使用$ arch可查看Linux版本 图片来自：网址 注意JDK8u202以下是免费的，往上就要商业付费，个人使用不需要图片并排显示：1 2 3 4 \u0026lt;table\u003e\u0026lt;tr\u003e \u0026lt;td\u003e\u0026lt;img src=pic1.jpg border=0\u003e\u0026lt;/td\u003e \u0026lt;td\u003e\u0026lt;img src=pic2.jpg border=0\u003e\u0026lt;/td\u003e \u0026lt;/tr\u003e\u0026lt;/table\u003e ","date":"2022-03-13T18:16:11.921Z","objectID":"6107f150ec433fb53c1fb147e38785d2_1","order":1,"summary":"cro Edition)，所以J2SE是3个版本中的其中一个，即标准版本。(4) java jdk-XXXX-i586与jdk-XXXX-x64区别? i586是32位系统、x64是64位系统(5) java jdk-XXXX-aarch64与jdk-XXXX-x64区别?(Linux) x86_64就是我们常用的台式机的体系架构，是基于冯诺依曼体系架构的。x86_64 Linux可以理解为在普通台式机上安装的Linux操作系统。 AArch64是一种ARMv8架构，也是一种计算机的体系架构。AArch64 Linux可以理解为在ARMv8架构的计算机上安装的Linux操作系统。 使用$ arch可查看Linux版本 图片来自：网址 注意JDK8u202以下是免费的，往上就要商业付费，个人使用不需要图片并排显示：1 2 3 4 \u0026lt;table\u003e\u0026lt;tr\u003e \u0026lt;td\u003e\u0026lt;img src=pic1.jpg border=0\u003e\u0026lt;/td\u003e \u0026lt;td\u003e\u0026lt;img src=pic2.jpg border=0\u003e\u0026lt;/td\u003e \u0026lt;/tr\u003e\u0026lt;/table\u003e ","tags":["Java","Install"],"title":"安装Java(jdk)及jdk版本探讨","url":"http://localhost:1313/archives/java-install-and-version-talk/"},{"categories":["tech"],"content":"OpenSSL安装 首推 生成SSL证书 忘了这个网站干啥用的 注意安装OpenSSL的时候 下面的代码特别慢 我大概用了半小时以上才装完1 2 3 nmake nmake test nmake install nmake test 可弄可不弄","date":"2022-03-13T10:45:24.654Z","objectID":"0a04e053f61ef11127bfaccd7ae66924_0","order":0,"summary":"OpenSSL安装 首推 生成SSL证书 忘了这个网站干啥用的 注意安装OpenSSL的时候 下面的代码特别慢 我大概用了半小时以上才装完1 2 3 nmake nmake test nmake install nmake test 可弄可不弄","tags":["Install"],"title":"OpenSSL安装配置及配置SSL证书","url":"http://localhost:1313/archives/openssl-install-and-get-sslcert/"},{"categories":["tech"],"content":"使用pathlib解决同名不同后缀(扩展名)的文件的转移 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pathlib import Path import shutil # 需求：将old_dir里面的json文件与pic_dir里的同名不同后缀进行复制到另一个文件夹里 # 文件路径 old_dir = Path('待复制的文件先放到一个文件夹里') # 如存放{‘picture1.json’, ‘picture2.json’,...}的文件夹 pic_dir = Path('同名不同后缀的文件夹') # 如存放{‘picture1.jpg’, ‘picture2.jpg’,...}的文件夹 save_path = Path('将同名不同后缀的文件放到新的文件夹里') # 最终的{‘picture1.jpg’, ‘picture2.jpg’,...}文件夹 # 只剩下文件名 如{‘picture1’, ‘picture2’,...} ['.j","date":"2022-03-11T17:11:49.912Z","objectID":"572a7ea82a0542c65a907bfd5b87cdea_0","order":0,"summary":"使用pathlib解决同名不同后缀(扩展名)的文件的转移 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from pathlib import Path import shutil # 需求：将old_dir里面的json文件与pic_dir里的同名不同后缀进行复制到另一个文件夹里 # 文件路径 old_dir = Path('待复制的文件先放到一个文件夹里') # 如存放{‘picture1.json’, ‘picture2.json’,...}的文件夹 pic_dir = Path('同名不同后缀的文件夹') # 如存放{‘picture1.jpg’, ‘picture2.jpg’,...}的文件夹 save_path = Path('将同名不同后缀的文件放到新的文件夹里') # 最终的{‘picture1.jpg’, ‘picture2.jpg’,...}文件夹 # 只剩下文件名 如{‘picture1’, ‘picture2’,...} ['.j","tags":["Python"],"title":"python 使用pathlib解决同名不同后缀(扩展名)的文件的转移","url":"http://localhost:1313/archives/pythontransferfileswiththesamename/"},{"categories":["tech"],"content":"pg']可放多个后缀['.jpg', '.gz'] json_names = {f.stem for f in old_dir.iterdir() if f.suffix == '.json'} nii_names = {Path(f).name for f in pic_dir.iterdir() if f.suffixes == ['.jpg']} for file_name in json_names \u0026 nii_names: # 同名文件 # json_path = old_dir / (file_name + '.json') # 重新拼接成picture1.json格式 # nii_path = pic_dir / (file_name + '.jpg') # (file_name + '.jpg.gz') # with open(json_path) as json_file, open(nii_path) as nii_file: # ... 对同名文件进行操作 # 另一种思路 if not save_path.exists(): # 文件夹不存在，则新建文件夹 pri","date":"2022-03-11T17:11:49.912Z","objectID":"572a7ea82a0542c65a907bfd5b87cdea_1","order":1,"summary":"pg']可放多个后缀['.jpg', '.gz'] json_names = {f.stem for f in old_dir.iterdir() if f.suffix == '.json'} nii_names = {Path(f).name for f in pic_dir.iterdir() if f.suffixes == ['.jpg']} for file_name in json_names \u0026 nii_names: # 同名文件 # json_path = old_dir / (file_name + '.json') # 重新拼接成picture1.json格式 # nii_path = pic_dir / (file_name + '.jpg') # (file_name + '.jpg.gz') # with open(json_path) as json_file, open(nii_path) as nii_file: # ... 对同名文件进行操作 # 另一种思路 if not save_path.exists(): # 文件夹不存在，则新建文件夹 pri","tags":["Python"],"title":"python 使用pathlib解决同名不同后缀(扩展名)的文件的转移","url":"http://localhost:1313/archives/pythontransferfileswiththesamename/"},{"categories":["other"],"content":"工程伦理答案","date":"2022-03-10T13:27:38.74Z","objectID":"67da7d435409948515d519c241446631_0","order":0,"summary":"工程伦理答案","tags":["Answer"],"title":"工程伦理（2021春）第一章课后习题答案","url":"http://localhost:1313/archives/gong-cheng-lun-li-2021-chun--di-yi-zhang-ke-hou-xi-ti-da-an/"},{"categories":["other"],"content":"答案来自：学堂在线第一章 C D D D B 《自然辩证法》一书是：\tC A ①马克思、恩格斯共同完成的著作； B ②恩格斯经过十年努力完成的著作； C ③恩格斯未完成的遗稿； D ④马克思撰写；恩格斯整理完成的著作。辩证唯物主义自然观讲的是：\tD A ①人们认识自然的辩证法； B ②人们变革自然的辩证法； C ③人们研究自然的辩证法； D ④自然界本身的辩证法。自然界物质运动服从某些共同规律表明：\tD A ①自然界具体物质运动的守恒性； B ②自然界物质运动不灭性； C ③自然界物质运动的绝对性； D ④自然界物质运动统一性。自然辩证法从当代自然科学的成果来阐述自然界本身的辩证法在人的认识中的反映，这种研究体现了：\tD A ①自然观与社会历史观的统一； B ②主观辩证法与客观辩证法的统一； C ③世界观与方法论的统一； D ④逻辑与历史的统一。自然辩证法的学科性质表明它与……处于同一层次\tB A ①辩证唯物主义； B ②历史唯物主义； C ③自然科学； D ④科学社会主义。第二章 D A B B ABDFG 古代自然观的基本特征：D A ①猜测性、辩证性、逻辑性； B ②直观性、系统","date":"2022-03-10T13:26:43.52Z","objectID":"c180a93df48d44719979843e042a69d8_0","order":0,"summary":"答案来自：学堂在线第一章 C D D D B 《自然辩证法》一书是：\tC A ①马克思、恩格斯共同完成的著作； B ②恩格斯经过十年努力完成的著作； C ③恩格斯未完成的遗稿； D ④马克思撰写；恩格斯整理完成的著作。辩证唯物主义自然观讲的是：\tD A ①人们认识自然的辩证法； B ②人们变革自然的辩证法； C ③人们研究自然的辩证法； D ④自然界本身的辩证法。自然界物质运动服从某些共同规律表明：\tD A ①自然界具体物质运动的守恒性； B ②自然界物质运动不灭性； C ③自然界物质运动的绝对性； D ④自然界物质运动统一性。自然辩证法从当代自然科学的成果来阐述自然界本身的辩证法在人的认识中的反映，这种研究体现了：\tD A ①自然观与社会历史观的统一； B ②主观辩证法与客观辩证法的统一； C ③世界观与方法论的统一； D ④逻辑与历史的统一。自然辩证法的学科性质表明它与……处于同一层次\tB A ①辩证唯物主义； B ②历史唯物主义； C ③自然科学； D ④科学社会主义。第二章 D A B B ABDFG 古代自然观的基本特征：D A ①猜测性、辩证性、逻辑性； B ②直观性、系统","tags":["Answer"],"title":"自然辩证法（学堂在线）答案/题库","url":"http://localhost:1313/archives/dialecticsofnature-xue-tang-zai-xian--answer--dataset/"},{"categories":["other"],"content":"性、分析性； C ③思辩性、联系性、综合性； D ④直观性、思辩性、猜测性。近代自然科学独立并建立体系并获得重大成就，最为重要的原因是： A A ①科学实验的兴起 B ②理性与实验相结合 C ③人类思想获得解放 D ④资本主义生产方式的兴起被恩格斯誉为向宗教发出“挑战书”、自然科学独立的“宣言书”的不朽著作是： B A ①《人体构造论》 B ②《天体运行论》 C ③《两大世界体系的对话》 D ④《心血运动论》人类的新进化是指： B A ①纯生物属性的进化； B ②人的社会属性改变推动人的生物属性改变的进化； C ③纯社会属性的进化； D ④人类语言符号的进化。古代自然观的基本特征：\tABDFG A ①康德的“星云假说” B ②赖尔《地质学原理》提出的地质渐变理论 C ③电子的发现及普朗克“能量子”假说 D ④能量守恒及转化定律，以及法拉第－麦克斯维的电磁场理论 F ⑥细胞学说和进化论 G ⑦道尔顿－阿夫伽德罗的原子－分子论和门捷耶夫的“元素周期律”第三章 ABCE C A D C 科研选题的基本原则是\tABCE A ①创新性原则 B ②科学性原则 C ③可行性原则 D ④主体际性 E ","date":"2022-03-10T13:26:43.52Z","objectID":"c180a93df48d44719979843e042a69d8_1","order":1,"summary":"性、分析性； C ③思辩性、联系性、综合性； D ④直观性、思辩性、猜测性。近代自然科学独立并建立体系并获得重大成就，最为重要的原因是： A A ①科学实验的兴起 B ②理性与实验相结合 C ③人类思想获得解放 D ④资本主义生产方式的兴起被恩格斯誉为向宗教发出“挑战书”、自然科学独立的“宣言书”的不朽著作是： B A ①《人体构造论》 B ②《天体运行论》 C ③《两大世界体系的对话》 D ④《心血运动论》人类的新进化是指： B A ①纯生物属性的进化； B ②人的社会属性改变推动人的生物属性改变的进化； C ③纯社会属性的进化； D ④人类语言符号的进化。古代自然观的基本特征：\tABDFG A ①康德的“星云假说” B ②赖尔《地质学原理》提出的地质渐变理论 C ③电子的发现及普朗克“能量子”假说 D ④能量守恒及转化定律，以及法拉第－麦克斯维的电磁场理论 F ⑥细胞学说和进化论 G ⑦道尔顿－阿夫伽德罗的原子－分子论和门捷耶夫的“元素周期律”第三章 ABCE C A D C 科研选题的基本原则是\tABCE A ①创新性原则 B ②科学性原则 C ③可行性原则 D ④主体际性 E ","tags":["Answer"],"title":"自然辩证法（学堂在线）答案/题库","url":"http://localhost:1313/archives/dialecticsofnature-xue-tang-zai-xian--answer--dataset/"},{"categories":["other"],"content":"⑤社会需求原则公理化方法从本质上说它属于一种：\tC A ①类比推理； B ②归纳推理； C ③演绎推理； D ④直觉推理。现代科学哲学研究表明，理论的评价并不是单一的理性评价，其原因在于：\tA A ①科学理论必须受到实践的检验； B ②科学理论是人类思维的创造； C ③科学理论的评价主体是科学权威； D ④科学理论不是理性的事业。下列不属于科学假说的主要特点是\tD A ① 科学性与猜测性的统一 B ② 抽象性与形象性的统一 C ③ 多样性与易变性的统一 D ④ 解释性与预见性的统一灵感是非逻辑思维的一种重要形式，从形式机制上看，你认为下列解释 哪一个最能反映灵感思维的本质：\tC A ①辩证唯物主义； B ②历史唯物主义； C ③自然科学； D ④科学社会主义。第四章 ABC A D B ABCD 在21世纪，科学技术工程运行的社会特点是：\tABC A ①科学技术工程的职业化 B ②科学技术工程运行的不平衡性 C ③科学、技术、工程与社会的一体化 D ④马克思撰写；恩格斯整理完成的著作。科学共同体是具有特定行为规范的社会群体，下列哪一个行为属于科学 共同体的越轨行为：\tA A ①保密； ","date":"2022-03-10T13:26:43.52Z","objectID":"c180a93df48d44719979843e042a69d8_2","order":2,"summary":"⑤社会需求原则公理化方法从本质上说它属于一种：\tC A ①类比推理； B ②归纳推理； C ③演绎推理； D ④直觉推理。现代科学哲学研究表明，理论的评价并不是单一的理性评价，其原因在于：\tA A ①科学理论必须受到实践的检验； B ②科学理论是人类思维的创造； C ③科学理论的评价主体是科学权威； D ④科学理论不是理性的事业。下列不属于科学假说的主要特点是\tD A ① 科学性与猜测性的统一 B ② 抽象性与形象性的统一 C ③ 多样性与易变性的统一 D ④ 解释性与预见性的统一灵感是非逻辑思维的一种重要形式，从形式机制上看，你认为下列解释 哪一个最能反映灵感思维的本质：\tC A ①辩证唯物主义； B ②历史唯物主义； C ③自然科学； D ④科学社会主义。第四章 ABC A D B ABCD 在21世纪，科学技术工程运行的社会特点是：\tABC A ①科学技术工程的职业化 B ②科学技术工程运行的不平衡性 C ③科学、技术、工程与社会的一体化 D ④马克思撰写；恩格斯整理完成的著作。科学共同体是具有特定行为规范的社会群体，下列哪一个行为属于科学 共同体的越轨行为：\tA A ①保密； ","tags":["Answer"],"title":"自然辩证法（学堂在线）答案/题库","url":"http://localhost:1313/archives/dialecticsofnature-xue-tang-zai-xian--answer--dataset/"},{"categories":["other"],"content":"B ②公有性； C ③普遍主义； D ④怀疑；知识经济属性表明，科学知识在认识论上意义上是一种：\tD A ①直接生产力； B ②进化系统； C ③网络知识经济； D ④间接生产力；科学、技术和工程的外在极限主要是指它们的发展受到：\tB A ①人类的生理因素的制约和影响； B ②社会环境的制约和影响； C ③人类认识功能的制约和影响； D ④科学技术工程形式和内容的制约和影响；自然辩证法的学科性质表明它与……处于同一层次\tABCD A ①工程伦理素质 B ②环境保护意识 C ③成本意识 D ④品质意识","date":"2022-03-10T13:26:43.52Z","objectID":"c180a93df48d44719979843e042a69d8_3","order":3,"summary":"B ②公有性； C ③普遍主义； D ④怀疑；知识经济属性表明，科学知识在认识论上意义上是一种：\tD A ①直接生产力； B ②进化系统； C ③网络知识经济； D ④间接生产力；科学、技术和工程的外在极限主要是指它们的发展受到：\tB A ①人类的生理因素的制约和影响； B ②社会环境的制约和影响； C ③人类认识功能的制约和影响； D ④科学技术工程形式和内容的制约和影响；自然辩证法的学科性质表明它与……处于同一层次\tABCD A ①工程伦理素质 B ②环境保护意识 C ③成本意识 D ④品质意识","tags":["Answer"],"title":"自然辩证法（学堂在线）答案/题库","url":"http://localhost:1313/archives/dialecticsofnature-xue-tang-zai-xian--answer--dataset/"},{"categories":["tech"],"content":"​ 安装anaconda后 Anaconda | Individual Edition ​将文件路径放入环境变量中​​创建吴恩达课后作业的python环境 conda创建虚拟环境 conda创建虚拟环境：Anaconda创建环境、删除环境、激活环境、退出环境1 conda create -n dl_wu python=3.6 如果遇到CondaHTTPError: HTTP 000 CONNECTION FAILED for url https://repo.anaconda.com/pkgs/main/win-64/current_repodata.json Elapsed: -这个问题。解决方法：conda config --add channels r 将文件内容改成 channels: - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ ssl_verify: true show_channel_urls: true 参考网址： CondaHTTPError: HTTP 000 CONNECTION FAILED ","date":"2022-02-22T16:47:58.541Z","objectID":"4d3243e4689410e3cef2fdce4bac2fee_0","order":0,"summary":"​ 安装anaconda后 Anaconda | Individual Edition ​将文件路径放入环境变量中​​创建吴恩达课后作业的python环境 conda创建虚拟环境 conda创建虚拟环境：Anaconda创建环境、删除环境、激活环境、退出环境1 conda create -n dl_wu python=3.6 如果遇到CondaHTTPError: HTTP 000 CONNECTION FAILED for url https://repo.anaconda.com/pkgs/main/win-64/current_repodata.json Elapsed: -这个问题。解决方法：conda config --add channels r 将文件内容改成 channels: - http://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ ssl_verify: true show_channel_urls: true 参考网址： CondaHTTPError: HTTP 000 CONNECTION FAILED ","tags":["Python","ComputerVision"],"title":"从零开始 配置吴恩达深度学习课后作业/编程/jupyter环境","url":"http://localhost:1313/archives/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E7%8E%AF%E5%A2%83/"},{"categories":["tech"],"content":"for url \u0026lt;https://repo.anaconda.com/pkgs/main/win-64/current_repodata.json Elapsed: \u003e-错误解决方法 Anaconda 解决 “CondaHTTPError: HTTP 000 CONNECTION FAILED for url“ 问题 | 解决spyder无法更新到最新版本 安装tensorflow、keras python和tensorflow对应的版本：TensorFlow的历史版本与对应Python版本 keras和tensorflow对应的版本：Tensorflow | TF与Keras版本对应这里我装的是tensorflow1.14和python3.6（不小心删掉pip的话 我是更新失败了就没了：python pip报错 Cannot open Scripts\\pip-script.py 更新用这个语句：1 python -m pip install --upgrade pip ）另外装tensorflow的时候遇到这个问题 解决方法：pip config set install.tru","date":"2022-02-22T16:47:58.541Z","objectID":"4d3243e4689410e3cef2fdce4bac2fee_1","order":1,"summary":"for url \u0026lt;https://repo.anaconda.com/pkgs/main/win-64/current_repodata.json Elapsed: \u003e-错误解决方法 Anaconda 解决 “CondaHTTPError: HTTP 000 CONNECTION FAILED for url“ 问题 | 解决spyder无法更新到最新版本 安装tensorflow、keras python和tensorflow对应的版本：TensorFlow的历史版本与对应Python版本 keras和tensorflow对应的版本：Tensorflow | TF与Keras版本对应这里我装的是tensorflow1.14和python3.6（不小心删掉pip的话 我是更新失败了就没了：python pip报错 Cannot open Scripts\\pip-script.py 更新用这个语句：1 python -m pip install --upgrade pip ）另外装tensorflow的时候遇到这个问题 解决方法：pip config set install.tru","tags":["Python","ComputerVision"],"title":"从零开始 配置吴恩达深度学习课后作业/编程/jupyter环境","url":"http://localhost:1313/archives/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E9%85%8D%E7%BD%AE%E5%90%B4%E6%81%A9%E8%BE%BE%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AF%BE%E5%90%8E%E4%BD%9C%E4%B8%9A%E7%8E%AF%E5%A2%83/"},{"categories":["create"],"content":"​ 参考：基于PCA的人脸识别方法——特征脸法参考：人脸识别之主成分分析（PCA）简易 系统展示 迁移后图片丢失1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 ","date":"2022-02-22T16:17:36.746Z","objectID":"09d342613b38f76f94f2c80606e1e99e_0","order":0,"summary":"​ 参考：基于PCA的人脸识别方法——特征脸法参考：人脸识别之主成分分析（PCA）简易 系统展示 迁移后图片丢失1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 ","tags":["Python","PCA"],"title":"PCA人脸识别+GUI+python","url":"http://localhost:1313/archives/pca%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABguipython/"},{"categories":["create"],"content":"139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 import sys import os import numpy as np import cv2 as cv from PyQt5 import QtCore, QtWidgets, QtGui from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog root_dir = 'FaceDB_orl' def createDataBase(path): print('--------正在获取数据--------') path1 = [] X = [] for dirpath, dirnames, fi","date":"2022-02-22T16:17:36.746Z","objectID":"09d342613b38f76f94f2c80606e1e99e_1","order":1,"summary":"139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 import sys import os import numpy as np import cv2 as cv from PyQt5 import QtCore, QtWidgets, QtGui from PyQt5.QtWidgets import QApplication, QMainWindow, QFileDialog root_dir = 'FaceDB_orl' def createDataBase(path): print('--------正在获取数据--------') path1 = [] X = [] for dirpath, dirnames, fi","tags":["Python","PCA"],"title":"PCA人脸识别+GUI+python","url":"http://localhost:1313/archives/pca%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABguipython/"},{"categories":["create"],"content":"lenames in os.walk(path): for file in filenames: temp_path = os.path.join(dirpath, file) path1.append(temp_path) for img_path in path1: img = cv.imread(img_path, cv.IMREAD_GRAYSCALE) # img = cv.resize(img, crop_size) temp = img.reshape(-1, 1) X.append(temp) X = np.array(X) # print(X.shape[0]) # m个数据 print('--------获取数据结束--------') return X.reshape(X.shape[0], X.shape[1]).T # (row*col, 400) def eigenface(X, k1=0, k2=0): print('--------正在特征提取--------') m = X.shape[1] # 400 # 计算平均脸及中心化 X_mean = np.","date":"2022-02-22T16:17:36.746Z","objectID":"09d342613b38f76f94f2c80606e1e99e_2","order":2,"summary":"lenames in os.walk(path): for file in filenames: temp_path = os.path.join(dirpath, file) path1.append(temp_path) for img_path in path1: img = cv.imread(img_path, cv.IMREAD_GRAYSCALE) # img = cv.resize(img, crop_size) temp = img.reshape(-1, 1) X.append(temp) X = np.array(X) # print(X.shape[0]) # m个数据 print('--------获取数据结束--------') return X.reshape(X.shape[0], X.shape[1]).T # (row*col, 400) def eigenface(X, k1=0, k2=0): print('--------正在特征提取--------') m = X.shape[1] # 400 # 计算平均脸及中心化 X_mean = np.","tags":["Python","PCA"],"title":"PCA人脸识别+GUI+python","url":"http://localhost:1313/archives/pca%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%ABguipython/"},{"categories":["tech"],"content":"Maven：Maven下载及安装 - Milburn - 博客园MySQL：MySQL的安装与配置——详细教程 - Winton-H - 博客园mysqld --install mysqld --initialize --console net start MySQL mysql -u root -p alter user 'root'@'localhost' identified by 'root(此处为你想要的密码)' ； exit mysql -u root -p(root你的密码) %mysql%\\bin （系统环境变量配置那里） rational rose：Rational Rose 2007安装及License Key Error问题的解决​matlab2020b: MATLAB 2020b 最新版激活安装（Win版） 解压密码：www.datapro.cool 或者 www.xuebear.com 无空格","date":"2022-02-22T16:12:19.03Z","objectID":"f2bc733cc649415f8824418c8917f966_0","order":0,"summary":"Maven：Maven下载及安装 - Milburn - 博客园MySQL：MySQL的安装与配置——详细教程 - Winton-H - 博客园mysqld --install mysqld --initialize --console net start MySQL mysql -u root -p alter user 'root'@'localhost' identified by 'root(此处为你想要的密码)' ； exit mysql -u root -p(root你的密码) %mysql%\\bin （系统环境变量配置那里） rational rose：Rational Rose 2007安装及License Key Error问题的解决​matlab2020b: MATLAB 2020b 最新版激活安装（Win版） 解压密码：www.datapro.cool 或者 www.xuebear.com 无空格","tags":["Install","Maven","MySQL","Rational Rose"],"title":"软件安装教程集合","url":"http://localhost:1313/archives/software-installation-set/"},{"categories":["tech"],"content":"​ 感谢原文博主！程序安装包下载：链接：https://pan.baidu.com/s/1RigVWufNh-TF84zCYjxhAw 提取码：i3om破解补丁：链接：https://pan.baidu.com/s/1ThXITtJN29BwF80Hv0-fkg 提取码：yvey破解在破解之前，需要下载的文件有两个ideaIU-2019.3.3.exe、jetbrains-agent-latest.zip，前者是程序安装包，后者是破解补丁包，下载补丁包后解压里面的jetbrains-agent.jar和important.txt到容易找到的地方且在同级目录下(推荐放在IDEA的安装目录下)。具体操作如下图所示：打开IDEA 重新启动IDEA：打开配置文件 在最后一行加入'-javaagent:'且后面再跟上你的破解补丁的位置，两者都要在同一行上；这里的路径千万别输错且不能有中文，否则以后会打不开IDEA，最好直接复制再加上文件名；改完后记得保存。 自动破解 重启完成后正常情况下就已经自动破解成功了，可以去下面的地方去看下结果。 手动破解：进入idea激活界面 License serve","date":"2022-02-19T11:36:27.628Z","objectID":"e86e86417503a331bed413b00688ccce_0","order":0,"summary":"​ 感谢原文博主！程序安装包下载：链接：https://pan.baidu.com/s/1RigVWufNh-TF84zCYjxhAw 提取码：i3om破解补丁：链接：https://pan.baidu.com/s/1ThXITtJN29BwF80Hv0-fkg 提取码：yvey破解在破解之前，需要下载的文件有两个ideaIU-2019.3.3.exe、jetbrains-agent-latest.zip，前者是程序安装包，后者是破解补丁包，下载补丁包后解压里面的jetbrains-agent.jar和important.txt到容易找到的地方且在同级目录下(推荐放在IDEA的安装目录下)。具体操作如下图所示：打开IDEA 重新启动IDEA：打开配置文件 在最后一行加入'-javaagent:'且后面再跟上你的破解补丁的位置，两者都要在同一行上；这里的路径千万别输错且不能有中文，否则以后会打不开IDEA，最好直接复制再加上文件名；改完后记得保存。 自动破解 重启完成后正常情况下就已经自动破解成功了，可以去下面的地方去看下结果。 手动破解：进入idea激活界面 License serve","tags":["Install"],"title":"IntelliJ IDEA 2019.3.3 永久破解","url":"http://localhost:1313/archives/intellijidea201933cracked/"},{"categories":["tech"],"content":"r方式激活 要使用License server激活就点击License server,下面的Server address中输入http://fls.jetbrains-agent.com，再点Activate，如出现下图的情况则激活成功。 Activation code 要使用Activation code激活就点击Activation code,并在下面的输入框中粘贴下面的激活码3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wN","date":"2022-02-19T11:36:27.628Z","objectID":"e86e86417503a331bed413b00688ccce_1","order":1,"summary":"r方式激活 要使用License server激活就点击License server,下面的Server address中输入http://fls.jetbrains-agent.com，再点Activate，如出现下图的情况则激活成功。 Activation code 要使用Activation code激活就点击Activation code,并在下面的输入框中粘贴下面的激活码3AGXEJXFK9-eyJsaWNlbnNlSWQiOiIzQUdYRUpYRks5IiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wN","tags":["Install"],"title":"IntelliJ IDEA 2019.3.3 永久破解","url":"http://localhost:1313/archives/intellijidea201933cracked/"},{"categories":["tech"],"content":"yJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciL","date":"2022-02-19T11:36:27.628Z","objectID":"e86e86417503a331bed413b00688ccce_2","order":2,"summary":"yJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwODktMDctMDciL","tags":["Install"],"title":"IntelliJ IDEA 2019.3.3 永久破解","url":"http://localhost:1313/archives/intellijidea201933cracked/"},{"categories":["tech"],"content":"CJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsY","date":"2022-02-19T11:36:27.628Z","objectID":"e86e86417503a331bed413b00688ccce_3","order":3,"summary":"CJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJmYWxsY","tags":["Install"],"title":"IntelliJ IDEA 2019.3.3 永久破解","url":"http://localhost:1313/archives/intellijidea201933cracked/"},{"categories":["tech"],"content":"mFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJy","date":"2022-02-19T11:36:27.628Z","objectID":"e86e86417503a331bed413b00688ccce_4","order":4,"summary":"mFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDg5LTA3LTA3IiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjA4OS0wNy0wNyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9XSwiaGFzaCI6IjEyNzk2ODc3LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-WGTHs6XpDhr+uumvbwQPOdlxWnQwgnGaL4eRnlpGKApEEkJy","tags":["Install"],"title":"IntelliJ IDEA 2019.3.3 永久破解","url":"http://localhost:1313/archives/intellijidea201933cracked/"},{"categories":["tech"],"content":"YvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJ","date":"2022-02-19T11:36:27.628Z","objectID":"e86e86417503a331bed413b00688ccce_5","order":5,"summary":"YvNEuPWBSrQkPmVpim/8Sab6HV04Dw3IzkJT0yTc29sPEXBf69+7y6Jv718FaJu4MWfsAk/ZGtNIUOczUQ0iGKKnSSsfQ/3UoMv0q/yJcfvj+me5Zd/gfaisCCMUaGjB/lWIPpEPzblDtVJbRexB1MALrLCEoDv3ujcPAZ7xWb54DiZwjYhQvQ+CvpNNF2jeTku7lbm5v+BoDsdeRq7YBt9ANLUKPr2DahcaZ4gctpHZXhG96IyKx232jYq9jQrFDbQMtVr3E+GsCekMEWSD//dLT+HuZdc1sAIYrw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJ","tags":["Install"],"title":"IntelliJ IDEA 2019.3.3 永久破解","url":"http://localhost:1313/archives/intellijidea201933cracked/"},{"categories":["tech"],"content":"yYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGN","date":"2022-02-19T11:36:27.628Z","objectID":"e86e86417503a331bed413b00688ccce_6","order":6,"summary":"yYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGN","tags":["Install"],"title":"IntelliJ IDEA 2019.3.3 永久破解","url":"http://localhost:1313/archives/intellijidea201933cracked/"},{"categories":["tech"],"content":"BkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/Ga","date":"2022-02-19T11:36:27.628Z","objectID":"e86e86417503a331bed413b00688ccce_7","order":7,"summary":"BkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/Ga","tags":["Install"],"title":"IntelliJ IDEA 2019.3.3 永久破解","url":"http://localhost:1313/archives/intellijidea201933cracked/"},{"categories":["tech"],"content":"AdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g== 再点Activate，如果出现如下图所示，则激活成功 我个人是在hosts文件里加上了0.0.0.0 account.jetbrains.com0.0.0.0 www.jetbrains.com然后用最后一个方法成功了​","date":"2022-02-19T11:36:27.628Z","objectID":"e86e86417503a331bed413b00688ccce_8","order":8,"summary":"AdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g== 再点Activate，如果出现如下图所示，则激活成功 我个人是在hosts文件里加上了0.0.0.0 account.jetbrains.com0.0.0.0 www.jetbrains.com然后用最后一个方法成功了​","tags":["Install"],"title":"IntelliJ IDEA 2019.3.3 永久破解","url":"http://localhost:1313/archives/intellijidea201933cracked/"},{"categories":null,"content":"仅作记录用https://github.com/Kuingsmile/PicList/issues/114 更换电脑后原相册图片都丢失，","date":"0001-01-01T00:00:00Z","objectID":"b894901b1b0e88ea8efd034220f3b371_0","order":0,"summary":"仅作记录用https://github.com/Kuingsmile/PicList/issues/114 更换电脑后原相册图片都丢失，","tags":null,"title":"","url":"http://localhost:1313/posts/tech/"}]
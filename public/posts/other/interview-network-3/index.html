<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8" />

    <meta name="generator" content="Hugo 0.140.2"><meta name="theme-color" content="#fff" />
    <meta name="color-scheme" content="light dark">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
    
    <meta http-equiv="Cache-Control" content="no-transform" />
    
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <title>面试之计算机网络-3 | 悠闲の小屋</title>

    <link rel="stylesheet" href="/css/meme.min.css" />

    
    
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js" defer></script><script src="/js/meme.min.js"></script>

    

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto&#43;Serif&#43;SC:wght@400;500;700&amp;family=Source&#43;Code&#43;Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Cinzel&#43;Decorative:wght@700&amp;display=swap" media="print" onload="this.media='all'" />
        <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto&#43;Serif&#43;SC:wght@400;500;700&amp;family=Source&#43;Code&#43;Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Cinzel&#43;Decorative:wght@700&amp;display=swap" /></noscript>

    <meta name="author" content="" /><meta name="description" content="使用 Session 的过程是怎样的？ 用户进行登录时，提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到本地中，生成一个 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从本地中取出用户信息，继续之前的业务操作。 Session和cookie应该如何去选择（适用场景）？ Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； 对于用户状态和敏感数据，应优先使用Session，因为数据存储在服务器端，更安全可靠。 对于用户偏好设置和非敏感数据，可以使用Cookie，便于在客户端存储和传递，减轻服务器压力。 需要注意的是，Session和Cookie可以结合使用，例如将Session ID存储在Cookie中，以便在客户端和服务器之间建立关联。 DDos 攻击了解吗？ DDoS (Distributed Denial of Service) 攻击是一种恶意行为，旨在通过超过目标系统处理能力的大量请求或恶意流量来使目标系统无法正常运行。
……" />

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#2a6df4" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="悠闲の小屋" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="悠闲の小屋" />
    <meta name="msapplication-starturl" content="../../../" />
    <meta name="msapplication-TileColor" content="#fff" />
    <meta name="msapplication-TileImage" content="../../../icons/mstile-150x150.png" />
    <link rel="manifest" href="/manifest.json" />

    
    

    
    <link rel="canonical" href="http://localhost:1313/posts/other/interview-network-3/" />
    

<script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "datePublished": "2024-01-13T21:57:09+08:00",
        "dateModified": "2024-05-03T14:50:48+08:00",
        "url": "http://localhost:1313/posts/other/interview-network-3/",
        "headline": "面试之计算机网络-3",
        "description": "使用 Session 的过程是怎样的？ 用户进行登录时，提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到本地中，生成一个 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从本地中取出用户信息，继续之前的业务操作。 Session和cookie应该如何去选择（适用场景）？ Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； 对于用户状态和敏感数据，应优先使用Session，因为数据存储在服务器端，更安全可靠。 对于用户偏好设置和非敏感数据，可以使用Cookie，便于在客户端存储和传递，减轻服务器压力。 需要注意的是，Session和Cookie可以结合使用，例如将Session ID存储在Cookie中，以便在客户端和服务器之间建立关联。 DDos 攻击了解吗？ DDoS (Distributed Denial of Service) 攻击是一种恶意行为，旨在通过超过目标系统处理能力的大量请求或恶意流量来使目标系统无法正常运行。\n……",
        "inLanguage" : "zh-CN",
        "articleSection": "posts",
        "wordCount":  4629 ,
        "image": ["https://pic.keepjolly.com/halo/blog/2024/01/20240113205956.png?imageMogr2/format/webp%7C","https://pic.keepjolly.com/halo/blog/2024/01/20240113210010.png?imageMogr2/format/webp%7C","https://pic.keepjolly.com/halo/blog/2024/01/20240113210046.jpg?imageMogr2/format/webp%7C","http://oss.interviewguide.cn/img/202205072300329.png","http://oss.interviewguide.cn/img/202205072301822.png"],
        "publisher": {
            "@type": "Organization",
            "name": "悠闲の小屋",
            "url": "http://localhost:1313/"
        },
        "mainEntityOfPage": {
            "@type": "WebSite",
            "@id": "http://localhost:1313/"
        }
    }
</script>

    

<meta name="twitter:card" content="summary_large_image" />



    



<meta property="og:title" content="面试之计算机网络-3" />
<meta property="og:description" content="使用 Session 的过程是怎样的？ 用户进行登录时，提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码，如果正确则把用户信息存储到本地中，生成一个 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从本地中取出用户信息，继续之前的业务操作。 Session和cookie应该如何去选择（适用场景）？ Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session； 对于用户状态和敏感数据，应优先使用Session，因为数据存储在服务器端，更安全可靠。 对于用户偏好设置和非敏感数据，可以使用Cookie，便于在客户端存储和传递，减轻服务器压力。 需要注意的是，Session和Cookie可以结合使用，例如将Session ID存储在Cookie中，以便在客户端和服务器之间建立关联。 DDos 攻击了解吗？ DDoS (Distributed Denial of Service) 攻击是一种恶意行为，旨在通过超过目标系统处理能力的大量请求或恶意流量来使目标系统无法正常运行。
……" />
<meta property="og:url" content="http://localhost:1313/posts/other/interview-network-3/" />
<meta property="og:site_name" content="悠闲の小屋" />
<meta property="og:locale" content="zh" /><meta property="og:image" content="https://pic.keepjolly.com/halo/blog/2024/01/20240113205956.png?imageMogr2/format/webp%7C" />
<meta property="og:type" content="article" />
    <meta property="article:published_time" content="2024-01-13T21:57:09&#43;08:00" />
    <meta property="article:modified_time" content="2024-05-03T14:50:48&#43;08:00" />
    
    <meta property="article:section" content="posts" />


        <meta name="google-site-verification" content="mBjLYgXaXR8EAfTNbi4DTVC5KOJuBHpZDsmtgbgC6Rs" />

    
    

    
</head>

    <body>
        <div class="container">
            
    <header class="header">
        
            <div class="header-wrapper">
                <div class="header-inner single">
                    
    <div class="site-brand">
        
            <a href="/" class="brand">悠闲の小屋</a>
        
    </div>

                    <nav class="nav">
    <ul class="menu" id="menu">
        
            
        
        
        
        
            
                <li class="menu-item"><a href="/categories/"><span class="menu-item-name">分类</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/tags/"><span class="menu-item-name">标签</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/about/"><span class="menu-item-name">关于</span></a>
                </li>
            
        
            
                
                    
                    
                        <li class="menu-item">
                            <a id="theme-switcher" href="#"><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a>
                        </li>
                    
                
            
        
            
                <li class="menu-item search-item">
                        <form id="search" class="search" role="search">
    <label for="search-input"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon search-icon"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></label>
    <input type="search" id="search-input" class="search-input">
</form>

<template id="search-result" hidden>
    <article class="content post">
        <h2 class="post-title"><a class="summary-title-link"></a></h2>
        <summary class="summary"></summary>
        <div class="read-more-container">
            <a class="read-more-link">阅读更多 »</a>
        </div>
    </article>
</template>

                    </li>
                
            
        
    </ul>
</nav>

                    
                </div>
            </div>
            
    <input type="checkbox" id="nav-toggle" aria-hidden="true" />
    <label for="nav-toggle" class="nav-toggle"></label>
    <label for="nav-toggle" class="nav-curtain"></label>


        
    </header>




            
            
    
    <div class = "toc-wrapper">
        

    </div>
    

<main class="main single" id="main">
    <div class="main-inner">

        

        <article class="content post h-entry" data-align="justify" data-type="posts" data-toc-num="true">

            <h1 class="post-title p-name">面试之计算机网络-3</h1>

            

            
                
            

            

            <nav class="contents">
  <h2 id="contents" class="contents-title">目录</h2><ol class="toc">
    <li><a id="contents:使用-session-的过程是怎样的" href="#使用-session-的过程是怎样的">使用 Session 的过程是怎样的？</a></li>
    <li><a id="contents:session和cookie应该如何去选择适用场景" href="#session和cookie应该如何去选择适用场景">Session和cookie应该如何去选择（适用场景）？</a></li>
    <li><a id="contents:ddos-攻击了解吗" href="#ddos-攻击了解吗">DDos 攻击了解吗？</a></li>
    <li><a id="contents:mtu和mss分别是什么" href="#mtu和mss分别是什么">MTU和MSS分别是什么？</a></li>
    <li><a id="contents:msl和ttl" href="#msl和ttl">MSL和TTL？</a></li>
    <li><a id="contents:http中有个缓存机制但如何保证缓存是最新的呢" href="#http中有个缓存机制但如何保证缓存是最新的呢">HTTP中有个缓存机制，但如何保证缓存是最新的呢？</a></li>
    <li><a id="contents:tcp头部中有哪些信息" href="#tcp头部中有哪些信息">TCP头部中有哪些信息？</a></li>
    <li><a id="contents:常见tcp的连接状态有哪些" href="#常见tcp的连接状态有哪些">常见TCP的连接状态有哪些？</a></li>
    <li><a id="contents:tcp是什么" href="#tcp是什么">TCP是什么？</a></li>
    <li><a id="contents:osi-的七层模型的主要功能" href="#osi-的七层模型的主要功能">OSI 的七层模型的主要功能？</a></li>
    <li><a id="contents:应用层常见协议知道多少了解几个" href="#应用层常见协议知道多少了解几个">应用层常见协议知道多少？了解几个？</a></li>
    <li><a id="contents:浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开什么情况下会断开" href="#浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开什么情况下会断开">浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</a></li>
    <li><a id="contents:三次握手相关内容" href="#三次握手相关内容">三次握手相关内容</a></li>
    <li><a id="contents:为什么需要三次握手两次不行吗" href="#为什么需要三次握手两次不行吗">为什么需要三次握手，两次不行吗？</a></li>
    <li><a id="contents:什么是半连接队列" href="#什么是半连接队列">什么是半连接队列？</a></li>
    <li><a id="contents:isninitial-sequence-number是固定的吗" href="#isninitial-sequence-number是固定的吗">ISN(Initial Sequence Number)是固定的吗？</a></li>
    <li><a id="contents:三次握手过程中可以携带数据吗" href="#三次握手过程中可以携带数据吗">三次握手过程中可以携带数据吗？</a></li>
    <li><a id="contents:syn攻击是什么" href="#syn攻击是什么">SYN攻击是什么？</a></li>
  </ol>
</nav><hr></hr><div class="post-body e-content">
                <h2 id="使用-session-的过程是怎样的"><a href="#使用-session-的过程是怎样的" class="anchor-link">#</a><a href="#contents:使用-session-的过程是怎样的" class="headings">使用 Session 的过程是怎样的？</a></h2>
<ol>
<li>用户进行登录时，提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到本地中，生成一个 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从本地中取出用户信息，继续之前的业务操作。</li>
</ol>
<h2 id="session和cookie应该如何去选择适用场景"><a href="#session和cookie应该如何去选择适用场景" class="anchor-link">#</a><a href="#contents:session和cookie应该如何去选择适用场景" class="headings">Session和cookie应该如何去选择（适用场景）？</a></h2>
<ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>对于用户状态和敏感数据，应优先使用Session，因为数据存储在服务器端，更安全可靠。</li>
<li>对于用户偏好设置和非敏感数据，可以使用Cookie，便于在客户端存储和传递，减轻服务器压力。</li>
<li>需要注意的是，Session和Cookie可以结合使用，例如将Session ID存储在Cookie中，以便在客户端和服务器之间建立关联。</li>
</ul>
<h2 id="ddos-攻击了解吗"><a href="#ddos-攻击了解吗" class="anchor-link">#</a><a href="#contents:ddos-攻击了解吗" class="headings">DDos 攻击了解吗？</a></h2>
<p>DDoS (Distributed Denial of Service) 攻击是一种恶意行为，旨在通过<del>超过目标系统处理能力的</del>大量请求或恶意流量来使目标系统无法正常运行。</p>
<p>DDos 预防：</p>
<ol>
<li>
<p>流量分析和监测：实施流量分析和监测系统，以便及时检测和识别异常的网络流量模式。</p>
</li>
<li>
<p>防火墙和过滤器：配置防火墙和过滤器以过滤恶意流量并屏蔽来自已知攻击源的访问。</p>
</li>
<li>
<p>负载均衡：使用负载均衡设备将流量分散到多个服务器上，减轻单个服务器的负载压力。</p>
</li>
<li>
<p>反向代理：使用反向代理服务器来<strong>隐藏真实服务器的IP地址</strong>，使其更难受到直接的攻击。</p>
</li>
<li>
<p>限制连接和频率：防止单个IP地址或用户对系统进行过多的连接或请求</p>
</li>
</ol>
<h2 id="mtu和mss分别是什么"><a href="#mtu和mss分别是什么" class="anchor-link">#</a><a href="#contents:mtu和mss分别是什么" class="headings">MTU和MSS分别是什么？</a></h2>
<p>MTU（Maximum Transmission Unit）是指数据链路层所能承载的最大数据包大小，以太网的MTU为1500字节。</p>
<p>MSS（Maximum Segment Size）表示在TCP传输数据的最大大小。是在建立TCP连接时通过协商确定的。MSS值为MTU值减去IPv4 Header（20 Byte）和TCP header（20 Byte）得到。</p>
<h2 id="msl和ttl"><a href="#msl和ttl" class="anchor-link">#</a><a href="#contents:msl和ttl" class="headings">MSL和TTL？</a></h2>
<p>MSL（Maximum Segment Lifetime），它是任何报文在网络上存在的<strong>最长时间</strong>。</p>
<p>IP 头中有一个 <code>TTL</code> 字段，是 IP 数据报可以经过的<strong>最大路由数</strong>，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 <strong>MSL 应该要大于等于 TTL 消耗为 0 的时间</strong>，以确保报文已被自然消亡。</p>
<h2 id="http中有个缓存机制但如何保证缓存是最新的呢"><a href="#http中有个缓存机制但如何保证缓存是最新的呢" class="anchor-link">#</a><a href="#contents:http中有个缓存机制但如何保证缓存是最新的呢" class="headings">HTTP中有个缓存机制，但如何保证缓存是最新的呢？</a></h2>
<p><img src="https://pic.keepjolly.com/halo/blog/2024/01/20240113205956.png?imageMogr2/format/webp%7C" alt="image"></p>
<p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
<p>强制缓存：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器会在 Response 头部加上 Cache-Control，表示资源过期时间；</li>
<li>浏览器再次请求访问服务器中的该资源时，会先比较请求时间与资源过期时间，如果没有过期，则直接使用该缓存，否则重新请求服务器；</li>
<li>服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。</li>
</ul>
<p>使用 ETag 字段实现的协商缓存的过程：</p>
<ul>
<li>当浏览器第一次请求访问服务器资源时，服务器在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</li>
<li>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：
<ul>
<li>如果没有过期，则直接使用本地缓存；</li>
<li>如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag；</li>
</ul>
</li>
<li>服务器再次收到请求后，<strong>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</strong>：
<ul>
<li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
<li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
</ul>
</li>
<li>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</li>
</ul>
<h2 id="tcp头部中有哪些信息"><a href="#tcp头部中有哪些信息" class="anchor-link">#</a><a href="#contents:tcp头部中有哪些信息" class="headings">TCP头部中有哪些信息？</a></h2>
<p><img src="https://pic.keepjolly.com/halo/blog/2024/01/20240113210010.png?imageMogr2/format/webp%7C" alt="image"></p>
<ul>
<li>
<p>源端口号、目的端口号</p>
</li>
<li>
<p>序号（32bit）：在建立连接时由计算机生成的随机数作为其初始值，每发送一次数据，就「累加」一次该「数据字节数」的大小。用于解决网络包乱序问题。</p>
</li>
<li>
<p>确认号（32bit）：指下一次「期望」收到的数据的序列号，<del>发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收</del>。<strong>用来解决丢包的问题。</strong></p>
</li>
<li>
<p>首部长（4bit）：32位系统中一个字等于4个字节，首部长度的单位是字，首部长度字段有4位，所以TCP首部最长为 $2^4 -1 = 15(字) = 60(字节)$。</p>
</li>
<li>
<p>标志位（6bit）：</p>
<ul>
<li>
<p>URG：标志紧急指针是否有效。</p>
</li>
<li>
<p>ACK：标志确认号是否有效（确认报文段）。</p>
</li>
<li>
<p>PSH：提示接收端立即从缓冲读走数据。</p>
</li>
<li>
<p>RST：表示要求对方重新建立连接（复位报文段）。</p>
</li>
<li>
<p>SYN：表示请求建立一个连接（连接报文段）。</p>
</li>
<li>
<p>FIN：表示关闭连接（断开报文段）。</p>
</li>
</ul>
</li>
<li>
<p>窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流量控制。</p>
</li>
<li>
<p>校验和（16bit）：接收端用CRC检验整个报文段的完整性。</p>
</li>
</ul>
<h2 id="常见tcp的连接状态有哪些"><a href="#常见tcp的连接状态有哪些" class="anchor-link">#</a><a href="#contents:常见tcp的连接状态有哪些" class="headings">常见TCP的连接状态有哪些？</a></h2>
<p><img src="https://pic.keepjolly.com/halo/blog/2024/01/20240113210046.jpg?imageMogr2/format/webp%7C" alt="image"></p>
<p><a href="https://blog.csdn.net/chenxiyuehh/article/details/100146419" target="_blank" rel="noopener">https://blog.csdn.net/chenxiyuehh/article/details/100146419</a></p>
<ul>
<li>CLOSED：初始关闭状态。</li>
<li>LISTEN：服务器处于监听状态。</li>
<li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li>
<li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li>
<li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li>
<li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li>
<li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段，发送ACK包给客户机。<del>在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</del></li>
<li>FIN_WAIT_2：客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li>
<li>LAST_ACK：服务端发送最后的FIN包，进入此状态，等待最后的客户端ACK响应，进入CLOSE状态。</li>
<li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态，之后进入CLOSE状态。</li>
</ul>
<h2 id="tcp是什么"><a href="#tcp是什么" class="anchor-link">#</a><a href="#contents:tcp是什么" class="headings">TCP是什么？</a></h2>
<p>TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<h2 id="osi-的七层模型的主要功能"><a href="#osi-的七层模型的主要功能" class="anchor-link">#</a><a href="#contents:osi-的七层模型的主要功能" class="headings">OSI 的七层模型的主要功能？</a></h2>
<p><img src="http://oss.interviewguide.cn/img/202205072300329.png" alt=""></p>
<ol>
<li>物理层：负责传输比特流，处理物理介质和电信号。</li>
<li>数据链路层：提供可靠的点对点数据传输，处理帧和物理地址。</li>
<li>网络层：将数据包从源主机传输到目标主机，处理路由和寻址。</li>
<li>传输层：提供端到端的可靠数据传输，处理连接和流控制。</li>
<li>会话层：管理应用程序之间的会话。</li>
<li>表示层：处理数据的表示和格式转换，提供加密和压缩功能。</li>
<li>应用层：给用户提供网络应用服务，如HTTP、FTP等。</li>
</ol>
<p>**物理层：**利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。
**数据链路层：**接收来自物理层的位流形式的数据，并封装成帧，传送到上一层
**网络层：**将网络地址翻译成对应的物理地址，并通过路由选择算法为分组通过通信子网选择最适当的路径。
**传输层：**在源端与目的端之间提供可靠的透明数据传输
**会话层：**负责在网络中的两节点之间建立、维持和终止通信
**表示层：**处理用户信息的表示问题，数据的编码，压缩和解压缩，数据的加密和解密
**应用层：**为用户的应用进程提供网络通信服务</p>
<h2 id="应用层常见协议知道多少了解几个"><a href="#应用层常见协议知道多少了解几个" class="anchor-link">#</a><a href="#contents:应用层常见协议知道多少了解几个" class="headings">应用层常见协议知道多少？了解几个？</a></h2>
<div class="table-container"><table>
  <thead>
      <tr>
          <th>协议</th>
          <th>名称</th>
          <th>默认端口</th>
          <th>底层协议</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>HTTP</td>
          <td>超文本传输协议</td>
          <td>80</td>
          <td>TCP</td>
      </tr>
      <tr>
          <td>HTTPS</td>
          <td>超文本传输安全协议</td>
          <td>443</td>
          <td>TCP</td>
      </tr>
      <tr>
          <td>Telnet</td>
          <td>Teletype远程登录服务的标准协议</td>
          <td>23</td>
          <td>TCP</td>
      </tr>
      <tr>
          <td>FTP</td>
          <td>文件传输协议</td>
          <td>20传输和21连接</td>
          <td>TCP</td>
      </tr>
      <tr>
          <td>TFTP</td>
          <td>Trivial File简单文件传输协议</td>
          <td>69</td>
          <td>UDP</td>
      </tr>
      <tr>
          <td>SMTP</td>
          <td>简单邮件传输协议（发送用）</td>
          <td>25</td>
          <td>TCP</td>
      </tr>
      <tr>
          <td>POP</td>
          <td>邮局协议（接收用）</td>
          <td>110</td>
          <td>TCP</td>
      </tr>
      <tr>
          <td>DNS</td>
          <td>域名解析服务</td>
          <td>53</td>
          <td>服务器间进行区域传输的时候用TCP<br/>客户端查询DNS服务器时用 UDP</td>
      </tr>
  </tbody>
</table></div>
<h2 id="浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开什么情况下会断开"><a href="#浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开什么情况下会断开" class="anchor-link">#</a><a href="#contents:浏览器在与服务器建立了一个-tcp-连接后是否会在一个-http-请求完成后断开什么情况下会断开" class="headings">浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？</a></h2>
<p>如果采取短连接，则在HTTP请求完成后断开。如果采取长连接，则会一直保持TCP连接。当遇到以下情况就会断开：</p>
<ol>
<li>服务器或浏览器主动关闭连接。</li>
<li>连接超时或故障。</li>
</ol>
<h2 id="三次握手相关内容"><a href="#三次握手相关内容" class="anchor-link">#</a><a href="#contents:三次握手相关内容" class="headings">三次握手相关内容</a></h2>
<p><img src="http://oss.interviewguide.cn/img/202205072301822.png" alt=""></p>
<ul>
<li>一开始，客户端和服务端都处于 <code>CLOSE</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
<li>客户端发送SYN包给服务器，其中<code>序列号</code>字段中填入随机初始化序号(ISN)，把 <code>SYN</code> 标志位置为 <code>1</code>。客户端处于 <code>SYN-SENT</code> 状态。</li>
<li>服务端收到客户端的 <code>SYN</code> 报文后，服务端发送SYN+ACK包给客户端。其中<code>序列号</code>字段中填入随机初始化序号，其次把 <code>确认应答号</code>字段填入客户端序列号+1，接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。服务端处于 <code>SYN-RCVD</code> 状态。</li>
<li>客户端收到服务端报文后，发送ACK包给服务器将，其中序列号为客户端序列号+1 ，其次<code>确认应答号</code>字段填入 服务端序列号+1 ， <code>ACK</code> 标志位置为 <code>1</code>。这次报文可以携带客户到服务端的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务端收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>
<h2 id="为什么需要三次握手两次不行吗"><a href="#为什么需要三次握手两次不行吗" class="anchor-link">#</a><a href="#contents:为什么需要三次握手两次不行吗" class="headings">为什么需要三次握手，两次不行吗？</a></h2>
<p>通过这个三次握手的过程，双方确保了彼此的接受和发送能力和彼此的初始序列号的确认。这种双向确认可以防止已失效的连接请求被错误地接受，确保了连接建立的可靠性，避免了资源浪费。</p>
<h2 id="什么是半连接队列"><a href="#什么是半连接队列" class="anchor-link">#</a><a href="#contents:什么是半连接队列" class="headings">什么是半连接队列？</a></h2>
<p>服务器第一次收到客户端的 SYN 之后，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在<strong>半连接队列</strong>。</p>
<p>扩展：
当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>
<p>这里在补充一点关于<strong>SYN-ACK 重传次数</strong>的问题： 服务器发送完SYN-ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传。如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s......</p>
<h2 id="isninitial-sequence-number是固定的吗"><a href="#isninitial-sequence-number是固定的吗" class="anchor-link">#</a><a href="#contents:isninitial-sequence-number是固定的吗" class="headings">ISN(Initial Sequence Number)是固定的吗？</a></h2>
<p>初始化序列号 ISN 由 M + F(localhost, localport, remotehost, remoteport)生成。</p>
<ul>
<li><code>M</code> 是一个计时器，这个计时器每隔 4 微秒加 1。</li>
<li><code>F</code> 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。</li>
</ul>
<p>用于防止已失效的连接请求被错误地接受，以及被攻击者得到初始序列号。</p>
<h2 id="三次握手过程中可以携带数据吗"><a href="#三次握手过程中可以携带数据吗" class="anchor-link">#</a><a href="#contents:三次握手过程中可以携带数据吗" class="headings">三次握手过程中可以携带数据吗？</a></h2>
<p>其实第三次握手的时候，是可以携带数据的。但是，<strong>第一次、第二次握手不可以携带数据</strong></p>
<p>也就是说，第一次握手不可以放数据，其中一个简单的原因就是<strong>会让服务器更加容易受到攻击了</strong>。而对于第三次的话，此时客户端已经处于 ESTABLISHED 状态。对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据。</p>
<h2 id="syn攻击是什么"><a href="#syn攻击是什么" class="anchor-link">#</a><a href="#contents:syn攻击是什么" class="headings">SYN攻击是什么？</a></h2>
<p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击。<strong>SYN攻击就是客户端在短时间内伪造大量不存在的IP地址，并向服务器不断地发送SYN包，而服务器将其不断放入半连接队列，直至填满也无法得到客户端ACK响应导致正常请求丢包</strong>，从而引起网络拥塞甚至系统瘫痪。SYN 攻击是一种典型的 DoS/DDoS 攻击。</p>
<p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstat 命令来检测 SYN 攻击。</p>
<pre tabindex="0"><code>netstat -n -p TCP | grep SYN_RECV
</code></pre><p>常见的防御 SYN 攻击的方法有如下几种：</p>
<ul>
<li>缩短超时（SYN Timeout）时间</li>
<li>过滤网关防护</li>
<li>SYN cookies技术</li>
</ul>

            </div>

            


        </article>

        

        


        


        


        


        


        
    <footer class="minimal-footer">
        
            <div class="post-tag"><a href="/tags/interview/" rel="tag" class="post-tag-link">#interview</a></div>
        
        
            <div class="post-category">
                <a href="/posts/" class="post-category-link active">posts</a> | 
            </div>
        
        
    </footer>



        


        


        


    </div>
</main>


            
    <div id="back-to-top" class="back-to-top">
        <a href="#"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a>
    </div>


            

        </div>
        

        
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css">
<script>
    if (typeof renderMathInElement === 'undefined') {
        const getScript = (options) => {
            const script = document.createElement('script');
            script.defer = true;
            script.crossOrigin = 'anonymous';
            Object.keys(options).forEach((key) => {
                script[key] = options[key];
            });
            document.body.appendChild(script);
        };
        getScript({
            src: 'https:\/\/cdn.jsdelivr.net\/npm\/katex@0.13.0\/dist\/katex.min.js',
            onload: () => {
                getScript({
                    src: 'https:\/\/cdn.jsdelivr.net\/npm\/katex@0.13.0\/dist\/contrib\/mhchem.min.js',
                    onload: () => {
                        getScript({
                            src: 'https:\/\/cdn.jsdelivr.net\/npm\/katex@0.13.0\/dist\/contrib\/auto-render.min.js',
                            onload: () => {
                                renderKaTex();
                            }
                        });
                    }
                });
            }
        });
    } else {
        renderKaTex();
    }
    function renderKaTex() {
        renderMathInElement(
            document.body,
            {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false}
                ]
            }
        );
    }
</script>










    <script src="https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js"></script>

<script>
    let imgNodes = document.querySelectorAll('div.post-body img');
    imgNodes = Array.from(imgNodes).filter(node => node.parentNode.tagName !== "A");

    mediumZoom(imgNodes, {
        background: 'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'
    })
</script>









    </body>
</html>

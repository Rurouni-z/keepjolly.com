<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8" />

    <meta name="generator" content="Hugo 0.140.2"><meta name="theme-color" content="#fff" />
    <meta name="color-scheme" content="light dark">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
    
    <meta http-equiv="Cache-Control" content="no-transform" />
    
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <title>面试之计算机网络-2 | 悠闲の小屋</title>

    <link rel="stylesheet" href="/css/meme.min.css" />

    
    
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js" defer></script><script src="/js/meme.min.js"></script>

    

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto&#43;Serif&#43;SC:wght@400;500;700&amp;family=Source&#43;Code&#43;Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Cinzel&#43;Decorative:wght@700&amp;display=swap" media="print" onload="this.media='all'" />
        <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto&#43;Serif&#43;SC:wght@400;500;700&amp;family=Source&#43;Code&#43;Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Cinzel&#43;Decorative:wght@700&amp;display=swap" /></noscript>

    <meta name="author" content="" /><meta name="description" content="HTTPS是如何保证数据传输的安全，整体的流程是什么？ （SSL是怎么工作保证安全的）
https://www.cnblogs.com/fangdada/p/15686204.html
ECDHE过程：
客户端首先会发送使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random） 当服务端收到客户端的消息后，会确认 TLS 版本号，选择ECDHE密码套件，以及生成随机数（Server Random），并会发送数字证书给客户端。 然后服务端会选择一个椭圆曲线，如x25519曲线，生成随机数作为私钥，再根据椭圆曲线和私钥计算出服务端的公钥，利用签名算法签名，并将曲线、公钥和签名发送给客户端。 客户端验证证书是否合法，合法则生成随机数作为客户端私钥，利用私钥和椭圆曲线计算出客户端公钥后发送给服务端。 双方利用客户端随机数和服务端随机数和ECDHE算出的共享密钥计算出会话密钥来加密通话。互相验证加密和解密是否成功，并且验证消息是否被篡改。 最后进行HTTP通信。 RSA过程：
……" />

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#2a6df4" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="悠闲の小屋" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="悠闲の小屋" />
    <meta name="msapplication-starturl" content="../../../" />
    <meta name="msapplication-TileColor" content="#fff" />
    <meta name="msapplication-TileImage" content="../../../icons/mstile-150x150.png" />
    <link rel="manifest" href="/manifest.json" />

    
    

    
    <link rel="canonical" href="http://localhost:1313/posts/other/interview-network-2/" />
    

<script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "datePublished": "2024-01-13T21:56:59+08:00",
        "dateModified": "2024-05-03T14:50:48+08:00",
        "url": "http://localhost:1313/posts/other/interview-network-2/",
        "headline": "面试之计算机网络-2",
        "description": "HTTPS是如何保证数据传输的安全，整体的流程是什么？ （SSL是怎么工作保证安全的）\nhttps://www.cnblogs.com/fangdada/p/15686204.html\nECDHE过程：\n客户端首先会发送使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random） 当服务端收到客户端的消息后，会确认 TLS 版本号，选择ECDHE密码套件，以及生成随机数（Server Random），并会发送数字证书给客户端。 然后服务端会选择一个椭圆曲线，如x25519曲线，生成随机数作为私钥，再根据椭圆曲线和私钥计算出服务端的公钥，利用签名算法签名，并将曲线、公钥和签名发送给客户端。 客户端验证证书是否合法，合法则生成随机数作为客户端私钥，利用私钥和椭圆曲线计算出客户端公钥后发送给服务端。 双方利用客户端随机数和服务端随机数和ECDHE算出的共享密钥计算出会话密钥来加密通话。互相验证加密和解密是否成功，并且验证消息是否被篡改。 最后进行HTTP通信。 RSA过程：\n……",
        "inLanguage" : "zh-CN",
        "articleSection": "posts",
        "wordCount":  4086 ,
        "image": ["https://pic.keepjolly.com/halo/blog/2024/01/20240113205804.png?imageMogr2/format/webp%7C","https://pic.keepjolly.com/halo/blog/2024/01/20240113205816.png?imageMogr2/format/webp%7C","https://pic.keepjolly.com/halo/blog/2024/01/20240113205825.png?imageMogr2/format/webp%7C"],
        "publisher": {
            "@type": "Organization",
            "name": "悠闲の小屋",
            "url": "http://localhost:1313/"
        },
        "mainEntityOfPage": {
            "@type": "WebSite",
            "@id": "http://localhost:1313/"
        }
    }
</script>

    

<meta name="twitter:card" content="summary_large_image" />



    



<meta property="og:title" content="面试之计算机网络-2" />
<meta property="og:description" content="HTTPS是如何保证数据传输的安全，整体的流程是什么？ （SSL是怎么工作保证安全的）
https://www.cnblogs.com/fangdada/p/15686204.html
ECDHE过程：
客户端首先会发送使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random） 当服务端收到客户端的消息后，会确认 TLS 版本号，选择ECDHE密码套件，以及生成随机数（Server Random），并会发送数字证书给客户端。 然后服务端会选择一个椭圆曲线，如x25519曲线，生成随机数作为私钥，再根据椭圆曲线和私钥计算出服务端的公钥，利用签名算法签名，并将曲线、公钥和签名发送给客户端。 客户端验证证书是否合法，合法则生成随机数作为客户端私钥，利用私钥和椭圆曲线计算出客户端公钥后发送给服务端。 双方利用客户端随机数和服务端随机数和ECDHE算出的共享密钥计算出会话密钥来加密通话。互相验证加密和解密是否成功，并且验证消息是否被篡改。 最后进行HTTP通信。 RSA过程：
……" />
<meta property="og:url" content="http://localhost:1313/posts/other/interview-network-2/" />
<meta property="og:site_name" content="悠闲の小屋" />
<meta property="og:locale" content="zh" /><meta property="og:image" content="https://pic.keepjolly.com/halo/blog/2024/01/20240113205804.png?imageMogr2/format/webp%7C" />
<meta property="og:type" content="article" />
    <meta property="article:published_time" content="2024-01-13T21:56:59&#43;08:00" />
    <meta property="article:modified_time" content="2024-05-03T14:50:48&#43;08:00" />
    
    <meta property="article:section" content="posts" />


        <meta name="google-site-verification" content="mBjLYgXaXR8EAfTNbi4DTVC5KOJuBHpZDsmtgbgC6Rs" />

    
    

    
</head>

    <body>
        <div class="container">
            
    <header class="header">
        
            <div class="header-wrapper">
                <div class="header-inner single">
                    
    <div class="site-brand">
        
            <a href="/" class="brand">悠闲の小屋</a>
        
    </div>

                    <nav class="nav">
    <ul class="menu" id="menu">
        
            
        
        
        
        
            
                <li class="menu-item"><a href="/categories/"><span class="menu-item-name">分类</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/tags/"><span class="menu-item-name">标签</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/about/"><span class="menu-item-name">关于</span></a>
                </li>
            
        
            
                
                    
                    
                        <li class="menu-item">
                            <a id="theme-switcher" href="#"><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a>
                        </li>
                    
                
            
        
            
                <li class="menu-item search-item">
                        <form id="search" class="search" role="search">
    <label for="search-input"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon search-icon"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></label>
    <input type="search" id="search-input" class="search-input">
</form>

<template id="search-result" hidden>
    <article class="content post">
        <h2 class="post-title"><a class="summary-title-link"></a></h2>
        <summary class="summary"></summary>
        <div class="read-more-container">
            <a class="read-more-link">阅读更多 »</a>
        </div>
    </article>
</template>

                    </li>
                
            
        
    </ul>
</nav>

                    
                </div>
            </div>
            
    <input type="checkbox" id="nav-toggle" aria-hidden="true" />
    <label for="nav-toggle" class="nav-toggle"></label>
    <label for="nav-toggle" class="nav-curtain"></label>


        
    </header>




            
            
    
    <div class = "toc-wrapper">
        

    </div>
    

<main class="main single" id="main">
    <div class="main-inner">

        

        <article class="content post h-entry" data-align="justify" data-type="posts" data-toc-num="true">

            <h1 class="post-title p-name">面试之计算机网络-2</h1>

            

            
                
            

            

            <nav class="contents">
  <h2 id="contents" class="contents-title">目录</h2><ol class="toc">
    <li><a id="contents:https是如何保证数据传输的安全整体的流程是什么" href="#https是如何保证数据传输的安全整体的流程是什么">HTTPS是如何保证数据传输的安全，整体的流程是什么？</a></li>
    <li><a id="contents:22如何保证公钥不被篡改" href="#22如何保证公钥不被篡改">22、如何保证公钥不被篡改？</a></li>
    <li><a id="contents:公钥加密计算量太大如何减少耗用的时间" href="#公钥加密计算量太大如何减少耗用的时间">公钥加密计算量太大，如何减少耗用的时间？</a></li>
    <li><a id="contents:http请求和响应报文有哪些主要字段" href="#http请求和响应报文有哪些主要字段">HTTP请求和响应报文有哪些主要字段？</a></li>
    <li><a id="contents:cookie是什么" href="#cookie是什么">Cookie是什么？</a></li>
    <li><a id="contents:cookie有什么用途" href="#cookie有什么用途">Cookie有什么用途？</a></li>
    <li><a id="contents:session知识大总结" href="#session知识大总结">Session知识大总结</a></li>
    <li><a id="contents:session-的工作原理是什么" href="#session-的工作原理是什么">Session 的工作原理是什么？</a></li>
    <li><a id="contents:cookie与session的对比" href="#cookie与session的对比">Cookie与Session的对比</a></li>
    <li><a id="contents:sql注入攻击了解吗" href="#sql注入攻击了解吗">SQL注入攻击了解吗？</a></li>
    <li><a id="contents:如何防范sql注入攻击" href="#如何防范sql注入攻击">如何防范SQL注入攻击</a></li>
    <li><a id="contents:什么是rarp工作原理" href="#什么是rarp工作原理">什么是RARP？工作原理</a></li>
    <li><a id="contents:端口有效范围是多少到多少" href="#端口有效范围是多少到多少">端口有效范围是多少到多少？</a></li>
    <li><a id="contents:为何把-tcpip-协议栈分成-5-层或7层开放式回答" href="#为何把-tcpip-协议栈分成-5-层或7层开放式回答">为何把 TCP/IP 协议栈分成 5 层（或7层）？开放式回答。</a></li>
    <li><a id="contents:dns查询方式有哪些" href="#dns查询方式有哪些">DNS查询方式有哪些？</a></li>
    <li><a id="contents:http中缓存的私有和共有字段知道吗" href="#http中缓存的私有和共有字段知道吗">HTTP中缓存的私有和共有字段？知道吗？</a></li>
    <li><a id="contents:get-方法参数写法是固定的吗" href="#get-方法参数写法是固定的吗">GET 方法参数写法是固定的吗？</a></li>
    <li><a id="contents:get-方法的长度限制是怎么回事" href="#get-方法的长度限制是怎么回事">GET 方法的长度限制是怎么回事？</a></li>
    <li><a id="contents:post-方法比-get-方法安全" href="#post-方法比-get-方法安全">POST 方法比 GET 方法安全？</a></li>
    <li><a id="contents:post-方法会产生两个-tcp-数据包你了解吗" href="#post-方法会产生两个-tcp-数据包你了解吗">POST 方法会产生两个 TCP 数据包？你了解吗？</a></li>
  </ol>
</nav><hr></hr><div class="post-body e-content">
                <h2 id="https是如何保证数据传输的安全整体的流程是什么"><a href="#https是如何保证数据传输的安全整体的流程是什么" class="anchor-link">#</a><a href="#contents:https是如何保证数据传输的安全整体的流程是什么" class="headings">HTTPS是如何保证数据传输的安全，整体的流程是什么？</a></h2>
<p>（SSL是怎么工作保证安全的）</p>
<p><a href="https://www.cnblogs.com/fangdada/p/15686204.html" target="_blank" rel="noopener">https://www.cnblogs.com/fangdada/p/15686204.html</a></p>
<p><img src="https://pic.keepjolly.com/halo/blog/2024/01/20240113205804.png?imageMogr2/format/webp%7C" alt="image"></p>
<p>ECDHE过程：</p>
<ol>
<li>客户端首先会发送使用的 <strong>TLS 版本号、支持的密码套件列表，以及生成的随机数</strong>（<em>Client Random</em>）</li>
<li>当服务端收到客户端的消息后，会<strong>确认 TLS 版本号，选择ECDHE密码套件，以及生成随机数</strong>（<em>Server Random</em>），并会<strong>发送数字证书给客户端</strong>。</li>
<li>然后服务端会选择一个<strong>椭圆曲线</strong>，如x25519曲线，生成<strong>随机数作为私钥</strong>，再根据椭圆曲线和私钥计算出服务端的公钥，利用签名算法签名，并将<strong>曲线、公钥和签名</strong>发送给客户端。</li>
<li>客户端验证证书是否合法，合法则生成随机数作为客户端私钥，利用私钥和椭圆曲线计算出客户端公钥后发送给服务端。</li>
<li>双方利用客户端随机数和服务端随机数和ECDHE算出的共享密钥计算出会话密钥来加密通话。互相验证加密和解密是否成功，并且验证消息是否被篡改。</li>
<li>最后进行HTTP通信。</li>
</ol>
<p><img src="https://pic.keepjolly.com/halo/blog/2024/01/20240113205816.png?imageMogr2/format/webp%7C" alt="image">
RSA过程：</p>
<ol>
<li>客户端首先会发送使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（<em>Client Random</em>）</strong></li>
<li>当服务端收到客户端的消息后，会确认 TLS 版本号，选择RSA密码套件，以及生成<strong>随机数（<em>Server Random</em>）</strong>，并会发送数字证书给客户端。</li>
<li>客户端验证证书是否合法，判断服务器是否真实，取出服务端公钥。</li>
<li>接着，客户端就会生成一个新的<strong>随机数 (<em>pre-master</em>)</strong>，用服务器的公钥加密该随机数，传给服务端。</li>
<li>然后，利用前面的3个随机数生成「会话密钥」，把之前所有发送的数据做个<strong>摘要</strong>，用会话密钥（master secret）加密。</li>
<li>服务器也是同样的操作，如果双方都验证加密和解密没问题，那么握手正式完成。</li>
<li>最后，就用「会话密钥」加解密 HTTP 请求和响应了。
RSA是缺点是不支持前向保密，一旦服务器的私钥泄漏了，则之前的通信内容就被破解。</li>
</ol>
<p>SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<h2 id="22如何保证公钥不被篡改"><a href="#22如何保证公钥不被篡改" class="anchor-link">#</a><a href="#contents:22如何保证公钥不被篡改" class="headings">22、如何保证公钥不被篡改？</a></h2>
<p>将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
<ul>
<li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li>
<li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成证书签名；</li>
<li>最后将证书签名添加在文件证书上，形成数字证书；</li>
</ul>
<h2 id="公钥加密计算量太大如何减少耗用的时间"><a href="#公钥加密计算量太大如何减少耗用的时间" class="anchor-link">#</a><a href="#contents:公钥加密计算量太大如何减少耗用的时间" class="headings">公钥加密计算量太大，如何减少耗用的时间？</a></h2>
<p><a href="https://stardust567.github.io/post/84d.html" target="_blank" rel="noopener">https://stardust567.github.io/post/84d.html</a>
解决方法：握手阶段使用非对称加密，通信采取对称加密的方式(使用对话密钥)并且使用ECDHE作为加密套件。</p>
<h2 id="http请求和响应报文有哪些主要字段"><a href="#http请求和响应报文有哪些主要字段" class="anchor-link">#</a><a href="#contents:http请求和响应报文有哪些主要字段" class="headings">HTTP请求和响应报文有哪些主要字段？</a></h2>
<p>请求报文
<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/28/2612910.html" target="_blank" rel="noopener">HTTP请求报文和HTTP响应报文</a></p>
<ul>
<li>请求行：Request Line （请求方法、url、协议版本）</li>
<li>请求头：Request Headers（键值对组成，如host、user-agent、accept）</li>
<li>请求体：Request Body</li>
</ul>
<p>响应报文</p>
<ul>
<li>状态行：Status Line （协议版本；响应状态代码；状态代码的文本描述）</li>
<li>响应头：Response Headers（content-type、content-length、server、connection）</li>
<li>响应体：Response Body</li>
</ul>
<h2 id="cookie是什么"><a href="#cookie是什么" class="anchor-link">#</a><a href="#contents:cookie是什么" class="headings">Cookie是什么？</a></h2>
<p>HTTP 协议是<strong>无状态</strong>的，HTTP/1.1 引入 Cookie 来保存状态信息。</p>
<p>Cookie 是<strong>服务器发送到用户浏览器并保存在本地的一小块数据</strong>，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p>
<h2 id="cookie有什么用途"><a href="#cookie有什么用途" class="anchor-link">#</a><a href="#contents:cookie有什么用途" class="headings">Cookie有什么用途？</a></h2>
<ul>
<li>会话状态管理（如用户登录状态）</li>
<li>喜好设置（存储用户偏好等设置，向用户显示喜好内容）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h2 id="session知识大总结"><a href="#session知识大总结" class="anchor-link">#</a><a href="#contents:session知识大总结" class="headings">Session知识大总结</a></h2>
<p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p>
<p><del>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</del></p>
<p>使用 Session 维护用户登录状态的过程如下：</p>
<ol>
<li>用户进行登录时，提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到本地中，生成一个 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从本地中取出用户信息，继续之前的业务操作。</li>
</ol>
<blockquote>
<p>注意：Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p>
</blockquote>
<h2 id="session-的工作原理是什么"><a href="#session-的工作原理是什么" class="anchor-link">#</a><a href="#contents:session-的工作原理是什么" class="headings">Session 的工作原理是什么？</a></h2>
<p>session 的工作原理是客户端登录完成之后，服务器会创建对应的 session，然后把 session 的 id 发送给客户端，客户端再存储到浏览器中。这样客户端每次访问服务器时，都会带着 session id，服务器拿到 session id 之后，在内存找到与之对应的 session 这样就可以正常工作了。</p>
<h2 id="cookie与session的对比"><a href="#cookie与session的对比" class="anchor-link">#</a><a href="#contents:cookie与session的对比" class="headings">Cookie与Session的对比</a></h2>
<p><a href="https://mp.weixin.qq.com/s/cuTmhjnzdngE0EEb5RlbxQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/cuTmhjnzdngE0EEb5RlbxQ</a></p>
<ul>
<li>存储范围不同，Cookie 保存在客户端(浏览器)，Session 保存在服务器端。</li>
<li>存储方式的不同，Cookie只能保存 ASCII，Session可以存任意数据类型，比如UserId等。（跟get/post一样）</li>
<li>存储时限不同，Cookie可设置为长时间保持，比如默认登录功能，Session一般有效时间较短，客户端关闭或者Session超时都会失效。</li>
<li>存储大小不同， 单个Cookie 保存的数据不能超过 4K，Session可存储数据远高于Cookie。</li>
<li>隐私策略不同，Cookie存储在客户端，信息容易被窃取;Session存储在服务端，相对安全一些。</li>
</ul>
<h2 id="sql注入攻击了解吗"><a href="#sql注入攻击了解吗" class="anchor-link">#</a><a href="#contents:sql注入攻击了解吗" class="headings">SQL注入攻击了解吗？</a></h2>
<p><a href="https://www.jianshu.com/p/078df7a35671" target="_blank" rel="noopener">https://www.jianshu.com/p/078df7a35671</a></p>
<p>攻击者在HTTP请求中注入恶意的SQL代码，服务器使用请求中的参数拼接数据库SQL命令时，恶意SQL被一起拼接，并在数据库中执行。</p>
<blockquote>
<p>用户登录，输入用户名 123' or 1=1 # ，密码 any ，如果此时使用参数构造的方式，就会出现</p>
</blockquote>
<div class="highlight"><div class="chroma">
<div class="table-container"><table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-mysql" data-lang="mysql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">username</span><span class="o">=</span><span class="s1">&#39;123&#39;</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="mi">1</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="c1">#&#39; and password=&#39;123&#39; or 1=1 #&#39;
</span></span></span></code></pre></td></tr></table></div>
</div>
</div><blockquote>
<p>按照 Mysql 语法，# 后面的内容会被忽略。由于判断语句 or 1=1 恒成立，所以结果当然返回真，成功登录。</p>
</blockquote>
<h2 id="如何防范sql注入攻击"><a href="#如何防范sql注入攻击" class="anchor-link">#</a><a href="#contents:如何防范sql注入攻击" class="headings">如何防范SQL注入攻击</a></h2>
<p>Web端</p>
<ul>
<li>有效性检验。</li>
<li>限制字符串输入的长度。</li>
</ul>
<p>服务端</p>
<ul>
<li>避免使用动态SQL。</li>
<li>使用预编译的PreparedStatement。</li>
<li>有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)</li>
<li>过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</li>
</ul>
<h2 id="什么是rarp工作原理"><a href="#什么是rarp工作原理" class="anchor-link">#</a><a href="#contents:什么是rarp工作原理" class="headings">什么是RARP？工作原理</a></h2>
<p>概括： 反向地址转换协议，是网络层协议，RARP与ARP工作方式相反。 RARP使只知道自己硬件地址的主机能够知道其IP地址。</p>
<p>原理：</p>
<ol>
<li>~~网络上的每台设备都会有一个独一无二的硬件地址。~~主机从网卡上读取MAC地址，然后在网络上发送一个RARP请求的广播数据包。</li>
<li>RARP服务器响应该RARP请求，为其分配IP地址，并将IP地址发送给主机。</li>
<li>主机收到RARP回应后，就可以使用得到的IP地址进行通讯。</li>
</ol>
<blockquote>
<p>无非就是发包，响应包，得到内容</p>
</blockquote>
<h2 id="端口有效范围是多少到多少"><a href="#端口有效范围是多少到多少" class="anchor-link">#</a><a href="#contents:端口有效范围是多少到多少" class="headings">端口有效范围是多少到多少？</a></h2>
<p>0-1023为知名端口号，比如其中HTTP是80，FTP是20（数据端口）、21（控制端口）</p>
<p>UDP和TCP报头使用两个字节存放端口号，所以端口号的有效范围是从0到65535。动态端口的范围是从1024到65535</p>
<h2 id="为何把-tcpip-协议栈分成-5-层或7层开放式回答"><a href="#为何把-tcpip-协议栈分成-5-层或7层开放式回答" class="anchor-link">#</a><a href="#contents:为何把-tcpip-协议栈分成-5-层或7层开放式回答" class="headings">为何把 TCP/IP 协议栈分成 5 层（或7层）？开放式回答。</a></h2>
<p>分层的好处：</p>
<ol>
<li>易维护与实现，将一个难以处理的复杂问题分解为若干个较容易处理的更小的问题。</li>
<li>灵活性好，各层之间是独立的。任何一层发生变化时，只要层间接口关系保持不变，则在这层以上或以下各层均不影响。</li>
<li>结构上可分割，各层都可以采用最合适的技术实现。</li>
<li>能促进标准化工作，每一层的功能及其所提供的服务都已有了明确的说明。</li>
</ol>
<p><a href="https://blog.csdn.net/qq_32798897/article/details/121879151" target="_blank" rel="noopener">https://blog.csdn.net/qq_32798897/article/details/121879151</a></p>
<h2 id="dns查询方式有哪些"><a href="#dns查询方式有哪些" class="anchor-link">#</a><a href="#contents:dns查询方式有哪些" class="headings">DNS查询方式有哪些？</a></h2>
<p><img src="https://pic.keepjolly.com/halo/blog/2024/01/20240113205825.png?imageMogr2/format/webp%7C" alt="image"></p>
<p><a href="https://zhuanlan.zhihu.com/p/423222573" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/423222573</a></p>
<p>递归查询</p>
<p>递归查询一般发生在 Client 请求 DNS Server。Client 发出一个域名解析的请求，DNS Server 必须返回对应的 IP 地址，或者返回找不到的错误。</p>
<p>迭代查询</p>
<p>迭代查询一般发生在 DNS Server 之间，当 Client 发出域名解析的请求后，DNS Server 需要经过多次查询，才能得到相应的结果。比如先找到根服务器、根据根服务器的信息找到顶级域名服务器，再根据顶级域名服务器找到权威服务器，最后根据权威服务器返回结果，或提示错误。</p>
<p>非递归查询</p>
<p>非递归查询发生在 Client 和 DNS Server 之间，指的是，请求的 DNS Server 已经知道答案，直接返回。</p>
<p><a href="https://juejin.cn/post/6844903900982558734" target="_blank" rel="noopener">https://juejin.cn/post/6844903900982558734</a></p>
<h2 id="http中缓存的私有和共有字段知道吗"><a href="#http中缓存的私有和共有字段知道吗" class="anchor-link">#</a><a href="#contents:http中缓存的私有和共有字段知道吗" class="headings">HTTP中缓存的私有和共有字段？知道吗？</a></h2>
<p>响应头中的Cache-Control: private 指令规定了将资源作为私有缓存，只能被<strong>单独用户</strong>使用，一般存储在<strong>用户浏览器</strong>中。</p>
<p>响应头中的Cache-Control:public 指令规定了将资源作为公共缓存，可以被<strong>多个用户</strong>使用，一般存储在<strong>代理服务器</strong>中。</p>
<h2 id="get-方法参数写法是固定的吗"><a href="#get-方法参数写法是固定的吗" class="anchor-link">#</a><a href="#contents:get-方法参数写法是固定的吗" class="headings">GET 方法参数写法是固定的吗？</a></h2>
<p>不固定，只要服务端能够解释出来就行，但一般来说，参数写在url的？后面，键值对用&amp;分离。</p>
<h2 id="get-方法的长度限制是怎么回事"><a href="#get-方法的长度限制是怎么回事" class="anchor-link">#</a><a href="#contents:get-方法的长度限制是怎么回事" class="headings">GET 方法的长度限制是怎么回事？</a></h2>
<p>HTTP 协议没有 Body 和 URL 的长度限制，对 URL 限制的大多是浏览器和服务器的原因。</p>
<p>为了浏览器的兼容性，需要限制url长度；服务器是为了性能和安全考虑，会给 URL 长度加限制。</p>
<h2 id="post-方法比-get-方法安全"><a href="#post-方法比-get-方法安全" class="anchor-link">#</a><a href="#contents:post-方法比-get-方法安全" class="headings">POST 方法比 GET 方法安全？</a></h2>
<p><a href="https://github.com/sisterAn/blog/issues/107" target="_blank" rel="noopener">https://github.com/sisterAn/blog/issues/107</a></p>
<p>在 HTTP 协议里，所谓的“安全”是指请求方法不会对服务器上的资源进行修改，“破坏”服务器上的资源。</p>
<p>按照这种定义，GET 请求方法是安全的，它对服务器资源执行的仅仅是只读操作，也是幂等的</p>
<blockquote>
<p>幂等指多次执行相同的操作，结果也都是相同的，即多次“幂”后结果“相等”</p>
</blockquote>
<p>POST 请求方法是不安全的，它会修改服务器上的资源，“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的</p>
<p>总结：</p>
<ul>
<li>GET：安全，幂等</li>
<li>POST：不安全，不幂等</li>
</ul>
<blockquote>
<p>对于传输来说，GET 和 POST 报文在传输上都是不安全的，因为 HTTP 在网络上是明文传输的，想要安全传输就得加密，也就是 HTTPS</p>
</blockquote>
<h2 id="post-方法会产生两个-tcp-数据包你了解吗"><a href="#post-方法会产生两个-tcp-数据包你了解吗" class="anchor-link">#</a><a href="#contents:post-方法会产生两个-tcp-数据包你了解吗" class="headings">POST 方法会产生两个 TCP 数据包？你了解吗？</a></h2>
<p>大多数框架都是尽量在一个 TCP 包里面把 HTTP 请求发出去的，但是也确实存在先发 HTTP 头，然后发 body 的框架。但是具体发多少个TCP包，这个 <strong>不是 HTTP 协议的事情是操作系统 TCP 协议栈与代码的问题，跟 HTTP 没关系</strong></p>

            </div>

            


        </article>

        

        


        


        


        


        


        
    <footer class="minimal-footer">
        
            <div class="post-tag"><a href="/tags/interview/" rel="tag" class="post-tag-link">#interview</a></div>
        
        
            <div class="post-category">
                <a href="/posts/" class="post-category-link active">posts</a> | 
            </div>
        
        
    </footer>



        


        


        


    </div>
</main>


            
    <div id="back-to-top" class="back-to-top">
        <a href="#"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a>
    </div>


            

        </div>
        

        
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css">
<script>
    if (typeof renderMathInElement === 'undefined') {
        const getScript = (options) => {
            const script = document.createElement('script');
            script.defer = true;
            script.crossOrigin = 'anonymous';
            Object.keys(options).forEach((key) => {
                script[key] = options[key];
            });
            document.body.appendChild(script);
        };
        getScript({
            src: 'https:\/\/cdn.jsdelivr.net\/npm\/katex@0.13.0\/dist\/katex.min.js',
            onload: () => {
                getScript({
                    src: 'https:\/\/cdn.jsdelivr.net\/npm\/katex@0.13.0\/dist\/contrib\/mhchem.min.js',
                    onload: () => {
                        getScript({
                            src: 'https:\/\/cdn.jsdelivr.net\/npm\/katex@0.13.0\/dist\/contrib\/auto-render.min.js',
                            onload: () => {
                                renderKaTex();
                            }
                        });
                    }
                });
            }
        });
    } else {
        renderKaTex();
    }
    function renderKaTex() {
        renderMathInElement(
            document.body,
            {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false}
                ]
            }
        );
    }
</script>










    <script src="https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js"></script>

<script>
    let imgNodes = document.querySelectorAll('div.post-body img');
    imgNodes = Array.from(imgNodes).filter(node => node.parentNode.tagName !== "A");

    mediumZoom(imgNodes, {
        background: 'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'
    })
</script>









    </body>
</html>

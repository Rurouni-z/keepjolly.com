<!DOCTYPE html>
<html lang="zh-CN">
    <head prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article#"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8" />

    <meta name="generator" content="Hugo 0.140.2"><meta name="theme-color" content="#fff" />
    <meta name="color-scheme" content="light dark">

    
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    
    <meta name="format-detection" content="telephone=no, date=no, address=no, email=no" />
    
    <meta http-equiv="Cache-Control" content="no-transform" />
    
    <meta http-equiv="Cache-Control" content="no-siteapp" />

    <title>Nerf初入门笔记 | 悠闲の小屋</title>

    <link rel="stylesheet" href="/css/meme.min.css" />

    
    
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2/dist/instantsearch.min.js" defer></script><script src="/js/meme.min.js"></script>

    

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />

        <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto&#43;Serif&#43;SC:wght@400;500;700&amp;family=Source&#43;Code&#43;Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Cinzel&#43;Decorative:wght@700&amp;display=swap" media="print" onload="this.media='all'" />
        <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto&#43;Serif&#43;SC:wght@400;500;700&amp;family=Source&#43;Code&#43;Pro:ital,wght@0,400;0,700;1,400;1,700&amp;family=Cinzel&#43;Decorative:wght@700&amp;display=swap" /></noscript>

    <meta name="author" content="" /><meta name="description" content="推荐一个专栏, 转载自来源, 再加入自己的东西
NeRF 是做什么的 通过使用稀疏的输入视图优化底层的的连续辐射体积场函数，实现复杂场景的新视角合成
……" />

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#2a6df4" />
    <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-title" content="悠闲の小屋" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="application-name" content="悠闲の小屋" />
    <meta name="msapplication-starturl" content="../../../" />
    <meta name="msapplication-TileColor" content="#fff" />
    <meta name="msapplication-TileImage" content="../../../icons/mstile-150x150.png" />
    <link rel="manifest" href="/manifest.json" />

    
    

    
    <link rel="canonical" href="http://localhost:1313/posts/learn/nerf_note/" />
    

<script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "datePublished": "2023-06-07T22:05:23+08:00",
        "dateModified": "2024-05-03T14:50:48+08:00",
        "url": "http://localhost:1313/posts/learn/nerf_note/",
        "headline": "Nerf初入门笔记",
        "description": "推荐一个专栏, 转载自来源, 再加入自己的东西\nNeRF 是做什么的 通过使用稀疏的输入视图优化底层的的连续辐射体积场函数，实现复杂场景的新视角合成\n……",
        "inLanguage" : "zh-CN",
        "articleSection": "posts",
        "wordCount":  5059 ,
        "image": ["https://pic.keepjolly.com/halo/blog/2023/06/20230607220051.jpg?imageMogr2/format/webp%7C","https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-1.png?imageMogr2/format/webp%7C","https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-2.jpg?imageMogr2/format/webp%7C","https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-3.jpg?imageMogr2/format/webp%7C","https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-4.jpg?imageMogr2/format/webp%7C","https://cdn.nlark.com/yuque/0/2023/jpeg/12600461/1685605681470-8fe98fb6-6bad-41a4-bfe3-db8edec29925.jpeg#averageHue=%23f7f1eb\u0026amp;clientId=u11484f18-29d5-4\u0026amp;from=ui\u0026amp;height=219\u0026amp;id=BHKkM\u0026amp;originHeight=261\u0026amp;originWidth=442\u0026amp;originalType=binary\u0026amp;ratio=1.25\u0026amp;rotation=0\u0026amp;showTitle=false\u0026amp;size=12333\u0026amp;status=done\u0026amp;style=none\u0026amp;taskId=u517107bc-b88c-4d70-a7a4-1a1cc2147d5\u0026amp;title=\u0026amp;width=371","https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-6.jpg?imageMogr2/format/webp%7C","https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-7.jpg?imageMogr2/format/webp%7C"],
        "author": {
            "@type": "Person",
            "url": "http://localhost:1313/",
            
        },
        "license": "在保留本文作者及本文链接的前提下，非商业用途随意转载分享(我会高强度自搜的喔👊)。",
        "publisher": {
            "@type": "Organization",
            "name": "悠闲の小屋",
            "url": "http://localhost:1313/"
        },
        "mainEntityOfPage": {
            "@type": "WebSite",
            "@id": "http://localhost:1313/"
        }
    }
</script>

    

<meta name="twitter:card" content="summary_large_image" />



    



<meta property="og:title" content="Nerf初入门笔记" />
<meta property="og:description" content="推荐一个专栏, 转载自来源, 再加入自己的东西
NeRF 是做什么的 通过使用稀疏的输入视图优化底层的的连续辐射体积场函数，实现复杂场景的新视角合成
……" />
<meta property="og:url" content="http://localhost:1313/posts/learn/nerf_note/" />
<meta property="og:site_name" content="悠闲の小屋" />
<meta property="og:locale" content="zh" /><meta property="og:image" content="https://pic.keepjolly.com/halo/blog/2023/06/20230607220051.jpg?imageMogr2/format/webp%7C" />
<meta property="og:type" content="article" />
    <meta property="article:published_time" content="2023-06-07T22:05:23&#43;08:00" />
    <meta property="article:modified_time" content="2024-05-03T14:50:48&#43;08:00" />
    
    <meta property="article:section" content="posts" />


        <meta name="google-site-verification" content="mBjLYgXaXR8EAfTNbi4DTVC5KOJuBHpZDsmtgbgC6Rs" />

    
    

    
</head>

    <body>
        <div class="container">
            
    <header class="header">
        
            <div class="header-wrapper">
                <div class="header-inner single">
                    
    <div class="site-brand">
        
            <a href="/" class="brand">悠闲の小屋</a>
        
    </div>

                    <nav class="nav">
    <ul class="menu" id="menu">
        
            
        
        
        
        
            
                <li class="menu-item"><a href="/categories/"><span class="menu-item-name">分类</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/tags/"><span class="menu-item-name">标签</span></a>
                </li>
            
        
            
                <li class="menu-item"><a href="/about/"><span class="menu-item-name">关于</span></a>
                </li>
            
        
            
                
                    
                    
                        <li class="menu-item">
                            <a id="theme-switcher" href="#"><span class="icon theme-icon-light">🌞</span><span class="icon theme-icon-dark">🌙</span></a>
                        </li>
                    
                
            
        
            
                <li class="menu-item search-item">
                        <form id="search" class="search" role="search">
    <label for="search-input"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="icon search-icon"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></label>
    <input type="search" id="search-input" class="search-input">
</form>

<template id="search-result" hidden>
    <article class="content post">
        <h2 class="post-title"><a class="summary-title-link"></a></h2>
        <summary class="summary"></summary>
        <div class="read-more-container">
            <a class="read-more-link">阅读更多 »</a>
        </div>
    </article>
</template>

                    </li>
                
            
        
    </ul>
</nav>

                    
                </div>
            </div>
            
    <input type="checkbox" id="nav-toggle" aria-hidden="true" />
    <label for="nav-toggle" class="nav-toggle"></label>
    <label for="nav-toggle" class="nav-curtain"></label>


        
    </header>




            
            
    
    <div class = "toc-wrapper">
        

    </div>
    

<main class="main single" id="main">
    <div class="main-inner">

        

        <article class="content post h-entry" data-align="justify" data-type="posts" data-toc-num="true">

            <h1 class="post-title p-name">Nerf初入门笔记</h1>

            

            
                
            

            

            <nav class="contents">
  <h2 id="contents" class="contents-title">目录</h2><ol class="toc">
    <li><a id="contents:nerf-是做什么的" href="#nerf-是做什么的">NeRF 是做什么的</a></li>
    <li><a id="contents:nerf-是怎么做的" href="#nerf-是怎么做的">NeRF 是怎么做的</a>
      <ol>
        <li><a id="contents:pipeline" href="#pipeline">Pipeline</a></li>
        <li><a id="contents:静态场景的表示" href="#静态场景的表示">静态场景的表示</a></li>
        <li><a id="contents:神经渲染" href="#神经渲染">神经渲染</a></li>
        <li><a id="contents:如何优化" href="#如何优化">如何优化</a>
          <ol>
            <li><a id="contents:位置编码positional-encoding" href="#位置编码positional-encoding">位置编码(Positional encoding)</a></li>
            <li><a id="contents:分层采样hierarchical-volume-sampling" href="#分层采样hierarchical-volume-sampling">分层采样(Hierarchical volume sampling)</a></li>
          </ol>
        </li>
        <li><a id="contents:细节说明" href="#细节说明">细节说明</a></li>
      </ol>
    </li>
    <li><a id="contents:nerf-做的结果怎么样" href="#nerf-做的结果怎么样">NeRF 做的结果怎么样</a>
      <ol>
        <li><a id="contents:相关指标" href="#相关指标">相关指标</a></li>
        <li><a id="contents:优势" href="#优势">优势</a></li>
        <li><a id="contents:不足" href="#不足">不足</a></li>
      </ol>
    </li>
    <li><a id="contents:nerf-不懂的地方" href="#nerf-不懂的地方">Nerf 不懂的地方</a>
      <ol>
        <li><a id="contents:positional-encoding" href="#positional-encoding">Positional Encoding</a></li>
        <li><a id="contents:3d-occupancy-fields" href="#3d-occupancy-fields">3D occupancy fields</a></li>
        <li><a id="contents:a-neural-3d-texture-field" href="#a-neural-3d-texture-field">a neural 3D texture field</a></li>
        <li><a id="contents:light-field-sample-interpolation-techniques" href="#light-field-sample-interpolation-techniques">light field sample interpolation techniques</a></li>
        <li><a id="contents:differentiable-rasterizers" href="#differentiable-rasterizers">Differentiable rasterizers</a></li>
        <li><a id="contents:alpha-compositing" href="#alpha-compositing">alpha-compositing</a></li>
        <li><a id="contents:discretization-artifacts" href="#discretization-artifacts">discretization artifacts</a></li>
        <li><a id="contents:view-dependent" href="#view-dependent">view-dependent</a></li>
        <li><a id="contents:如何看图三" href="#如何看图三">如何看图三</a></li>
        <li><a id="contents:inverse-transform-sampling" href="#inverse-transform-sampling">inverse transform sampling</a></li>
        <li><a id="contents:deepsdf" href="#deepsdf">DeepSDF</a></li>
      </ol>
    </li>
  </ol>
</nav><hr></hr><div class="post-body e-content">
                <p>推荐一个<a href="https://zhuanlan.zhihu.com/p/486710656" target="_blank" rel="noopener">专栏</a>, 转载自<a href="https://zicx.top/notebook/research/nerf/note/#hierarchical-volume-sampling" target="_blank" rel="noopener">来源</a>, 再加入自己的东西</p>
<h2 id="nerf-是做什么的"><a href="#nerf-是做什么的" class="anchor-link">#</a><a href="#contents:nerf-是做什么的" class="headings">NeRF 是做什么的</a></h2>
<p>通过使用稀疏的输入视图优化底层的的连续辐射体积场函数，实现<strong>复杂场景的新视角合成</strong></p>
<h2 id="nerf-是怎么做的"><a href="#nerf-是怎么做的" class="anchor-link">#</a><a href="#contents:nerf-是怎么做的" class="headings">NeRF 是怎么做的</a></h2>
<p><img src="https://pic.keepjolly.com/halo/blog/2023/06/20230607220051.jpg?imageMogr2/format/webp%7C" alt="image">，(b)生成射线，(c)立体渲染，(d)算 mse loss。&quot;)</p>
<h3 id="pipeline"><a href="#pipeline" class="anchor-link">#</a><a href="#contents:pipeline" class="headings">Pipeline</a></h3>
<p><a href="https://github.com/yangkang2021/nerf-learn/blob/master/nerf/02.%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E4%B8%8E%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.md" target="_blank" rel="noopener">nerf(二)---工作流程与基本原理</a></p>
<ul>
<li>a).沿着相机光线的方向采样 5D 坐标</li>
<li>b).将坐标信息输入到 MLP 中，产生颜色和体积密度</li>
<li>c).使用立体渲染将颜色和体积密度合成为图像</li>
<li>d).渲染函数是可微分的，因此可以通过最小化合成图像和实际观察到的图像之间的残差来优化场景表示</li>
</ul>
<h3 id="静态场景的表示"><a href="#静态场景的表示" class="anchor-link">#</a><a href="#contents:静态场景的表示" class="headings">静态场景的表示</a></h3>
<ul>
<li>使用全连接（非卷积）深度网络(多层感知机，MLP)来表示场景</li>
<li>输入是一个连续的5D坐标：**空间位置 **$(x,y,z)$ 和 <strong>2D 观察方向</strong>$(\theta, \phi)$</li>
<li>输出是该空间位置的**体积密度 <strong>$\sigma$</strong> 和视角相关的颜色 **$\textbf{c} = (r,g,b)$<br />这里的体积密度只对某一个空间点$(x,y,z)$ 而言，它表示一条穿过空间点$(x,y,z)$ 的射线累计了多少辐射(radiance)，后面会将它转化为概率密度</li>
</ul>
<p><strong>多视图之间保持连续一致性</strong></p>
<ul>
<li>体积密度 $\sigma$ 函数只与空间位置 $\mathbf{x}$ 有关 --&gt; $\sigma(\mathbf{x})$</li>
<li>颜色 $c$ 函数与空间位置 $\mathbf{x}$ 和视角 $\mathbf{d}$ 都有关 --&gt; $c(\mathbf{x},\mathbf{d})$</li>
</ul>
<p><strong>MLP 的设计</strong></p>
<ul>
<li>用 8 个全连接层来处理输入的空间坐标 $x$ (激活函数为 ReLU，每层256个通道)</li>
<li>输出 $\sigma$ 和一个 256 维的特征向量</li>
<li>将特征向量和视角方向 $d$ 连接起来</li>
<li>传递到一个额外的全连接层 (激活函数为 ReLU，128个通道)</li>
<li>输出依赖于视图的 RGB 颜色</li>
</ul>
<p><strong>MLP 的 Loss 计算</strong><br />$\mathcal{L}=\sum_{\mathbf{r} \in \mathcal{R}}\left[\left|\hat{C}_c(\mathbf{r})-C(\mathbf{r})\right|_2^2+\left|\hat{C}_f(\mathbf{r})-C(\mathbf{r})\right|_2^2\right]$</p>
<ul>
<li>用了两个 MLP 网络，分别是<strong>粗(coarse) 网络和细(fine) 网络</strong></li>
</ul>
<blockquote>
<p>后续<strong>如何优化</strong>的部分会具体解释粗网络和细网络</p>
</blockquote>
<ul>
<li>$\mathcal{R}$ 是每个 batch 里面光线的集合，$\mathbf{r}$ 是指集合里面的每一条光线</li>
<li>$C(\mathbf{r})$，$\hat{C}_c(\mathbf{r})$，$\hat{C}_f(\mathbf{r})$ 分别是gt实景，粗网络，细网络中输出的光线 RGB 颜色</li>
<li>同时还将 $\hat{C}_c(\mathbf{r})$ 的损失最小化，以便粗网络的权重分布可以用于在细网络中分配样本</li>
</ul>
<h3 id="神经渲染"><a href="#神经渲染" class="anchor-link">#</a><a href="#contents:神经渲染" class="headings">神经渲染</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/486642042" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/486642042</a></p>
<ul>
<li>沿着相机光线查询 5D 坐标来合成视图</li>
<li>使用<strong>立体渲染</strong>将输出颜色和密度投影到 2D 图像中</li>
</ul>
<p>从特定的视角渲染 NeRF 的过程</p>
<ul>
<li>利用穿过场景的相机光线，生成一组采样的三维点 $P_{3D}$</li>
<li>利用三维点和对应的 2D 视角方向作为 MLP 的输入，输出密度和颜色</li>
<li>使用立体渲染技术将输出颜色和密度累积到一个二维图像 $I_{2D}$ 中</li>
</ul>
<blockquote>
<p>由于具有可微性，所以可以利用<strong>梯度下降</strong>的方法来优化 MLP 网络，<strong>最小化每个观察图像和 NeRF 渲染出来的相应视图之间的误差</strong></p>
</blockquote>
<p>该部分详细内容参见 <a href="./math.md">NeRF 的数学推导</a>[NeRF数学公式从零推导](<a href="https://www.bilibili.com/video/BV1Wd4y1X7H1/" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1Wd4y1X7H1/</a>)<br />光线可以表示为一个 3D 空间坐标<br />$\mathbf{r}(t) = \mathbf{o} + t \mathbf{d}$</p>
<blockquote>
<p>原文中的一些假设：</p>
<ol>
<li>场景是由一团发光粒子组成的，这里粒子密度的空间分布会发生变化</li>
<li>发射的光（每一个体素都会向四周均匀发出光）不随观察视角而改变</li>
</ol>
</blockquote>
<p>假设<strong>距离</strong> $t$ 的近场边界和远场边界分别为 $t_n$ 和 $t_f$ ，那么对于一条射线，它的期望颜色表达式应该如下：<br />$C(\mathbf{r})=\int_{t_n}^{t_f} T(t) \sigma(\mathbf{r}(t)) \mathbf{c}(\mathbf{r}(t), \mathbf{d}) d t, \text{ where } T(t)=\exp \left(-\int_{t_n}^t \sigma(\mathbf{r}(s)) d s\right)$<br />函数 $T(t)$ 表示的是光线在 $t_n$ 到 $t$ 距离内的透射率，即光线在不碰到任何其他粒子的情况下能够传播的概率<br />一张示例图：<br /><img src="https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-1.png?imageMogr2/format/webp%7C" alt="image"><br />从连续的 NeRF 中渲染视图需要估计相机光线追踪的每个像素的积分 $C(\mathbf{r})$</p>
<blockquote>
<p><em>这个很好理解，因为 2D 图像的每一个像素值实际上是相机发出的一条射线上的所有点累积叠加的结果</em></p>
</blockquote>
<p>文中估计积分的方法是 <a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%B1%82%E7%A7%AF" target="_blank" rel="noopener">数值积分(Quadrature)</a><br />简单来说，就是分层抽样，把 $[t_n, t_f]$ 等分成 $\mathbf{N}$ 个区间，然后从每个区间内均匀随机地抽取一个样本</p>
<p>$t_i \sim \mathcal{U}\left[t_n+\frac{i-1}{N}\left(t_f-t_n\right), t_n+\frac{i}{N}\left(t_f-t_n\right)\right] \quad i =1,2,...N$</p>
<blockquote>
<p>这里得到的 $t_i$ 是每个小区间内的随机抽取样本点的空间坐标</p>
</blockquote>
<p>根据数值积分方法估计的颜色积分结果如下所示：<br />$\hat{C}(\mathbf{r})=\sum_{i=1}^N T_i\left(1-\exp \left(-\sigma_i \delta_i\right)\right) \mathbf{c}<em>i, \text { where } T_i=\exp \left(-\sum</em>{j=1}^{i-1} \sigma_j \delta_j\right)$<br />通过分层抽样的方式，将<strong>连续的积分变成了离散的求和</strong>，$\delta_i = t_{i+1} - t_i$ 是<strong>样本间隔(距离)</strong><br />文中还提到了可以简化为传统的 Alpha 合成，对应的 alpha value 是<br />$\alpha_i = 1 - exp(-\sigma_i \delta_i)$</p>
<h3 id="如何优化"><a href="#如何优化" class="anchor-link">#</a><a href="#contents:如何优化" class="headings">如何优化</a></h3>
<p>输入为一系列<strong>已知相机位姿</strong>的图像<br /><strong>两方面的优化：</strong></p>
<ul>
<li>使用<strong>位置编码</strong>来转换输入的 5D 坐标，将坐标映射到<strong>更高维度的空间</strong>中，使相似的内容分离到更远的地方，从而使 MLP 能够表示<strong>更高频率的函数</strong>，使得物体表面的几何和纹理更加逼真</li>
<li>采用了一种<strong>由粗到细的分层采样</strong>程序，对于颜色贡献大的点附近采样密集，贡献小的点附近采样稀疏，以减少必要的采样次数，充分采样整个高频场景表示</li>
</ul>
<blockquote>
<p>这个采样的过程应该是指相机光线对真实 3D 场景的采样，在输入到 MLP 之前</p>
</blockquote>
<h4 id="位置编码positional-encoding"><a href="#位置编码positional-encoding" class="anchor-link">#</a><a href="#contents:位置编码positional-encoding" class="headings">位置编码(Positional encoding)</a></h4>
<blockquote>
<p>深度网络更偏向于学习低频函数，研究表明，在将输入通过高频函数映射到更高维空间后再传递给网络，可以更好地拟合包含<strong>高频变化</strong>的数据</p>
</blockquote>
<p>将原先的表示函数变成两个函数的组合：<br />$F_{\Theta}=F_{\Theta}^{\prime} \circ \gamma$<br />两个函数，$F_{\Theta}^{\prime}$ 函数需要网络学习的，就是一个普通的 MLP，$\gamma$ 函数则不需要学习<br />$\gamma$ 在这里是一个映射(mapping) 函数，从空间 $\mathbf{R}$ 映射到高维空间 $\mathbf{R}^{2L}$<br />原文中使用的编码方程如下：<br />$\gamma(p)=\left(\sin \left(2^0 \pi p\right), \cos \left(2^0 \pi p\right), \cdots, \sin \left(2^{L-1} \pi p\right), \cos \left(2^{L-1} \pi p\right)\right)$<br />$\gamma(\cdot)$ 分别作用于空间坐标 $\mathbf{x}$ 中的<strong>每一个分量(x,y,z)</strong> 和 视角方向的单位向量 $\mathbf{d}$ 的<strong>三个分量</strong>，最后会被归一化到区间 [-1, 1] 之间(sinh 函数)<br />文中用到的<strong>超参数</strong></p>
<ul>
<li>$L = 10 \quad \text{for} \quad \gamma(\mathbf{x})$</li>
<li>$L = 4 \quad \text{for} \quad \gamma(\mathbf{d})$</li>
</ul>
<blockquote>
<p><em>维度 <em>$L$</em> 的选择和场景的复杂度以及算力有关，也决定了神经网络能学习到的最高频率的大小</em></p>
</blockquote>
<h4 id="分层采样hierarchical-volume-sampling"><a href="#分层采样hierarchical-volume-sampling" class="anchor-link">#</a><a href="#contents:分层采样hierarchical-volume-sampling" class="headings">分层采样(Hierarchical volume sampling)</a></h4>
<p>通过按照样本对最终渲染的预期影响进行比例分配提高渲染效率<br />同时优化两个 MLP 网络：&quot;coarse&quot; 和 &quot;fine&quot;</p>
<ol>
<li>将在相机射线上，由 near 和 far 构成的区间范围等分，然后在每个小区间内均匀采样得到一个采样点，一共 $N_c$  个采样点</li>
<li>利用这些空间点来评估粗网络</li>
<li>再在每条射线上生成更多信息的采样点 (猜想是粗网络的结果<strong>输出了样本点的概率密度分布</strong>，为第二次采样提供了参考)</li>
<li>使用<a href="https://zhuanlan.zhihu.com/p/396618080" target="_blank" rel="noopener">逆变换采样</a>采样第二组 $N_f$ 个空间位置点，用<strong>两组空间点</strong>评估细网络，并使用两组空间点来计算射线最后的颜色 $\hat{C}_f(\mathbf{r})$</li>
</ol>
<p><strong>第三步具体是怎么做的</strong><br />首先将原方程中粗网络 $\hat{C_c}(\mathbf{r})$ 的 Alpha 合成的颜色重写为沿着光线采样到的所有颜色 $c_i$ 的加权和<br />$\hat{C}<em>c(\mathbf{r})=\sum</em>{i=1}^{N_c} w_i c_i, \quad w_i=T_i\left(1-\exp \left(-\sigma_i \delta_i\right)\right)$</p>
<blockquote>
<p>这个权值 $w_i$ 和透过率以及体积密度有关</p>
</blockquote>
<p>将权值归一化后可以化为沿射线分布的<strong>分段常数概率密度函数</strong>(Piecewise-constant PDF), <strong>目的是粗略估计射线上的物体分布情况</strong><br />$\hat{w_i} = \frac{w_i}{\sum_{j=1}^{N_c}w_j}$</p>
<h3 id="细节说明"><a href="#细节说明" class="anchor-link">#</a><a href="#contents:细节说明" class="headings">细节说明</a></h3>
<p><strong>体积边界</strong><br />对于合成图像: 缩放场景，使其位于以原点为中心、边长为 2 $([-1,1])$的立方体内，并仅查询这个边界体积内的 NeRF 表示<br />对于真实图像: 数据集包含可以存在于最近点和无穷远点之间的内容，用归一化的方式将这些点的深度范围映射到区间 [-1, 1]<br />这将所有光线的起点移动到<strong>场景的近平面(near plane)</strong>，将相机的透视光映射为变换后体积中的平行光线，并使用<strong>视差</strong>而不是使用度量深度，因此<strong>所有坐标都是有界限的</strong><br /><strong>训练</strong><br />对于真实场景的数据，在优化过程中对输出结果 $\sigma$ 添加了随机高斯噪声 (在通过 ReLU 之前)<br /><strong>渲染</strong><br />在测试的时候，在每条射线上采样 64 个点输入到粗网络中，采样 64+128=192 个点到细网络中，<strong>每条光线一共采样 256 个点</strong><br />对于合成的图片，每张图片需要 640k 条光线；对于真实场景，每张图片需要 762k 条光线</p>
<h2 id="nerf-做的结果怎么样"><a href="#nerf-做的结果怎么样" class="anchor-link">#</a><a href="#contents:nerf-做的结果怎么样" class="headings">NeRF 做的结果怎么样</a></h2>
<h3 id="相关指标"><a href="#相关指标" class="anchor-link">#</a><a href="#contents:相关指标" class="headings">相关指标</a></h3>
<ul>
<li>PSNR: 峰值信噪比，是一种评价<strong>图像质量</strong>的指标 <em>(越高越好)</em></li>
<li>SSIM: 结构相似性，是一种衡量两幅<strong>图像相似度</strong>的指标 <em>(越高越好)</em></li>
<li>LPIPS: 学习感知图像块相似度，是一种度量两幅<strong>图像之间的差别</strong>的指标 <em>(越低越好)</em></li>
</ul>
<h3 id="优势"><a href="#优势" class="anchor-link">#</a><a href="#contents:优势" class="headings">优势</a></h3>
<ul>
<li>继承了体积表示的优点，可以表示<strong>复杂的几何形状和外观</strong></li>
<li>适合使用投影图像进行<strong>基于梯度（可微）的优化</strong></li>
<li>克服了在高分辨率建模复杂场景时，<strong>离散化体素网格</strong>所带来的<strong>存储成本过高</strong>的问题</li>
</ul>
<h3 id="不足"><a href="#不足" class="anchor-link">#</a><a href="#contents:不足" class="headings">不足</a></h3>
<ul>
<li>训练速度太慢：每个像素都需要近 200 次 MLP 模型的前向预测</li>
<li>模型泛化性太差：NeRF 要针对每个场景单独进行训练，无法直接扩展到新出现的场景</li>
</ul>
<h2 id="nerf-不懂的地方"><a href="#nerf-不懂的地方" class="anchor-link">#</a><a href="#contents:nerf-不懂的地方" class="headings">Nerf 不懂的地方</a></h2>
<h3 id="positional-encoding"><a href="#positional-encoding" class="anchor-link">#</a><a href="#contents:positional-encoding" class="headings">Positional Encoding</a></h3>
<p><a href="https://zhuanlan.zhihu.com/p/623432244" target="_blank" rel="noopener">思考Positional Encoding</a><br />map each input 5D coordinate into a higher dimensional space。<br />为什么要映射到高维空间：<br />This is consistent with recent work by Rahaman et al. [35], which shows that deep networks are biased towards learning lower frequency functions. They additionally show that** mapping the inputs to a higher dimensional space using high frequency functions** before passing them to the network enables <strong>better fitting of data</strong> that contains high frequency variation.</p>
<h3 id="3d-occupancy-fields"><a href="#3d-occupancy-fields" class="anchor-link">#</a><a href="#contents:3d-occupancy-fields" class="headings">3D occupancy fields</a></h3>
<p>推荐博客: <a href="https://blog.csdn.net/qq_34342853/article/details/120078510" target="_blank" rel="noopener">1</a>, <a href="https://hideoninternet.github.io/2019/12/21/b040bbb5/" target="_blank" rel="noopener">2</a><br /><strong>就是用一个隐函数来表示物体的连续边界.</strong></p>
<ul>
<li>体素表示的缺点：内存随分辨率呈立方增加，故需要限制在32<em>32</em>32或64<em>64</em>64。使用例如八叉树的数据自适应表示来降低内存，实现起来又会复杂，现有数据自适应算法依旧局限于相对较小的256<em>256</em>256分辨率。</li>
<li>点云表示的缺点：由于缺少底层网格的连接结构，需要额外的后处理来从模型中提取三维几何图形。</li>
<li>网格表示的缺点：现有的网格表示通常基于对一个模板网格的变形，因此不允许任意拓扑。</li>
</ul>
<p><a href="https://blog.csdn.net/weixin_45616624/article/details/122790729" target="_blank" rel="noopener">Occupancy Networks</a>基于对连续三维占据函数进行直接学习的三维重建新方法。利用神经网络实现对任意分辨率的占据函数的预测。训练时大大降低了内存，推理时利用简单的多分辨率等值面提取算法从学习的模型中提取网格。<br /><img src="https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-2.jpg?imageMogr2/format/webp%7C" alt="image"></p>
<h3 id="a-neural-3d-texture-field"><a href="#a-neural-3d-texture-field" class="anchor-link">#</a><a href="#contents:a-neural-3d-texture-field" class="headings">a neural 3D texture field</a></h3>
<p>a <a href="https://arxiv.org/abs/1905.07259" target="_blank" rel="noopener">Texture Field</a> as a mapping from 3D point p, shape embedding s and condition z to color c:</p>
<h3 id="light-field-sample-interpolation-techniques"><a href="#light-field-sample-interpolation-techniques" class="anchor-link">#</a><a href="#contents:light-field-sample-interpolation-techniques" class="headings">light field sample interpolation techniques</a></h3>
<p>远古方法了,不做了解,引用论文最迟都是2012年.</p>
<h3 id="differentiable-rasterizers"><a href="#differentiable-rasterizers" class="anchor-link">#</a><a href="#contents:differentiable-rasterizers" class="headings">Differentiable rasterizers</a></h3>
<p>optimize mesh representations to reproduce a set of input images<br />可参考博客:<a href="https://blog.csdn.net/qq_43420530/article/details/117909788" target="_blank" rel="noopener">1</a>, <a href="https://zhuanlan.zhihu.com/p/584510853" target="_blank" rel="noopener">2</a></p>
<h3 id="alpha-compositing"><a href="#alpha-compositing" class="anchor-link">#</a><a href="#contents:alpha-compositing" class="headings">alpha-compositing</a></h3>
<p><a href="https://zh.wikipedia.org/zh-tw/Alpha%E5%90%88%E6%88%90" target="_blank" rel="noopener">Alpha合成</a>（英語：alpha compositing）是一種將圖像與背景結合的過程，結合後可以產生部分透明或全透明的視覺效果。</p>
<h3 id="discretization-artifacts"><a href="#discretization-artifacts" class="anchor-link">#</a><a href="#contents:discretization-artifacts" class="headings">discretization artifacts</a></h3>
<p>搞不懂,离散化伪影?<br />41 24 论文 他们用的是什么方法</p>
<h3 id="view-dependent"><a href="#view-dependent" class="anchor-link">#</a><a href="#contents:view-dependent" class="headings">view-dependent</a></h3>
<p>view-dependent就是加入了direction（θ,ϕ），可以使得每个方向都有独立的颜色变化<br /><img src="https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-3.jpg?imageMogr2/format/webp%7C" alt="image"></p>
<h3 id="如何看图三"><a href="#如何看图三" class="anchor-link">#</a><a href="#contents:如何看图三" class="headings">如何看图三</a></h3>
<p>图三表示不同方向下，展示的结果会不一致，有镜面反射的效果<br /><a href="https://blog.devgenius.io/paper-explained-nerf-representing-scenes-as-neural-radiance-fields-for-view-synthesis-e16567180531" target="_blank" rel="noopener">In the case of a fully Lambertian surface</a> ( imagine an ideal “matte” surface like a terracotta vase), when a light ray hits a point the light enters slightly into the surface of the object and <strong>is scattered in all directions</strong>. In this case, I can look at the point from any direction and its color will be about the same. At the opposite extreme we have a perfect mirror: in this case each light ray is reflected in only one direction and this makes that, for example, when we look at a mirror what we see changes depending on where we are looking from. Fig. 3 of the paper shows the effect of the viewing direction</p>
<h3 id="inverse-transform-sampling"><a href="#inverse-transform-sampling" class="anchor-link">#</a><a href="#contents:inverse-transform-sampling" class="headings">inverse transform sampling</a></h3>
<p>已知PDF和CDF后, 就可以求逆函数, 再通过采样均匀分布的点，将其代入到逆函数，进而得到服从指数分布的样本点(最终目标).<br /><a href="https://zhuanlan.zhihu.com/p/396618080" target="_blank" rel="noopener">采样理论概述（逆变换采样、拒绝采样）</a></p>
<h3 id="deepsdf"><a href="#deepsdf" class="anchor-link">#</a><a href="#contents:deepsdf" class="headings">DeepSDF</a></h3>
<p><a href="https://blog.csdn.net/qq_43420530/article/details/122404223" target="_blank" rel="noopener">推荐博客</a>、<a href="https://openaccess.thecvf.com/content_CVPR_2019/papers/Park_DeepSDF_Learning_Continuous_Signed_Distance_Functions_for_Shape_Representation_CVPR_2019_paper.pdf" target="_blank" rel="noopener">论文</a><br /><a href="https://www.jianshu.com/p/d34afd45f28e" target="_blank" rel="noopener">传统的sdf，文中也介绍了ray tracing、ray marching。。。</a><br /><img src="https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-4.jpg?imageMogr2/format/webp%7C" alt="image"><br />正式介绍DeepSDF：</p>
<ol>
<li>首先，我们可以用SDF（Signed Distance Function）这样一个函数来隐式地表示一个三维物体，输入是空间中点的三维坐标，输出是这个点离我们想表示的物体表面的最近距离，如果在外部就是正，内部就是负。<strong>显然只要SDF找的好，从理论上来说，我们就能够简单粗暴地表示任意复杂且连续的物体</strong>，这也是物体的隐式表示方式与用点云、体素、网格等表示方式相比最大的好处。</li>
</ol>
<p>$S D F(\boldsymbol{x})=s: \boldsymbol{x} \in \mathbb{R}^{3}, s \in \mathbb{R}$<br />其中x为三维的采样点，s为一维的带正负的数值，假定真的有这样一个完美的SDF函数，那么我们就能用图形学中现成的Marching Cubes方法将其转换成网格数据，或者直接用raycasting方法直接渲染，在这里不作详细讨论。</p>
<ol start="2">
<li>现在假定我们有几个离散的SDF函数的输入与输出，我们想要通过某种方式得到这个完整的SDF函数，最终就能实现根据这几个离散的采样点来重建整个三维物体了，这也是本文的根本目的。本文提出的DeepSDF思想便是，用<strong>神经网络当做SDF函数的拟合器</strong>，训练完（或者说拟合完）之后，输入大量自定义的三维空间采样点，再提取出所有值为0的点组成面，就能够重建整个三维物体了。因为神经网络是万能函数拟合器，所以说这种方法可以表示任意精度的，连续的三维物体，只不过是得取决于你的采样点数量与神经网络的层数罢了</li>
<li>很显然，基于上面的思想我们很自然地想到这种结构：</li>
</ol>
<p><img src="https://cdn.nlark.com/yuque/0/2023/jpeg/12600461/1685605681470-8fe98fb6-6bad-41a4-bfe3-db8edec29925.jpeg#averageHue=%23f7f1eb&amp;clientId=u11484f18-29d5-4&amp;from=ui&amp;height=219&amp;id=BHKkM&amp;originHeight=261&amp;originWidth=442&amp;originalType=binary&amp;ratio=1.25&amp;rotation=0&amp;showTitle=false&amp;size=12333&amp;status=done&amp;style=none&amp;taskId=u517107bc-b88c-4d70-a7a4-1a1cc2147d5&amp;title=&amp;width=371" alt="image"><br />在这里，神经网络的作用不是去实现某种功能，而是<strong>去表示物体或场景本身</strong>，因此也会导致后续的各种训练上和我们正常认知的神经网络训练方式有些许的区别（关于这两者区别建议看一下<a href="https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-5..png?imageMogr2/format/webp%7C" target="_blank" rel="noopener">《用神经网络表示物体或场景与用神经网络完成任务的区别与联系》</a>）</p>
<ol start="4">
<li>这样就万事大吉了吗？并没有，因为如果用这种方法，并不是数据驱动的，而更像是一种数学的方法，我们<strong>每次进行重建的时候都得重新训练一个神经网络得到表示这个物体的专属SDF</strong>，比如给我一个轿车的若干采样点，我给训练出来了，你要是再给我一个卡车的采样点，我还得重新训练，虽说这样我们根本不需要数据集，但是缺点显而易见：我是希望在神经网络中引入对三维数据集的一些先验来辅助拟合，以便于更好地进行三维重建的，比如你就给我8个采样点，分别代表正方体的8个顶点，如果不引入数据集（如汽车数据集）的先验的话，最终拟合出来的东西肯定就是一个正方体（或者是个球体）之类的东西，而不是像个汽车的样子。</li>
<li>因此，本文提出了下面的架构：</li>
</ol>
<p><img src="https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-6.jpg?imageMogr2/format/webp%7C" alt="image"><br />假定数据集中的某类数据被编码成latent code进行表示，这样我将这个latent code和三维坐标同时丢入神经网络查询得到sdf值，其实就能够得到某类中某个具体的三维物体的SDF函数表示了</p>
<ol>
<li>auto-coder</li>
</ol>
<p><img src="https://pic.keepjolly.com/halo/blog/2023/06/20230607220051-7.jpg?imageMogr2/format/webp%7C" alt="image"></p>

            </div>

            


        </article>

        

        


        


        


        


        


        
    <footer class="minimal-footer">
        
            <div class="post-tag"><a href="/tags/computervision/" rel="tag" class="post-tag-link">#computervision</a></div>
        
        
            <div class="post-category">
                <a href="/posts/" class="post-category-link active">posts</a> | 
            </div>
        
        
    </footer>



        


        


        


    </div>
</main>


            
    <div id="back-to-top" class="back-to-top">
        <a href="#"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="icon arrow-up"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a>
    </div>


            

        </div>
        

        
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css">
<script>
    if (typeof renderMathInElement === 'undefined') {
        const getScript = (options) => {
            const script = document.createElement('script');
            script.defer = true;
            script.crossOrigin = 'anonymous';
            Object.keys(options).forEach((key) => {
                script[key] = options[key];
            });
            document.body.appendChild(script);
        };
        getScript({
            src: 'https:\/\/cdn.jsdelivr.net\/npm\/katex@0.13.0\/dist\/katex.min.js',
            onload: () => {
                getScript({
                    src: 'https:\/\/cdn.jsdelivr.net\/npm\/katex@0.13.0\/dist\/contrib\/mhchem.min.js',
                    onload: () => {
                        getScript({
                            src: 'https:\/\/cdn.jsdelivr.net\/npm\/katex@0.13.0\/dist\/contrib\/auto-render.min.js',
                            onload: () => {
                                renderKaTex();
                            }
                        });
                    }
                });
            }
        });
    } else {
        renderKaTex();
    }
    function renderKaTex() {
        renderMathInElement(
            document.body,
            {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "\\[", right: "\\]", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false}
                ]
            }
        );
    }
</script>










    <script src="https://cdn.jsdelivr.net/npm/medium-zoom@latest/dist/medium-zoom.min.js"></script>

<script>
    let imgNodes = document.querySelectorAll('div.post-body img');
    imgNodes = Array.from(imgNodes).filter(node => node.parentNode.tagName !== "A");

    mediumZoom(imgNodes, {
        background: 'hsla(var(--color-bg-h), var(--color-bg-s), var(--color-bg-l), 0.95)'
    })
</script>









    </body>
</html>

---
title: 面试之计算机网络-4
date: 2024-01-13 21:57:19 +0800
lastmod: 
summary: 
url: 
slug: interview-network-4
toc: true
rightToc: false
categories: 
- other
tags: 
- Interview
original: false
---


## 四次挥手相关内容

![](http://oss.interviewguide.cn/img/202205220036404.png)

TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，客户端或服务器均可主动发起挥手动作。

- 客户端打算关闭连接，此时会发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。


## 挥手为什么需要四次？

服务器收到客户端的 FIN 报文时，内核会马上回一个 ACK 应答报文，**但是服务端应用程序可能还有数据要发送，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序**：

- 如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数；
- 如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数，

## MSL和TTL？

MSL（Maximum Segment Lifetime），它是任何报文在网络上存在的**最长时间**。

IP 头中有一个 `TTL` 字段，是 IP 数据报可以经过的**最大路由数**，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。

MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 **MSL 应该要大于等于 TTL 消耗为 0 的时间**，以确保报文已被自然消亡。

## 四次挥手释放连接时，等待2MSL的意义?

1. 保证客户端发送的最后一个ACK报文段能够到达服务端。 因为这个ACK有可能丢失，如果丢失服务器会超时重传这个FIN报文，接着客户端再重传一次确认，重新启动时间等待计时器。保证服务器能正常的关闭。
2. 防止历史连接中的数据，出现在本连接中。经过2MSL，就可以使历史连接内所产生的所有报文段都从网络中消失。

## 为什么TIME_WAIT状态需要经过2MSL才能返回到CLOSE状态？

同上


## TCP粘包问题是什么？你会如何去解决它？

**TCP粘包**是由于TCP是面向流的协议，它只提供了数据的可靠传输，而没有明确的消息边界，用户不知道数据的边界在哪里，导致解析出错。

**解决**：
1. 通过特殊标识符表示数据包的边界，例如\n\r，\t，或者一些隐藏字符。
2. 在TCP报文的头部加上表示数据长度。
3. 发送数据时**定长**发送。


## OSI七层模型中表示层和会话层功能是什么？

参考OSI七层模型。

## 三次握手四次挥手的变迁图

建议不看

《TCP/IP详解 卷1:协议》有一张TCP状态变迁图，很具有代表性，有助于大家理解三次握手和四次挥手的状态变化。如下图所示，粗的实线箭头表示正常的客户端状态变迁，粗的虚线箭头表示正常的服务器状态变迁。

![](http://oss.interviewguide.cn/img/202205220036408.png)

## 对称密钥加密的优点缺点？

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。

- 优点：运算速度快
- 缺点：无法安全地将密钥传输给通信方

## 非对称密钥加密你了解吗？优缺点？

非对称密钥加密，加密和解密使用不同的密钥。

- **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
- **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢。


## HTTPS是什么？

HTTPS 并不是新协议，而是让 **HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信**。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

## HTTP的缺点有哪些？

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

## HTTPS采用的加密方式有哪些？是对称还是非对称？

HTTPS 采用混合的加密机制，使用**非对称密钥加密用于传输会话密钥来保证传输过程的安全性**，之后使用**对称密钥加密通信来保证通信过程的效率**。

可以说一下ECDHE的过程。

## 为什么有的时候刷新页面不需要重新建立 SSL 连接？

由于浏览器和服务器之间的持久连接机制。当客户端发送新的请求时，提供了之前建立 SSL 连接时的会话标识符或会话票据，服务器就可以使用这些信息恢复之前的 SSL 会话状态，从而避免重新进行完整的 SSL 握手过程。

## SSL中的认证中的证书是什么？了解过吗？

一个数字证书通常包含了：

- 公钥；
- 持有者**信息**；
- 证书认证机构（CA）的**信息**；
- CA 对这份文件的**数字签名**及使用的**算法**；
- 证书有效期；
- 还有一些其他额外信息；

数字证书的作用，是用来认证公钥持有者的身份，以防止第三方进行冒充。

扩展
![Pasted image 20230908141615](https://pic.keepjolly.com/halo/blog/2024/01/20240113210112.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5)
CA 签发证书的过程，如上图左边部分：

- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
- 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；
- 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：

- 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
- 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。


## HTTP如何禁用缓存？如何确认缓存？

可以通过 Cache-Control 首部字段来控制缓存：

 - **Cache-Control: no-store**：指示客户端不缓存任何响应，每次请求都要向服务器发送。
- Cache-Control: no-cache：指示客户端在使用缓存前必须先向服务器进行重新验证。

要确认缓存是否生效，可以使用以下方法之一：

1. 查看响应头：在HTTP响应中，可以查看响应头中的缓存控制指令和其他相关字段。其中，常见的字段包括：
    
    - Cache-Control：指示缓存行为的指令。
    - Expires：指示响应的过期时间。
    - ETag：用于标识响应内容的唯一标识符。
    - Last-Modified：指示响应内容的最后修改时间。
    
    通过查看这些响应头字段的值，可以了解缓存是否被启用，并确定缓存的相关信息。

## GET与POST传递数据的最大长度能够达到多少呢？

HTTP 协议没有GET(URL)和POST(Body)的长度限制，对 URL 限制的大多是浏览器和服务器的原因。

为了浏览器的兼容性，需要限制url长度，一般情况下最大应为2083字节；服务器是为了性能和安全考虑，会给get、post长度加限制。

了解：

>这个限制是特定的浏览器及服务器对它的限制，比如IE对URL长度的限制是2083字节(2K+35字节)。对于其他浏览器，如FireFox，Netscape等，则没有长度限制，这个时候其限制取决于服务器的操作系统；即如果url太长，服务器可能会因为安全方面的设置从而拒绝请求或者发生不完整的数据请求。
>
>post 理论上讲是没有大小限制的，HTTP协议规范也没有进行大小限制，但实际上post所能传递的数据量大小取决于服务器的设置和内存大小。
>
>因为我们一般post的数据量很少超过MB的，所以我们很少能感觉的到post的数据量限制，但实际中如果你上传文件的过程中可能会发现这样一个问题，即上传个头比较大的文件到服务器时候，可能上传不上去。
>
>以php语言来说，查原因的时候你也许会看到有说PHP上传文件涉及到的参数PHP默认的上传有限定，一般这个值是2MB，更改这个值需要更改php.conf的post_max_size这个值。这就很明白的说明了这个问题了。

## 网络层常见协议？可以说一下吗？

![Pasted image 20230908152424](https://pic.keepjolly.com/halo/blog/2024/01/20240113210118.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5)

1. Internet Protocol (IP)：IP是互联网的基础协议，负责在网络中传输数据包。~~它使用IP地址来标识网络上的设备，并提供数据包的路由功能。~~
    
2. Internet Control Message Protocol (ICMP)：ICMP用于在IP网络中传输控制消息。~~它主要用于网络故障排除、错误报告和网络状态查询等。~~
    
3. Internet Group Management Protocol (IGMP)：IGMP是用于在IP网络中管理多播组的协议。~~它允许主机加入或离开多播组，并与路由器通信以确定多播数据的传输~~。
    
4. Address Resolution Protocol (ARP)：ARP用于将IP地址解析为物理（MAC）地址。~~当主机需要与目标设备通信时，它可以使用ARP协议来获取目标设备的物理地址。~~
    
5. Reverse Address Resolution Protocol (RARP)：RARP与ARP相反，它将物理地址解析为IP地址。~~它可以帮助没有硬盘和操作系统配置的设备（如磁盘less工作站）获取其IP地址。~~
    
6. Internet Protocol version 6 (IPv6)：IPv6是IP协议的下一代版本，旨在解决IPv4地址耗尽和其他一些限制。它使用128位的地址空间，提供更大的地址容量和其他改进。


## TCP四大拥塞控制算法总结？（极其重要）

![Pasted image 20230908162813](https://pic.keepjolly.com/halo/blog/2024/01/20240113210122.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5)

### 慢启动算法 – Slow Start

慢启动是TCP连接刚开始时的拥塞控制算法。
慢启动的算法的规则就是：**每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**呈指数增加。
 
>慢启动算法：
>
>- 连接建立完成后，一开始初始化 `cwnd = 1`，表示可以传一个 `MSS` 大小的数据。
>- 当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个
>- 当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个，呈指数增长。

慢启动算法还有一个慢启动门限 `ssthresh` （slow start threshold）状态变量。
- 当 `cwnd` < `ssthresh` 时，使用慢启动算法。
- 当 `cwnd` >= `ssthresh` 时，就会使用「拥塞避免算法」。

~~一般来说 `ssthresh` 的大小是 `65535` 字节。~~

### 拥塞避免算法 – Congestion Avoidance

当拥塞窗口 `cwnd` 「超过」慢启动门限 `ssthresh` 就会进入拥塞避免算法。

进入拥塞避免算法后，它的规则是：**每当收到一个 ACK 时，cwnd 增加 1/cwnd。**，呈线性增长。

>接上前面的慢启动的例子，现假定 `ssthresh` 为 `8`：
>
>- 当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 `MSS` 大小的数据，变成了**线性增长。**

过了慢启动阈值后，拥塞避免算法可以避免窗口增长过快导致窗口拥塞，而是缓慢的增加调整到网络的最佳值，直到出现丢包现象，触发拥塞发生的算法。

### 拥塞发生算法

当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：

- 超时重传
- 快速重传

超时重传是在发送一个数据以后就开启一个计时器，在指定时间内如果没有收到ACK报文，说明网络拥塞严重，就触发该算法：
将慢启动门限`ssthresh` 设为 `cwnd/2`，拥塞窗口`cwnd` 重置为 cwnd 初始化值(Linux 是10)，进入慢启动算法。
![Pasted image 20230908164038](https://pic.keepjolly.com/halo/blog/2024/01/20240113210129.png?imageMogr2/format/webp%7C?watermark/3/type/3/text/a2VlcGpvbGx5)

快速重传是当发送方连续三次收到前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。
它将拥塞窗口设置为原来的一半，慢启动门限设置为拥塞窗口大小。
- `cwnd = cwnd/2` ，也就是设置为原来的一半;
- `ssthresh = cwnd`;
- 进入快速恢复算法

### 快速恢复算法 – Fast Recovery

快速恢复算法是认为，还能收到 3 个重复 ACK 说明网络也不那么糟糕，他将：

- 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个重复数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的 ACK，那么 cwnd 增加 1；
- 如果收到新数据的 ACK 后，把 cwnd 设置为 ssthresh 的值，重新进入拥塞避免算法；

## 为何快速重传是选择3次ACK？

主要的考虑还是要区分包的丢失是由于链路故障还是乱序等其他因素引发。
